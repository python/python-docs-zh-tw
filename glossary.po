# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Translators:
# Steven Hsu <hsuhaochun@gmail.com>, 2021-2022
# Matt Wang <mattwang44@gmail.com>, 2021
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-31 08:13+0000\n"
"PO-Revision-Date: 2022-10-23 20:00+0800\n"
"Last-Translator: Steven Hsu <hsuhaochun@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2\n"

#: ../../glossary.rst:5
msgid "Glossary"
msgstr "術語表"

#: ../../glossary.rst:10
msgid "``>>>``"
msgstr "``>>>``"

#: ../../glossary.rst:12
msgid ""
"The default Python prompt of the interactive shell.  Often seen for code "
"examples which can be executed interactively in the interpreter."
msgstr ""
"互動式 shell 的預設 Python 提示字元。常見於能在直譯器中以互動方式被執行的程式"
"碼範例。"

#: ../../glossary.rst:14
msgid "``...``"
msgstr "``...``"

#: ../../glossary.rst:16
msgid "Can refer to:"
msgstr "可以表示："

#: ../../glossary.rst:18
msgid ""
"The default Python prompt of the interactive shell when entering the code "
"for an indented code block, when within a pair of matching left and right "
"delimiters (parentheses, square brackets, curly braces or triple quotes), or "
"after specifying a decorator."
msgstr ""
"在一個被縮排的程式碼區塊、在一對匹配的左右定界符（delimiter，例如括號、方括"
"號、花括號或三引號）內部，或是在指定一個裝飾器 (decorator) 之後，要輸入程式碼"
"時，互動式 shell 顯示的預設 Python 提示字元。"

#: ../../glossary.rst:23
msgid "The :const:`Ellipsis` built-in constant."
msgstr "內建常數 :const:`Ellipsis`\\ 。"

#: ../../glossary.rst:24
msgid "2to3"
msgstr "2to3"

#: ../../glossary.rst:26
msgid ""
"A tool that tries to convert Python 2.x code to Python 3.x code by handling "
"most of the incompatibilities which can be detected by parsing the source "
"and traversing the parse tree."
msgstr ""
"一個試著將 Python 2.x 程式碼轉換為 Python 3.x 程式碼的工具，它是透過處理大部"
"分的不相容性來達成此目的，而這些不相容性能夠透過剖析原始碼和遍歷剖析樹而被檢"
"測出來。"

#: ../../glossary.rst:30
msgid ""
"2to3 is available in the standard library as :mod:`lib2to3`; a standalone "
"entry point is provided as :file:`Tools/scripts/2to3`.  See :ref:`2to3-"
"reference`."
msgstr ""
"2to3 在可以標準函式庫中以 :mod:`lib2to3` 被使用；它提供了一個獨立的入口點，"
"在 :file:`Tools/scripts/2to3`\\ 。請參閱 :ref:`2to3-reference`。"

#: ../../glossary.rst:33
msgid "abstract base class"
msgstr "abstract base class（抽象基底類別）"

#: ../../glossary.rst:35
msgid ""
"Abstract base classes complement :term:`duck-typing` by providing a way to "
"define interfaces when other techniques like :func:`hasattr` would be clumsy "
"or subtly wrong (for example with :ref:`magic methods <special-lookup>`).  "
"ABCs introduce virtual subclasses, which are classes that don't inherit from "
"a class but are still recognized by :func:`isinstance` and :func:"
"`issubclass`; see the :mod:`abc` module documentation.  Python comes with "
"many built-in ABCs for data structures (in the :mod:`collections.abc` "
"module), numbers (in the :mod:`numbers` module), streams (in the :mod:`io` "
"module), import finders and loaders (in the :mod:`importlib.abc` module).  "
"You can create your own ABCs with the :mod:`abc` module."
msgstr ""
"抽象基底類別（又稱為 ABC）提供了一種定義介面的方法，作為 :term:`duck-typing`"
"\\ （鴨子型別）的補充。其他類似的技術，像是 :func:`hasattr`\\ ，則顯得笨拙或"
"是帶有細微的錯誤（例如使用\\ :ref:`魔術方法 (magic method) <special-lookup>`"
"\\ ）。ABC 採用虛擬的 subclass（子類別），它們並不繼承自另一個 class（類"
"別），但仍可被 :func:`isinstance` 及 :func:`issubclass` 辨識；請參閱 :mod:"
"`abc` 模組的說明文件。Python 有許多內建的 ABC，用於資料結構（在 :mod:"
"`collections.abc` 模組）、數字（在 :mod:`numbers` 模組）、串流（在 :mod:`io` "
"模組）及 import 尋檢器和載入器（在 :mod:`importlib.abc` 模組）。你可以使用 :"
"mod:`abc` 模組建立自己的 ABC。"

#: ../../glossary.rst:46
msgid "annotation"
msgstr "annotation（註釋）"

#: ../../glossary.rst:48
msgid ""
"A label associated with a variable, a class attribute or a function "
"parameter or return value, used by convention as a :term:`type hint`."
msgstr ""
"一個與變數、class 屬性、函式的參數或回傳值相關聯的標籤。照慣例，它被用來作"
"為 :term:`type hint`\\ （型別提示）。"

#: ../../glossary.rst:52
msgid ""
"Annotations of local variables cannot be accessed at runtime, but "
"annotations of global variables, class attributes, and functions are stored "
"in the :attr:`__annotations__` special attribute of modules, classes, and "
"functions, respectively."
msgstr ""
"在運行時 (runtime)，區域變數的註釋無法被存取，但全域變數、class 屬性和函式的"
"註解，會分別被儲存在模組、class 和函式的 :attr:`__annotations__` 特殊屬性中。"

#: ../../glossary.rst:58
msgid ""
"See :term:`variable annotation`, :term:`function annotation`, :pep:`484` "
"and :pep:`526`, which describe this functionality. Also see :ref:"
"`annotations-howto` for best practices on working with annotations."
msgstr ""
"請參閱 :term:`variable annotation`\\ 、\\ :term:`function annotation`"
"\\ 、\\ :pep:`484` 和 :pep:`526`，這些章節皆有此功能的說明。關於註釋的最佳實"
"踐方法也請參閱 :ref:`annotations-howto`\\ 。"

#: ../../glossary.rst:62
msgid "argument"
msgstr "argument（引數）"

#: ../../glossary.rst:64
msgid ""
"A value passed to a :term:`function` (or :term:`method`) when calling the "
"function.  There are two kinds of argument:"
msgstr ""
"呼叫函式時被傳遞給 :term:`function`\\ （或 :term:`method`\\ ）的值。引數有兩"
"種："

#: ../../glossary.rst:67
msgid ""
":dfn:`keyword argument`: an argument preceded by an identifier (e.g. "
"``name=``) in a function call or passed as a value in a dictionary preceded "
"by ``**``.  For example, ``3`` and ``5`` are both keyword arguments in the "
"following calls to :func:`complex`::"
msgstr ""
":dfn:`關鍵字引數 (keyword argument)`\\ ：在函式呼叫中，以識別字（identifier，"
"例如 ``name=``\\ ）開頭的引數，或是以 ``**`` 後面 dictionary（字典）內的值被"
"傳遞的引數。例如，``3`` 和 ``5`` 都是以下 :func:`complex` 呼叫中的關鍵字引"
"數：\n"
"\n"
"::"

#: ../../glossary.rst:75
msgid ""
":dfn:`positional argument`: an argument that is not a keyword argument. "
"Positional arguments can appear at the beginning of an argument list and/or "
"be passed as elements of an :term:`iterable` preceded by ``*``. For example, "
"``3`` and ``5`` are both positional arguments in the following calls::"
msgstr ""
":dfn:`位置引數 (positional argument)`\\ ：不是關鍵字引數的引數。位置引數可在"
"一個引數列表的起始處出現，和（或）作為 ``*`` 之後的 :term:`iterable`\\ （可疊"
"代物件）中的元素被傳遞。例如，``3`` 和 ``5`` 都是以下呼叫中的位置引數：\n"
"\n"
"::"

#: ../../glossary.rst:84
msgid ""
"Arguments are assigned to the named local variables in a function body. See "
"the :ref:`calls` section for the rules governing this assignment. "
"Syntactically, any expression can be used to represent an argument; the "
"evaluated value is assigned to the local variable."
msgstr ""
"引數會被指定給函式主體中的附名區域變數。關於支配這個指定過程的規則，請參閱"
"\\ :ref:`calls`\\ 章節。在語法上，任何運算式都可以被用來表示一個引數；其評估"
"值會被指定給區域變數。"

#: ../../glossary.rst:89
msgid ""
"See also the :term:`parameter` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"and :pep:`362`."
msgstr ""
"另請參閱術語表的 :term:`parameter`\\ （參數）條目、常見問題中的\\ :ref:`引數"
"和參數之間的差異 <faq-argument-vs-parameter>`\\ ，以及 :pep:`362`\\ 。"

#: ../../glossary.rst:92
msgid "asynchronous context manager"
msgstr "asynchronous context manager（非同步情境管理器）"

#: ../../glossary.rst:94
msgid ""
"An object which controls the environment seen in an :keyword:`async with` "
"statement by defining :meth:`__aenter__` and :meth:`__aexit__` methods.  "
"Introduced by :pep:`492`."
msgstr ""
"一個可以控制 :keyword:`async with` 陳述式中所見環境的物件，而它是透過定義 :"
"meth:`__aenter__` 和 :meth:`__aexit__` method（方法）來控制的。由 :pep:`492` "
"引入。"

#: ../../glossary.rst:97
msgid "asynchronous generator"
msgstr "asynchronous generator（非同步產生器）"

#: ../../glossary.rst:99
msgid ""
"A function which returns an :term:`asynchronous generator iterator`.  It "
"looks like a coroutine function defined with :keyword:`async def` except "
"that it contains :keyword:`yield` expressions for producing a series of "
"values usable in an :keyword:`async for` loop."
msgstr ""
"一個會回傳 :term:`asynchronous generator iterator`\\ （非同步產生器疊代器）的"
"函式。它看起來像一個以 :keyword:`async def` 定義的協程函式 (coroutine "
"function)，但不同的是它包含了 :keyword:`yield` 運算式，能生成一系列可用於 :"
"keyword:`async for` 迴圈的值。"

#: ../../glossary.rst:104
msgid ""
"Usually refers to an asynchronous generator function, but may refer to an "
"*asynchronous generator iterator* in some contexts.  In cases where the "
"intended meaning isn't clear, using the full terms avoids ambiguity."
msgstr ""
"這個術語通常用來表示一個非同步產生器函式，但在某些情境中，也可能是表示\\ *非"
"同步產生器疊代器 (asynchronous generator iterator)*。萬一想表達的意思不夠清"
"楚，那就使用完整的術語，以避免歧義。"

#: ../../glossary.rst:108
msgid ""
"An asynchronous generator function may contain :keyword:`await` expressions "
"as well as :keyword:`async for`, and :keyword:`async with` statements."
msgstr ""
"一個非同步產生器函式可能包含 :keyword:`await` 運算式，以及 :keyword:`async "
"for` 和 :keyword:`async with` 陳述式。"

#: ../../glossary.rst:111
msgid "asynchronous generator iterator"
msgstr "asynchronous generator iterator（非同步產生器疊代器）"

#: ../../glossary.rst:113
msgid "An object created by a :term:`asynchronous generator` function."
msgstr ""
"一個由 :term:`asynchronous generator`\\ （非同步產生器）函式所建立的物件。"

#: ../../glossary.rst:115
msgid ""
"This is an :term:`asynchronous iterator` which when called using the :meth:"
"`__anext__` method returns an awaitable object which will execute the body "
"of the asynchronous generator function until the next :keyword:`yield` "
"expression."
msgstr ""
"這是一個 :term:`asynchronous iterator`\\ （非同步疊代器），當它以 :meth:"
"`__anext__` method 被呼叫時，會回傳一個可等待物件 (awaitable object)，該物件"
"將執行非同步產生器的函式主體，直到遇到下一個 :keyword:`yield` 運算式。"

#: ../../glossary.rst:120
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"location execution state (including local variables and pending try-"
"statements).  When the *asynchronous generator iterator* effectively resumes "
"with another awaitable returned by :meth:`__anext__`, it picks up where it "
"left off.  See :pep:`492` and :pep:`525`."
msgstr ""
"每個 :keyword:`yield` 會暫停處理程序，並記住位置執行狀態（包括區域變數及擱置"
"中的 try 陳述式）。當\\ *非同步產生器疊代器*\\ 以另一個被 :meth:`__anext__` "
"回傳的可等待物件有效地回復時，它會從停止的地方繼續執行。請參閱 :pep:`492` "
"和 :pep:`525`。"

#: ../../glossary.rst:125
msgid "asynchronous iterable"
msgstr "asynchronous iterable（非同步可疊代物件）"

#: ../../glossary.rst:127
msgid ""
"An object, that can be used in an :keyword:`async for` statement. Must "
"return an :term:`asynchronous iterator` from its :meth:`__aiter__` method.  "
"Introduced by :pep:`492`."
msgstr ""
"一個物件，它可以在 :keyword:`async for` 陳述式中被使用。必須從它的 :meth:"
"`__aiter__` method 回傳一個 :term:`asynchronous iterator`\\ （非同步疊代"
"器）。由 :pep:`492` 引入。"

#: ../../glossary.rst:130
msgid "asynchronous iterator"
msgstr "asynchronous iterator（非同步疊代器）"

#: ../../glossary.rst:132
msgid ""
"An object that implements the :meth:`__aiter__` and :meth:`__anext__` "
"methods.  ``__anext__`` must return an :term:`awaitable` object. :keyword:"
"`async for` resolves the awaitables returned by an asynchronous iterator's :"
"meth:`__anext__` method until it raises a :exc:`StopAsyncIteration` "
"exception.  Introduced by :pep:`492`."
msgstr ""
"一個實作 :meth:`__aiter__` 和 :meth:`__anext__` method 的物件。\\ "
"``__anext__`` 必須回傳一個 :term:`awaitable`\\ （可等待物件）。\\ :keyword:"
"`async for` 會解析非同步疊代器的 :meth:`__anext__` method 所回傳的可等待物"
"件，直到它引發 :exc:`StopAsyncIteration` 例外。由 :pep:`492` 引入。"

#: ../../glossary.rst:137
msgid "attribute"
msgstr "attribute（屬性）"

#: ../../glossary.rst:139
msgid ""
"A value associated with an object which is usually referenced by name using "
"dotted expressions. For example, if an object *o* has an attribute *a* it "
"would be referenced as *o.a*."
msgstr ""
"一個與某物件相關聯的值，該值大多能透過使用點分隔運算式 (dotted expression) 的"
"名稱被參照。例如，如果物件 *o* 有一個屬性 *a*，則該屬性能以 *o.a* 被參照。"

#: ../../glossary.rst:144
msgid ""
"It is possible to give an object an attribute whose name is not an "
"identifier as defined by :ref:`identifiers`, for example using :func:"
"`setattr`, if the object allows it. Such an attribute will not be accessible "
"using a dotted expression, and would instead need to be retrieved with :func:"
"`getattr`."
msgstr ""
"如果一個物件允許，給予該物件一個名稱不是由\\ :ref:`identifiers`\\ 所定義之識"
"別符 (identifier) 的屬性是有可能的，例如使用 :func:`setattr`。像這樣的屬性將"
"無法使用點分隔運算式來存取，而是需要使用 :func:`getattr` 來取得它。"

#: ../../glossary.rst:149
msgid "awaitable"
msgstr "awaitable（可等待物件）"

#: ../../glossary.rst:151
msgid ""
"An object that can be used in an :keyword:`await` expression.  Can be a :"
"term:`coroutine` or an object with an :meth:`__await__` method. See also :"
"pep:`492`."
msgstr ""
"一個可以在 :keyword:`await` 運算式中被使用的物件。它可以是一個 :term:"
"`coroutine`\\ （協程），或是一個有 :meth:`__await__` method 的物件。另請參"
"閱 :pep:`492`。"

#: ../../glossary.rst:154
msgid "BDFL"
msgstr "BDFL"

#: ../../glossary.rst:156
msgid ""
"Benevolent Dictator For Life, a.k.a. `Guido van Rossum <https://gvanrossum."
"github.io/>`_, Python's creator."
msgstr ""
"Benevolent Dictator For Life（終身仁慈獨裁者），又名 `Guido van Rossum "
"<https://gvanrossum.github.io/>`_\\ ，Python 的創造者。"

#: ../../glossary.rst:158
msgid "binary file"
msgstr "binary file（二進制檔案）"

#: ../../glossary.rst:160
msgid ""
"A :term:`file object` able to read and write :term:`bytes-like objects "
"<bytes-like object>`. Examples of binary files are files opened in binary "
"mode (``'rb'``, ``'wb'`` or ``'rb+'``), :data:`sys.stdin.buffer`, :data:`sys."
"stdout.buffer`, and instances of :class:`io.BytesIO` and :class:`gzip."
"GzipFile`."
msgstr ""
"一個能夠讀取和寫入 :term:`bytes-like objects <bytes-like object>`\\ （類位元"
"組串物件）的 :term:`file object`\\ （檔案物件）。二進制檔案的例子有：以二進制"
"模式（``'rb'``、``'wb'`` 或 ``'rb+'``）開啟的檔案、\\ :data:`sys.stdin."
"buffer`、\\ :data:`sys.stdout.buffer`，以及 :class:`io.BytesIO` 和 :class:"
"`gzip.GzipFile` 實例。"

#: ../../glossary.rst:167
msgid ""
"See also :term:`text file` for a file object able to read and write :class:"
"`str` objects."
msgstr ""
"另請參閱 :term:`text file`\\ （文字檔案），它是一個能夠讀取和寫入 :class:"
"`str` 物件的檔案物件。"

#: ../../glossary.rst:169
msgid "borrowed reference"
msgstr "borrowed reference（借用參照）"

#: ../../glossary.rst:171
msgid ""
"In Python's C API, a borrowed reference is a reference to an object. It does "
"not modify the object reference count. It becomes a dangling pointer if the "
"object is destroyed. For example, a garbage collection can remove the last :"
"term:`strong reference` to the object and so destroy it."
msgstr ""
"在 Python 的 C API 中，借用參照是一個對物件的參照。它不會修改該物件的參照計"
"數 (reference count)。如果該物件被銷毀，它會成為一個迷途指標 (dangling "
"pointer)。例如，一次垃圾回收 (garbage collection) 可以移除對物件的最後一個 :"
"term:`strong reference`\\ （強參照），而將該物件銷毀。"

#: ../../glossary.rst:176
msgid ""
"Calling :c:func:`Py_INCREF` on the :term:`borrowed reference` is recommended "
"to convert it to a :term:`strong reference` in-place, except when the object "
"cannot be destroyed before the last usage of the borrowed reference. The :c:"
"func:`Py_NewRef` function can be used to create a new :term:`strong "
"reference`."
msgstr ""
"對 :term:`borrowed reference` 呼叫 :c:func:`Py_INCREF` 以將它原地 (in-place) "
"轉換為 :term:`strong reference` 是被建議的做法，除非該物件不能在最後一次使用"
"借用參照之前被銷毀。\\ :c:func:`Py_NewRef` 函式可用於建立一個新的 :term:"
"`strong reference`。"

#: ../../glossary.rst:181
msgid "bytes-like object"
msgstr "bytes-like object（類位元組串物件）"

#: ../../glossary.rst:183
msgid ""
"An object that supports the :ref:`bufferobjects` and can export a C-:term:"
"`contiguous` buffer. This includes all :class:`bytes`, :class:`bytearray`, "
"and :class:`array.array` objects, as well as many common :class:`memoryview` "
"objects.  Bytes-like objects can be used for various operations that work "
"with binary data; these include compression, saving to a binary file, and "
"sending over a socket."
msgstr ""
"一個支援\\ :ref:`bufferobjects`\\ 且能夠匯出 C-:term:`contiguous` 緩衝區的物"
"件。這包括所有的 :class:`bytes`、\\ :class:`bytearray` 和 :class:`array."
"array` 物件，以及許多常見的 :class:`memoryview` 物件。類位元組串物件可用於處"
"理二進制資料的各種運算；這些運算包括壓縮、儲存至二進制檔案和透過 socket（插"
"座）發送。"

#: ../../glossary.rst:190
msgid ""
"Some operations need the binary data to be mutable.  The documentation often "
"refers to these as \"read-write bytes-like objects\".  Example mutable "
"buffer objects include :class:`bytearray` and a :class:`memoryview` of a :"
"class:`bytearray`. Other operations require the binary data to be stored in "
"immutable objects (\"read-only bytes-like objects\"); examples of these "
"include :class:`bytes` and a :class:`memoryview` of a :class:`bytes` object."
msgstr ""
"有些運算需要二進制資料是可變的。說明文件通常會將這些物件稱為「可讀寫的類位元"
"組串物件」。可變緩衝區的物件包括 :class:`bytearray`，以及 :class:`bytearray` "
"的 :class:`memoryview`。其他的運算需要讓二進制資料被儲存在不可變物件（「唯讀"
"的類位元組串物件」）中；這些物件包括 :class:`bytes`，以及 :class:`bytes` 物件"
"的 :class:`memoryview`。"

#: ../../glossary.rst:198
msgid "bytecode"
msgstr "bytecode（位元組碼）"

#: ../../glossary.rst:200
msgid ""
"Python source code is compiled into bytecode, the internal representation of "
"a Python program in the CPython interpreter.  The bytecode is also cached in "
"``.pyc`` files so that executing the same file is faster the second time "
"(recompilation from source to bytecode can be avoided).  This \"intermediate "
"language\" is said to run on a :term:`virtual machine` that executes the "
"machine code corresponding to each bytecode. Do note that bytecodes are not "
"expected to work between different Python virtual machines, nor to be stable "
"between Python releases."
msgstr ""
"Python 的原始碼會被編譯成位元組碼，它是 Python 程式在 CPython 直譯器中的內部"
"表示法。該位元組碼也會被暫存在 ``.pyc`` 檔案中，以便第二次執行同一個檔案時能"
"夠更快速（可以不用從原始碼重新編譯為位元組碼）。這種「中間語言 (intermediate "
"language)」據說是運行在一個 :term:`virtual machine`\\ （虛擬機器）上，該虛擬"
"機器會執行與每個位元組碼對應的機器碼 (machine code)。要注意的是，位元組碼理論"
"上是無法在不同的 Python 虛擬機器之間運作的，也不能在不同版本的 Python 之間保"
"持穩定。"

#: ../../glossary.rst:210
msgid ""
"A list of bytecode instructions can be found in the documentation for :ref:"
"`the dis module <bytecodes>`."
msgstr ""
"位元組碼的指令列表可以在 :ref:`dis 模組 <bytecodes>`\\ 的說明文件中找到。"

#: ../../glossary.rst:212
msgid "callable"
msgstr "callable（可呼叫物件）"

#: ../../glossary.rst:214
msgid ""
"A callable is an object that can be called, possibly with a set of arguments "
"(see :term:`argument`), with the following syntax::"
msgstr ""
"一個 callable 是可以被呼叫的物件，呼叫時可能以下列形式帶有一組引數（請見 :"
"term:`argument`）：\n"
"\n"
"::"

#: ../../glossary.rst:219
msgid ""
"A :term:`function`, and by extension a :term:`method`, is a callable. An "
"instance of a class that implements the :meth:`~object.__call__` method is "
"also a callable."
msgstr ""
"一個 :term:`function` 與其延伸的 :term:`method` 都是 callable。一個有實作 :"
"meth:`~object.__call__` 方法的 class 之實例也是個 callable。"

#: ../../glossary.rst:222
msgid "callback"
msgstr "callback（回呼）"

#: ../../glossary.rst:224
msgid ""
"A subroutine function which is passed as an argument to be executed at some "
"point in the future."
msgstr ""
"作為引數被傳遞的一個副程式 (subroutine) 函式，會在未來的某個時間點被執行。"

#: ../../glossary.rst:226
msgid "class"
msgstr "class（類別）"

#: ../../glossary.rst:228
msgid ""
"A template for creating user-defined objects. Class definitions normally "
"contain method definitions which operate on instances of the class."
msgstr ""
"一個用於建立使用者定義物件的模板。Class 的定義通常會包含 method 的定義，這些 "
"method 可以在 class 的實例上進行操作。"

#: ../../glossary.rst:231
msgid "class variable"
msgstr "class variable（類別變數）"

#: ../../glossary.rst:233
msgid ""
"A variable defined in a class and intended to be modified only at class "
"level (i.e., not in an instance of the class)."
msgstr ""
"一個在 class 中被定義，且應該只能在 class 層次（意即不是在 class 的實例中）被"
"修改的變數。"

#: ../../glossary.rst:235
msgid "complex number"
msgstr "complex number（複數）"

#: ../../glossary.rst:237
msgid ""
"An extension of the familiar real number system in which all numbers are "
"expressed as a sum of a real part and an imaginary part.  Imaginary numbers "
"are real multiples of the imaginary unit (the square root of ``-1``), often "
"written ``i`` in mathematics or ``j`` in engineering.  Python has built-in "
"support for complex numbers, which are written with this latter notation; "
"the imaginary part is written with a ``j`` suffix, e.g., ``3+1j``.  To get "
"access to complex equivalents of the :mod:`math` module, use :mod:`cmath`.  "
"Use of complex numbers is a fairly advanced mathematical feature.  If you're "
"not aware of a need for them, it's almost certain you can safely ignore them."
msgstr ""
"一個我們熟悉的實數系統的擴充，在此所有數字都會被表示為一個實部和一個虛部之"
"和。虛數就是虛數單位（``-1`` 的平方根）的實數倍，此單位通常在數學中被寫為 "
"``i``，在工程學中被寫為 ``j``。Python 內建了對複數的支援，它是用後者的記法來"
"表示複數；虛部會帶著一個後綴的 ``j`` 被編寫，例如 ``3+1j``。若要將 :mod:"
"`math` 模組內的工具等效地用於複數，請使用 :mod:`cmath` 模組。複數的使用是一個"
"相當進階的數學功能。如果你沒有察覺到對它們的需求，那麼幾乎能確定你可以安全地"
"忽略它們。"

#: ../../glossary.rst:247
msgid "context manager"
msgstr "context manager（情境管理器）"

#: ../../glossary.rst:249
msgid ""
"An object which controls the environment seen in a :keyword:`with` statement "
"by defining :meth:`__enter__` and :meth:`__exit__` methods. See :pep:`343`."
msgstr ""
"一個可以控制 :keyword:`with` 陳述式中所見環境的物件，而它是透過定義 :meth:"
"`__enter__` 和 :meth:`__exit__` method 來控制的。請參閱 :pep:`343`\\ 。"

#: ../../glossary.rst:252
msgid "context variable"
msgstr "context variable（情境變數）"

#: ../../glossary.rst:254
msgid ""
"A variable which can have different values depending on its context. This is "
"similar to Thread-Local Storage in which each execution thread may have a "
"different value for a variable. However, with context variables, there may "
"be several contexts in one execution thread and the main usage for context "
"variables is to keep track of variables in concurrent asynchronous tasks. "
"See :mod:`contextvars`."
msgstr ""
"一個變數，其值可以根據上下文的情境而有所不同。這類似執行緒區域儲存區 (Thread-"
"Local Storage)，在其中，一個變數在每個執行緒可能具有不同的值。然而，關於情境"
"變數，在一個執行緒中可能會有多個情境，而情境變數的主要用途，是在並行的非同步"
"任務 (concurrent asynchronous task) 中，對於變數狀態的追蹤。請參閱 :mod:"
"`contextvars`\\ 。"

#: ../../glossary.rst:261
msgid "contiguous"
msgstr "contiguous（連續的）"

#: ../../glossary.rst:265
msgid ""
"A buffer is considered contiguous exactly if it is either *C-contiguous* or "
"*Fortran contiguous*.  Zero-dimensional buffers are C and Fortran "
"contiguous.  In one-dimensional arrays, the items must be laid out in memory "
"next to each other, in order of increasing indexes starting from zero.  In "
"multidimensional C-contiguous arrays, the last index varies the fastest when "
"visiting items in order of memory address.  However, in Fortran contiguous "
"arrays, the first index varies the fastest."
msgstr ""
"如果一個緩衝區是 *C-contiguous* 或是 *Fortran contiguous*，則它會確切地被視為"
"是連續的。零維 (zero-dimensional) 的緩衝區都是 C 及 Fortran contiguous。在一"
"維 (one-dimensional) 陣列中，各項目必須在記憶體中彼此相鄰地排列，而其索引順序"
"是從零開始遞增。在多維的 (multidimensional) C-contiguous 陣列中，按記憶體位址"
"的順序訪問各個項目時，最後一個索引的變化最快。然而，在 Fortran contiguous 陣"
"列中，第一個索引的變化最快。"

#: ../../glossary.rst:273
msgid "coroutine"
msgstr "coroutine（協程）"

#: ../../glossary.rst:275
msgid ""
"Coroutines are a more generalized form of subroutines. Subroutines are "
"entered at one point and exited at another point.  Coroutines can be "
"entered, exited, and resumed at many different points.  They can be "
"implemented with the :keyword:`async def` statement.  See also :pep:`492`."
msgstr ""
"協程是副程式 (subroutine) 的一種更為廣義的形式。副程式是在某個時間點被進入並"
"在另一個時間點被退出。協程可以在許多不同的時間點被進入、退出和回復。它們能夠"
"以 :keyword:`async def` 陳述式被實作。另請參閱 :pep:`492`\\ 。"

#: ../../glossary.rst:280
msgid "coroutine function"
msgstr "coroutine function（協程函式）"

#: ../../glossary.rst:282
msgid ""
"A function which returns a :term:`coroutine` object.  A coroutine function "
"may be defined with the :keyword:`async def` statement, and may contain :"
"keyword:`await`, :keyword:`async for`, and :keyword:`async with` keywords.  "
"These were introduced by :pep:`492`."
msgstr ""
"一個回傳 :term:`coroutine`\\ （協程）物件的函式。一個協程函式能以 :keyword:"
"`async def` 陳述式被定義，並可能會包含 :keyword:`await`\\ 、\\ :keyword:"
"`async for` 和 :keyword:`async with` 關鍵字。這些關鍵字由 :pep:`492` 引入。"

#: ../../glossary.rst:287
msgid "CPython"
msgstr "CPython"

#: ../../glossary.rst:289
msgid ""
"The canonical implementation of the Python programming language, as "
"distributed on `python.org <https://www.python.org>`_.  The term \"CPython\" "
"is used when necessary to distinguish this implementation from others such "
"as Jython or IronPython."
msgstr ""
"Python 程式語言的標準實作 (canonical implementation)，被發布在 `python.org "
"<https://www.python.org>`_ 上。「CPython」這個術語在必要時被使用，以區分此實"
"作與其它語言的實作，例如 Jython 或 IronPython。"

#: ../../glossary.rst:293
msgid "decorator"
msgstr "decorator（裝飾器）"

#: ../../glossary.rst:295
msgid ""
"A function returning another function, usually applied as a function "
"transformation using the ``@wrapper`` syntax.  Common examples for "
"decorators are :func:`classmethod` and :func:`staticmethod`."
msgstr ""
"一個函式，它會回傳另一個函式，通常它會使用 ``@wrapper`` 語法，被應用為一種函"
"式的變換 (function transformation)。裝飾器的常見範例是 :func:`classmethod` "
"和 :func:`staticmethod`\\ 。"

#: ../../glossary.rst:299
msgid ""
"The decorator syntax is merely syntactic sugar, the following two function "
"definitions are semantically equivalent::"
msgstr ""
"裝飾器語法只是語法糖。以下兩個函式定義在語義上是等效的：\n"
"\n"
"::"

#: ../../glossary.rst:310
msgid ""
"The same concept exists for classes, but is less commonly used there.  See "
"the documentation for :ref:`function definitions <function>` and :ref:`class "
"definitions <class>` for more about decorators."
msgstr ""
"Class 也存在相同的概念，但在那裡比較不常用。關於裝飾器的更多內容，請參閱\\ :"
"ref:`函式定義 <function>`\\ 和 :ref:`class 定義 <class>`\\ 的說明文件。"

#: ../../glossary.rst:313
msgid "descriptor"
msgstr "descriptor（描述器）"

#: ../../glossary.rst:315
msgid ""
"Any object which defines the methods :meth:`__get__`, :meth:`__set__`, or :"
"meth:`__delete__`.  When a class attribute is a descriptor, its special "
"binding behavior is triggered upon attribute lookup.  Normally, using *a.b* "
"to get, set or delete an attribute looks up the object named *b* in the "
"class dictionary for *a*, but if *b* is a descriptor, the respective "
"descriptor method gets called.  Understanding descriptors is a key to a deep "
"understanding of Python because they are the basis for many features "
"including functions, methods, properties, class methods, static methods, and "
"reference to super classes."
msgstr ""
"任何定義了 :meth:`__get__`\\ 、\\ :meth:`__set__` 或 :meth:`__delete__` "
"method 的物件。當一個 class 屬性是一個描述器時，它的特殊連結行為會在屬性查找"
"時被觸發。通常，使用 *a.b* 來取得、設定或刪除某個屬性時，會在 *a* 的 class 字"
"典中查找名稱為 *b* 的物件，但如果 *b* 是一個描述器，則相對應的描述器 method "
"會被呼叫。對描述器的理解是深入理解 Python 的關鍵，因為它們是許多功能的基礎，"
"這些功能包括函式、method、屬性 (property)、class method、靜態 method，以及對 "
"super class（父類別）的參照。"

#: ../../glossary.rst:325
msgid ""
"For more information about descriptors' methods, see :ref:`descriptors` or "
"the :ref:`Descriptor How To Guide <descriptorhowto>`."
msgstr ""
"關於描述器 method 的更多資訊，請參閱\\ :ref:`descriptors`\\ 或\\ :ref:`描述器"
"使用指南 <descriptorhowto>`\\ 。"

#: ../../glossary.rst:327
msgid "dictionary"
msgstr "dictionary（字典）"

#: ../../glossary.rst:329
msgid ""
"An associative array, where arbitrary keys are mapped to values.  The keys "
"can be any object with :meth:`__hash__` and :meth:`__eq__` methods. Called a "
"hash in Perl."
msgstr ""
"一個關聯陣列 (associative array)，其中任意的鍵會被映射到值。鍵可以是任何帶"
"有 :meth:`__hash__` 和 :meth:`__eq__` method 的物件。在 Perl 中被稱為雜湊 "
"(hash)。"

#: ../../glossary.rst:332
msgid "dictionary comprehension"
msgstr "dictionary comprehension（字典綜合運算）"

#: ../../glossary.rst:334
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a dictionary with the results. ``results = {n: n ** 2 for n in "
"range(10)}`` generates a dictionary containing key ``n`` mapped to value ``n "
"** 2``. See :ref:`comprehensions`."
msgstr ""
"一種緊密的方法，用來處理一個可疊代物件中的全部或部分元素，並將處理結果以一個"
"字典回傳。``results = {n: n ** 2 for n in range(10)}`` 會產生一個字典，它包含"
"了鍵 ``n`` 映射到值 ``n ** 2``。請參閱\\ :ref:`comprehensions`\\ 。"

#: ../../glossary.rst:338
msgid "dictionary view"
msgstr "dictionary view（字典檢視）"

#: ../../glossary.rst:340
msgid ""
"The objects returned from :meth:`dict.keys`, :meth:`dict.values`, and :meth:"
"`dict.items` are called dictionary views. They provide a dynamic view on the "
"dictionary’s entries, which means that when the dictionary changes, the view "
"reflects these changes. To force the dictionary view to become a full list "
"use ``list(dictview)``.  See :ref:`dict-views`."
msgstr ""
"從 :meth:`dict.keys`\\ 、\\ :meth:`dict.values` 及 :meth:`dict.items` 回傳的"
"物件被稱為字典檢視。它們提供了字典中項目的動態檢視，這表示當字典有變動時，該"
"檢視會反映這些變動。若要強制將字典檢視轉為完整的 list（串列），須使用 "
"``list(dictview)``。請參閱\\ :ref:`dict-views`\\ 。"

#: ../../glossary.rst:346
msgid "docstring"
msgstr "docstring（說明字串）"

#: ../../glossary.rst:348
msgid ""
"A string literal which appears as the first expression in a class, function "
"or module.  While ignored when the suite is executed, it is recognized by "
"the compiler and put into the :attr:`__doc__` attribute of the enclosing "
"class, function or module.  Since it is available via introspection, it is "
"the canonical place for documentation of the object."
msgstr ""
"一個在 class、函式或模組中，作為第一個運算式出現的字串文本。雖然它在套件執行"
"時會被忽略，但它會被編譯器辨識，並被放入所屬 class、函式或模組的 :attr:"
"`__doc__` 屬性中。由於說明字串可以透過內省 (introspection) 來瀏覽，因此它是物"
"件的說明文件存放的標準位置。"

#: ../../glossary.rst:354
msgid "duck-typing"
msgstr "duck-typing（鴨子型別）"

#: ../../glossary.rst:356
msgid ""
"A programming style which does not look at an object's type to determine if "
"it has the right interface; instead, the method or attribute is simply "
"called or used (\"If it looks like a duck and quacks like a duck, it must be "
"a duck.\")  By emphasizing interfaces rather than specific types, well-"
"designed code improves its flexibility by allowing polymorphic "
"substitution.  Duck-typing avoids tests using :func:`type` or :func:"
"`isinstance`.  (Note, however, that duck-typing can be complemented with :"
"term:`abstract base classes <abstract base class>`.)  Instead, it typically "
"employs :func:`hasattr` tests or :term:`EAFP` programming."
msgstr ""
"一種程式設計風格，它不是藉由檢查一個物件的型別來確定它是否具有正確的介面；取"
"而代之的是，method 或屬性會單純地被呼叫或使用。（「如果它看起來像一隻鴨子而且"
"叫起來像一隻鴨子，那麼它一定是一隻鴨子。」）因為強調介面而非特定型別，精心設"
"計的程式碼能讓多形替代 (polymorphic substitution) 來增進它的靈活性。鴨子型別"
"要避免使用 :func:`type` 或 :func:`isinstance` 進行測試。（但是請注意，鴨子型"
"別可以用\\ :term:`抽象基底類別 (abstract base class) <abstract base class>` "
"來補充。）然而，它通常會採用 :func:`hasattr` 測試，或是 :term:`EAFP` 程式設計"
"風格。"

#: ../../glossary.rst:365
msgid "EAFP"
msgstr "EAFP"

#: ../../glossary.rst:367
msgid ""
"Easier to ask for forgiveness than permission.  This common Python coding "
"style assumes the existence of valid keys or attributes and catches "
"exceptions if the assumption proves false.  This clean and fast style is "
"characterized by the presence of many :keyword:`try` and :keyword:`except` "
"statements.  The technique contrasts with the :term:`LBYL` style common to "
"many other languages such as C."
msgstr ""
"Easier to ask for forgiveness than permission.（請求寬恕比請求許可更容易。）"
"這種常見的 Python 編碼風格會先假設有效的鍵或屬性的存在，並在該假設被推翻時再"
"捕獲例外。這種乾淨且快速的風格，其特色是存在許多的 :keyword:`try` 和 :"
"keyword:`except` 陳述式。該技術與許多其他語言（例如 C）常見的 :term:`LBYL` 風"
"格形成了對比。"

#: ../../glossary.rst:373
msgid "expression"
msgstr "expression（運算式）"

#: ../../glossary.rst:375
msgid ""
"A piece of syntax which can be evaluated to some value.  In other words, an "
"expression is an accumulation of expression elements like literals, names, "
"attribute access, operators or function calls which all return a value.  In "
"contrast to many other languages, not all language constructs are "
"expressions.  There are also :term:`statement`\\s which cannot be used as "
"expressions, such as :keyword:`while`.  Assignments are also statements, not "
"expressions."
msgstr ""
"一段可以被評估並求值的語法。換句話說，一個運算式就是文字、名稱、屬性存取、運"
"算子或函式呼叫等運算式元件的累積，而這些元件都能回傳一個值。與許多其他語言不"
"同的是，並非所有的 Python 語言構造都是運算式。另外有一些 :term:`statement`\\ "
"（陳述式）不能被用作運算式，例如 :keyword:`while`\\ 。賦值 (assignment) 也是"
"陳述式，而不是運算式。"

#: ../../glossary.rst:382
msgid "extension module"
msgstr "extension module（擴充模組）"

#: ../../glossary.rst:384
msgid ""
"A module written in C or C++, using Python's C API to interact with the core "
"and with user code."
msgstr ""
"一個以 C 或 C++ 編寫的模組，它使用 Python 的 C API 來與核心及使用者程式碼進行"
"互動。"

#: ../../glossary.rst:386
msgid "f-string"
msgstr "f-string（f 字串）"

#: ../../glossary.rst:388
msgid ""
"String literals prefixed with ``'f'`` or ``'F'`` are commonly called \"f-"
"strings\" which is short for :ref:`formatted string literals <f-strings>`.  "
"See also :pep:`498`."
msgstr ""
"以 ``'f'`` 或 ``'F'`` 為前綴的字串文本通常被稱為「f 字串」，它是\\ :ref:`格式"
"化的字串文本 <f-strings>`\\ 的縮寫。另請參閱 :pep:`498`\\ 。"

#: ../../glossary.rst:391
msgid "file object"
msgstr "file object（檔案物件）"

#: ../../glossary.rst:393
msgid ""
"An object exposing a file-oriented API (with methods such as :meth:`read()` "
"or :meth:`write()`) to an underlying resource.  Depending on the way it was "
"created, a file object can mediate access to a real on-disk file or to "
"another type of storage or communication device (for example standard input/"
"output, in-memory buffers, sockets, pipes, etc.).  File objects are also "
"called :dfn:`file-like objects` or :dfn:`streams`."
msgstr ""
"一個讓使用者透過檔案導向 (file-oriented) API（如 :meth:`read()` 或 :meth:"
"`write()` 等 method）來操作底層資源的物件。根據檔案物件被建立的方式，它能夠協"
"調對真實磁碟檔案或是其他類型的儲存器或通訊裝置（例如標準輸入／輸出、記憶體內"
"緩衝區、socket（插座）、管線 (pipe) 等）的存取。檔案物件也被稱為\\ :dfn:`類檔"
"案物件 (file-like object)` 或\\ :dfn:`串流 (stream)`\\ 。"

#: ../../glossary.rst:401
msgid ""
"There are actually three categories of file objects: raw :term:`binary files "
"<binary file>`, buffered :term:`binary files <binary file>` and :term:`text "
"files <text file>`. Their interfaces are defined in the :mod:`io` module.  "
"The canonical way to create a file object is by using the :func:`open` "
"function."
msgstr ""
"實際上，有三種檔案物件：原始的\\ :term:`二進制檔案 <binary file>`\\ 、緩衝的"
"\\ :term:`二進制檔案 <binary file>`\\ 和\\ :term:`文字檔案 <text file>`\\ 。"
"它們的介面在 :mod:`io` 模組中被定義。建立檔案物件的標準方法是使用 :func:"
"`open` 函式。"

#: ../../glossary.rst:406
msgid "file-like object"
msgstr "file-like object（類檔案物件）"

#: ../../glossary.rst:408
msgid "A synonym for :term:`file object`."
msgstr ":term:`file object`\\ （檔案物件）的同義字。"

#: ../../glossary.rst:409
msgid "filesystem encoding and error handler"
msgstr "filesystem encoding and error handler（檔案系統編碼和錯誤處理函式）"

#: ../../glossary.rst:411
msgid ""
"Encoding and error handler used by Python to decode bytes from the operating "
"system and encode Unicode to the operating system."
msgstr ""
"Python 所使用的一種編碼和錯誤處理函式，用來解碼來自作業系統的位元組，以及將 "
"Unicode 編碼到作業系統。"

#: ../../glossary.rst:414
msgid ""
"The filesystem encoding must guarantee to successfully decode all bytes "
"below 128. If the file system encoding fails to provide this guarantee, API "
"functions can raise :exc:`UnicodeError`."
msgstr ""
"檔案系統編碼必須保證能成功解碼所有小於 128 的位元組。如果檔案系統編碼無法提供"
"此保證，則 API 函式會引發 :exc:`UnicodeError`\\ 。"

#: ../../glossary.rst:418
msgid ""
"The :func:`sys.getfilesystemencoding` and :func:`sys."
"getfilesystemencodeerrors` functions can be used to get the filesystem "
"encoding and error handler."
msgstr ""
":func:`sys.getfilesystemencoding` 和 :func:`sys.getfilesystemencodeerrors` 函"
"式可用於取得檔案系統編碼和錯誤處理函式。"

#: ../../glossary.rst:422
msgid ""
"The :term:`filesystem encoding and error handler` are configured at Python "
"startup by the :c:func:`PyConfig_Read` function: see :c:member:`~PyConfig."
"filesystem_encoding` and :c:member:`~PyConfig.filesystem_errors` members of :"
"c:type:`PyConfig`."
msgstr ""
":term:`filesystem encoding and error handler`\\ （檔案系統編碼和錯誤處理函"
"式）會在 Python 啟動時由 :c:func:`PyConfig_Read` 函式來配置：請參閱 :c:"
"member:`~PyConfig.filesystem_encoding`\\ ，以及 :c:type:`PyConfig` 的成員 :c:"
"member:`~PyConfig.filesystem_errors`\\ 。"

#: ../../glossary.rst:427
msgid "See also the :term:`locale encoding`."
msgstr "另請參閱 :term:`locale encoding`\\ （區域編碼）。"

#: ../../glossary.rst:428
msgid "finder"
msgstr "finder（尋檢器）"

#: ../../glossary.rst:430
msgid ""
"An object that tries to find the :term:`loader` for a module that is being "
"imported."
msgstr ""
"一個物件，它會嘗試為正在被 import 的模組尋找 :term:`loader`\\ （載入器）。"

#: ../../glossary.rst:433
msgid ""
"Since Python 3.3, there are two types of finder: :term:`meta path finders "
"<meta path finder>` for use with :data:`sys.meta_path`, and :term:`path "
"entry finders <path entry finder>` for use with :data:`sys.path_hooks`."
msgstr ""
"從 Python 3.3 開始，有兩種類型的尋檢器：\\ :term:`元路徑尋檢器 (meta path "
"finder) <meta path finder>` 會使用 :data:`sys.meta_path`\\ ，而\\ :term:`路徑"
"項目尋檢器 (path entry finder) <path entry finder>` 會使用 :data:`sys."
"path_hooks`\\ 。"

#: ../../glossary.rst:437
msgid "See :pep:`302`, :pep:`420` and :pep:`451` for much more detail."
msgstr "請參閱 :pep:`302`\\ 、\\ :pep:`420` 和 :pep:`451` 以了解更多細節。"

#: ../../glossary.rst:438
msgid "floor division"
msgstr "floor division（向下取整除法）"

#: ../../glossary.rst:440
msgid ""
"Mathematical division that rounds down to nearest integer.  The floor "
"division operator is ``//``.  For example, the expression ``11 // 4`` "
"evaluates to ``2`` in contrast to the ``2.75`` returned by float true "
"division.  Note that ``(-11) // 4`` is ``-3`` because that is ``-2.75`` "
"rounded *downward*. See :pep:`238`."
msgstr ""
"向下無條件捨去到最接近整數的數學除法。向下取整除法的運算子是 ``//``。例如，運"
"算式 ``11 // 4`` 的計算結果為 ``2``，與 float（浮點數）真除法所回傳的 "
"``2.75`` 不同。請注意，``(-11) // 4`` 的結果是 ``-3``，因為是 ``-2.75`` 被\\ "
"*向下*\\ 無條件捨去。請參閱 :pep:`238`\\ 。"

#: ../../glossary.rst:445
msgid "function"
msgstr "function（函式）"

#: ../../glossary.rst:447
msgid ""
"A series of statements which returns some value to a caller. It can also be "
"passed zero or more :term:`arguments <argument>` which may be used in the "
"execution of the body. See also :term:`parameter`, :term:`method`, and the :"
"ref:`function` section."
msgstr ""
"一連串的陳述式，它能夠向呼叫者回傳一些值。它也可以被傳遞零個或多個\\ :term:`"
"引數 <argument>`\\ ，這些引數可被使用於函式本體的執行。另請參閱 :term:"
"`parameter`\\ （參數）、\\ :term:`method`\\ （方法），以及\\ :ref:`function`"
"\\ 章節。"

#: ../../glossary.rst:451
msgid "function annotation"
msgstr "function annotation（函式註釋）"

#: ../../glossary.rst:453
msgid "An :term:`annotation` of a function parameter or return value."
msgstr "函式參數或回傳值的一個 :term:`annotation`\\ （註釋）。"

#: ../../glossary.rst:455
msgid ""
"Function annotations are usually used for :term:`type hints <type hint>`: "
"for example, this function is expected to take two :class:`int` arguments "
"and is also expected to have an :class:`int` return value::"
msgstr ""
"函式註釋通常被使用於\\ :term:`型別提示 <type hint>`\\ ：例如，這個函式預期會"
"得到兩個 :class:`int` 引數，並會有一個 :class:`int` 回傳值：\n"
"\n"
"::"

#: ../../glossary.rst:463
msgid "Function annotation syntax is explained in section :ref:`function`."
msgstr "函式註釋的語法在\\ :ref:`function`\\ 章節有詳細解釋。"

#: ../../glossary.rst:465
msgid ""
"See :term:`variable annotation` and :pep:`484`, which describe this "
"functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr ""
"請參閱 :term:`variable annotation` 和 :pep:`484`\\ ，皆有此功能的描述。關於註"
"釋的最佳實踐方法，另請參閱 :ref:`annotations-howto`\\ 。"

#: ../../glossary.rst:469
msgid "__future__"
msgstr "__future__"

#: ../../glossary.rst:471
msgid ""
"A :ref:`future statement <future>`, ``from __future__ import <feature>``, "
"directs the compiler to compile the current module using syntax or semantics "
"that will become standard in a future release of Python. The :mod:"
"`__future__` module documents the possible values of *feature*.  By "
"importing this module and evaluating its variables, you can see when a new "
"feature was first added to the language and when it will (or did) become the "
"default::"
msgstr ""
":ref:`future 陳述式 <future>`\\ ：``from __future__ import <feature>``，會指"
"示編譯器使用那些在 Python 未來的發布版本中將成為標準的語法或語義，來編譯當前"
"的模組。而 :mod:`__future__` 模組則記錄了 *feature（功能）*\\ 可能的值。透過 "
"import 此模組並對其變數求值，你可以看見一個新的功能是何時首次被新增到此語言"
"中，以及它何時將會（或已經）成為預設的功能：\n"
"\n"
"::"

#: ../../glossary.rst:482
msgid "garbage collection"
msgstr "garbage collection（垃圾回收）"

#: ../../glossary.rst:484
msgid ""
"The process of freeing memory when it is not used anymore.  Python performs "
"garbage collection via reference counting and a cyclic garbage collector "
"that is able to detect and break reference cycles.  The garbage collector "
"can be controlled using the :mod:`gc` module."
msgstr ""
"當記憶體不再被使用時，將其釋放的過程。Python 執行垃圾回收，是透過參照計數 "
"(reference counting)，以及一個能夠檢測和中斷參照循環 (reference cycle) 的循環"
"垃圾回收器 (cyclic garbage collector) 來完成。垃圾回收器可以使用 :mod:`gc` 模"
"組對其進行控制。"

#: ../../glossary.rst:490
msgid "generator"
msgstr "generator（產生器）"

#: ../../glossary.rst:492
msgid ""
"A function which returns a :term:`generator iterator`.  It looks like a "
"normal function except that it contains :keyword:`yield` expressions for "
"producing a series of values usable in a for-loop or that can be retrieved "
"one at a time with the :func:`next` function."
msgstr ""
"一個會回傳 :term:`generator iterator`\\ （產生器疊代器）的函式。它看起來像一"
"個正常的函式，但不同的是它包含了 :keyword:`yield` 運算式，能產生一系列的值，"
"這些值可用於 for 迴圈，或是以 :func:`next` 函式，每次檢索其中的一個值。"

#: ../../glossary.rst:497
msgid ""
"Usually refers to a generator function, but may refer to a *generator "
"iterator* in some contexts.  In cases where the intended meaning isn't "
"clear, using the full terms avoids ambiguity."
msgstr ""
"這個術語通常用來表示一個產生器函式，但在某些情境中，也可能是表示\\ *產生器疊"
"代器*\\ 。萬一想表達的意思不夠清楚，那就使用完整的術語，以避免歧義。"

#: ../../glossary.rst:500
msgid "generator iterator"
msgstr "generator iterator（產生器疊代器）"

#: ../../glossary.rst:502
msgid "An object created by a :term:`generator` function."
msgstr "一個由 :term:`generator`\\ （產生器）函式所建立的物件。"

#: ../../glossary.rst:504
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"location execution state (including local variables and pending try-"
"statements).  When the *generator iterator* resumes, it picks up where it "
"left off (in contrast to functions which start fresh on every invocation)."
msgstr ""
"每個 :keyword:`yield` 會暫停處理程序，並記住位置執行狀態（包括區域變數及擱置"
"中的 try 陳述式）。當\\ *產生器疊代器*\\ 回復時，它會從停止的地方繼續執行（與"
"那些每次調用時都要重新開始的函式有所不同）。"

#: ../../glossary.rst:511
msgid "generator expression"
msgstr "generator expression（產生器運算式）"

#: ../../glossary.rst:513
msgid ""
"An expression that returns an iterator.  It looks like a normal expression "
"followed by a :keyword:`!for` clause defining a loop variable, range, and an "
"optional :keyword:`!if` clause.  The combined expression generates values "
"for an enclosing function::"
msgstr ""
"一個會回傳疊代器的運算式。它看起來像一個正常的運算式，後面接著一個 :keyword:"
"`!for` 子句，該子句定義了迴圈變數、範圍以及一個選擇性的 :keyword:`!if` 子句。"
"該組合運算式會為外層函數產生多個值：\n"
"\n"
"::"

#: ../../glossary.rst:520
msgid "generic function"
msgstr "generic function（泛型函式）"

#: ../../glossary.rst:522
msgid ""
"A function composed of multiple functions implementing the same operation "
"for different types. Which implementation should be used during a call is "
"determined by the dispatch algorithm."
msgstr ""
"一個由多個函式組成的函式，該函式會對不同的型別實作相同的運算。呼叫期間應該使"
"用哪種實作，是由調度演算法 (dispatch algorithm) 來決定。"

#: ../../glossary.rst:526
msgid ""
"See also the :term:`single dispatch` glossary entry, the :func:`functools."
"singledispatch` decorator, and :pep:`443`."
msgstr ""
"另請參閱 :term:`single dispatch`\\ （單一調度）術語表條目、\\ :func:"
"`functools.singledispatch` 裝飾器和 :pep:`443`\\ 。"

#: ../../glossary.rst:528
msgid "generic type"
msgstr "generic type（泛型型別）"

#: ../../glossary.rst:530
msgid ""
"A :term:`type` that can be parameterized; typically a :ref:`container "
"class<sequence-types>` such as :class:`list` or :class:`dict`. Used for :"
"term:`type hints <type hint>` and :term:`annotations <annotation>`."
msgstr ""
"一個能夠被參數化 (parameterized) 的 :term:`type`\\ （型別）；通常是一個 :ref:"
"`容器型別 <sequence-types>`\\ ，像是 :class:`list` 和 :class:`dict`。它被用於"
"\\ :term:`型別提示 <type hint>`\\ 和\\ :term:`註釋 <annotation>`\\ 。"

#: ../../glossary.rst:535
msgid ""
"For more details, see :ref:`generic alias types<types-genericalias>`, :pep:"
"`483`, :pep:`484`, :pep:`585`, and the :mod:`typing` module."
msgstr ""
"詳情請參閱\\ :ref:`泛型別名型別 <types-genericalias>`\\ 、\\ :pep:`483`"
"\\ 、\\ :pep:`484`\\ 、\\ :pep:`585` 和 :mod:`typing` 模組。"

#: ../../glossary.rst:537
msgid "GIL"
msgstr "GIL"

#: ../../glossary.rst:539
msgid "See :term:`global interpreter lock`."
msgstr "請參閱 :term:`global interpreter lock`\\ （全域直譯器鎖）。"

#: ../../glossary.rst:540
msgid "global interpreter lock"
msgstr "global interpreter lock（全域直譯器鎖）"

#: ../../glossary.rst:542
msgid ""
"The mechanism used by the :term:`CPython` interpreter to assure that only "
"one thread executes Python :term:`bytecode` at a time. This simplifies the "
"CPython implementation by making the object model (including critical built-"
"in types such as :class:`dict`) implicitly safe against concurrent access.  "
"Locking the entire interpreter makes it easier for the interpreter to be "
"multi-threaded, at the expense of much of the parallelism afforded by multi-"
"processor machines."
msgstr ""
":term:`CPython` 直譯器所使用的機制，用以確保每次都只有一個執行緒能執行 "
"Python 的 :term:`bytecode`\\ （位元組碼）。透過使物件模型（包括關鍵的內建型"
"別，如 :class:`dict`\\ ）自動地避免並行存取 (concurrent access) 的危險，此機"
"制可以簡化 CPython 的實作。鎖定整個直譯器，會使直譯器更容易成為多執行緒 "
"(multi-threaded)，但代價是會犧牲掉多處理器的機器能夠提供的一大部分平行性 "
"(parallelism)。"

#: ../../glossary.rst:551
msgid ""
"However, some extension modules, either standard or third-party, are "
"designed so as to release the GIL when doing computationally intensive tasks "
"such as compression or hashing.  Also, the GIL is always released when doing "
"I/O."
msgstr ""
"然而，有些擴充模組，無論是標準的或是第三方的，它們被設計成在執行壓縮或雜湊等"
"計算密集 (computationally intensive) 的任務時，可以解除 GIL。另外，在執行 I/"
"O 時，GIL 總是會被解除。"

#: ../../glossary.rst:556
msgid ""
"Past efforts to create a \"free-threaded\" interpreter (one which locks "
"shared data at a much finer granularity) have not been successful because "
"performance suffered in the common single-processor case. It is believed "
"that overcoming this performance issue would make the implementation much "
"more complicated and therefore costlier to maintain."
msgstr ""
"過去對於建立「無限制執行緒」直譯器（以更高的精細度鎖定共享資料的直譯器）的努"
"力並未成功，因為在一般的單一處理器情況下，效能會有所損失。一般認為，若要克服"
"這個效能問題，會使實作變得複雜許多，進而付出更高的維護成本。"

#: ../../glossary.rst:562
msgid "hash-based pyc"
msgstr "hash-based pyc（雜湊架構的 pyc）"

#: ../../glossary.rst:564
msgid ""
"A bytecode cache file that uses the hash rather than the last-modified time "
"of the corresponding source file to determine its validity. See :ref:`pyc-"
"invalidation`."
msgstr ""
"一個位元組碼 (bytecode) 暫存檔，它使用雜湊值而不是對應原始檔案的最後修改時"
"間，來確定其有效性。請參閱\\ :ref:`pyc-invalidation`\\ 。"

#: ../../glossary.rst:567
msgid "hashable"
msgstr "hashable（可雜湊的）"

#: ../../glossary.rst:569
msgid ""
"An object is *hashable* if it has a hash value which never changes during "
"its lifetime (it needs a :meth:`__hash__` method), and can be compared to "
"other objects (it needs an :meth:`__eq__` method).  Hashable objects which "
"compare equal must have the same hash value."
msgstr ""
"如果一個物件有一個雜湊值，該值在其生命週期中永不改變（它需要一個 :meth:"
"`__hash__` method），且可與其他物件互相比較（它需要一個 :meth:`__eq__` "
"method），那麼它就是一個\\ *可雜湊*\\ 物件。比較結果為相等的多個可雜湊物件，"
"它們必須擁有相同的雜湊值。"

#: ../../glossary.rst:574
msgid ""
"Hashability makes an object usable as a dictionary key and a set member, "
"because these data structures use the hash value internally."
msgstr ""
"可雜湊性 (hashability) 使一個物件可用作 dictionary（字典）的鍵和 set（集合）"
"的成員，因為這些資料結構都在其內部使用了雜湊值。"

#: ../../glossary.rst:577
msgid ""
"Most of Python's immutable built-in objects are hashable; mutable containers "
"(such as lists or dictionaries) are not; immutable containers (such as "
"tuples and frozensets) are only hashable if their elements are hashable.  "
"Objects which are instances of user-defined classes are hashable by "
"default.  They all compare unequal (except with themselves), and their hash "
"value is derived from their :func:`id`."
msgstr ""
"大多數的 Python 不可變內建物件都是可雜湊的；可變的容器（例如 list 或 "
"dictionary）並不是；而不可變的容器（例如 tuple（元組）和 frozenset），只有當"
"它們的元素是可雜湊的，它們本身才是可雜湊的。若物件是使用者自定 class 的實例，"
"則這些物件會被預設為可雜湊的。它們在互相比較時都是不相等的（除非它們與自己比"
"較），而它們的雜湊值則是衍生自它們的 :func:`id`\\ 。"

#: ../../glossary.rst:584
msgid "IDLE"
msgstr "IDLE"

#: ../../glossary.rst:586
msgid ""
"An Integrated Development and Learning Environment for Python. :ref:`idle` "
"is a basic editor and interpreter environment which ships with the standard "
"distribution of Python."
msgstr ""
"Python 的 Integrated Development and Learning Environment（整合開發與學習環"
"境）。:ref:`idle` 是一個基本的編輯器和直譯器環境，它和 Python 的標準發行版本"
"一起被提供。"

#: ../../glossary.rst:589
msgid "immutable"
msgstr "immutable（不可變物件）"

#: ../../glossary.rst:591
msgid ""
"An object with a fixed value.  Immutable objects include numbers, strings "
"and tuples.  Such an object cannot be altered.  A new object has to be "
"created if a different value has to be stored.  They play an important role "
"in places where a constant hash value is needed, for example as a key in a "
"dictionary."
msgstr ""
"一個具有固定值的物件。不可變物件包括數字、字串和 tuple（元組）。這類物件是不"
"能被改變的。如果一個不同的值必須被儲存，則必須建立一個新的物件。它們在需要恆"
"定雜湊值的地方，扮演重要的角色，例如 dictionary（字典）中的一個鍵。"

#: ../../glossary.rst:596
msgid "import path"
msgstr "import path（匯入路徑）"

#: ../../glossary.rst:598
msgid ""
"A list of locations (or :term:`path entries <path entry>`) that are searched "
"by the :term:`path based finder` for modules to import. During import, this "
"list of locations usually comes from :data:`sys.path`, but for subpackages "
"it may also come from the parent package's ``__path__`` attribute."
msgstr ""
"一個位置（或\\ :term:`路徑項目 <path entry>`\\ ）的列表，而那些位置就是在 "
"import 模組時，會被 :term:`path based finder`\\ （基於路徑的尋檢器）搜尋模組"
"的位置。在 import 期間，此位置列表通常是來自 :data:`sys.path`\\ ，但對於子套"
"件 (subpackage) 而言，它也可能是來自父套件的 ``__path__`` 屬性。"

#: ../../glossary.rst:603
msgid "importing"
msgstr "importing（匯入）"

#: ../../glossary.rst:605
msgid ""
"The process by which Python code in one module is made available to Python "
"code in another module."
msgstr ""
"一個過程。一個模組中的 Python 程式碼可以透過此過程，被另一個模組中的 Python "
"程式碼使用。"

#: ../../glossary.rst:607
msgid "importer"
msgstr "importer（匯入器）"

#: ../../glossary.rst:609
msgid ""
"An object that both finds and loads a module; both a :term:`finder` and :"
"term:`loader` object."
msgstr ""
"一個能夠尋找及載入模組的物件；它既是 :term:`finder`\\ （尋檢器）也是 :term:"
"`loader`\\ （載入器）物件。"

#: ../../glossary.rst:611
msgid "interactive"
msgstr "interactive（互動的）"

#: ../../glossary.rst:613
msgid ""
"Python has an interactive interpreter which means you can enter statements "
"and expressions at the interpreter prompt, immediately execute them and see "
"their results.  Just launch ``python`` with no arguments (possibly by "
"selecting it from your computer's main menu). It is a very powerful way to "
"test out new ideas or inspect modules and packages (remember ``help(x)``)."
msgstr ""
"Python 有一個互動式直譯器，這表示你可以在直譯器的提示字元輸入陳述式和運算式，"
"立即執行它們並且看到它們的結果。只要啟動 ``python``，不需要任何引數（可能藉由"
"從你的電腦的主選單選擇它）。這是測試新想法或檢查模塊和包的非常強大的方法（請"
"記住help(x)）。"

#: ../../glossary.rst:619
msgid "interpreted"
msgstr "interpreted（直譯的）"

#: ../../glossary.rst:621
msgid ""
"Python is an interpreted language, as opposed to a compiled one, though the "
"distinction can be blurry because of the presence of the bytecode compiler.  "
"This means that source files can be run directly without explicitly creating "
"an executable which is then run. Interpreted languages typically have a "
"shorter development/debug cycle than compiled ones, though their programs "
"generally also run more slowly.  See also :term:`interactive`."
msgstr ""
"Python 是一種直譯語言，而不是編譯語言，不過這個區分可能有些模糊，因為有位元組"
"碼 (bytecode) 編譯器的存在。這表示原始檔案可以直接被運行，而不需明確地建立另"
"一個執行檔，然後再執行它。直譯語言通常比編譯語言有更短的開發／除錯週期，不過"
"它們的程式通常也運行得較慢。另請參閱 :term:`interactive`\\ （互動的）。"

#: ../../glossary.rst:628
msgid "interpreter shutdown"
msgstr "interpreter shutdown（直譯器關閉）"

#: ../../glossary.rst:630
msgid ""
"When asked to shut down, the Python interpreter enters a special phase where "
"it gradually releases all allocated resources, such as modules and various "
"critical internal structures.  It also makes several calls to the :term:"
"`garbage collector <garbage collection>`. This can trigger the execution of "
"code in user-defined destructors or weakref callbacks. Code executed during "
"the shutdown phase can encounter various exceptions as the resources it "
"relies on may not function anymore (common examples are library modules or "
"the warnings machinery)."
msgstr ""
"當 Python 直譯器被要求關閉時，它會進入一個特殊階段，在此它逐漸釋放所有被配置"
"的資源，例如模組和各種關鍵內部結構。它也會多次呼叫\\ :term:`垃圾回收器 "
"(garbage collector) <garbage collection>`\\ 。這能夠觸發使用者自定的解構函式 "
"(destructor) 或弱引用的回呼 (weakref callback)，並執行其中的程式碼。在關閉階"
"段被執行的程式碼會遇到各種例外，因為它所依賴的資源可能不再有作用了（常見的例"
"子是函式庫模組或是警告機制）。"

#: ../../glossary.rst:639
msgid ""
"The main reason for interpreter shutdown is that the ``__main__`` module or "
"the script being run has finished executing."
msgstr ""
"直譯器關閉的主要原因，是 ``__main__`` 模組或正被運行的腳本已經執行完成。"

#: ../../glossary.rst:641
msgid "iterable"
msgstr "iterable（可疊代物件）"

#: ../../glossary.rst:643
msgid ""
"An object capable of returning its members one at a time. Examples of "
"iterables include all sequence types (such as :class:`list`, :class:`str`, "
"and :class:`tuple`) and some non-sequence types like :class:`dict`, :term:"
"`file objects <file object>`, and objects of any classes you define with an :"
"meth:`__iter__` method or with a :meth:`__getitem__` method that implements :"
"term:`sequence` semantics."
msgstr ""
"一種能夠一次回傳一個其中成員的物件。可疊代物件的例子包括所有的序列型別（像"
"是 :class:`list`\\ 、\\ :class:`str` 和 :class:`tuple`\\ ）和某些非序列型別，"
"像是 :class:`dict`\\ 、\\ :term:`檔案物件 <file object>`\\ ，以及你所定義的任"
"何 class 物件，只要那些 class 有 :meth:`__iter__` method 或是實作 :term:"
"`sequence`\\ （序列）語意的 :meth:`__getitem__` method，該物件就是可疊代物"
"件。"

#: ../../glossary.rst:650
msgid ""
"Iterables can be used in a :keyword:`for` loop and in many other places "
"where a sequence is needed (:func:`zip`, :func:`map`, ...).  When an "
"iterable object is passed as an argument to the built-in function :func:"
"`iter`, it returns an iterator for the object.  This iterator is good for "
"one pass over the set of values.  When using iterables, it is usually not "
"necessary to call :func:`iter` or deal with iterator objects yourself.  The "
"``for`` statement does that automatically for you, creating a temporary "
"unnamed variable to hold the iterator for the duration of the loop.  See "
"also :term:`iterator`, :term:`sequence`, and :term:`generator`."
msgstr ""
"可疊代物件可用於 :keyword:`for` 迴圈和許多其他需要一個序列的地方 (:func:`zip`"
"\\ 、\\ :func:`map`\\ ...)。當一個可疊代物件作為引數被傳遞給內建函式 :func:"
"`iter` 時，它會為該物件回傳一個疊代器。此疊代器適用於針對一組值進行一遍 (one "
"pass) 運算。使用疊代器時，通常不一定要呼叫 :func:`iter` 或自行處理疊代器物"
"件。``for`` 陳述式會自動地為你處理這些事，它會建立一個暫時性的未命名變數，用"
"於在迴圈期間保有該疊代器。另請參閱 :term:`iterator`\\ （疊代器）、\\ :term:"
"`sequence`\\ （序列）和 :term:`generator`\\ （產生器）。"

#: ../../glossary.rst:660
msgid "iterator"
msgstr "iterator（疊代器）"

#: ../../glossary.rst:662
msgid ""
"An object representing a stream of data.  Repeated calls to the iterator's :"
"meth:`~iterator.__next__` method (or passing it to the built-in function :"
"func:`next`) return successive items in the stream.  When no more data are "
"available a :exc:`StopIteration` exception is raised instead.  At this "
"point, the iterator object is exhausted and any further calls to its :meth:"
"`__next__` method just raise :exc:`StopIteration` again.  Iterators are "
"required to have an :meth:`__iter__` method that returns the iterator object "
"itself so every iterator is also iterable and may be used in most places "
"where other iterables are accepted.  One notable exception is code which "
"attempts multiple iteration passes.  A container object (such as a :class:"
"`list`) produces a fresh new iterator each time you pass it to the :func:"
"`iter` function or use it in a :keyword:`for` loop.  Attempting this with an "
"iterator will just return the same exhausted iterator object used in the "
"previous iteration pass, making it appear like an empty container."
msgstr ""
"一個表示資料流的物件。重複地呼叫疊代器的 :meth:`~iterator.__next__` "
"method（或是將它傳遞給內建函式 :func:`next`\\ ）會依序回傳資料流中的各項目。"
"當不再有資料時，則會引發 :exc:`StopIteration` 例外。此時，該疊代器物件已被用"
"盡，而任何對其 :meth:`__next__` method 的進一步呼叫，都只會再次引發 :exc:"
"`StopIteration`\\ 。疊代器必須有一個 :meth:`__iter__` method，它會回傳疊代器"
"物件本身，所以每個疊代器也都是可疊代物件，且可以用於大多數適用其他可疊代物件"
"的場合。一個明顯的例外，是嘗試多遍疊代 (multiple iteration passes) 的程式碼。"
"一個容器物件（像是 :class:`list`\\ ）在每次你將它傳遞給 :func:`iter` 函式或"
"在 :keyword:`for` 迴圈中使用它時，都會產生一個全新的疊代器。使用疊代器嘗試此"
"事（多遍疊代）時，只會回傳在前一遍疊代中被用過的、同一個已被用盡的疊代器物"
"件，使其看起來就像一個空的容器。"

#: ../../glossary.rst:677
msgid "More information can be found in :ref:`typeiter`."
msgstr "在\\ :ref:`typeiter`\\ 文中可以找到更多資訊。"

#: ../../glossary.rst:681
msgid ""
"CPython does not consistently apply the requirement that an iterator define :"
"meth:`__iter__`."
msgstr ""
"CPython 並不是始終如一地都會檢查「疊代器有定義 :meth:`__iter__`\\ 」這個規"
"定。"

#: ../../glossary.rst:683
msgid "key function"
msgstr "key function（鍵函式）"

#: ../../glossary.rst:685
msgid ""
"A key function or collation function is a callable that returns a value used "
"for sorting or ordering.  For example, :func:`locale.strxfrm` is used to "
"produce a sort key that is aware of locale specific sort conventions."
msgstr ""
"鍵函式或理序函式 (collation function) 是一個可呼叫 (callable) 函式，它會回傳"
"一個用於排序 (sorting) 或定序 (ordering) 的值。例如，\\ :func:`locale."
"strxfrm` 被用來產生一個了解區域特定排序慣例的排序鍵。"

#: ../../glossary.rst:690
msgid ""
"A number of tools in Python accept key functions to control how elements are "
"ordered or grouped.  They include :func:`min`, :func:`max`, :func:`sorted`, :"
"meth:`list.sort`, :func:`heapq.merge`, :func:`heapq.nsmallest`, :func:`heapq."
"nlargest`, and :func:`itertools.groupby`."
msgstr ""
"Python 中的許多工具，都接受以鍵函式來控制元素被定序或分組的方式。它們包括 :"
"func:`min`\\ 、\\ :func:`max`\\ 、\\ :func:`sorted`\\ 、\\ :meth:`list.sort`"
"\\ 、\\ :func:`heapq.merge`\\ 、\\ :func:`heapq.nsmallest`\\ 、\\ :func:"
"`heapq.nlargest` 和 :func:`itertools.groupby`\\ 。"

#: ../../glossary.rst:696
msgid ""
"There are several ways to create a key function.  For example. the :meth:"
"`str.lower` method can serve as a key function for case insensitive sorts.  "
"Alternatively, a key function can be built from a :keyword:`lambda` "
"expression such as ``lambda r: (r[0], r[2])``.  Also, :func:`operator."
"attrgetter`, :func:`operator.itemgetter`, and :func:`operator.methodcaller` "
"are three key function constructors.  See the :ref:`Sorting HOW TO "
"<sortinghowto>` for examples of how to create and use key functions."
msgstr ""
"有幾種方法可以建立一個鍵函式。例如，\\ :meth:`str.lower` method 可以作為不分"
"大小寫排序的鍵函式。或者，一個鍵函式也可以從 :keyword:`lambda` 運算式被建造，"
"例如 ``lambda r: (r[0], r[2])``。另外，:func:`operator.attrgetter`\\ 、\\ :"
"func:`operator.itemgetter` 和 :func:`operator.methodcaller` 為三個鍵函式的建"
"構函式 (constructor)。關於如何建立和使用鍵函式的範例，請參閱\\ :ref:`如何排"
"序 <sortinghowto>`\\ 。"

#: ../../glossary.rst:703
msgid "keyword argument"
msgstr "keyword argument（關鍵字引數）"

#: ../../glossary.rst:705 ../../glossary.rst:994
msgid "See :term:`argument`."
msgstr "請參閱 :term:`argument`\\ （引數）。"

#: ../../glossary.rst:706
msgid "lambda"
msgstr "lambda"

#: ../../glossary.rst:708
msgid ""
"An anonymous inline function consisting of a single :term:`expression` which "
"is evaluated when the function is called.  The syntax to create a lambda "
"function is ``lambda [parameters]: expression``"
msgstr ""
"由單一 :term:`expression`\\ （運算式）所組成的一個匿名行內函式 (inline "
"function)，於該函式被呼叫時求值。建立 lambda 函式的語法是 ``lambda "
"[parameters]: expression``"

#: ../../glossary.rst:711
msgid "LBYL"
msgstr "LBYL"

#: ../../glossary.rst:713
msgid ""
"Look before you leap.  This coding style explicitly tests for pre-conditions "
"before making calls or lookups.  This style contrasts with the :term:`EAFP` "
"approach and is characterized by the presence of many :keyword:`if` "
"statements."
msgstr ""
"Look before you leap.（三思而後行。）這種編碼風格會在進行呼叫或查找之前，明確"
"地測試先決條件。這種風格與 :term:`EAFP` 方式形成對比，且它的特色是會有許多 :"
"keyword:`if` 陳述式的存在。"

#: ../../glossary.rst:718
msgid ""
"In a multi-threaded environment, the LBYL approach can risk introducing a "
"race condition between \"the looking\" and \"the leaping\".  For example, "
"the code, ``if key in mapping: return mapping[key]`` can fail if another "
"thread removes *key* from *mapping* after the test, but before the lookup. "
"This issue can be solved with locks or by using the EAFP approach."
msgstr ""
"在一個多執行緒環境中，LBYL 方式有在「三思」和「後行」之間引入了競爭條件 "
"(race condition) 的風險。例如以下程式碼 ``if key in mapping: return "
"mapping[key]``，如果另一個執行緒在測試之後但在查找之前，從 *mapping* 中移除"
"了 *key*，則該程式碼就會失效。這個問題可以用鎖 (lock) 或使用 EAFP 編碼方式來"
"解決。"

#: ../../glossary.rst:723
msgid "locale encoding"
msgstr "locale encoding（區域編碼）"

#: ../../glossary.rst:725
msgid ""
"On Unix, it is the encoding of the LC_CTYPE locale. It can be set with :func:"
"`locale.setlocale(locale.LC_CTYPE, new_locale) <locale.setlocale>`."
msgstr ""
"在 Unix 上，它是 LC_CTYPE 區域設定的編碼。它可以用 :func:`locale."
"setlocale(locale.LC_CTYPE, new_locale) <locale.setlocale>` 來設定。"

#: ../../glossary.rst:728
msgid "On Windows, it is the ANSI code page (ex: ``\"cp1252\"``)."
msgstr "在 Windows 上，它是 ANSI 代碼頁（code page，例如 ``\"cp1252\"``\\ ）。"

#: ../../glossary.rst:730
msgid ""
"On Android and VxWorks, Python uses ``\"utf-8\"`` as the locale encoding."
msgstr "在 Android 和 VxWorks 上，Python 使用 ``\"utf-8\"`` 作為區域編碼。"

#: ../../glossary.rst:732
msgid "``locale.getencoding()`` can be used to get the locale encoding."
msgstr "``locale.getencoding()`` 可以用來取得區域編碼。"

#: ../../glossary.rst:734
msgid "See also the :term:`filesystem encoding and error handler`."
msgstr "也請參考 :term:`filesystem encoding and error handler`。"

#: ../../glossary.rst:735
msgid "list"
msgstr "list（串列）"

#: ../../glossary.rst:737
msgid ""
"A built-in Python :term:`sequence`.  Despite its name it is more akin to an "
"array in other languages than to a linked list since access to elements is "
"O(1)."
msgstr ""
"一個 Python 內建的 :term:`sequence` （序列）。儘管它的名字是 list，它其實更類"
"似其他語言中的一個陣列 (array) 而較不像一個鏈結串列 (linked list)，因為存取元"
"素的時間複雜度是 O(1)。"

#: ../../glossary.rst:740
msgid "list comprehension"
msgstr "list comprehension（串列綜合運算）"

#: ../../glossary.rst:742
msgid ""
"A compact way to process all or part of the elements in a sequence and "
"return a list with the results.  ``result = ['{:#04x}'.format(x) for x in "
"range(256) if x % 2 == 0]`` generates a list of strings containing even hex "
"numbers (0x..) in the range from 0 to 255. The :keyword:`if` clause is "
"optional.  If omitted, all elements in ``range(256)`` are processed."
msgstr ""
"一種用來處理一個序列中的全部或部分元素，並將處理結果以一個 list 回傳的簡要方"
"法。``result = ['{:#04x}'.format(x) for x in range(256) if x % 2 == 0]`` 會產"
"生一個字串 list，其中包含 0 到 255 範圍內，所有偶數的十六進位數 (0x..)。\\ :"
"keyword:`if` 子句是選擇性的。如果省略它，則 ``range(256)`` 中的所有元素都會被"
"處理。"

#: ../../glossary.rst:748
msgid "loader"
msgstr "loader（載入器）"

#: ../../glossary.rst:750
msgid ""
"An object that loads a module. It must define a method named :meth:"
"`load_module`. A loader is typically returned by a :term:`finder`. See :pep:"
"`302` for details and :class:`importlib.abc.Loader` for an :term:`abstract "
"base class`."
msgstr ""
"一個能夠載入模組的物件。它必須定義一個名為 :meth:`load_module` 的 method（方"
"法）。載入器通常是被 :term:`finder`\\ （尋檢器）回傳。更多細節請參閱 :pep:"
"`302`，關於 :term:`abstract base class`\\ （抽象基底類別），請參閱 :class:"
"`importlib.abc.Loader`\\ 。"

#: ../../glossary.rst:754
msgid "magic method"
msgstr "magic method（魔術方法）"

#: ../../glossary.rst:758
msgid "An informal synonym for :term:`special method`."
msgstr ":term:`special method`\\ （特殊方法）的一個非正式同義詞。"

#: ../../glossary.rst:759
msgid "mapping"
msgstr "mapping（對映）"

#: ../../glossary.rst:761
msgid ""
"A container object that supports arbitrary key lookups and implements the "
"methods specified in the :class:`collections.abc.Mapping` or :class:"
"`collections.abc.MutableMapping` :ref:`abstract base classes <collections-"
"abstract-base-classes>`.  Examples include :class:`dict`, :class:"
"`collections.defaultdict`, :class:`collections.OrderedDict` and :class:"
"`collections.Counter`."
msgstr ""
"一個容器物件，它支援任意鍵的查找，且能實作 :ref:`abstract base classes（抽象"
"基底類別） <collections-abstract-base-classes>`\\ 中，\\ :class:`collections."
"abc.Mapping` 或 :class:`collections.abc.MutableMapping` 所指定的 method。範例"
"包括 :class:`dict`\\ 、\\ :class:`collections.defaultdict`\\ 、\\ :class:"
"`collections.OrderedDict` 和 :class:`collections.Counter`\\ 。"

#: ../../glossary.rst:767
msgid "meta path finder"
msgstr "meta path finder（元路徑尋檢器）"

#: ../../glossary.rst:769
msgid ""
"A :term:`finder` returned by a search of :data:`sys.meta_path`.  Meta path "
"finders are related to, but different from :term:`path entry finders <path "
"entry finder>`."
msgstr ""
"一種經由搜尋 :data:`sys.meta_path` 而回傳的 :term:`finder`\\ （尋檢器）。元路"
"徑尋檢器與\\ :term:`路徑項目尋檢器 (path entry finder) <path entry finder>` "
"相關但是不同。"

#: ../../glossary.rst:773
msgid ""
"See :class:`importlib.abc.MetaPathFinder` for the methods that meta path "
"finders implement."
msgstr ""
"關於元路徑尋檢器實作的 method，請參閱 :class:`importlib.abc.MetaPathFinder`"
"\\ 。"

#: ../../glossary.rst:775
msgid "metaclass"
msgstr "metaclass（元類別）"

#: ../../glossary.rst:777
msgid ""
"The class of a class.  Class definitions create a class name, a class "
"dictionary, and a list of base classes.  The metaclass is responsible for "
"taking those three arguments and creating the class.  Most object oriented "
"programming languages provide a default implementation.  What makes Python "
"special is that it is possible to create custom metaclasses.  Most users "
"never need this tool, but when the need arises, metaclasses can provide "
"powerful, elegant solutions.  They have been used for logging attribute "
"access, adding thread-safety, tracking object creation, implementing "
"singletons, and many other tasks."
msgstr ""
"一種 class 的 class。Class 定義過程會建立一個 class 名稱、一個 class "
"dictionary（字典），以及一個 base class（基底類別）的列表。Metaclass 負責接受"
"這三個引數，並建立該 class。大多數的物件導向程式語言會提供一個預設的實作。"
"Python 的特別之處在於它能夠建立自訂的 metaclass。大部分的使用者從未需要此工"
"具，但是當需要時，metaclass 可以提供強大且優雅的解決方案。它們已被用於記錄屬"
"性存取、增加執行緒安全性、追蹤物件建立、實作單例模式 (singleton)，以及許多其"
"他的任務。"

#: ../../glossary.rst:787
msgid "More information can be found in :ref:`metaclasses`."
msgstr "更多資訊可以在\\ :ref:`metaclasses`\\ 章節中找到。"

#: ../../glossary.rst:788
msgid "method"
msgstr "method（方法）"

#: ../../glossary.rst:790
msgid ""
"A function which is defined inside a class body.  If called as an attribute "
"of an instance of that class, the method will get the instance object as its "
"first :term:`argument` (which is usually called ``self``). See :term:"
"`function` and :term:`nested scope`."
msgstr ""
"一個在 class 本體內被定義的函式。如果 method 作為其 class 實例的一個屬性被呼"
"叫，則它將會得到該實例物件成為它的第一個 :term:`argument`\\ （引數）（此引數"
"通常被稱為 ``self``）。請參閱 :term:`function`\\ （函式）和 :term:`nested "
"scope`\\ （巢狀作用域）。"

#: ../../glossary.rst:794
msgid "method resolution order"
msgstr "method resolution order（方法解析順序）"

#: ../../glossary.rst:796
msgid ""
"Method Resolution Order is the order in which base classes are searched for "
"a member during lookup. See `The Python 2.3 Method Resolution Order <https://"
"www.python.org/download/releases/2.3/mro/>`_ for details of the algorithm "
"used by the Python interpreter since the 2.3 release."
msgstr ""
"方法解析順序是在查找某個成員的過程中，base class（基底類別）被搜尋的順序。關"
"於第 2.3 版至今，Python 直譯器所使用的演算法細節，請參閱 `Python 2.3 版方法解"
"析順序 <https://www.python.org/download/releases/2.3/mro/>`_\\ 。"

#: ../../glossary.rst:800
msgid "module"
msgstr "module（模組）"

#: ../../glossary.rst:802
msgid ""
"An object that serves as an organizational unit of Python code.  Modules "
"have a namespace containing arbitrary Python objects.  Modules are loaded "
"into Python by the process of :term:`importing`."
msgstr ""
"一個擔任 Python 程式碼的組織單位 (organizational unit) 的物件。模組有一個命名"
"空間，它包含任意的 Python 物件。模組是藉由 :term:`importing` 的過程，被載入"
"至 Python。"

#: ../../glossary.rst:806
msgid "See also :term:`package`."
msgstr "另請參閱 :term:`package`\\ （套件）。"

#: ../../glossary.rst:807
msgid "module spec"
msgstr "module spec（模組規格）"

#: ../../glossary.rst:809
msgid ""
"A namespace containing the import-related information used to load a module. "
"An instance of :class:`importlib.machinery.ModuleSpec`."
msgstr ""
"一個命名空間，它包含用於載入模組的 import 相關資訊。它是 :class:`importlib."
"machinery.ModuleSpec` 的一個實例。"

#: ../../glossary.rst:811
msgid "MRO"
msgstr "MRO"

#: ../../glossary.rst:813
msgid "See :term:`method resolution order`."
msgstr "請參閱 :term:`method resolution order`\\ （方法解析順序）。"

#: ../../glossary.rst:814
msgid "mutable"
msgstr "mutable（可變物件）"

#: ../../glossary.rst:816
msgid ""
"Mutable objects can change their value but keep their :func:`id`.  See also :"
"term:`immutable`."
msgstr ""
"可變物件可以改變它們的值，但維持它們的 :func:`id`\\ 。另請參閱 :term:"
"`immutable`\\ （不可變物件）。"

#: ../../glossary.rst:818
msgid "named tuple"
msgstr "named tuple（附名元組）"

#: ../../glossary.rst:820
msgid ""
"The term \"named tuple\" applies to any type or class that inherits from "
"tuple and whose indexable elements are also accessible using named "
"attributes.  The type or class may have other features as well."
msgstr ""
"術語「named tuple（附名元組）」是指從 tuple 繼承的任何型別或 class，且它的可"
"索引 (indexable) 元素也可以用附名屬性來存取。這些型別或 class 也可以具有其他"
"的特性。"

#: ../../glossary.rst:824
msgid ""
"Several built-in types are named tuples, including the values returned by :"
"func:`time.localtime` and :func:`os.stat`.  Another example is :data:`sys."
"float_info`::"
msgstr ""
"有些內建型別是 named tuple，包括由 :func:`time.localtime` 和 :func:`os.stat` "
"回傳的值。另一個例子是 :data:`sys.float_info`\\ ：\n"
"\n"
"::"

#: ../../glossary.rst:835
msgid ""
"Some named tuples are built-in types (such as the above examples). "
"Alternatively, a named tuple can be created from a regular class definition "
"that inherits from :class:`tuple` and that defines named fields.  Such a "
"class can be written by hand or it can be created with the factory function :"
"func:`collections.namedtuple`.  The latter technique also adds some extra "
"methods that may not be found in hand-written or built-in named tuples."
msgstr ""
"有些 named tuple 是內建型別（如上例）。或者，一個 named tuple 也可以從一個正"
"規的 class 定義來建立，只要該 class 是繼承自 :class:`tuple`\\ ，且定義了附名"
"欄位 (named field) 即可。這類的 class 可以手工編寫，也可以使用工廠函式 "
"(factory function) :func:`collections.namedtuple` 來建立。後者技術也增加了一"
"些額外的 method，這些 method 可能是在手寫或內建的 named tuple 中，無法找到"
"的。"

#: ../../glossary.rst:842
msgid "namespace"
msgstr "namespace（命名空間）"

#: ../../glossary.rst:844
msgid ""
"The place where a variable is stored.  Namespaces are implemented as "
"dictionaries.  There are the local, global and built-in namespaces as well "
"as nested namespaces in objects (in methods).  Namespaces support modularity "
"by preventing naming conflicts.  For instance, the functions :func:`builtins."
"open <.open>` and :func:`os.open` are distinguished by their namespaces.  "
"Namespaces also aid readability and maintainability by making it clear which "
"module implements a function.  For instance, writing :func:`random.seed` or :"
"func:`itertools.islice` makes it clear that those functions are implemented "
"by the :mod:`random` and :mod:`itertools` modules, respectively."
msgstr ""
"變數被儲存的地方。命名空間是以 dictionary（字典）被實作。有區域的、全域的及內"
"建的命名空間，而在物件中（在 method 中）也有巢狀的命名空間。命名空間藉由防止"
"命名衝突，來支援模組化。例如，函式 :func:`builtins.open <.open>` 和 :func:"
"`os.open` 是透過它們的命名空間來區分彼此。命名空間也藉由明確地區分是哪個模組"
"在實作一個函式，來增進可讀性及可維護性。例如，寫出 :func:`random.seed` 或 :"
"func:`itertools.islice` 明確地表示，這些函式分別是由 :mod:`random` 和 :mod:"
"`itertools` 模組在實作。"

#: ../../glossary.rst:854
msgid "namespace package"
msgstr "namespace package（命名空間套件）"

#: ../../glossary.rst:856
msgid ""
"A :pep:`420` :term:`package` which serves only as a container for "
"subpackages.  Namespace packages may have no physical representation, and "
"specifically are not like a :term:`regular package` because they have no "
"``__init__.py`` file."
msgstr ""
"一個 :pep:`420` :term:`package`\\ （套件），它只能作為子套件 (subpackage) 的"
"一個容器。命名空間套件可能沒有實體的表示法，而且具體來說它們不像是一個 :term:"
"`regular package`\\ （正規套件），因為它們並沒有 ``__init__.py`` 這個檔案。"

#: ../../glossary.rst:861
msgid "See also :term:`module`."
msgstr "另請參閱 :term:`module`\\ （模組）。"

#: ../../glossary.rst:862
msgid "nested scope"
msgstr "nested scope（巢狀作用域）"

#: ../../glossary.rst:864
msgid ""
"The ability to refer to a variable in an enclosing definition.  For "
"instance, a function defined inside another function can refer to variables "
"in the outer function.  Note that nested scopes by default work only for "
"reference and not for assignment.  Local variables both read and write in "
"the innermost scope.  Likewise, global variables read and write to the "
"global namespace.  The :keyword:`nonlocal` allows writing to outer scopes."
msgstr ""
"能夠參照外層定義 (enclosing definition) 中的變數的能力。舉例來說，一個函式如"
"果是在另一個函式中被定義，則它便能夠參照外層函式中的變數。請注意，在預設情況"
"下，巢狀作用域僅適用於參照，而無法用於賦值。區域變數能在最內層作用域中讀取及"
"寫入。同樣地，全域變數是在全域命名空間中讀取及寫入。\\ :keyword:`nonlocal` 容"
"許對外層作用域進行寫入。"

#: ../../glossary.rst:871
msgid "new-style class"
msgstr "new-style class（新式類別）"

#: ../../glossary.rst:873
msgid ""
"Old name for the flavor of classes now used for all class objects.  In "
"earlier Python versions, only new-style classes could use Python's newer, "
"versatile features like :attr:`~object.__slots__`, descriptors, properties, :"
"meth:`__getattribute__`, class methods, and static methods."
msgstr ""
"一個舊名，它是指現在所有的 class 物件所使用的 class 風格。在早期的 Python 版"
"本中，只有新式 class 才能使用 Python 較新的、多樣的功能，像是 :attr:`~object."
"__slots__`\\ 、描述器 (descriptor)、屬性 (property)、\\ :meth:"
"`__getattribute__`\\ 、class method（類別方法）和 static method（靜態方法）。"

#: ../../glossary.rst:877
msgid "object"
msgstr "object（物件）"

#: ../../glossary.rst:879
msgid ""
"Any data with state (attributes or value) and defined behavior (methods).  "
"Also the ultimate base class of any :term:`new-style class`."
msgstr ""
"具有狀態（屬性或值）及被定義的行為（method）的任何資料。它也是任何 :term:"
"`new-style class`\\ （新式類別）的最終 base class（基底類別）。"

#: ../../glossary.rst:882
msgid "package"
msgstr "package（套件）"

#: ../../glossary.rst:884
msgid ""
"A Python :term:`module` which can contain submodules or recursively, "
"subpackages.  Technically, a package is a Python module with a ``__path__`` "
"attribute."
msgstr ""
"一個 Python 的 :term:`module`\\ （模組），它可以包含子模組 (submodule) 或是遞"
"迴的子套件 (subpackage)。技術上而言，套件就是具有 ``__path__`` 屬性的一個 "
"Python 模組。"

#: ../../glossary.rst:888
msgid "See also :term:`regular package` and :term:`namespace package`."
msgstr ""
"另請參閱 :term:`regular package`\\ （正規套件）和 :term:`namespace package`"
"\\ （命名空間套件）。"

#: ../../glossary.rst:889
msgid "parameter"
msgstr "parameter（參數）"

#: ../../glossary.rst:891
msgid ""
"A named entity in a :term:`function` (or method) definition that specifies "
"an :term:`argument` (or in some cases, arguments) that the function can "
"accept.  There are five kinds of parameter:"
msgstr ""
"在 :term:`function`\\ （函式）或 method 定義中的一個命名實體 (named entity)，"
"它指明該函式能夠接受的一個 :term:`argument`\\ （引數），或在某些情況下指示多"
"個引數。共有有五種不同的參數類型："

#: ../../glossary.rst:895
msgid ""
":dfn:`positional-or-keyword`: specifies an argument that can be passed "
"either :term:`positionally <argument>` or as a :term:`keyword argument "
"<argument>`.  This is the default kind of parameter, for example *foo* and "
"*bar* in the following::"
msgstr ""
":dfn:`positional-or-keyword`\\ （位置或關鍵字）：指明一個可以\\ :term:`按照位"
"置 <argument>`\\ 或是作為\\ :term:`關鍵字引數 <argument>`\\ 被傳遞的引數。這"
"是參數的預設類型，例如以下的 *foo* 和 *bar*：\n"
"\n"
"::"

#: ../../glossary.rst:904
msgid ""
":dfn:`positional-only`: specifies an argument that can be supplied only by "
"position. Positional-only parameters can be defined by including a ``/`` "
"character in the parameter list of the function definition after them, for "
"example *posonly1* and *posonly2* in the following::"
msgstr ""
":dfn:`positional-only`\\ （僅限位置）：指明一個只能按照位置被提供的引數。在函"
"式定義的參數列表中包含一個 ``/`` 字元，就可以在該字元前面定義僅限位置參數，例"
"如以下的 *posonly1* 和 *posonly2*：\n"
"\n"
"::"

#: ../../glossary.rst:913
msgid ""
":dfn:`keyword-only`: specifies an argument that can be supplied only by "
"keyword.  Keyword-only parameters can be defined by including a single var-"
"positional parameter or bare ``*`` in the parameter list of the function "
"definition before them, for example *kw_only1* and *kw_only2* in the "
"following::"
msgstr ""
":dfn:`keyword-only`\\ （僅限關鍵字）：指明一個只能以關鍵字被提供的引數。在函"
"式定義的參數列表中，包含一個任意數量位置參數 (var-positional parameter) 或是"
"單純的 ``*`` 字元，就可以在其後方定義僅限關鍵字參數，例如以下的 *kw_only1* "
"和 *kw_only2*：\n"
"\n"
"::"

#: ../../glossary.rst:921
msgid ""
":dfn:`var-positional`: specifies that an arbitrary sequence of positional "
"arguments can be provided (in addition to any positional arguments already "
"accepted by other parameters).  Such a parameter can be defined by "
"prepending the parameter name with ``*``, for example *args* in the "
"following::"
msgstr ""
":dfn:`var-positional`\\ （任意數量位置）：指明一串能以任意序列被提供的位置引"
"數（在已被其他參數接受的任何位置引數之外）。這類參數是透過在其參數名稱字首加"
"上 ``*`` 來定義的，例如以下的 *args*：\n"
"\n"
"::"

#: ../../glossary.rst:929
msgid ""
":dfn:`var-keyword`: specifies that arbitrarily many keyword arguments can be "
"provided (in addition to any keyword arguments already accepted by other "
"parameters).  Such a parameter can be defined by prepending the parameter "
"name with ``**``, for example *kwargs* in the example above."
msgstr ""
":dfn:`var-keyword`\\ （任意數量關鍵字）：指明可被提供的任意數量關鍵字引數（在"
"已被其他參數接受的任何關鍵字引數之外）。這類參數是透過在其參數名稱字首加上 "
"``**`` 來定義的，例如上面範例中的 *kwargs*。"

#: ../../glossary.rst:935
msgid ""
"Parameters can specify both optional and required arguments, as well as "
"default values for some optional arguments."
msgstr ""
"參數可以指明引數是選擇性的或必需的，也可以為一些選擇性的引數指定預設值。"

#: ../../glossary.rst:938
msgid ""
"See also the :term:`argument` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"the :class:`inspect.Parameter` class, the :ref:`function` section, and :pep:"
"`362`."
msgstr ""
"另請參閱術語表的 :term:`argument`\\ （引數）條目、常見問題中的\\ :ref:`引數和"
"參數之間的差異 <faq-argument-vs-parameter>`\\ 、\\ :class:`inspect."
"Parameter` class、\\ :ref:`function`\\ 章節，以及 :pep:`362`\\ 。"

#: ../../glossary.rst:942
msgid "path entry"
msgstr "path entry（路徑項目）"

#: ../../glossary.rst:944
msgid ""
"A single location on the :term:`import path` which the :term:`path based "
"finder` consults to find modules for importing."
msgstr ""
"在 :term:`import path`\\ （匯入路徑）中的一個位置，而 :term:`path based "
"finder` （基於路徑的尋檢器）會參考該位置來尋找要 import 的模組。"

#: ../../glossary.rst:946
msgid "path entry finder"
msgstr "path entry finder（路徑項目尋檢器）"

#: ../../glossary.rst:948
msgid ""
"A :term:`finder` returned by a callable on :data:`sys.path_hooks` (i.e. a :"
"term:`path entry hook`) which knows how to locate modules given a :term:"
"`path entry`."
msgstr ""
"被 :data:`sys.path_hooks` 中的一個可呼叫物件 (callable)（意即一個 :term:"
"`path entry hook`\\ ）所回傳的一種 :term:`finder`\\ ，它知道如何以一個 :term:"
"`path entry`\\ 定位模組。"

#: ../../glossary.rst:952
msgid ""
"See :class:`importlib.abc.PathEntryFinder` for the methods that path entry "
"finders implement."
msgstr ""
"關於路徑項目尋檢器實作的 method，請參閱 :class:`importlib.abc."
"PathEntryFinder`\\ 。"

#: ../../glossary.rst:954
msgid "path entry hook"
msgstr "path entry hook（路徑項目鉤）"

#: ../../glossary.rst:956
msgid ""
"A callable on the :data:`sys.path_hook` list which returns a :term:`path "
"entry finder` if it knows how to find modules on a specific :term:`path "
"entry`."
msgstr ""
"在 :data:`sys.path_hook` 列表中的一個可呼叫物件 (callable)，若它知道如何在一"
"個特定的 :term:`path entry` 中尋找模組，則會回傳一個 :term:`path entry "
"finder`\\ （路徑項目尋檢器）。"

#: ../../glossary.rst:959
msgid "path based finder"
msgstr "path based finder（基於路徑的尋檢器）"

#: ../../glossary.rst:961
msgid ""
"One of the default :term:`meta path finders <meta path finder>` which "
"searches an :term:`import path` for modules."
msgstr ""
"預設的\\ :term:`元路徑尋檢器 (meta path finder) <meta path finder>` 之一，它"
"會在一個 :term:`import path` 中搜尋模組。"

#: ../../glossary.rst:963
msgid "path-like object"
msgstr "path-like object（類路徑物件）"

#: ../../glossary.rst:965
msgid ""
"An object representing a file system path. A path-like object is either a :"
"class:`str` or :class:`bytes` object representing a path, or an object "
"implementing the :class:`os.PathLike` protocol. An object that supports the :"
"class:`os.PathLike` protocol can be converted to a :class:`str` or :class:"
"`bytes` file system path by calling the :func:`os.fspath` function; :func:"
"`os.fsdecode` and :func:`os.fsencode` can be used to guarantee a :class:"
"`str` or :class:`bytes` result instead, respectively. Introduced by :pep:"
"`519`."
msgstr ""
"一個表示檔案系統路徑的物件。類路徑物件可以是一個表示路徑的 :class:`str` 或 :"
"class:`bytes` 物件，或是一個實作 :class:`os.PathLike` 協定的物件。透過呼叫 :"
"func:`os.fspath` 函式，一個支援 :class:`os.PathLike` 協定的物件可以被轉換為 :"
"class:`str` 或 :class:`bytes` 檔案系統路徑；而 :func:`os.fsdecode` 及 :func:"
"`os.fsencode` 則分別可用於確保 :class:`str` 及 :class:`bytes` 的結果。由 :"
"pep:`519` 引入。"

#: ../../glossary.rst:973
msgid "PEP"
msgstr "PEP"

#: ../../glossary.rst:975
msgid ""
"Python Enhancement Proposal. A PEP is a design document providing "
"information to the Python community, or describing a new feature for Python "
"or its processes or environment. PEPs should provide a concise technical "
"specification and a rationale for proposed features."
msgstr ""
"Python Enhancement Proposal（Python 增強提案）。PEP 是一份設計說明文件，它能"
"為 Python 社群提供資訊，或是描述 Python 的一個新功能或該功能的程序和環境。"
"PEP 應該要提供簡潔的技術規範以及被提案功能的運作原理。"

#: ../../glossary.rst:981
msgid ""
"PEPs are intended to be the primary mechanisms for proposing major new "
"features, for collecting community input on an issue, and for documenting "
"the design decisions that have gone into Python. The PEP author is "
"responsible for building consensus within the community and documenting "
"dissenting opinions."
msgstr ""
"PEP 的存在目的，是要成為重大新功能的提案、社群中關於某個問題的意見收集，以及"
"已納入 Python 的設計決策的記錄，這些過程的主要機制。PEP 的作者要負責在社群內"
"建立共識並記錄反對意見。"

#: ../../glossary.rst:987
msgid "See :pep:`1`."
msgstr "請參閱 :pep:`1`\\ 。"

#: ../../glossary.rst:988
msgid "portion"
msgstr "portion（部分）"

#: ../../glossary.rst:990
msgid ""
"A set of files in a single directory (possibly stored in a zip file) that "
"contribute to a namespace package, as defined in :pep:`420`."
msgstr ""
"在單一目錄中的一組檔案（也可能儲存在一個 zip 檔中），這些檔案能對一個命名空間"
"套件 (namespace package) 有所貢獻，如同 :pep:`420` 中的定義。"

#: ../../glossary.rst:992
msgid "positional argument"
msgstr "positional argument（位置引數）"

#: ../../glossary.rst:995
msgid "provisional API"
msgstr "provisional API（暫行 API）"

#: ../../glossary.rst:997
msgid ""
"A provisional API is one which has been deliberately excluded from the "
"standard library's backwards compatibility guarantees.  While major changes "
"to such interfaces are not expected, as long as they are marked provisional, "
"backwards incompatible changes (up to and including removal of the "
"interface) may occur if deemed necessary by core developers.  Such changes "
"will not be made gratuitously -- they will occur only if serious fundamental "
"flaws are uncovered that were missed prior to the inclusion of the API."
msgstr ""
"暫行 API 是指，從標準函式庫的向後相容性 (backwards compatibility) 保證中，故"
"意被排除的 API。雖然此類介面，只要它們被標示為暫行的，理論上並不會有重大的變"
"更，但如果核心開發人員認為有必要，也可能會出現向後不相容的變更（甚至包括移除"
"該介面）。這種變更並不會無端地產生——只有 API 被納入之前未察覺的嚴重基本缺陷被"
"揭露時，它們才會發生。"

#: ../../glossary.rst:1006
msgid ""
"Even for provisional APIs, backwards incompatible changes are seen as a "
"\"solution of last resort\" - every attempt will still be made to find a "
"backwards compatible resolution to any identified problems."
msgstr ""
"即使對於暫行 API，向後不相容的變更也會被視為「最後的解決方案」——對於任何被發"
"現的問題，仍然會盡可能找出一個向後相容的解決方案。"

#: ../../glossary.rst:1010
msgid ""
"This process allows the standard library to continue to evolve over time, "
"without locking in problematic design errors for extended periods of time.  "
"See :pep:`411` for more details."
msgstr ""
"這個過程使得標準函式庫能隨著時間不斷進化，而避免耗費過長的時間去鎖定有問題的"
"設計錯誤。請參閱 :pep:`411` 了解更多細節。"

#: ../../glossary.rst:1013
msgid "provisional package"
msgstr "provisional package（暫行套件）"

#: ../../glossary.rst:1015
msgid "See :term:`provisional API`."
msgstr "請參閱 :term:`provisional API`\\ （暫行 API）。"

#: ../../glossary.rst:1016
msgid "Python 3000"
msgstr "Python 3000"

#: ../../glossary.rst:1018
msgid ""
"Nickname for the Python 3.x release line (coined long ago when the release "
"of version 3 was something in the distant future.)  This is also abbreviated "
"\"Py3k\"."
msgstr ""
"Python 3.x 系列版本的暱稱（很久以前創造的，當時第 3 版的發布是在遙遠的未"
"來。）也可以縮寫為「Py3k」。"

#: ../../glossary.rst:1021
msgid "Pythonic"
msgstr "Pythonic（Python 風格的）"

#: ../../glossary.rst:1023
msgid ""
"An idea or piece of code which closely follows the most common idioms of the "
"Python language, rather than implementing code using concepts common to "
"other languages.  For example, a common idiom in Python is to loop over all "
"elements of an iterable using a :keyword:`for` statement.  Many other "
"languages don't have this type of construct, so people unfamiliar with "
"Python sometimes use a numerical counter instead::"
msgstr ""
"一個想法或一段程式碼，它應用了 Python 語言最常見的慣用語，而不是使用其他語言"
"常見的概念來實作程式碼。例如，Python 中常見的一種習慣用法，是使用一個 :"
"keyword:`for` 陳述式，對一個可疊代物件的所有元素進行迴圈。許多其他語言並沒有"
"這種類型的架構，所以不熟悉 Python 的人有時會使用一個數值計數器來代替：\n"
"\n"
"::"

#: ../../glossary.rst:1033
msgid "As opposed to the cleaner, Pythonic method::"
msgstr ""
"相較之下，以下方法更簡潔、更具有 Python 風格：\n"
"\n"
"::"

#: ../../glossary.rst:1037
msgid "qualified name"
msgstr "qualified name（限定名稱）"

#: ../../glossary.rst:1039
msgid ""
"A dotted name showing the \"path\" from a module's global scope to a class, "
"function or method defined in that module, as defined in :pep:`3155`.  For "
"top-level functions and classes, the qualified name is the same as the "
"object's name::"
msgstr ""
"一個「點分隔名稱」，它顯示從一個模組的全域作用域到該模組中定義的 class、函式"
"或 method 的「路徑」，如 :pep:`3155` 中的定義。對於頂層的函式和 class 而言，"
"限定名稱與其物件名稱相同：\n"
"\n"
"::"

#: ../../glossary.rst:1056
msgid ""
"When used to refer to modules, the *fully qualified name* means the entire "
"dotted path to the module, including any parent packages, e.g. ``email.mime."
"text``::"
msgstr ""
"當用於引用模組時，\\ *完全限定名稱 (fully qualified name)* 是表示該模組的完整"
"點分隔路徑，包括任何的父套件，例如 ``email.mime.text``：\n"
"\n"
"::"

#: ../../glossary.rst:1063
msgid "reference count"
msgstr "reference count（參照計數）"

#: ../../glossary.rst:1065
msgid ""
"The number of references to an object.  When the reference count of an "
"object drops to zero, it is deallocated.  Reference counting is generally "
"not visible to Python code, but it is a key element of the :term:`CPython` "
"implementation.  Programmers can call the :func:`sys.getrefcount` function "
"to return the reference count for a particular object."
msgstr ""
"對於一個物件的參照次數。當一個物件的參照計數下降到零時，它會被解除配置 "
"(deallocated)。參照計數通常在 Python 程式碼中看不到，但它卻是 :term:"
"`CPython` 實作的一個關鍵元素。程式設計師可以呼叫 :func:`~sys.getrefcount` 函"
"式來回傳一個特定物件的參照計數。"

#: ../../glossary.rst:1071
msgid "regular package"
msgstr "regular package（正規套件）"

#: ../../glossary.rst:1073
msgid ""
"A traditional :term:`package`, such as a directory containing an ``__init__."
"py`` file."
msgstr ""
"一個傳統的 :term:`package`\\ （套件），例如一個包含 ``__init__.py`` 檔案的目"
"錄。"

#: ../../glossary.rst:1076
msgid "See also :term:`namespace package`."
msgstr "另請參閱 :term:`namespace package`\\ （命名空間套件）。"

#: ../../glossary.rst:1077
msgid "__slots__"
msgstr "__slots__"

#: ../../glossary.rst:1079
msgid ""
"A declaration inside a class that saves memory by pre-declaring space for "
"instance attributes and eliminating instance dictionaries.  Though popular, "
"the technique is somewhat tricky to get right and is best reserved for rare "
"cases where there are large numbers of instances in a memory-critical "
"application."
msgstr ""
"在 class 內部的一個宣告，它藉由預先宣告實例屬性的空間，以及消除實例 "
"dictionary（字典），來節省記憶體。雖然該技術很普遍，但它有點難以正確地使用，"
"最好保留給那種在一個記憶體關鍵 (memory-critical) 的應用程式中存在大量實例的罕"
"見情況。"

#: ../../glossary.rst:1084
msgid "sequence"
msgstr "sequence（序列）"

#: ../../glossary.rst:1086
msgid ""
"An :term:`iterable` which supports efficient element access using integer "
"indices via the :meth:`__getitem__` special method and defines a :meth:"
"`__len__` method that returns the length of the sequence. Some built-in "
"sequence types are :class:`list`, :class:`str`, :class:`tuple`, and :class:"
"`bytes`. Note that :class:`dict` also supports :meth:`__getitem__` and :meth:"
"`__len__`, but is considered a mapping rather than a sequence because the "
"lookups use arbitrary :term:`immutable` keys rather than integers."
msgstr ""
"一個 :term:`iterable`\\ （可疊代物件），它透過 :meth:`__getitem__` special "
"method（特殊方法），使用整數索引來支援高效率的元素存取，並定義了一個 :meth:"
"`__len__` method 來回傳該序列的長度。一些內建序列型別包括 :class:`list`"
"\\ 、\\ :class:`str`\\ 、\\ :class:`tuple` 和 :class:`bytes`\\ 。請注意，雖"
"然 :class:`dict` 也支援 :meth:`__getitem__` 和 :meth:`__len__`\\ ，但它被視為"
"對映 (mapping) 而不是序列，因為其查找方式是使用任意的 :term:`immutable` 鍵，"
"而不是整數。"

#: ../../glossary.rst:1095
msgid ""
"The :class:`collections.abc.Sequence` abstract base class defines a much "
"richer interface that goes beyond just :meth:`__getitem__` and :meth:"
"`__len__`, adding :meth:`count`, :meth:`index`, :meth:`__contains__`, and :"
"meth:`__reversed__`. Types that implement this expanded interface can be "
"registered explicitly using :func:`~abc.ABCMeta.register`."
msgstr ""
"抽象基底類別 (abstract base class) :class:`collections.abc.Sequence` 定義了一"
"個更加豐富的介面，並不僅止於 :meth:`__getitem__` 和 :meth:`__len__`\\ ，還增"
"加了 :meth:`count`\\ 、\\ :meth:`index`\\ 、\\ :meth:`__contains__` 和 :meth:"
"`__reversed__`\\ 。實作此擴充介面的型別，可以使用 :func:`~abc.ABCMeta."
"register` 被明確地註冊。"

#: ../../glossary.rst:1102
msgid "set comprehension"
msgstr "set comprehension（集合綜合運算）"

#: ../../glossary.rst:1104
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a set with the results. ``results = {c for c in 'abracadabra' if c "
"not in 'abc'}`` generates the set of strings ``{'r', 'd'}``.  See :ref:"
"`comprehensions`."
msgstr ""
"一種緊密的方法，用來處理一個可疊代物件中的全部或部分元素，並將處理結果以一個 "
"set 回傳。``results = {c for c in 'abracadabra' if c not in 'abc'}`` 會產生一"
"個字串 set：``{'r', 'd'}``。請參閱\\ :ref:`comprehensions`\\ 。"

#: ../../glossary.rst:1108
msgid "single dispatch"
msgstr "single dispatch（單一調度）"

#: ../../glossary.rst:1110
msgid ""
"A form of :term:`generic function` dispatch where the implementation is "
"chosen based on the type of a single argument."
msgstr ""
":term:`generic function`\\ （泛型函式）調度的一種形式，在此，實作的選擇是基於"
"單一引數的型別。"

#: ../../glossary.rst:1112
msgid "slice"
msgstr "slice（切片）"

#: ../../glossary.rst:1114
msgid ""
"An object usually containing a portion of a :term:`sequence`.  A slice is "
"created using the subscript notation, ``[]`` with colons between numbers "
"when several are given, such as in ``variable_name[1:3:5]``.  The bracket "
"(subscript) notation uses :class:`slice` objects internally."
msgstr ""
"一個物件，它通常包含一段 :term:`sequence`\\ （序列）的某一部分。建立一段切片"
"的方法是使用下標符號 (subscript notation) ``[]``\\ ，若要給出多個數字，則在數"
"字之間使用冒號，例如 ``variable_name[1:3:5]``。在括號（下標）符號的內部，會使"
"用 :class:`slice` 物件。"

#: ../../glossary.rst:1118
msgid "special method"
msgstr "special method（特殊方法）"

#: ../../glossary.rst:1122
msgid ""
"A method that is called implicitly by Python to execute a certain operation "
"on a type, such as addition.  Such methods have names starting and ending "
"with double underscores.  Special methods are documented in :ref:"
"`specialnames`."
msgstr ""
"一種會被 Python 自動呼叫的 method，用於對某種型別執行某種運算，例如加法。這"
"種 method 的名稱會在開頭和結尾有兩個下底線。Special method 在\\ :ref:"
"`specialnames`\\ 中有詳細說明。"

#: ../../glossary.rst:1126
msgid "statement"
msgstr "statement（陳述式）"

#: ../../glossary.rst:1128
msgid ""
"A statement is part of a suite (a \"block\" of code).  A statement is either "
"an :term:`expression` or one of several constructs with a keyword, such as :"
"keyword:`if`, :keyword:`while` or :keyword:`for`."
msgstr ""
"陳述式是一個套組（suite，一個程式碼「區塊」）中的一部分。陳述式可以是一個 :"
"term:`expression`\\ （運算式），或是含有關鍵字（例如 :keyword:`if`\\ 、\\ :"
"keyword:`while` 或 :keyword:`for`\\ ）的多種結構之一。"

#: ../../glossary.rst:1131
msgid "strong reference"
msgstr "strong reference（強參照）"

#: ../../glossary.rst:1133
msgid ""
"In Python's C API, a strong reference is a reference to an object which "
"increments the object's reference count when it is created and decrements "
"the object's reference count when it is deleted."
msgstr ""
"在 Python 的 C API 中，強參照是一個對物件的參照，在它被建立時會增加該物件的參"
"照計數 (reference count)，在它被刪除時則會減少該物件的參照計數。"

#: ../../glossary.rst:1137
msgid ""
"The :c:func:`Py_NewRef` function can be used to create a strong reference to "
"an object. Usually, the :c:func:`Py_DECREF` function must be called on the "
"strong reference before exiting the scope of the strong reference, to avoid "
"leaking one reference."
msgstr ""
":c:func:`Py_NewRef` 函式可用於建立一個對物件的強參照。通常，在退出強參照的作"
"用域之前，必須在該強參照上呼叫 :c:func:`Py_DECREF` 函式，以避免洩漏一個參照。"

#: ../../glossary.rst:1142
msgid "See also :term:`borrowed reference`."
msgstr "另請參閱 :term:`borrowed reference`\\ （借用參照）。"

#: ../../glossary.rst:1143
msgid "text encoding"
msgstr "text encoding（文字編碼）"

#: ../../glossary.rst:1145
msgid ""
"A string in Python is a sequence of Unicode code points (in range ``U"
"+0000``--``U+10FFFF``). To store or transfer a string, it needs to be "
"serialized as a sequence of bytes."
msgstr ""
"Python 中的字串是一個 Unicode 碼點 (code point) 的序列（範圍在 ``U+0000`` -- "
"``U+10FFFF`` 之間）。若要儲存或傳送一個字串，它必須被序列化為一個位元組序列。"

#: ../../glossary.rst:1149
msgid ""
"Serializing a string into a sequence of bytes is known as \"encoding\", and "
"recreating the string from the sequence of bytes is known as \"decoding\"."
msgstr ""
"將一個字串序列化為位元組序列，稱為「編碼」，而從位元組序列重新建立該字串則稱"
"為「解碼 (decoding)」。"

#: ../../glossary.rst:1152
msgid ""
"There are a variety of different text serialization :ref:`codecs <standard-"
"encodings>`, which are collectively referred to as \"text encodings\"."
msgstr ""
"有多種不同的文字序列化編解碼器 (:ref:`codecs <standard-encodings>`)，它們被統"
"稱為「文字編碼」。"

#: ../../glossary.rst:1155
msgid "text file"
msgstr "text file（文字檔案）"

#: ../../glossary.rst:1157
msgid ""
"A :term:`file object` able to read and write :class:`str` objects. Often, a "
"text file actually accesses a byte-oriented datastream and handles the :term:"
"`text encoding` automatically. Examples of text files are files opened in "
"text mode (``'r'`` or ``'w'``), :data:`sys.stdin`, :data:`sys.stdout`, and "
"instances of :class:`io.StringIO`."
msgstr ""
"一個能夠讀取和寫入 :class:`str` 物件的一個 :term:`file object`\\ （檔案物"
"件）。通常，文字檔案實際上是存取位元組導向的資料流 (byte-oriented "
"datastream) 並會自動處理 :term:`text encoding`\\ （文字編碼）。文字檔案的例子"
"有：以文字模式（``'r'`` 或 ``'w'``）開啟的檔案、\\ :data:`sys.stdin`\\ 、\\ :"
"data:`sys.stdout` 以及 :class:`io.StringIO` 的實例。"

#: ../../glossary.rst:1164
msgid ""
"See also :term:`binary file` for a file object able to read and write :term:"
"`bytes-like objects <bytes-like object>`."
msgstr ""
"另請參閱 :term:`binary file`\\ （二進制檔案），它是一個能夠讀取和寫入\\ :"
"term:`類位元組串物件 (bytes-like object) <bytes-like object>` 的檔案物件。"

#: ../../glossary.rst:1166
msgid "triple-quoted string"
msgstr "triple-quoted string（三引號內字串）"

#: ../../glossary.rst:1168
msgid ""
"A string which is bound by three instances of either a quotation mark (\") "
"or an apostrophe (').  While they don't provide any functionality not "
"available with single-quoted strings, they are useful for a number of "
"reasons.  They allow you to include unescaped single and double quotes "
"within a string and they can span multiple lines without the use of the "
"continuation character, making them especially useful when writing "
"docstrings."
msgstr ""
"由三個雙引號 (“) 或單引號 (') 的作為邊界的一個字串。雖然它們並沒有提供異於單"
"引號字串的任何額外功能，但基於許多原因，它們仍是很有用的。它們讓你可以在字串"
"中包含未跳脫 (unescaped) 的單引號和雙引號，而且它們不需使用連續字元 "
"(continuation character) 就可以跨越多行，這使得它們在編寫說明字串時特別有用。"

#: ../../glossary.rst:1175
msgid "type"
msgstr "type（型別）"

#: ../../glossary.rst:1177
msgid ""
"The type of a Python object determines what kind of object it is; every "
"object has a type.  An object's type is accessible as its :attr:`~instance."
"__class__` attribute or can be retrieved with ``type(obj)``."
msgstr ""
"一個 Python 物件的型別決定了它是什麼類型的物件；每個物件都有一個型別。一個物"
"件的型別可以用它的 :attr:`~instance.__class__` 屬性來存取，或以 "
"``type(obj)`` 來檢索。"

#: ../../glossary.rst:1181
msgid "type alias"
msgstr "type alias（型別別名）"

#: ../../glossary.rst:1183
msgid "A synonym for a type, created by assigning the type to an identifier."
msgstr "一個型別的同義詞，透過將型別指定給一個識別符 (identifier) 來建立。"

#: ../../glossary.rst:1185
msgid ""
"Type aliases are useful for simplifying :term:`type hints <type hint>`. For "
"example::"
msgstr ""
"型別別名對於簡化\\ :term:`型別提示 (type hint) <type hint>` 很有用。例如：\n"
"\n"
"::"

#: ../../glossary.rst:1192
msgid "could be made more readable like this::"
msgstr ""
"可以寫成這樣，更具有可讀性：\n"
"\n"
"::"

#: ../../glossary.rst:1199 ../../glossary.rst:1213
msgid "See :mod:`typing` and :pep:`484`, which describe this functionality."
msgstr "請參閱 :mod:`typing` 和 :pep:`484`\\ ，有此功能的描述。"

#: ../../glossary.rst:1200
msgid "type hint"
msgstr "type hint（型別提示）"

#: ../../glossary.rst:1202
msgid ""
"An :term:`annotation` that specifies the expected type for a variable, a "
"class attribute, or a function parameter or return value."
msgstr ""
"一種 :term:`annotation`\\ （註釋），它指定一個變數、一個 class 屬性或一個函式"
"的參數或回傳值的預期型別。"

#: ../../glossary.rst:1205
msgid ""
"Type hints are optional and are not enforced by Python but they are useful "
"to static type analysis tools, and aid IDEs with code completion and "
"refactoring."
msgstr ""
"型別提示是選擇性的，而不是被 Python 強制的，但它們對靜態型別分析工具很有用，"
"並能協助 IDE 完成程式碼的補全 (completion) 和重構 (refactoring)。"

#: ../../glossary.rst:1209
msgid ""
"Type hints of global variables, class attributes, and functions, but not "
"local variables, can be accessed using :func:`typing.get_type_hints`."
msgstr ""
"全域變數、class 屬性和函式（不含區域變數）的型別提示，都可以使用 :func:"
"`typing.get_type_hints` 來存取。"

#: ../../glossary.rst:1214
msgid "universal newlines"
msgstr "universal newlines（通用換行字元）"

#: ../../glossary.rst:1216
msgid ""
"A manner of interpreting text streams in which all of the following are "
"recognized as ending a line: the Unix end-of-line convention ``'\\n'``, the "
"Windows convention ``'\\r\\n'``, and the old Macintosh convention "
"``'\\r'``.  See :pep:`278` and :pep:`3116`, as well as :func:`bytes."
"splitlines` for an additional use."
msgstr ""
"一種解譯文字流 (text stream) 的方式，會將以下所有的情況識別為一行的結束："
"Unix 行尾慣例 ``'\\n'``、Windows 慣例 ``'\\r\\n'`` 和舊的 Macintosh 慣例 "
"``'\\r'``。請參閱 :pep:`278` 和 :pep:`3116`\\ ，以及用於 :func:`bytes."
"splitlines` 的附加用途。"

#: ../../glossary.rst:1221
msgid "variable annotation"
msgstr "variable annotation（變數註釋）"

#: ../../glossary.rst:1223
msgid "An :term:`annotation` of a variable or a class attribute."
msgstr "一個變數或 class 屬性的 :term:`annotation`\\ （註釋）。"

#: ../../glossary.rst:1225
msgid ""
"When annotating a variable or a class attribute, assignment is optional::"
msgstr ""
"註釋變數或 class 屬性時，賦值是選擇性的：\n"
"\n"
"::"

#: ../../glossary.rst:1230
msgid ""
"Variable annotations are usually used for :term:`type hints <type hint>`: "
"for example this variable is expected to take :class:`int` values::"
msgstr ""
"變數註釋通常用於\\ :term:`型別提示 (type hint) <type hint>`\\ ：例如，這個變"
"數預期會取得 :class:`int`\\ （整數）值：\n"
"\n"
"::"

#: ../../glossary.rst:1236
msgid "Variable annotation syntax is explained in section :ref:`annassign`."
msgstr "變數註釋的語法在\\ :ref:`annassign`\\ 章節有詳細的解釋。"

#: ../../glossary.rst:1238
msgid ""
"See :term:`function annotation`, :pep:`484` and :pep:`526`, which describe "
"this functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr ""
"請參閱 :term:`function annotation`\\ （函式註釋）、\\ :pep:`484` 和 :pep:"
"`526`\\ ，皆有此功能的描述。關於註釋的最佳實踐方法，另請參閱 :ref:"
"`annotations-howto`\\ 。"

#: ../../glossary.rst:1242
msgid "virtual environment"
msgstr "virtual environment（虛擬環境）"

#: ../../glossary.rst:1244
msgid ""
"A cooperatively isolated runtime environment that allows Python users and "
"applications to install and upgrade Python distribution packages without "
"interfering with the behaviour of other Python applications running on the "
"same system."
msgstr ""
"一個協作隔離 (cooperatively isolated) 的執行環境，能讓 Python 的使用者和應用"
"程式得以安裝和升級 Python 發佈套件，而不會對同一個系統上運行的其他 Python 應"
"用程式的行為產生干擾。"

#: ../../glossary.rst:1249
msgid "See also :mod:`venv`."
msgstr "另請參閱 :mod:`venv`\\ 。"

#: ../../glossary.rst:1250
msgid "virtual machine"
msgstr "virtual machine（虛擬機器）"

#: ../../glossary.rst:1252
msgid ""
"A computer defined entirely in software.  Python's virtual machine executes "
"the :term:`bytecode` emitted by the bytecode compiler."
msgstr ""
"一部完全由軟體所定義的電腦 (computer)。Python 的虛擬機器會執行由 :term:"
"`bytecode`\\ （位元組碼）編譯器所發出的位元組碼。"

#: ../../glossary.rst:1254
msgid "Zen of Python"
msgstr "Zen of Python（Python 之禪）"

#: ../../glossary.rst:1256
msgid ""
"Listing of Python design principles and philosophies that are helpful in "
"understanding and using the language.  The listing can be found by typing "
"\"``import this``\" at the interactive prompt."
msgstr ""
"Python 設計原則與哲學的列表，其內容有助於理解和使用此語言。此列表可以透過在互"
"動式提式字元後輸入「``import this``」來找到它。"

#~ msgid "coercion"
#~ msgstr "coercion（強制轉型）"

#~ msgid ""
#~ "The implicit conversion of an instance of one type to another during an "
#~ "operation which involves two arguments of the same type.  For example, "
#~ "``int(3.15)`` converts the floating point number to the integer ``3``, "
#~ "but in ``3+4.5``, each argument is of a different type (one int, one "
#~ "float), and both must be converted to the same type before they can be "
#~ "added or it will raise a :exc:`TypeError`.  Without coercion, all "
#~ "arguments of even compatible types would have to be normalized to the "
#~ "same value by the programmer, e.g., ``float(3)+4.5`` rather than just "
#~ "``3+4.5``."
#~ msgstr ""
#~ "在涉及兩個不同型別引數的操作過程中，將某一種型別的實例換為另一種型別的隱式"
#~ "轉換 (implicit conversion) 過程。例如，``int(3.15)`` 會將浮點數轉換為整數 "
#~ "``3``，但在 ``3+4.5`` 中，每個引數是不同的型別（一個 int，一個 float），而"
#~ "這兩個引數必須在被轉換為相同的型別之後才能相加，否則就會引發 :exc:"
#~ "`TypeError`\\ 。如果沒有強制轉型，即使所有的引數型別皆相容，它們都必須要由"
#~ "程式設計師正規化 (normalize) 為相同的值，例如，要用 ``float(3)+4.5`` 而不"
#~ "能只是 ``3+4.5``。"

#~ msgid ""
#~ "Python uses the :term:`filesystem encoding and error handler` to convert "
#~ "between Unicode filenames and bytes filenames."
#~ msgstr ""
#~ "Python 使用 :term:`filesystem encoding and error handler`\\ （檔案系統編碼"
#~ "和錯誤處理函式）在 Unicode 檔案名稱和位元組檔案名稱之間進行轉換。"

#~ msgid "A codec which encodes Unicode strings to bytes."
#~ msgstr "將 Unicode 字串編碼為位元組的一個編解碼器 (codec)。"
