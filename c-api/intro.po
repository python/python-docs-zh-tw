# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Matt Wang <mattwang44@gmail.com>, 2023
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-07-17 17:39+0800\n"
"PO-Revision-Date: 2023-04-25 18:01+0800\n"
"Last-Translator: Matt Wang <mattwang44@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../c-api/intro.rst:8
msgid "Introduction"
msgstr "簡介"

#: ../../c-api/intro.rst:10
msgid ""
"The Application Programmer's Interface to Python gives C and C++ programmers "
"access to the Python interpreter at a variety of levels.  The API is equally "
"usable from C++, but for brevity it is generally referred to as the Python/C "
"API.  There are two fundamentally different reasons for using the Python/C "
"API. The first reason is to write *extension modules* for specific purposes; "
"these are C modules that extend the Python interpreter.  This is probably "
"the most common use.  The second reason is to use Python as a component in a "
"larger application; this technique is generally referred to as :dfn:"
"`embedding` Python in an application."
msgstr ""
"對於 Python 的應用程式開發介面使得 C 和 C++ 開發者能夠在各種層級存取 Python "
"直譯器。該 API 同樣可用於 C++，但為簡潔起見，通常將其稱為 Python/C API。使用 "
"Python/C API 有兩個不同的原因，第一個是為特定目的來編寫\\ *擴充模組*；這些是"
"擴充 Python 直譯器的 C 模組，這可能是最常見的用法。第二個原因是在更大的應用程"
"式中將 Python 作為零件使用；這種技術通常在應用程式中稱為 :dfn:`embedding`\\ "
"（嵌入式）Python。"

#: ../../c-api/intro.rst:20
msgid ""
"Writing an extension module is a relatively well-understood process, where a "
"\"cookbook\" approach works well.  There are several tools that automate the "
"process to some extent.  While people have embedded Python in other "
"applications since its early existence, the process of embedding Python is "
"less straightforward than writing an extension."
msgstr ""
"編寫擴充模組是一個相對容易理解的過程，其中「食譜 (cookbook)」方法很有效。有幾"
"種工具可以在一定程度上自動化該過程，儘管人們從早期就將 Python 嵌入到其他應用"
"程式中，但嵌入 Python 的過程並不像編寫擴充那樣簡單。"

#: ../../c-api/intro.rst:26
msgid ""
"Many API functions are useful independent of whether you're embedding  or "
"extending Python; moreover, most applications that embed Python  will need "
"to provide a custom extension as well, so it's probably a  good idea to "
"become familiar with writing an extension before  attempting to embed Python "
"in a real application."
msgstr ""
"不論你是嵌入還是擴充 Python，許多 API 函式都是很有用的；此外，大多數嵌入 "
"Python 的應用程式也需要提供自定義擴充模組，因此在嘗試將 Python 嵌入實際應用程"
"式之前熟悉編寫擴充可能是個好主意。"

#: ../../c-api/intro.rst:34
msgid "Coding standards"
msgstr "編寫標準"

#: ../../c-api/intro.rst:36
msgid ""
"If you're writing C code for inclusion in CPython, you **must** follow the "
"guidelines and standards defined in :PEP:`7`.  These guidelines apply "
"regardless of the version of Python you are contributing to.  Following "
"these conventions is not necessary for your own third party extension "
"modules, unless you eventually expect to contribute them to Python."
msgstr ""
"如果你正在編寫要引入於 CPython 中的 C 程式碼，你\\ **必須**\\ 遵循 :PEP:`7` "
"中定義的指南和標準。無論你貢獻的 Python 版本如何，這些指南都適用。對於你自己"
"的第三方擴充模組，則不必遵循這些約定，除非你希望最終將它們貢獻給 Python。"

#: ../../c-api/intro.rst:46
msgid "Include Files"
msgstr "引入檔案 (include files)"

#: ../../c-api/intro.rst:48
msgid ""
"All function, type and macro definitions needed to use the Python/C API are "
"included in your code by the following line::"
msgstr ""
"使用 Python/C API 所需的所有函式、型別和巨集的定義都透過以下這幾行來在你的程"
"式碼中引入："

#: ../../c-api/intro.rst:54
msgid ""
"This implies inclusion of the following standard headers: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, ``<limits.h>``, ``<assert.h>`` and ``<stdlib."
"h>`` (if available)."
msgstr ""
"這意味著會引入以下標準標頭：``<stdio.h>``、``<string.h>``、``<errno.h>``、"
"``<limits.h>``、``<assert.h>`` 和 ``<stdlib.h>``\\ （如果可用）。"

#: ../../c-api/intro.rst:60
msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` before "
"any standard headers are included."
msgstr ""
"由於 Python 可能會定義一些會影響某些系統上標準標頭檔的預處理器 (pre-"
"processor)，因此你\\ *必須*\\ 在引入任何標準標頭檔之前引入 :file:`Python.h`。"

#: ../../c-api/intro.rst:64
msgid ""
"It is recommended to always define ``PY_SSIZE_T_CLEAN`` before including "
"``Python.h``.  See :ref:`arg-parsing` for a description of this macro."
msgstr ""
"建議在引入 ``Python.h`` 之前都要定義 ``PY_SSIZE_T_CLEAN``。有關此巨集的說明，"
"請參閱\\ :ref:`arg-parsing`。"

#: ../../c-api/intro.rst:67
msgid ""
"All user visible names defined by Python.h (except those defined by the "
"included standard headers) have one of the prefixes ``Py`` or ``_Py``.  "
"Names beginning with ``_Py`` are for internal use by the Python "
"implementation and should not be used by extension writers. Structure member "
"names do not have a reserved prefix."
msgstr ""
"所有定義於 Python.h 中且使用者可見的名稱（另外透過標準標頭檔引入的除外）都具"
"有 ``Py`` 或 ``_Py`` 前綴。以 ``_Py`` 開頭的名稱供 Python 實作內部使用，擴充"
"編寫者不應使用。結構成員名稱沒有保留前綴。"

#: ../../c-api/intro.rst:74
msgid ""
"User code should never define names that begin with ``Py`` or ``_Py``. This "
"confuses the reader, and jeopardizes the portability of the user code to "
"future Python versions, which may define additional names beginning with one "
"of these prefixes."
msgstr ""
"使用者程式碼不應定義任何以 ``Py`` 或 ``_Py`` 開頭的名稱。這會讓讀者感到困惑，"
"並危及使用者程式碼在未來 Python 版本上的可移植性，這些版本可能會定義以這些前"
"綴之一開頭的其他名稱。"

#: ../../c-api/intro.rst:79
msgid ""
"The header files are typically installed with Python.  On Unix, these  are "
"located in the directories :file:`{prefix}/include/pythonversion/` and :file:"
"`{exec_prefix}/include/pythonversion/`, where :option:`prefix <--prefix>` "
"and :option:`exec_prefix <--exec-prefix>` are defined by the corresponding "
"parameters to Python's :program:`configure` script and *version* is ``'%d."
"%d' % sys.version_info[:2]``.  On Windows, the headers are installed in :"
"file:`{prefix}/include`, where ``prefix`` is the installation directory "
"specified to the installer."
msgstr ""
"標頭檔通常隨 Python 一起安裝。在 Unix 上它們位於目錄 :file:`{prefix}/include/"
"pythonversion/` 和 :file:`{exec_prefix}/include/pythonversion/`，其中 :"
"option:`prefix <--prefix>` 和 :option:`exec_prefix <--exec-prefix>` 由 "
"Python 的 :program:`configure` 腳本的相應參數定義，*version* 是 ``'%d.%d' % "
"sys.version_info[:2]``。在 Windows 上，標頭安裝在 :file:`{prefix}/include` "
"中，其中 ``prefix`` 是指定給安裝程式 (installer) 用的安裝目錄。"

#: ../../c-api/intro.rst:88
msgid ""
"To include the headers, place both directories (if different) on your "
"compiler's search path for includes.  Do *not* place the parent directories "
"on the search path and then use ``#include <pythonX.Y/Python.h>``; this will "
"break on multi-platform builds since the platform independent headers under :"
"option:`prefix <--prefix>` include the platform specific headers from :"
"option:`exec_prefix <--exec-prefix>`."
msgstr ""
"要引入標頭，請將兩個（如果不同）目錄放在編譯器的引入搜索路徑 (search path) "
"中。*不要*\\ 將父目錄放在搜索路徑上，然後使用 ``#include <pythonX.Y/Python."
"h>``；這會在多平台建置上壞掉，因為 :option:`prefix <--prefix>` 下獨立於平台的"
"標頭包括來自 :option:`exec_prefix <--exec-prefix>` 的平台特定標頭。"

#: ../../c-api/intro.rst:95
msgid ""
"C++ users should note that although the API is defined entirely using C, the "
"header files properly declare the entry points to be ``extern \"C\"``. As a "
"result, there is no need to do anything special to use the API from C++."
msgstr ""
"C++ 使用者應注意，儘管 API 完全使用 C 來定義，但標頭檔適當地將入口點聲明為 "
"``extern \"C\"``。因此，無需執行任何特殊操作即可使用 C++ 中的 API。"

#: ../../c-api/intro.rst:101
msgid "Useful macros"
msgstr "有用的巨集"

#: ../../c-api/intro.rst:103
msgid ""
"Several useful macros are defined in the Python header files.  Many are "
"defined closer to where they are useful (e.g. :c:macro:`Py_RETURN_NONE`). "
"Others of a more general utility are defined here.  This is not necessarily "
"a complete listing."
msgstr ""
"Python 標頭檔中定義了幾個有用的巨集，大多被定義在它們有用的地方附近（例如 :c:"
"macro:`Py_RETURN_NONE`），其他是更通用的工具程式。以下並不一定是完整的列表。"

#: ../../c-api/intro.rst:110
msgid "Return the absolute value of ``x``."
msgstr "回傳 ``x`` 的絕對值。"

#: ../../c-api/intro.rst:116
msgid ""
"Ask the compiler to always inline a static inline function. The compiler can "
"ignore it and decides to not inline the function."
msgstr ""
"要求編譯器總是嵌入靜態行內函式 (static inline function)，編譯器可以忽略它並決"
"定不嵌入該函式。"

#: ../../c-api/intro.rst:119
msgid ""
"It can be used to inline performance critical static inline functions when "
"building Python in debug mode with function inlining disabled. For example, "
"MSC disables function inlining when building in debug mode."
msgstr ""
"在禁用函式嵌入的除錯模式下建置 Python 時，它可用於嵌入有性能要求的靜態行內函"
"式。例如，MSC 在除錯模式下建置時禁用函式嵌入。"

#: ../../c-api/intro.rst:123
msgid ""
"Marking blindly a static inline function with Py_ALWAYS_INLINE can result in "
"worse performances (due to increased code size for example). The compiler is "
"usually smarter than the developer for the cost/benefit analysis."
msgstr ""
"盲目地使用 Py_ALWAYS_INLINE 標記靜態行內函式可能會導致更差的性能（例如程式碼"
"大小增加）。在成本/收益分析方面，編譯器通常比開發人員更聰明。"

#: ../../c-api/intro.rst:127
msgid ""
"If Python is :ref:`built in debug mode <debug-build>` (if the ``Py_DEBUG`` "
"macro is defined), the :c:macro:`Py_ALWAYS_INLINE` macro does nothing."
msgstr ""
"如果 Python 是\\ :ref:`在除錯模式下建置 <debug-build>`\\ （如果 ``Py_DEBUG`` "
"巨集有被定義），:c:macro:`Py_ALWAYS_INLINE` 巨集就什麼都不會做。"

#: ../../c-api/intro.rst:130
msgid "It must be specified before the function return type. Usage::"
msgstr ""
"它必須在函式回傳型別之前被指定。用法：\n"
"\n"
"::"

#: ../../c-api/intro.rst:138
msgid ""
"Argument must be a character or an integer in the range [-128, 127] or [0, "
"255].  This macro returns ``c`` cast to an ``unsigned char``."
msgstr ""
"引數必須是 [-128, 127] 或 [0, 255] 範圍內的字元或整數。這個巨集會將 ``c`` 轉"
"換為 ``unsigned char`` 並回傳。"

#: ../../c-api/intro.rst:143
msgid ""
"Use this for deprecated declarations.  The macro must be placed before the "
"symbol name."
msgstr "將其用於已棄用的聲明。巨集必須放在符號名稱之前。"

#: ../../c-api/intro.rst:146 ../../c-api/intro.rst:232
#: ../../c-api/intro.rst:250
msgid "Example::"
msgstr ""
"範例：\n"
"\n"
"::"

#: ../../c-api/intro.rst:150
msgid "MSVC support was added."
msgstr "新增了 MSVC 支援。"

#: ../../c-api/intro.rst:155
msgid ""
"Like ``getenv(s)``, but returns ``NULL`` if :option:`-E` was passed on the "
"command line (see :c:member:`PyConfig.use_environment`)."
msgstr ""
"類似於 ``getenv(s)``，但如果在命令列上傳遞了 :option:`-E` 則回傳 ``NULL`` "
"（請見 :c:member:`PyConfig.use_environment`）。"

#: ../../c-api/intro.rst:160
msgid "Return the maximum value between ``x`` and ``y``."
msgstr "回傳 ``x`` 和 ``y`` 之間的最大值。"

#: ../../c-api/intro.rst:166
msgid "Return the size of a structure (``type``) ``member`` in bytes."
msgstr "以位元組為單位回傳結構 (``type``) ``member`` 的大小。"

#: ../../c-api/intro.rst:172
msgid "Return the minimum value between ``x`` and ``y``."
msgstr "回傳 ``x`` 和 ``y`` 之間的最小值。"

#: ../../c-api/intro.rst:178
msgid ""
"Disable inlining on a function. For example, it reduces the C stack "
"consumption: useful on LTO+PGO builds which heavily inline code (see :issue:"
"`33720`)."
msgstr ""
"禁用函式的嵌入。例如，它減少了 C 堆疊的消耗：對大量嵌入程式碼的 LTO+PGO 建置"
"很有用（請參閱 :issue:`33720`）。"

#: ../../c-api/intro.rst:182
msgid "Usage::"
msgstr ""
"用法：\n"
"\n"
"::"

#: ../../c-api/intro.rst:190
msgid ""
"Convert ``x`` to a C string.  E.g. ``Py_STRINGIFY(123)`` returns ``\"123\"``."
msgstr ""
"將 ``x`` 轉換為 C 字串。例如 ``Py_STRINGIFY(123)`` 會回傳 ``\"123\"``。"

#: ../../c-api/intro.rst:197
msgid ""
"Use this when you have a code path that cannot be reached by design. For "
"example, in the ``default:`` clause in a ``switch`` statement for which all "
"possible values are covered in ``case`` statements.  Use this in places "
"where you might be tempted to put an ``assert(0)`` or ``abort()`` call."
msgstr ""
"當你的設計中有無法達到的程式碼路徑時，請使用此選項。例如在 ``case`` 語句已涵"
"蓋了所有可能值的 ``switch`` 陳述式中的 ``default:`` 子句。在你可能想要呼叫 "
"``assert(0)`` 或 ``abort()`` 的地方使用它。"

#: ../../c-api/intro.rst:202
msgid ""
"In release mode, the macro helps the compiler to optimize the code, and "
"avoids a warning about unreachable code.  For example, the macro is "
"implemented with ``__builtin_unreachable()`` on GCC in release mode."
msgstr ""
"在發布模式 (release mode) 下，巨集幫助編譯器最佳化程式碼，並避免有關無法存取"
"程式碼的警告。例如該巨集是在發布模式下於 GCC 使用 "
"``__builtin_unreachable()`` 來實作。"

#: ../../c-api/intro.rst:206
msgid ""
"A use for ``Py_UNREACHABLE()`` is following a call a function that never "
"returns but that is not declared :c:macro:`_Py_NO_RETURN`."
msgstr ""
"``Py_UNREACHABLE()`` 的一個用途是，在對一個永不回傳但並未聲明為 :c:macro:"
"`_Py_NO_RETURN` 的函式之呼叫後使用。"

#: ../../c-api/intro.rst:209
msgid ""
"If a code path is very unlikely code but can be reached under exceptional "
"case, this macro must not be used.  For example, under low memory condition "
"or if a system call returns a value out of the expected range.  In this "
"case, it's better to report the error to the caller.  If the error cannot be "
"reported to caller, :c:func:`Py_FatalError` can be used."
msgstr ""
"如果程式碼路徑是極不可能但在特殊情況下可以到達，則不得使用此巨集。例如在低記"
"憶體條件下或系統呼叫回傳了超出預期範圍的值。在這種情況下，最好將錯誤回報給呼"
"叫者。如果無法回報錯誤則可以使用 :c:func:`Py_FatalError`。"

#: ../../c-api/intro.rst:219
msgid ""
"Use this for unused arguments in a function definition to silence compiler "
"warnings. Example: ``int func(int a, int Py_UNUSED(b)) { return a; }``."
msgstr ""
"將此用於函式定義中未使用的參數以消除編譯器警告。例如：``int func(int a, int "
"Py_UNUSED(b)) { return a; }``。"

#: ../../c-api/intro.rst:226
msgid ""
"Creates a variable with name ``name`` that can be used in docstrings. If "
"Python is built without docstrings, the value will be empty."
msgstr ""
"建立一個名為 ``name`` 的變數，可以在文件字串中使用。如果 Python 是在沒有文件"
"字串的情況下建置，則該值將為空。"

#: ../../c-api/intro.rst:229
msgid ""
"Use :c:macro:`PyDoc_STRVAR` for docstrings to support building Python "
"without docstrings, as specified in :pep:`7`."
msgstr ""
"如 :pep:`7` 中所指明，使用 :c:macro:`PyDoc_STRVAR` 作為文件字串可以支援在沒有"
"文件字串的情況下建置 Python。"

#: ../../c-api/intro.rst:244
msgid ""
"Creates a docstring for the given input string or an empty string if "
"docstrings are disabled."
msgstr "為給定的輸入字串建立一個文件字串，如果文件字串被禁用則建立空字串。"

#: ../../c-api/intro.rst:247
msgid ""
"Use :c:macro:`PyDoc_STR` in specifying docstrings to support building Python "
"without docstrings, as specified in :pep:`7`."
msgstr ""
"如 :pep:`7` 中所指明，使用 :c:macro:`PyDoc_STR` 指定文件字串以支援在沒有文件"
"字串下建置 Python。"

#: ../../c-api/intro.rst:262
msgid "Objects, Types and Reference Counts"
msgstr "物件、型別和參照計數"

#: ../../c-api/intro.rst:266
msgid ""
"Most Python/C API functions have one or more arguments as well as a return "
"value of type :c:expr:`PyObject*`.  This type is a pointer to an opaque data "
"type representing an arbitrary Python object.  Since all Python object types "
"are treated the same way by the Python language in most situations (e.g., "
"assignments, scope rules, and argument passing), it is only fitting that "
"they should be represented by a single C type.  Almost all Python objects "
"live on the heap: you never declare an automatic or static variable of type :"
"c:type:`PyObject`, only pointer variables of type :c:expr:`PyObject*` can  "
"be declared.  The sole exception are the type objects; since these must "
"never be deallocated, they are typically static :c:type:`PyTypeObject` "
"objects."
msgstr ""
"大多數 Python/C API 函式都有一個或多個引數以及一個型別為 :c:expr:`PyObject*` "
"的回傳值，此型別是一個指標，指向一個表示任意 Python 物件的晦暗 (opaque) 資料"
"型別。由於在大多數情況下，Python 語言以相同的方式處理所有 Python 物件型別（例"
"如賦值、作用域規則和引數傳遞），因此它們應該由單個 C 型別來表示。幾乎所有的 "
"Python 物件都存在於堆積 (heap) 中：你永遠不會聲明 :c:type:`PyObject` 型別的自"
"動變數或靜態變數，只能聲明 :c:expr:`PyObject*` 型別的指標變數。唯一的例外是型"
"別物件；由於它們絕不能被釋放，因此它們通常是靜態 :c:type:`PyTypeObject` 物"
"件。"

#: ../../c-api/intro.rst:277
msgid ""
"All Python objects (even Python integers) have a :dfn:`type` and a :dfn:"
"`reference count`.  An object's type determines what kind of object it is (e."
"g., an integer, a list, or a user-defined function; there are many more as "
"explained in :ref:`types`).  For each of the well-known types there is a "
"macro to check whether an object is of that type; for instance, "
"``PyList_Check(a)`` is true if (and only if) the object pointed to by *a* is "
"a Python list."
msgstr ""
"所有 Python 物件（甚至是 Python 整數）都有一個型別 (:dfn:`type`) 和一個參照計"
"數 (:dfn:`reference count`)。一個物件的型別決定了它是什麼種類的物件（例如一個"
"整數、一個 list 或一個使用者定義的函式；還有更多型別，請見\\ :ref:"
"`types`\\ ）。對於每個眾所周知的型別，都有一個巨集來檢查物件是否屬於該型別；"
"例如，若（且唯若）*a* 指向的物件是 Python list 時，``PyList_Check(a)`` 為真。"

#: ../../c-api/intro.rst:288
msgid "Reference Counts"
msgstr "參照計數"

#: ../../c-api/intro.rst:290
msgid ""
"The reference count is important because today's computers have a  finite "
"(and often severely limited) memory size; it counts how many  different "
"places there are that have a reference to an object.  Such a  place could be "
"another object, or a global (or static) C variable, or  a local variable in "
"some C function. When an object's reference count  becomes zero, the object "
"is deallocated.  If it contains references to  other objects, their "
"reference count is decremented. Those other  objects may be deallocated in "
"turn, if this decrement makes their reference count become zero, and so on.  "
"(There's an obvious problem  with objects that reference each other here; "
"for now, the solution is  \"don't do that.\")"
msgstr ""
"參照計數很重要，因為現今的電腦記憶體大小是有限的（而且通常是非常有限的）；它"
"計算有多少個不同的地方參照了一個物件。這樣的地方可以是另一個物件，或者全域"
"（或靜態）C 變數，或者某個 C 函式中的本地變數。當一個物件的參照計數變為零時，"
"該物件將被釋放 (deallocated)。如果它包含對其他物件的參照，則它們的參照計數會"
"減少。如果這樣的減少使它們的參照計數變為零，則可以依次釋放那些其他物件，依此"
"類推。 （此處相互參照物件的存在是個明顯的問題；目前，解決方案是「就不要那樣"
"做」。）"

#: ../../c-api/intro.rst:305
msgid ""
"Reference counts are always manipulated explicitly.  The normal way is  to "
"use the macro :c:func:`Py_INCREF` to increment an object's reference count "
"by one, and :c:func:`Py_DECREF` to decrement it by   one.  The :c:func:"
"`Py_DECREF` macro is considerably more complex than the incref one, since it "
"must check whether the reference count becomes zero and then cause the "
"object's deallocator to be called. The deallocator is a function pointer "
"contained in the object's type structure.  The type-specific deallocator "
"takes care of decrementing the reference counts for other objects contained "
"in the object if this is a compound object type, such as a list, as well as "
"performing any additional finalization that's needed.  There's no chance "
"that the reference count can overflow; at least as many bits are used to "
"hold the reference count as there are distinct memory locations in virtual "
"memory (assuming ``sizeof(Py_ssize_t) >= sizeof(void*)``). Thus, the "
"reference count increment is a simple operation."
msgstr ""
"參照計數總是被明確地操作。正常的方法是使用巨集 :c:func:`Py_INCREF` 將物件的參"
"照計數加一，並使用巨集 :c:func:`Py_DECREF` 來將其減一。:c:func:`Py_DECREF` 巨"
"集比 incref 巨集複雜得多，因為它必須檢查參照計數是否變為零，然後呼叫物件的釋"
"放器 (deallocator)。釋放器是包含在物件型別結構中的函式指標。特定型別的釋放"
"器，在如果是一個複合物件型別（例如 list）時負責減少物件中包含的其他物件的參照"
"計數，並執行任何需要的額外完結步驟。參照計數不可能溢出；至少與虛擬記憶體中用"
"來保存參照計數的不同記憶體位置數量一樣多的位元會被使用（假設 "
"``sizeof(Py_ssize_t) >= sizeof(void*)``）。因此參照計數增加是一個簡單的操作。"

#: ../../c-api/intro.rst:319
msgid ""
"It is not necessary to increment an object's reference count for every  "
"local variable that contains a pointer to an object.  In theory, the  "
"object's reference count goes up by one when the variable is made to  point "
"to it and it goes down by one when the variable goes out of  scope.  "
"However, these two cancel each other out, so at the end the  reference count "
"hasn't changed.  The only real reason to use the  reference count is to "
"prevent the object from being deallocated as  long as our variable is "
"pointing to it.  If we know that there is at  least one other reference to "
"the object that lives at least as long as our variable, there is no need to "
"increment the reference count  temporarily. An important situation where "
"this arises is in objects  that are passed as arguments to C functions in an "
"extension module  that are called from Python; the call mechanism guarantees "
"to hold a  reference to every argument for the duration of the call."
msgstr ""
"沒有必要為每個包含物件指標的本地變數增加物件的參照計數。理論上，當變數指向它"
"時，物件的參照計數會增加 1，而當變數離開作用域時就會減少 1。然而這兩者會相互"
"抵消，所以最後參照計數沒有改變。使用參照計數的唯一真正原因是防止物件還有變數"
"指向它時被釋放。如果我們知道至少有一個物件的其他參照生存了至少與我們的變數一"
"樣久，就不需要臨時增加參照計數。出現這種情況的一個重要情況是在從 Python 呼叫"
"的擴充模組中作為引數傳遞給 C 函式的物件；呼叫機制保證在呼叫期間保持對每個參數"
"的參照。"

#: ../../c-api/intro.rst:333
msgid ""
"However, a common pitfall is to extract an object from a list and hold on to "
"it for a while without incrementing its reference count. Some other "
"operation might conceivably remove the object from the list, decrementing "
"its reference count and possibly deallocating it. The real danger is that "
"innocent-looking operations may invoke arbitrary Python code which could do "
"this; there is a code path which allows control to flow back to the user "
"from a :c:func:`Py_DECREF`, so almost any operation is potentially dangerous."
msgstr ""
"然而，一個常見的陷阱是從一個 list 中提取一個物件並保留它一段時間而不增加其參"
"照計數。某些其他操作可能會從列表中刪除該物件，減少其參照計數並可能取消分配"
"它。真正的危險是看似無害的操作可能會呼叫可以執行此操作的任意 Python 程式碼；"
"有一個程式碼路徑允許控制權從 :c:func:`Py_DECREF` 回歸使用者，因此幾乎任何操作"
"都有潛在危險。"

#: ../../c-api/intro.rst:341
msgid ""
"A safe approach is to always use the generic operations (functions  whose "
"name begins with ``PyObject_``, ``PyNumber_``, ``PySequence_`` or "
"``PyMapping_``). These operations always increment the reference count of "
"the object they return. This leaves the caller with the responsibility to "
"call :c:func:`Py_DECREF` when they are done with the result; this soon "
"becomes second nature."
msgstr ""
"一種安全的方法是都使用通用 (generics) 操作（名稱以 ``PyObject_``、"
"``PyNumber_``、``PySequence_`` 或 ``PyMapping_`` 開頭的函式）。這些操作總是增"
"加它們回傳的物件的參照計數。這讓呼叫者有責任在處理完結果後呼叫 :c:func:"
"`Py_DECREF`；這就成為第二本質。"

#: ../../c-api/intro.rst:351
msgid "Reference Count Details"
msgstr "參照計數詳細資訊"

#: ../../c-api/intro.rst:353
msgid ""
"The reference count behavior of functions in the Python/C API is best  "
"explained in terms of *ownership of references*.  Ownership pertains to "
"references, never to objects (objects are not owned: they are always "
"shared).  \"Owning a reference\" means being responsible for calling "
"Py_DECREF on it when the reference is no longer needed.  Ownership can also "
"be transferred, meaning that the code that receives ownership of the "
"reference then becomes responsible for eventually decref'ing it by calling :"
"c:func:`Py_DECREF` or :c:func:`Py_XDECREF` when it's no longer needed---or "
"passing on this responsibility (usually to its caller). When a function "
"passes ownership of a reference on to its caller, the caller is said to "
"receive a *new* reference.  When no ownership is transferred, the caller is "
"said to *borrow* the reference. Nothing needs to be done for a :term:"
"`borrowed reference`."
msgstr ""
"Python/C API 中函式的參照計數行為最好用\\ *參照的所有權*\\ 來解釋。所有權附屬"
"於參照而非物件（物件並非被擁有，它們總是共享的）。「擁有參照」意味著當不再需"
"要該參照時，負責在其上呼叫 Py_DECREF。所有權也可以轉移，這意味著接收參照所有"
"權的程式碼最終會負責在不需要參照時透過呼叫 :c:func:`Py_DECREF` 或 :c:func:"
"`Py_XDECREF` 減少參照 --- 或者將這個責任再傳遞出去（通常是給它的呼叫者）。當"
"一個函式將參照的所有權傳遞給它的呼叫者時，呼叫者被稱為接收到一個\\ *新*\\ 參"
"照。當沒有所有權轉移時，呼叫者被稱為\\ *借用*\\ 參照。如果是\\ :term:`借用參"
"照 <borrowed reference>`\\ 就不需要做任何事情。"

#: ../../c-api/intro.rst:366
msgid ""
"Conversely, when a calling function passes in a reference to an  object, "
"there are two possibilities: the function *steals* a  reference to the "
"object, or it does not.  *Stealing a reference* means that when you pass a "
"reference to a function, that function assumes that it now owns that "
"reference, and you are not responsible for it any longer."
msgstr ""
"相反地，當呼叫的函式傳入物件的參照時，有兩種可能性：函式有\\ *竊取 (steal)* "
"物件的參照，或者沒有。 *竊取參照*\\ 意味著當你將參照傳遞給函式時，該函式假定"
"它現在擁有該參照，並且你不再對它負責。"

#: ../../c-api/intro.rst:376
msgid ""
"Few functions steal references; the two notable exceptions are :c:func:"
"`PyList_SetItem` and :c:func:`PyTuple_SetItem`, which  steal a reference to "
"the item (but not to the tuple or list into which the item is put!).  These "
"functions were designed to steal a reference because of a common idiom for "
"populating a tuple or list with newly created objects; for example, the code "
"to create the tuple ``(1, 2, \"three\")`` could look like this (forgetting "
"about error handling for the moment; a better way to code this is shown "
"below)::"
msgstr ""
"很少有函式會竊取參照；兩個值得注意的例外是 :c:func:`PyList_SetItem` 和 :c:"
"func:`PyTuple_SetItem`，它們竊取了對項目的參照（但不是對項目所在的 tuple 或 "
"list 的參照！）。因為有著使用新建立的物件來增加 (populate) tuple 或 list 的習"
"慣，這些函式旨在竊取參照；例如，建立 tuple ``(1, 2, \"three\")`` 的程式碼可以"
"如下所示（先暫時忘記錯誤處理；更好的編寫方式如下所示）："

#: ../../c-api/intro.rst:391
msgid ""
"Here, :c:func:`PyLong_FromLong` returns a new reference which is immediately "
"stolen by :c:func:`PyTuple_SetItem`.  When you want to keep using an object "
"although the reference to it will be stolen, use :c:func:`Py_INCREF` to grab "
"another reference before calling the reference-stealing function."
msgstr ""
"這裡 :c:func:`PyLong_FromLong` 會回傳一個新的參照，它立即被 :c:func:"
"`PyTuple_SetItem` 竊取。如果你想繼續使用一個物件，儘管對它的參照將被竊取，請"
"在呼叫參照竊取函式之前使用 :c:func:`Py_INCREF` 來獲取另一個參照。"

#: ../../c-api/intro.rst:396
msgid ""
"Incidentally, :c:func:`PyTuple_SetItem` is the *only* way to set tuple "
"items; :c:func:`PySequence_SetItem` and :c:func:`PyObject_SetItem` refuse to "
"do this since tuples are an immutable data type.  You should only use :c:"
"func:`PyTuple_SetItem` for tuples that you are creating yourself."
msgstr ""
"附帶地說，:c:func:`PyTuple_SetItem` 是設定 tuple 項目的\\ *唯一*\\ 方法； :c:"
"func:`PySequence_SetItem` 和 :c:func:`PyObject_SetItem` 拒絕這樣做，因為 "
"tuple 是一種不可變 (immutable) 的資料型別。你應該只對你自己建立的 tuple 使"
"用 :c:func:`PyTuple_SetItem`。"

#: ../../c-api/intro.rst:401
msgid ""
"Equivalent code for populating a list can be written using :c:func:"
"`PyList_New` and :c:func:`PyList_SetItem`."
msgstr ""
"可以使用 :c:func:`PyList_New` 和 :c:func:`PyList_SetItem` 編寫用於填充列表的"
"等效程式碼。"

#: ../../c-api/intro.rst:404
msgid ""
"However, in practice, you will rarely use these ways of creating and "
"populating a tuple or list.  There's a generic function, :c:func:"
"`Py_BuildValue`, that can create most common objects from C values, directed "
"by a :dfn:`format string`. For example, the above two blocks of code could "
"be replaced by the following (which also takes care of the error checking)::"
msgstr ""
"但是在實際操作中你很少會使用這些方法來建立和增加 tuple 和 list。有一個通用函"
"式 :c:func:`Py_BuildValue` 可以從 C 值建立最常見的物件，由 :dfn:`format "
"string` 引導。例如上面的兩個程式碼可以用以下程式碼替換（它還負責了錯誤檢"
"查）：\n"
"\n"
"::"

#: ../../c-api/intro.rst:415
msgid ""
"It is much more common to use :c:func:`PyObject_SetItem` and friends with "
"items whose references you are only borrowing, like arguments that were "
"passed in to the function you are writing.  In that case, their behaviour "
"regarding reference counts is much saner, since you don't have to increment "
"a reference count so you can give a reference away (\"have it be stolen\").  "
"For example, this function sets all items of a list (actually, any mutable "
"sequence) to a given item::"
msgstr ""
"更常見的是以那些借用參照的項目來使用 :c:func:`PyObject_SetItem` 及其系列函"
"式，比如傳遞給你正在編寫的函式的引數。在那種情況下，他們關於參照計數的行為會"
"比較穩健，因為你不必增加參照計數就可以放棄參照（「讓它被竊取」）。例如，此函"
"式將 list（實際上是任何可變序列）的所有項目設定於給定項目："

#: ../../c-api/intro.rst:445
msgid ""
"The situation is slightly different for function return values.   While "
"passing a reference to most functions does not change your  ownership "
"responsibilities for that reference, many functions that  return a reference "
"to an object give you ownership of the reference. The reason is simple: in "
"many cases, the returned object is created  on the fly, and the reference "
"you get is the only reference to the  object.  Therefore, the generic "
"functions that return object references, like :c:func:`PyObject_GetItem` "
"and  :c:func:`PySequence_GetItem`, always return a new reference (the caller "
"becomes the owner of the reference)."
msgstr ""
"函式回傳值的情況略有不同。雖然傳遞對大多數函式的參照不會改變你對該參照的所有"
"權責任，但許多回傳物件參照的函式會給你該參照的所有權。原因很簡單：在很多情況"
"下，回傳的物件是即時建立的，你獲得的參照是對該物件的唯一參照。因此回傳物件參"
"照的通用函式，如 :c:func:`PyObject_GetItem` 和 :c:func:`PySequence_GetItem`，"
"總是回傳一個新的參照（呼叫者成為參照的所有者）。"

#: ../../c-api/intro.rst:454
msgid ""
"It is important to realize that whether you own a reference returned  by a "
"function depends on which function you call only --- *the plumage* (the type "
"of the object passed as an argument to the function) *doesn't enter into it!"
"* Thus, if you  extract an item from a list using :c:func:`PyList_GetItem`, "
"you don't own the reference --- but if you obtain the same item from the "
"same list using :c:func:`PySequence_GetItem` (which happens to take exactly "
"the same arguments), you do own a reference to the returned object."
msgstr ""
"重要的是要意識到你是否擁有一個函式回傳的參照只取決於你呼叫哪個函式 --- *羽毛 "
"(plumage)*（作為引數傳遞給函式的物件之型別）\\ *不會進入它！*\\ 因此，如果你"
"使用 :c:func:`PyList_GetItem` 從 list 中提取一個項目，你不會擁有其參照 --- 但"
"如果你使用 :c:func:`PySequence_GetItem` 從同一 list 中獲取相同的項目（且恰好"
"使用完全相同的引數），你確實會擁有對回傳物件的參照。"

#: ../../c-api/intro.rst:466
msgid ""
"Here is an example of how you could write a function that computes the sum "
"of the items in a list of integers; once using  :c:func:`PyList_GetItem`, "
"and once using :c:func:`PySequence_GetItem`. ::"
msgstr ""
"以下是一個範例，說明如何編寫函式來計算一個整數 list 中項目的總和；一次使用 :"
"c:func:`PyList_GetItem`，一次使用 :c:func:`PySequence_GetItem`：\n"
"\n"
"::"

#: ../../c-api/intro.rst:530
msgid "Types"
msgstr "型別"

#: ../../c-api/intro.rst:532
msgid ""
"There are few other data types that play a significant role in  the Python/C "
"API; most are simple C types such as :c:expr:`int`,  :c:expr:`long`, :c:expr:"
"`double` and :c:expr:`char*`.  A few structure types  are used to describe "
"static tables used to list the functions exported  by a module or the data "
"attributes of a new object type, and another is used to describe the value "
"of a complex number.  These will  be discussed together with the functions "
"that use them."
msgstr ""
"有少數幾個其他的資料型別在 Python/C API 中發揮重要作用；大多數是簡單的 C 型"
"別，例如 :c:expr:`int`、:c:expr:`long`、:c:expr:`double` 和 :c:expr:`char*`。"
"一些結構型別被用於描述用於列出模組所匯出的函式或新物件型別的資料屬性的靜態"
"表，其他則用於描述複數的值。這些將與使用它們的函式一起討論。"

#: ../../c-api/intro.rst:542
msgid ""
"A signed integral type such that ``sizeof(Py_ssize_t) == sizeof(size_t)``. "
"C99 doesn't define such a thing directly (size_t is an unsigned integral "
"type). See :pep:`353` for details. ``PY_SSIZE_T_MAX`` is the largest "
"positive value of type :c:type:`Py_ssize_t`."
msgstr ""
"一個帶符號的整數型別，使得 ``sizeof(Py_ssize_t) == sizeof(size_t)``。 C99 沒"
"有直接定義這樣的東西（size_t 是無符號整數型別）。有關詳細資訊，請參閱 :pep:"
"`353`。 ``PY_SSIZE_T_MAX`` 是 :c:type:`Py_ssize_t` 型別的最大正值。"

#: ../../c-api/intro.rst:551
msgid "Exceptions"
msgstr "例外"

#: ../../c-api/intro.rst:553
msgid ""
"The Python programmer only needs to deal with exceptions if specific  error "
"handling is required; unhandled exceptions are automatically  propagated to "
"the caller, then to the caller's caller, and so on, until they reach the top-"
"level interpreter, where they are reported to the  user accompanied by a "
"stack traceback."
msgstr ""
"如果需要特定的錯誤處理，Python 開發者就只需要處理例外；未處理的例外會自動傳遞"
"給呼叫者，然後傳遞給呼叫者的呼叫者，依此類推，直到它們到達頂層直譯器，在那裡"
"它們透過堆疊回溯 (stack trace) 回報給使用者。"

#: ../../c-api/intro.rst:561
msgid ""
"For C programmers, however, error checking always has to be explicit.  All "
"functions in the Python/C API can raise exceptions, unless an explicit claim "
"is made otherwise in a function's documentation.  In general, when a "
"function encounters an error, it sets an exception, discards any object "
"references that it owns, and returns an error indicator.  If not documented "
"otherwise, this indicator is either ``NULL`` or ``-1``, depending on the "
"function's return type. A few functions return a Boolean true/false result, "
"with false indicating an error.  Very few functions return no explicit error "
"indicator or have an ambiguous return value, and require explicit testing "
"for errors with :c:func:`PyErr_Occurred`.  These exceptions are always "
"explicitly documented."
msgstr ""
"然而，對於 C 開發者來說，錯誤檢查總是必須是顯式的。除非在函式的文件中另有明確"
"聲明，否則 Python/C API 中的所有函式都可以引發例外。通常當一個函式遇到錯誤"
"時，它會設定一個例外，丟棄它擁有的任何物件參照，並回傳一個錯誤指示器。如果沒"
"有另外文件記錄，這個指示器要麼是 ``NULL`` 不然就是 ``-1``，取決於函式的回傳型"
"別。有些函式會回傳布林值 true/false 結果，false 表示錯誤。很少有函式不回傳明"
"確的錯誤指示器或者有不明確的回傳值，而需要使用 :c:func:`PyErr_Occurred` 明確"
"測試錯誤。這些例外都會被明確地記錄於文件。"

#: ../../c-api/intro.rst:576
msgid ""
"Exception state is maintained in per-thread storage (this is  equivalent to "
"using global storage in an unthreaded application).  A  thread can be in one "
"of two states: an exception has occurred, or not. The function :c:func:"
"`PyErr_Occurred` can be used to check for this: it returns a borrowed "
"reference to the exception type object when an exception has occurred, and "
"``NULL`` otherwise.  There are a number of functions to set the exception "
"state: :c:func:`PyErr_SetString` is the most common (though not the most "
"general) function to set the exception state, and :c:func:`PyErr_Clear` "
"clears the exception state."
msgstr ""
"例外的狀態會在個別執行緒的存儲空間 (per-thread storage) 中維護（這相當於在非"
"執行緒應用程式中使用全域存儲空間）。執行緒可以處於兩種狀態之一：發生例外或未"
"發生例外。函式 :c:func:`PyErr_Occurred` 可用於檢查這一點：當例外發生時，它回"
"傳對例外型別物件的借用參照，否則回傳 ``NULL``。設定例外狀態的函式有很多：:c:"
"func:`PyErr_SetString` 是最常見的（儘管不是最通用的）設定例外狀態的函式，而 :"
"c:func:`PyErr_Clear` 是用來清除例外狀態。"

#: ../../c-api/intro.rst:586
msgid ""
"The full exception state consists of three objects (all of which can  be "
"``NULL``): the exception type, the corresponding exception  value, and the "
"traceback.  These have the same meanings as the Python result of ``sys."
"exc_info()``; however, they are not the same: the Python objects represent "
"the last exception being handled by a Python  :keyword:`try` ... :keyword:"
"`except` statement, while the C level exception state only exists while an "
"exception is being passed on between C functions until it reaches the Python "
"bytecode interpreter's  main loop, which takes care of transferring it to "
"``sys.exc_info()`` and friends."
msgstr ""
"完整的例外狀態由三個（都可以為 ``NULL`` 的）物件組成：例外型別、對應的例外值"
"和回溯。這些與 ``sys.exc_info()`` 的 Python 結果具有相同的含義；但是它們並不"
"相同：Python 物件表示由 Python :keyword:`try` ... :keyword:`except` 陳述式處"
"理的最後一個例外，而 C 層級的例外狀態僅在例外在 C 函式間傳遞時存在，直到它到"
"達 Python 位元組碼直譯器的主迴圈，該迴圈負責將它傳遞給 ``sys.exc_info()`` 和"
"其系列函式。"

#: ../../c-api/intro.rst:598
msgid ""
"Note that starting with Python 1.5, the preferred, thread-safe way to access "
"the exception state from Python code is to call the function :func:`sys."
"exc_info`, which returns the per-thread exception state for Python code.  "
"Also, the semantics of both ways to access the exception state have changed "
"so that a function which catches an exception will save and restore its "
"thread's exception state so as to preserve the exception state of its "
"caller.  This prevents common bugs in exception handling code caused by an "
"innocent-looking function overwriting the exception being handled; it also "
"reduces the often unwanted lifetime extension for objects that are "
"referenced by the stack frames in the traceback."
msgstr ""
"請注意，從 Python 1.5 開始，從 Python 程式碼存取例外狀態的首選且支援執行緒安"
"全的方法是呼叫 :func:`sys.exc_info` 函式，它回傳 Python 程式碼的個別執行緒例"
"外狀態。此外，兩種存取例外狀態方法的語義都發生了變化，因此捕獲例外的函式將保"
"存和恢復其執行緒的例外狀態，從而保留其呼叫者的例外狀態。這可以防止例外處理程"
"式碼中的常見錯誤，這些錯誤是由看似無辜的函式覆蓋了正在處理的例外而引起的；它"
"還替回溯中被堆疊幀 (stack frame) 參照的物件減少了通常不需要的生命週期延長。"

#: ../../c-api/intro.rst:609
msgid ""
"As a general principle, a function that calls another function to  perform "
"some task should check whether the called function raised an  exception, and "
"if so, pass the exception state on to its caller.  It  should discard any "
"object references that it owns, and return an  error indicator, but it "
"should *not* set another exception --- that would overwrite the exception "
"that was just raised, and lose important information about the exact cause "
"of the error."
msgstr ""
"作為一般原則，呼叫另一個函式來執行某些任務的函式應該檢查被呼叫函式是否引發了"
"例外，如果是，則將例外狀態傳遞給它的呼叫者。它應該丟棄它擁有的任何物件參照，"
"並回傳一個錯誤指示符，但它\\ *不應該*\\ 設定另一個例外 --- 這將覆蓋剛剛引發的"
"例外，並丟失關於錯誤確切原因的重要資訊。"

#: ../../c-api/intro.rst:618
msgid ""
"A simple example of detecting exceptions and passing them on is shown in "
"the :c:func:`sum_sequence` example above.  It so happens that this example "
"doesn't need to clean up any owned references when it detects an error.  The "
"following example function shows some error cleanup.  First, to remind you "
"why you like Python, we show the equivalent Python code::"
msgstr ""
"上面的 :c:func:`sum_sequence` 範例展示了一個檢測例外並將其繼續傳遞的例子。碰"
"巧這個例子在檢測到錯誤時不需要清理任何擁有的參照。以下範例函式展示了一些錯誤"
"清理。首先，為了提醒你為什麼喜歡 Python，我們展示了等效的 Python 程式碼：\n"
"\n"
"::"

#: ../../c-api/intro.rst:633
msgid "Here is the corresponding C code, in all its glory::"
msgstr "這是相應的 C 程式碼："

#: ../../c-api/intro.rst:685
msgid ""
"This example represents an endorsed use of the ``goto`` statement  in C! It "
"illustrates the use of :c:func:`PyErr_ExceptionMatches` and :c:func:"
"`PyErr_Clear` to handle specific exceptions, and the use of :c:func:"
"`Py_XDECREF` to dispose of owned references that may be ``NULL`` (note the "
"``'X'`` in the name; :c:func:`Py_DECREF` would crash when confronted with a "
"``NULL`` reference).  It is important that the variables used to hold owned "
"references are initialized to ``NULL`` for this to work; likewise, the "
"proposed return value is initialized to ``-1`` (failure) and only set to "
"success after the final call made is successful."
msgstr ""
"這個例子代表了在 C 語言中對使用 ``goto`` 陳述句的認同！它闡述了以 :c:func:"
"`PyErr_ExceptionMatches` 和 :c:func:`PyErr_Clear` 來處理特定的例外，以及以 :"
"c:func:`Py_XDECREF` 來配置其所擁有且可能為 ``NULL`` 的參照（注意名稱中的 "
"``'X'``\\ ；:c:func:`Py_DECREF` 在遇到 ``NULL`` 參照時會崩潰）。重要的是，用"
"於保存擁有的參照的變數被初始化為 ``NULL`` 以使其能夠順利作用；同樣地，回傳值"
"被初始化為 ``-1``\\ （失敗），並且僅在最後一次呼叫成功後才設定為成功。"

#: ../../c-api/intro.rst:699
msgid "Embedding Python"
msgstr "嵌入式Python"

#: ../../c-api/intro.rst:701
msgid ""
"The one important task that only embedders (as opposed to extension writers) "
"of the Python interpreter have to worry about is the initialization, and "
"possibly the finalization, of the Python interpreter.  Most functionality of "
"the interpreter can only be used after the interpreter has been initialized."
msgstr ""
"只有 Python 直譯器的嵌入者（而不是擴充編寫者）需要擔心的一項重要任務是 "
"Python 直譯器的初始化與完成階段。直譯器的大部分功能只能在直譯器初始化後使用。"

#: ../../c-api/intro.rst:714
msgid ""
"The basic initialization function is :c:func:`Py_Initialize`. This "
"initializes the table of loaded modules, and creates the fundamental "
"modules :mod:`builtins`, :mod:`__main__`, and :mod:`sys`.  It also "
"initializes the module search path (``sys.path``)."
msgstr ""
"基本的初始化函式是 :c:func:`Py_Initialize`。這會初始化帶有載入模組的表，並建"
"立基礎模組 :mod:`builtins`、:mod:`__main__` 和 :mod:`sys`。它還會初始化模組搜"
"索路徑 (``sys.path``)。"

#: ../../c-api/intro.rst:719
msgid ""
":c:func:`Py_Initialize` does not set the \"script argument list\"  (``sys."
"argv``). If this variable is needed by Python code that will be executed "
"later, setting :c:member:`PyConfig.argv` and :c:member:`PyConfig.parse_argv` "
"must be set: see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
":c:func:`Py_Initialize` 不設定「腳本引數列表 (script argument list)」 (``sys."
"argv``)。如果稍後將要執行的 Python 程式碼需要此變數，則必須設定 :c:member:"
"`PyConfig.argv` 和 :c:member:`PyConfig.parse_argv`，請見 :ref:`Python 初始化"
"配置 <init-config>`。"

#: ../../c-api/intro.rst:724
msgid ""
"On most systems (in particular, on Unix and Windows, although the details "
"are slightly different), :c:func:`Py_Initialize` calculates the module "
"search path based upon its best guess for the location of the standard "
"Python interpreter executable, assuming that the Python library is found in "
"a fixed location relative to the Python interpreter executable.  In "
"particular, it looks for a directory named :file:`lib/python{X.Y}` relative "
"to the parent directory where the executable named :file:`python` is found "
"on the shell command search path (the environment variable :envvar:`PATH`)."
msgstr ""
"在大多數系統上（特別是在 Unix 和 Windows 上，儘管細節略有不同），:c:func:"
"`Py_Initialize` 會假設Python 函式庫相對於 Python 直譯器可執行檔案的位置固定，"
"並根據其對標準 Python 直譯器可執行檔案位置的最佳猜測來計算模組搜索路徑。或者"
"更詳細地說，它會在 shell 命令搜索路徑（環境變數 :envvar:`PATH`）中找到名為 :"
"file:`python` 的可執行檔案，並在其父目錄中查找一個名為 :file:`lib/python{X.Y}"
"` 的目錄的相對位置。"

#: ../../c-api/intro.rst:733
msgid ""
"For instance, if the Python executable is found in :file:`/usr/local/bin/"
"python`, it will assume that the libraries are in :file:`/usr/local/lib/"
"python{X.Y}`.  (In fact, this particular path is also the \"fallback\" "
"location, used when no executable file named :file:`python` is found along :"
"envvar:`PATH`.)  The user can override this behavior by setting the "
"environment variable :envvar:`PYTHONHOME`, or insert additional directories "
"in front of the standard path by setting :envvar:`PYTHONPATH`."
msgstr ""
"例如，如果在 :file:`/usr/local/bin/python` 中找到 Python 可執行檔案，它將假定"
"函式庫位於 :file:`/usr/local/lib/python{X.Y}` 中。 （事實上這個特定的路徑也是"
"「後備 (fallback)」位置，當在 :envvar:`PATH` 中找不到名為 :file:`python` 的可"
"執行檔案時使用。）使用者可以透過設定環境變數來覆蓋此行為 :envvar:"
"`PYTHONHOME`，或者透過設定 :envvar:`PYTHONPATH` 在標準路徑前面插入額外的目"
"錄。"

#: ../../c-api/intro.rst:748
msgid ""
"The embedding application can steer the search by calling "
"``Py_SetProgramName(file)`` *before* calling  :c:func:`Py_Initialize`.  Note "
"that :envvar:`PYTHONHOME` still overrides this and :envvar:`PYTHONPATH` is "
"still inserted in front of the standard path.  An application that requires "
"total control has to provide its own implementation of :c:func:"
"`Py_GetPath`, :c:func:`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, and :c:"
"func:`Py_GetProgramFullPath` (all defined in :file:`Modules/getpath.c`)."
msgstr ""
"嵌入的應用程式可以透過在呼叫 :c:func:`Py_Initialize` *之前*\\ 呼叫 "
"``Py_SetProgramName(file)`` 來引導搜索。請注意 :envvar:`PYTHONHOME` 仍然覆蓋"
"它並且 :envvar:`PYTHONPATH` 仍然插入在標準路徑的前面。需要完全控制權的應用程"
"式必須實作自己的 :c:func:`Py_GetPath`、:c:func:`Py_GetPrefix`、:c:func:"
"`Py_GetExecPrefix` 和 :c:func:`Py_GetProgramFullPath`\\（全部定義在 :file:"
"`Modules/getpath.c`)。"

#: ../../c-api/intro.rst:758
msgid ""
"Sometimes, it is desirable to \"uninitialize\" Python.  For instance,  the "
"application may want to start over (make another call to :c:func:"
"`Py_Initialize`) or the application is simply done with its  use of Python "
"and wants to free memory allocated by Python.  This can be accomplished by "
"calling :c:func:`Py_FinalizeEx`.  The function :c:func:`Py_IsInitialized` "
"returns true if Python is currently in the initialized state.  More "
"information about these functions is given in a later chapter. Notice that :"
"c:func:`Py_FinalizeEx` does *not* free all memory allocated by the Python "
"interpreter, e.g. memory allocated by extension modules currently cannot be "
"released."
msgstr ""
"有時會希望能夠「取消初始化 (uninitialize)」Python。例如，應用程式可能想要重新"
"開始（再次呼叫 :c:func:`Py_Initialize`）或者應用程式簡單地完成了對 Python 的"
"使用並想要釋放 Python 分配的記憶體。這可以透過呼叫 :c:func:`Py_FinalizeEx` 來"
"完成。如果 Python 當前處於初始化狀態，函式 :c:func:`Py_IsInitialized` 會回傳 "
"true。有關這些功能的更多資訊將在後面的章節中給出。請注意 :c:func:"
"`Py_FinalizeEx` *不會*\\ 釋放由 Python 直譯器分配的所有記憶體，例如目前無法釋"
"放被擴充模組所分配的記憶體。"

#: ../../c-api/intro.rst:772
msgid "Debugging Builds"
msgstr "除錯建置"

#: ../../c-api/intro.rst:774
msgid ""
"Python can be built with several macros to enable extra checks of the "
"interpreter and extension modules.  These checks tend to add a large amount "
"of overhead to the runtime so they are not enabled by default."
msgstr ""
"Python 可以在建置時使用多個巨集來啟用對直譯器和擴充模組的額外檢查，這些檢查往"
"往會在執行環境 (runtime) 增加大量開銷 (overhead)，因此預設情況下不啟用它們。"

#: ../../c-api/intro.rst:778
msgid ""
"A full list of the various types of debugging builds is in the file :file:"
"`Misc/SpecialBuilds.txt` in the Python source distribution. Builds are "
"available that support tracing of reference counts, debugging the memory "
"allocator, or low-level profiling of the main interpreter loop.  Only the "
"most frequently used builds will be described in the remainder of this "
"section."
msgstr ""
"Python 原始碼發佈版本中的 :file:`Misc/SpecialBuilds.txt` 檔案有一份包含多種除"
"錯構置的完整列表，為支援追蹤參照計數、為記憶體分配器除錯或對主直譯器迴圈進行"
"低階分析的建置。本節的其餘部分將僅描述最常用的建置。"

#: ../../c-api/intro.rst:784
msgid ""
"Compiling the interpreter with the :c:macro:`Py_DEBUG` macro defined "
"produces what is generally meant by :ref:`a debug build of Python <debug-"
"build>`. :c:macro:`Py_DEBUG` is enabled in the Unix build by adding :option:"
"`--with-pydebug` to the :file:`./configure` command. It is also implied by "
"the presence of the not-Python-specific :c:macro:`_DEBUG` macro.  When :c:"
"macro:`Py_DEBUG` is enabled in the Unix build, compiler optimization is "
"disabled."
msgstr ""
"使用定義的 :c:macro:`Py_DEBUG` 巨集編譯直譯器會生成 :ref:`Python 的除錯建置 "
"<debug-build>`。 :c:macro:`Py_DEBUG` 在 Unix 建置中要透過在 :file:`./"
"configure` 命令中加入 :option:`--with-pydebug` 來啟用。非 Python 限定的 :c:"
"macro:`_DEBUG` 巨集的存在也暗示了這一點。當 :c:macro:`Py_DEBUG` 在 Unix 建置"
"中啟用時，編譯器最佳化會被禁用。"

#: ../../c-api/intro.rst:792
msgid ""
"In addition to the reference count debugging described below, extra checks "
"are performed, see :ref:`Python Debug Build <debug-build>`."
msgstr ""
"除了下面描述的參照計數除錯之外，還會執行額外的檢查，請參閱 :ref:`Python 除錯"
"建置 <debug-build>`。"

#: ../../c-api/intro.rst:795
msgid ""
"Defining :c:macro:`Py_TRACE_REFS` enables reference tracing (see the :option:"
"`configure --with-trace-refs option <--with-trace-refs>`). When defined, a "
"circular doubly linked list of active objects is maintained by adding two "
"extra fields to every :c:type:`PyObject`.  Total allocations are tracked as "
"well.  Upon exit, all existing references are printed.  (In interactive mode "
"this happens after every statement run by the interpreter.)"
msgstr ""
"定義 :c:macro:`Py_TRACE_REFS` 來啟用參照追蹤（參見\\ :option:`調用 --with-"
"trace-refs 選項 <--with-trace-refs>`）。當有定義時，透過向每個 :c:type:"
"`PyObject` 新增兩個額外欄位來維護有效物件的循環雙向鍊表 (circular doubly "
"linked list)。全體分配也有被追蹤。退出時將印出所有現行參照。（在交互模式下，"
"這發生在直譯器運行的每個陳述句之後。）"

#: ../../c-api/intro.rst:802
msgid ""
"Please refer to :file:`Misc/SpecialBuilds.txt` in the Python source "
"distribution for more detailed information."
msgstr ""
"有關更多詳細資訊，請參閱 Python 原始碼發布版中的 :file:`Misc/SpecialBuilds."
"txt`。"

#: ../../c-api/intro.rst:264
msgid "object"
msgstr "object（物件）"

#: ../../c-api/intro.rst:264
msgid "type"
msgstr "type（型別）"

#: ../../c-api/intro.rst:301
msgid "Py_INCREF()"
msgstr "Py_INCREF()"

#: ../../c-api/intro.rst:301
msgid "Py_DECREF()"
msgstr "Py_DECREF()"

#: ../../c-api/intro.rst:372
msgid "PyList_SetItem()"
msgstr "PyList_SetItem()"

#: ../../c-api/intro.rst:372
msgid "PyTuple_SetItem()"
msgstr "PyTuple_SetItem()"

#: ../../c-api/intro.rst:443
msgid "set_all()"
msgstr "set_all()"

#: ../../c-api/intro.rst:462
msgid "PyList_GetItem()"
msgstr "PyList_GetItem()"

#: ../../c-api/intro.rst:462
msgid "PySequence_GetItem()"
msgstr "PySequence_GetItem()"

#: ../../c-api/intro.rst:492
msgid "sum_list()"
msgstr "sum_list()"

#: ../../c-api/intro.rst:524 ../../c-api/intro.rst:616
msgid "sum_sequence()"
msgstr "sum_sequence()"

#: ../../c-api/intro.rst:559
msgid "PyErr_Occurred()"
msgstr "PyErr_Occurred()"

#: ../../c-api/intro.rst:572
msgid "PyErr_SetString()"
msgstr "PyErr_SetString()"

#: ../../c-api/intro.rst:572 ../../c-api/intro.rst:680
msgid "PyErr_Clear()"
msgstr "PyErr_Clear()"

#: ../../c-api/intro.rst:596
msgid "exc_info() (in module sys)"
msgstr "exc_info() （sys 模組中）"

#: ../../c-api/intro.rst:631 ../../c-api/intro.rst:678
msgid "incr_item()"
msgstr "incr_item()"

#: ../../c-api/intro.rst:680
msgid "PyErr_ExceptionMatches()"
msgstr "PyErr_ExceptionMatches()"

#: ../../c-api/intro.rst:680
msgid "Py_XDECREF()"
msgstr "Py_XDECREF()"

#: ../../c-api/intro.rst:706
msgid "Py_Initialize()"
msgstr "Py_Initialize()"

#: ../../c-api/intro.rst:706
msgid "module"
msgstr "module（模組）"

#: ../../c-api/intro.rst:706
msgid "builtins"
msgstr "builtins（內建）"

#: ../../c-api/intro.rst:706
msgid "__main__"
msgstr "__main__"

#: ../../c-api/intro.rst:706
msgid "sys"
msgstr "sys"

#: ../../c-api/intro.rst:706
msgid "search"
msgstr "search（搜尋）"

#: ../../c-api/intro.rst:706
msgid "path"
msgstr "path（路徑）"

#: ../../c-api/intro.rst:706
msgid "path (in module sys)"
msgstr "path（sys 模組中）"

#: ../../c-api/intro.rst:741
msgid "Py_SetProgramName()"
msgstr "Py_SetProgramName()"

#: ../../c-api/intro.rst:741
msgid "Py_GetPath()"
msgstr "Py_GetPath()"

#: ../../c-api/intro.rst:741
msgid "Py_GetPrefix()"
msgstr "Py_GetPrefix()"

#: ../../c-api/intro.rst:741
msgid "Py_GetExecPrefix()"
msgstr "Py_GetExecPrefix()"

#: ../../c-api/intro.rst:741
msgid "Py_GetProgramFullPath()"
msgstr "Py_GetProgramFullPath()"

#: ../../c-api/intro.rst:756
msgid "Py_IsInitialized()"
msgstr "Py_IsInitialized()"
