# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Leon H., 2017
# Adrian Liaw <adrianliaw2000@gmail.com>, 2018
# Matt Wang <mattwang44@gmail.com>, 2021
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-08 00:03+0000\n"
"PO-Revision-Date: 2022-06-12 15:22+0800\n"
"Last-Translator: Matt Wang <mattwang44@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.1\n"

#: ../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "內建型別"

#: ../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr "以下章節描述了直譯器中内建的標準型別。"

#: ../../library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr "主要內建型別為數字、序列、映射、class（類別）、實例和例外。"

#: ../../library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"有些集合類別是 mutable（可變的）。那些用於原地 (in-place) 加入、移除或重新排"
"列其成員且不回傳特定項的 method（方法），也只會回傳 ``None`` 而非集合實例自"
"己。"

#: ../../library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth "
"value, and converted to a string (with the :func:`repr` function or the "
"slightly different :func:`str` function).  The latter function is implicitly "
"used when an object is written by the :func:`print` function."
msgstr ""
"某些操作已被多種物件型別支援；特別是實務上所有物件都已經可以做相等性比較、真"
"值檢測及被轉換為字串（使用 :func:`repr` 函式或稍有差異的 :func:`str` 函式），"
"後者為當物件傳入 :func:`print` 函式印出時在背後被呼叫的函式。"

#: ../../library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "真值檢測"

#: ../../library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"任何物件都可以進行檢測以判斷是否為真值，以便在 :keyword:`if` 或 :keyword:"
"`while` 條件中使用，或是作為如下所述 boolean（布林）運算之運算元所用。"

#: ../../library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`~object.__bool__` method that returns ``False`` or a :meth:`~object."
"__len__` method that returns zero, when called with the object. [1]_  Here "
"are most of the built-in objects considered false:"
msgstr ""
"預設情況下，一個物件會被視為真值，除非它的 class 定義了會回傳 ``False`` 的 :"
"meth:`~object.__bool__` method 或是定義了會回傳零的 :meth:`~object.__len__` "
"method。[1]_ 以下列出了大部分會被視為 false 的內建物件："

#: ../../library/stdtypes.rst:56
msgid "constants defined to be false: ``None`` and ``False``"
msgstr "定義為 false 之常數：``None`` 與 ``False``"

#: ../../library/stdtypes.rst:58
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"任何數值型別的零：``0``、``0.0``、``0j``、``Decimal(0)``、``Fraction(0, 1)``"

#: ../../library/stdtypes.rst:61
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"空的序列和集合：``''``、``()``、``[]``、``{}``、``set()``、``range(0)``"

#: ../../library/stdtypes.rst:70
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"除非另有特別說明，產生 boolean 結果的操作或內建函式都會回傳 ``0`` 或 "
"``False`` 作為假值、``1`` 或 ``True`` 作為真值。（重要例外： boolean 運算 "
"``or`` 和 ``and`` 回傳的是其中一個運算元。）"

#: ../../library/stdtypes.rst:79
msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr ""
"Boolean（布林）運算 --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"

#: ../../library/stdtypes.rst:83
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "下方為 Boolean 運算，按優先順序排序："

#: ../../library/stdtypes.rst:86 ../../library/stdtypes.rst:144
#: ../../library/stdtypes.rst:276 ../../library/stdtypes.rst:366
#: ../../library/stdtypes.rst:416 ../../library/stdtypes.rst:965
#: ../../library/stdtypes.rst:1170
msgid "Operation"
msgstr "運算"

#: ../../library/stdtypes.rst:86 ../../library/stdtypes.rst:276
#: ../../library/stdtypes.rst:366 ../../library/stdtypes.rst:416
#: ../../library/stdtypes.rst:965 ../../library/stdtypes.rst:1170
msgid "Result"
msgstr "結果"

#: ../../library/stdtypes.rst:86 ../../library/stdtypes.rst:276
#: ../../library/stdtypes.rst:416 ../../library/stdtypes.rst:965
#: ../../library/stdtypes.rst:1170 ../../library/stdtypes.rst:2423
#: ../../library/stdtypes.rst:3642
msgid "Notes"
msgstr "註解"

#: ../../library/stdtypes.rst:88
msgid "``x or y``"
msgstr "``x or y``"

#: ../../library/stdtypes.rst:88
msgid "if *x* is true, then *x*, else *y*"
msgstr "假如 *x* 為真，則 *x*，否則 *y*"

#: ../../library/stdtypes.rst:88 ../../library/stdtypes.rst:967
#: ../../library/stdtypes.rst:970 ../../library/stdtypes.rst:1181
#: ../../library/stdtypes.rst:2429 ../../library/stdtypes.rst:3648
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/stdtypes.rst:91
msgid "``x and y``"
msgstr "``x and y``"

#: ../../library/stdtypes.rst:91
msgid "if *x* is false, then *x*, else *y*"
msgstr "假如 *x* 為假，則 *x*，否則 *y*"

#: ../../library/stdtypes.rst:91 ../../library/stdtypes.rst:289
#: ../../library/stdtypes.rst:309 ../../library/stdtypes.rst:1209
#: ../../library/stdtypes.rst:2433 ../../library/stdtypes.rst:2435
#: ../../library/stdtypes.rst:3652 ../../library/stdtypes.rst:3654
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/stdtypes.rst:94
msgid "``not x``"
msgstr "``not x``"

#: ../../library/stdtypes.rst:94
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "假如 *x* 為假，則 ``True``，否則 ``False``"

#: ../../library/stdtypes.rst:94 ../../library/stdtypes.rst:979
#: ../../library/stdtypes.rst:1212 ../../library/stdtypes.rst:2437
#: ../../library/stdtypes.rst:2439 ../../library/stdtypes.rst:2441
#: ../../library/stdtypes.rst:2443 ../../library/stdtypes.rst:3656
#: ../../library/stdtypes.rst:3658 ../../library/stdtypes.rst:3660
#: ../../library/stdtypes.rst:3662
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/stdtypes.rst:103 ../../library/stdtypes.rst:320
#: ../../library/stdtypes.rst:434 ../../library/stdtypes.rst:1016
#: ../../library/stdtypes.rst:1221 ../../library/stdtypes.rst:2469
#: ../../library/stdtypes.rst:3692
msgid "Notes:"
msgstr "註解："

#: ../../library/stdtypes.rst:106
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"這是一個短路運算子，所以他只有在第一個引數為假時，才會對第二個引數求值。"

#: ../../library/stdtypes.rst:110
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"這是一個短路運算子，所以他只有在第一個引數為真時，才會對第二個引數求值。"

#: ../../library/stdtypes.rst:114
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` 比非 Boolean 運算子有較低的優先權，因此 ``not a == b`` 可直譯為 "
"``not (a == b)``，而 ``a == not b`` 會導致語法錯誤。"

#: ../../library/stdtypes.rst:121
msgid "Comparisons"
msgstr "比較運算"

#: ../../library/stdtypes.rst:135
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"在 Python 裡共有 8 種比較運算。他們的優先順序都相同（皆優先於 Boolean 運"
"算）。比較運算可以任意的串連；例如，``x < y <= z`` 等同於 ``x < y and y <= "
"z``，差異只在於前者的 *y* 只有被求值一次（但在這兩個例子中，當 ``x < y`` 為假"
"時，*z* 皆不會被求值）。"

#: ../../library/stdtypes.rst:141
msgid "This table summarizes the comparison operations:"
msgstr "這個表格統整所有比較運算："

#: ../../library/stdtypes.rst:144 ../../library/stdtypes.rst:2400
#: ../../library/stdtypes.rst:2423 ../../library/stdtypes.rst:3619
#: ../../library/stdtypes.rst:3642
msgid "Meaning"
msgstr "含義"

#: ../../library/stdtypes.rst:146
msgid "``<``"
msgstr "``<``"

#: ../../library/stdtypes.rst:146
msgid "strictly less than"
msgstr "小於"

#: ../../library/stdtypes.rst:148
msgid "``<=``"
msgstr "``<=``"

#: ../../library/stdtypes.rst:148
msgid "less than or equal"
msgstr "小於等於"

#: ../../library/stdtypes.rst:150
msgid "``>``"
msgstr "``>``"

#: ../../library/stdtypes.rst:150
msgid "strictly greater than"
msgstr "大於"

#: ../../library/stdtypes.rst:152
msgid "``>=``"
msgstr "``>=``"

#: ../../library/stdtypes.rst:152
msgid "greater than or equal"
msgstr "大於等於"

#: ../../library/stdtypes.rst:154
msgid "``==``"
msgstr "``==``"

#: ../../library/stdtypes.rst:154
msgid "equal"
msgstr "等於"

#: ../../library/stdtypes.rst:156
msgid "``!=``"
msgstr "``!=``"

#: ../../library/stdtypes.rst:156
msgid "not equal"
msgstr "不等於"

#: ../../library/stdtypes.rst:158
msgid "``is``"
msgstr "``is``"

#: ../../library/stdtypes.rst:158
msgid "object identity"
msgstr "物件識別性"

#: ../../library/stdtypes.rst:160
msgid "``is not``"
msgstr "``is not``"

#: ../../library/stdtypes.rst:160
msgid "negated object identity"
msgstr "否定的物件識別性"

#: ../../library/stdtypes.rst:167
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. The ``==`` operator is always defined but for some object types (for "
"example, class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, "
"``>`` and ``>=`` operators are only defined where they make sense; for "
"example, they raise a :exc:`TypeError` exception when one of the arguments "
"is a complex number."
msgstr ""
"除了不同的數值型別外，不同型別的物件不能進行相等比較。運算子 ``==`` 總有定"
"義，但在某些物件型別（例如，class 物件）時，運算子會等同於 :keyword:`is`。其"
"他運算子 ``<``、``<=``、``>`` 及 ``>=`` 皆僅在有意義的部分有所定義；例如，當"
"其中一個引數為複數時，將引發一個 :exc:`TypeError` 的例外。"

#: ../../library/stdtypes.rst:181
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`~object.__eq__` method."
msgstr ""
"一個 class 的非相同實例通常會比較為不相等，除非 class 有定義 :meth:`~object."
"__eq__` method。"

#: ../../library/stdtypes.rst:184
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`~object.__lt__`, :meth:`~object.__le__`, :meth:`~object."
"__gt__`, and :meth:`~object.__ge__` (in general, :meth:`~object.__lt__` and :"
"meth:`~object.__eq__` are sufficient, if you want the conventional meanings "
"of the comparison operators)."
msgstr ""
"一個 class 的實例不可以與其他相同 class 的實例或其他物件型別進行排序，除非 "
"class 定義足夠的 method ，包含 :meth:`~object.__lt__`、:meth:`~object."
"__le__`、:meth:`~object.__gt__` 及 :meth:`~object.__ge__`\\ （一般來說，使"
"用 :meth:`~object.__lt__` 及 :meth:`~object.__eq__` 就可以滿足常規意義上的比"
"較運算子）。"

#: ../../library/stdtypes.rst:191
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
"無法自定義 :keyword:`is` 與 :keyword:`is not` 運算子的行為；這兩個運算子也可"
"以運用在任意兩個物件且不會引發例外。"

#: ../../library/stdtypes.rst:199
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`~object.__contains__` method."
msgstr ""
"此外，擁有相同的語法優先序的 :keyword:`in` 及 :keyword:`not in` 兩種運算皆被"
"\\ :term:`可疊代物件 <iterable>`\\ 或者有實作 :meth:`~object.__contains__` "
"method 的型別所支援。"

#: ../../library/stdtypes.rst:206
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "數值型別 --- :class:`int`、:class:`float`、:class:`complex`"

#: ../../library/stdtypes.rst:216
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating-"
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating-point "
"numbers are usually implemented using :c:expr:`double` in C; information "
"about the precision and internal representation of floating-point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating-point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes the additional "
"numeric types :mod:`fractions.Fraction`, for rationals, and :mod:`decimal."
"Decimal`, for floating-point numbers with user-definable precision.)"
msgstr ""
"數值型別共有三種：:dfn:`整數`、:dfn:`浮點數` 及 :dfn:`複數`。此外，Boolean 為"
"整數中的一個子型別。整數有無限的精度。浮點數通常使用 C 裡面的 :c:expr:"
"`double` 實作。關於在你程式所運作的機器上之浮點數的精度及內部表示法可以在 :"
"data:`sys.float_info` 進行查找。複數包含實數及虛數的部分，這兩部分各自是一個"
"浮點數。若要從一個複數 *z* 提取這兩部分，需使用 ``z.real`` 及 ``z.imag``。"
"（標準函式庫包含額外的數值型別，像是 :mod:`fractions.Fraction` 表示有理數，"
"而 :mod:`decimal.Decimal` 表示可由使用者制定精度的浮點數。）"

#: ../../library/stdtypes.rst:238
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating-point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"數字是由字面數值或內建公式及運算子的結果所產生的。未經修飾的字面數值（含十六"
"進位、八進位及二進位數值）會 yield 整數。包含小數點或指數符號的字面數值會 "
"yield 浮點數。在數值後面加上 ``'j'`` 或是 ``'J'`` 會 yield 一個虛數（意即一個"
"實數為 0 的複數）。你也可以將整數與浮點數相加以得到一個有實部與虛部的複數。"

#: ../../library/stdtypes.rst:263
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex. A comparison between numbers "
"of different types behaves as though the exact values of those numbers were "
"being compared. [2]_"
msgstr ""
"Python 完全支援混和運算：當一個二元運算子的運算元有不同數值型別時，「較窄」型"
"別的運算元會被拓寬到另一個型別的運算元；在此處，整數窄於浮點數，浮點數又窄於"
"複數。不同型別的數字間的比較等同於這些數字的精確值進行比較。[2]_"

#: ../../library/stdtypes.rst:269
msgid ""
"The constructors :func:`int`, :func:`float`, and :func:`complex` can be used "
"to produce numbers of a specific type."
msgstr ""
"建構函式： :func:`int`、:func:`float` 及 :func:`complex` 可以用來產生特定型別"
"的數字。"

#: ../../library/stdtypes.rst:272
msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr ""
"所有數值型別（除複數外）皆支援以下的運算（有關運算的先後順序，詳見 :ref:"
"`operator-summary`）："

#: ../../library/stdtypes.rst:276
msgid "Full documentation"
msgstr "完整文件"

#: ../../library/stdtypes.rst:278
msgid "``x + y``"
msgstr "``x + y``"

#: ../../library/stdtypes.rst:278
msgid "sum of *x* and *y*"
msgstr "*x* 及 *y* 的加總"

#: ../../library/stdtypes.rst:280
msgid "``x - y``"
msgstr "``x - y``"

#: ../../library/stdtypes.rst:280
msgid "difference of *x* and *y*"
msgstr "*x* 及 *y* 的相減"

#: ../../library/stdtypes.rst:282
msgid "``x * y``"
msgstr "``x * y``"

#: ../../library/stdtypes.rst:282
msgid "product of *x* and *y*"
msgstr "*x* 及 *y* 的相乘"

#: ../../library/stdtypes.rst:284
msgid "``x / y``"
msgstr "``x / y``"

#: ../../library/stdtypes.rst:284
msgid "quotient of *x* and *y*"
msgstr "*x* 及 *y* 相除之商"

#: ../../library/stdtypes.rst:286
msgid "``x // y``"
msgstr "``x // y``"

#: ../../library/stdtypes.rst:286
msgid "floored quotient of *x* and *y*"
msgstr "*x* 及 *y* 的整數除法"

#: ../../library/stdtypes.rst:286
msgid "\\(1)\\(2)"
msgstr "\\(1)\\(2)"

#: ../../library/stdtypes.rst:289
msgid "``x % y``"
msgstr "``x % y``"

#: ../../library/stdtypes.rst:289
msgid "remainder of ``x / y``"
msgstr "``x / y`` 的餘數"

#: ../../library/stdtypes.rst:291
msgid "``-x``"
msgstr "``-x``"

#: ../../library/stdtypes.rst:291
msgid "*x* negated"
msgstr "*x* 的負數"

#: ../../library/stdtypes.rst:293
msgid "``+x``"
msgstr "``+x``"

#: ../../library/stdtypes.rst:293
msgid "*x* unchanged"
msgstr "*x* 不變"

#: ../../library/stdtypes.rst:295
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../../library/stdtypes.rst:295
msgid "absolute value or magnitude of *x*"
msgstr "*x* 的絕對值或量 (magnitude)"

#: ../../library/stdtypes.rst:295
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/stdtypes.rst:298
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../../library/stdtypes.rst:298
msgid "*x* converted to integer"
msgstr "將 *x* 轉為整數"

#: ../../library/stdtypes.rst:298
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: ../../library/stdtypes.rst:298
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/stdtypes.rst:300
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../../library/stdtypes.rst:300
msgid "*x* converted to floating point"
msgstr "將 *x* 轉為浮點數"

#: ../../library/stdtypes.rst:300
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: ../../library/stdtypes.rst:300
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../../library/stdtypes.rst:302
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../../library/stdtypes.rst:302
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr "一個複數，其實部為 *re*，虛部為 *im*。*im* 預設為零。"

#: ../../library/stdtypes.rst:302 ../../library/stdtypes.rst:1202
#: ../../library/stdtypes.rst:2431 ../../library/stdtypes.rst:3679
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/stdtypes.rst:302
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../../library/stdtypes.rst:306
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../../library/stdtypes.rst:306
msgid "conjugate of the complex number *c*"
msgstr "為複數 *c* 的共軛複數"

#: ../../library/stdtypes.rst:309
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../library/stdtypes.rst:309
msgid "the pair ``(x // y, x % y)``"
msgstr "一對 ``(x // y, x % y)``"

#: ../../library/stdtypes.rst:309
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/stdtypes.rst:311
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../../library/stdtypes.rst:311 ../../library/stdtypes.rst:313
msgid "*x* to the power *y*"
msgstr "*x* 的 *y* 次方"

#: ../../library/stdtypes.rst:311 ../../library/stdtypes.rst:313
#: ../../library/stdtypes.rst:1191 ../../library/stdtypes.rst:1194
#: ../../library/stdtypes.rst:2456 ../../library/stdtypes.rst:2459
#: ../../library/stdtypes.rst:2462 ../../library/stdtypes.rst:3675
#: ../../library/stdtypes.rst:3682
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/stdtypes.rst:311
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/stdtypes.rst:313
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../../library/stdtypes.rst:323
msgid ""
"Also referred to as integer division.  For operands of type :class:`int`, "
"the result has type :class:`int`.  For operands of type :class:`float`, the "
"result has type :class:`float`.  In general, the result is a whole integer, "
"though the result's type is not necessarily :class:`int`.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"也被稱為整數除法。對於型別為 :class:`int` 的運算元來說，結果之型別會是 :"
"class:`int`。對於型別為 :class:`float` 的運算元來說，結果之型別會是 :class:"
"`float`。一般來說，結果會是一個整數，但其型別不一定會是 :class:`int`。結果總"
"是會往負無窮大的方向取整數值： ``1//2`` 為 ``0``、``(-1)//2`` 為 ``-1``、"
"``1//(-2)`` 為 ``-1`` 及 ``(-1)//(-2)`` 為 ``0``。"

#: ../../library/stdtypes.rst:331
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr "不可用於複數。在適當情形下，可使用 :func:`abs` 轉換為浮點數。"

#: ../../library/stdtypes.rst:342
msgid ""
"Conversion from :class:`float` to :class:`int` truncates, discarding the "
"fractional part. See functions :func:`math.floor` and :func:`math.ceil` for "
"alternative conversions."
msgstr ""
"從 :class:`float` 轉換為 :class:`int` 會導致截斷並排除小數部分。詳見 :func:"
"`math.floor` 及 :func:`math.ceil` 以了解更多轉換方式。"

#: ../../library/stdtypes.rst:347
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"浮點數也接受帶有可選的前綴 \"+\" 及 \"-\" 的 \"nan\" 及  \"inf\" 字串，其分別"
"代表非數字（NaN）及正負無窮。"

#: ../../library/stdtypes.rst:351
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python 將 ``pow(0, 0)`` 及 ``0 ** 0`` 定義為 ``1`` 這是程式語言的普遍做法。"

#: ../../library/stdtypes.rst:355
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"字面數值接受包含數字 ``0`` 到 ``9`` 或任何等效的 Unicode 字元（具有 ``Nd`` 屬"
"性的 code points（碼位））。"

#: ../../library/stdtypes.rst:358
msgid ""
"See `the Unicode Standard <https://unicode.org/Public/UNIDATA/extracted/"
"DerivedNumericType.txt>`_ for a complete list of code points with the ``Nd`` "
"property."
msgstr ""
"請參閱 `Unicode 標準 <https://unicode.org/Public/UNIDATA/extracted/"
"DerivedNumericType.txt>`_\\ 以了解具有 ``Nd`` 屬性的 code points 完整列表。"

#: ../../library/stdtypes.rst:362
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"所有 :class:`numbers.Real` 型別（:class:`int` 及 :class:`float`）也適用下列運"
"算："

#: ../../library/stdtypes.rst:368
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../../library/stdtypes.rst:368
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* 截斷為 :class:`~numbers.Integral`"

#: ../../library/stdtypes.rst:371
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../../library/stdtypes.rst:371
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr "*x* 進位至小數點後第 *n* 位，使用偶數捨入法。若省略 *n* ，則預設為 0。"

#: ../../library/stdtypes.rst:375
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../../library/stdtypes.rst:375
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "小於等於 *x* 的最大 :class:`~numbers.Integral`"

#: ../../library/stdtypes.rst:378
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../../library/stdtypes.rst:378
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "大於等於 *x* 的最小 :class:`~numbers.Integral`"

#: ../../library/stdtypes.rst:382
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr "關於其他數值運算請詳見 :mod:`math` 及 :mod:`cmath` modules（模組）。"

#: ../../library/stdtypes.rst:391
msgid "Bitwise Operations on Integer Types"
msgstr "整數型別的位元運算"

#: ../../library/stdtypes.rst:405
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""
"位元運算只對整數有意義。位元運算的計算結果就如同對二的補數執行無窮多個符號位"
"元。"

#: ../../library/stdtypes.rst:409
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"二元位元運算的優先順序皆低於數字運算，但高於比較運算；一元運算 ``~`` 與其他一"
"元數值運算有一致的優先順序（``+`` 及 ``-``）。"

#: ../../library/stdtypes.rst:413
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr "這個表格列出所有位元運算並以優先順序由先至後排序。"

#: ../../library/stdtypes.rst:418
msgid "``x | y``"
msgstr "``x | y``"

#: ../../library/stdtypes.rst:418
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "*x* 及 *y* 的位元 :dfn:`或`"

#: ../../library/stdtypes.rst:418 ../../library/stdtypes.rst:421
#: ../../library/stdtypes.rst:424 ../../library/stdtypes.rst:1216
#: ../../library/stdtypes.rst:2445 ../../library/stdtypes.rst:2449
#: ../../library/stdtypes.rst:3664 ../../library/stdtypes.rst:3668
msgid "\\(4)"
msgstr "\\(4)"

#: ../../library/stdtypes.rst:421
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../../library/stdtypes.rst:421
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "*x* 及 *y* 的位元 :dfn:`邏輯互斥或`"

#: ../../library/stdtypes.rst:424
msgid "``x & y``"
msgstr "``x & y``"

#: ../../library/stdtypes.rst:424
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "*x* 及 *y* 的位元 :dfn:`與`"

#: ../../library/stdtypes.rst:427
msgid "``x << n``"
msgstr "``x << n``"

#: ../../library/stdtypes.rst:427
msgid "*x* shifted left by *n* bits"
msgstr "*x* 往左移動 *n* 個位元"

#: ../../library/stdtypes.rst:427
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../library/stdtypes.rst:429
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../../library/stdtypes.rst:429
msgid "*x* shifted right by *n* bits"
msgstr "*x* 往右移動 *n* 個位元"

#: ../../library/stdtypes.rst:429
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../../library/stdtypes.rst:431
msgid "``~x``"
msgstr "``~x``"

#: ../../library/stdtypes.rst:431
msgid "the bits of *x* inverted"
msgstr "反轉 *x* 的位元"

#: ../../library/stdtypes.rst:437
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr "負數位移是不被允許並會引發 :exc:`ValueError` 的錯誤。"

#: ../../library/stdtypes.rst:440
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``."
msgstr "向左移動 *n* 個位元等同於乘以 ``pow(2, n)``。"

#: ../../library/stdtypes.rst:443
msgid ""
"A right shift by *n* bits is equivalent to floor division by ``pow(2, n)``."
msgstr "向右移動 *n* 個位元等同於向下除法除以 ``pow(2, n)``。"

#: ../../library/stdtypes.rst:446
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""
"在有限的二的補數表示法中執行這些計算（一個有效位元寬度為 ``1 + max(x."
"bit_length(), y.bit_length())`` 或以上）並至少有一個額外的符號擴展位元，便足"
"以得到與無窮多個符號位元相同的結果。"

#: ../../library/stdtypes.rst:453
msgid "Additional Methods on Integer Types"
msgstr "整數型別的附加 methods"

#: ../../library/stdtypes.rst:455
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"整數型別實作了 :class:`numbers.Integral` :term:`抽象基底類別 <abstract base "
"class>`。此外，它提供了一些 methods："

#: ../../library/stdtypes.rst:460
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr "回傳以二進位表示一個整數所需要的位元數，不包括符號及首位的零： ::"

#: ../../library/stdtypes.rst:469
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"更準確來說，若 ``x`` 非為零，則 ``x.bit_length()`` 會得出滿足 ``2**(k-1) <= "
"abs(x) < 2**k`` 的單一正整數 ``k``。同樣地，當 ``abs(x)`` 足夠小到能正確地取"
"得捨入的對數，則 ``k = 1 + int(log(abs(x), 2))``。若 ``x`` 為零，則 ``x."
"bit_length()`` 會回傳 ``0``。"

#: ../../library/stdtypes.rst:475 ../../library/stdtypes.rst:498
#: ../../library/stdtypes.rst:543 ../../library/stdtypes.rst:587
msgid "Equivalent to::"
msgstr "等同於： ::"

#: ../../library/stdtypes.rst:486
msgid ""
"Return the number of ones in the binary representation of the absolute value "
"of the integer. This is also known as the population count. Example::"
msgstr "回傳在絕對值表示的二進位中 1 的個數。這也被稱作母體計數。舉例來說： ::"

#: ../../library/stdtypes.rst:507
msgid "Return an array of bytes representing an integer."
msgstr "回傳表示一個整數的一列位元組。"

#: ../../library/stdtypes.rst:519
msgid ""
"The integer is represented using *length* bytes, and defaults to 1.  An :exc:"
"`OverflowError` is raised if the integer is not representable with the given "
"number of bytes."
msgstr ""
"此整數會使用 *length* 位元組表示，並且預設為 1。如果該整數無法用給定的位元組"
"數來表示，則會引發 :exc:`OverflowError`。"

#: ../../library/stdtypes.rst:523
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte array."
msgstr ""
"*byteorder* 引數決定了用來表示整數的位元組順序並且預設為 ``\"big\"``。如果 "
"byteorder 是 ``\"big\"``，最重要的位元組位於位元組陣列的開頭。如果 byteorder "
"是 ``\"little\"``，最重要的位元組位於位元組陣列的結尾。"

#: ../../library/stdtypes.rst:529
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"*signed* 引數決定是否使用二的補數來表示整數。如果 *signed* 是 ``False`` 並且"
"給定了一個負整數，則會引發 :exc:`OverflowError`。*signed* 的預設值是 "
"``False``。"

#: ../../library/stdtypes.rst:534
msgid ""
"The default values can be used to conveniently turn an integer into a single "
"byte object::"
msgstr "預設值可以方便地將一個整數轉換為單一位元組物件： ::"

#: ../../library/stdtypes.rst:540
msgid ""
"However, when using the default arguments, don't try to convert a value "
"greater than 255 or you'll get an :exc:`OverflowError`."
msgstr ""
"然而，使用預設引數時，不要嘗試轉換大於 255 的值，否則你將會得到一個 :exc:"
"`OverflowError`。"

#: ../../library/stdtypes.rst:556
msgid "Added default argument values for ``length`` and ``byteorder``."
msgstr "為 ``length`` 和 ``byteorder`` 添加了預設引數值。"

#: ../../library/stdtypes.rst:561
msgid "Return the integer represented by the given array of bytes."
msgstr "回傳由給定的位元組陣列表示的整數。"

#: ../../library/stdtypes.rst:574
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"引數 *bytes* 必須是一個\\ :term:`類位元組物件 <bytes-like object>`\\ 或是一個"
"產生位元組的可疊代物件。"

#: ../../library/stdtypes.rst:577
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte "
"array.  To request the native byte order of the host system, use :data:`sys."
"byteorder` as the byte order value."
msgstr ""
"*byteorder* 引數決定了用來表示整數的位元組順序並且預設為 ``\"big\"``。如果 "
"*byteorder* 是 ``\"big\"``，最重要的位元組位於位元組陣列的開頭。如果 "
"*byteorder* 是 ``\"little\"``，最重要的位元組位於位元組陣列的結尾。若要請求主"
"機系統的本機位元組順序，請使用 :data:`sys.byteorder` 作為位元組順序值。"

#: ../../library/stdtypes.rst:584
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr "*signed* 引數指示是否使用二的補數來表示整數。"

#: ../../library/stdtypes.rst:604
msgid "Added default argument value for ``byteorder``."
msgstr "為 ``byteorder`` 添加了預設引數值。"

#: ../../library/stdtypes.rst:609
msgid ""
"Return a pair of integers whose ratio is equal to the original integer and "
"has a positive denominator.  The integer ratio of integers (whole numbers) "
"is always the integer as the numerator and ``1`` as the denominator."
msgstr ""
"回傳一對整數，其比率等於原始整數並且有一個正分母。整數（整個數值）的整數比率"
"總是整數作為分子，並且 ``1`` 作為分母。"

#: ../../library/stdtypes.rst:618
msgid ""
"Returns ``True``. Exists for duck type compatibility with :meth:`float."
"is_integer`."
msgstr "回傳 ``True``。為了與 :meth:`float.is_integer` 的鴨子型別相容而存在。"

#: ../../library/stdtypes.rst:623
msgid "Additional Methods on Float"
msgstr "浮點數的附加 methods"

#: ../../library/stdtypes.rst:625
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"浮點數型別實作了 :class:`numbers.Real` :term:`抽象基底類別 <abstract base "
"class>`。浮點數也有下列附加 methods。"

#: ../../library/stdtypes.rst:630
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"float. The ratio is in lowest terms and has a positive denominator.  Raises :"
"exc:`OverflowError` on infinities and a :exc:`ValueError` on NaNs."
msgstr ""
"回傳一對整數，其比率完全等於原始浮點數。比率是在最低條件下並且有一個正分母。"
"在無窮大時引發 :exc:`OverflowError`，在 NaN 時引發 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:637
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"如果浮點數實例是有限的並且具有整數值，則回傳 ``True``，否則回傳 "
"``False``： ::"

#: ../../library/stdtypes.rst:645
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"兩個 methods 皆支援十六進位字串之間的轉換。由於 Python 的浮點數內部以二進位數"
"值儲存，將浮點數轉換為或從 *十進位* 字串通常涉及一個小的四捨五入誤差。相反"
"地，十六進位字串允許精確表示和指定浮點數。這在除錯和數值工作中可能會有用。"

#: ../../library/stdtypes.rst:656
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"回傳浮點數的十六進位字串表示。對於有限浮點數，此表示方式總是包含一個前導 "
"``0x`` 及一個尾部 ``p`` 和指數。"

#: ../../library/stdtypes.rst:664
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"Class method 回傳由十六進位字串 *s* 表示的浮點數。字串 *s* 可能有前導及尾部的"
"空白。"

#: ../../library/stdtypes.rst:669
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
"請注意 :meth:`float.hex` 是一個實例 method，而 :meth:`float.fromhex` 是一個 "
"class method。"

#: ../../library/stdtypes.rst:672
msgid "A hexadecimal string takes the form::"
msgstr "一個十六進位字串的形式如下： ::"

#: ../../library/stdtypes.rst:676
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"其中可選的 ``sign`` 可以是 ``+`` 或 ``-``，``integer`` 和 ``fraction`` 是十六"
"進位數字的字串，而 ``exponent`` 是一個十進位整數並且有一個可選的前導符號。大"
"小寫不重要，並且整數或小數部分至少有一個十六進位數字。這個語法與 C99 標準的"
"第 6.4.4.2 節指定的語法相似，也與 Java 1.5 以後的語法相似。特別是 :meth:"
"`float.hex` 的輸出可用作 C 或 Java 程式碼中的十六進位浮點數文字，並且 C 的 "
"``%a`` 格式字元或 Java 的 ``Double.toHexString`` 產生的十六進位字串可被 :"
"meth:`float.fromhex` 接受。"

#: ../../library/stdtypes.rst:689
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"請注意指數是以十進位而非十六進位寫入，並且它給出了乘以係數的 2 的次方。例如，"
"十六進位字串 ``0x3.a7p10`` 表示浮點數 ``(3 + 10./16 + 7./16**2) * 2.0**10``，"
"或 ``3740.0``： ::"

#: ../../library/stdtypes.rst:699
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"對 ``3740.0`` 應用反向轉換會給出一個不同的十六進位字串，它表示相同的數字： ::"

#: ../../library/stdtypes.rst:709
msgid "Hashing of numeric types"
msgstr "數值型別的雜湊"

#: ../../library/stdtypes.rst:711
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`~object."
"__hash__` method documentation for more details).  For ease of "
"implementation and efficiency across a variety of numeric types (including :"
"class:`int`, :class:`float`, :class:`decimal.Decimal` and :class:`fractions."
"Fraction`) Python's hash for numeric types is based on a single mathematical "
"function that's defined for any rational number, and hence applies to all "
"instances of :class:`int` and :class:`fractions.Fraction`, and all finite "
"instances of :class:`float` and :class:`decimal.Decimal`.  Essentially, this "
"function is given by reduction modulo ``P`` for a fixed prime ``P``.  The "
"value of ``P`` is made available to Python as the :attr:`~sys.hash_info."
"modulus` attribute of :data:`sys.hash_info`."
msgstr ""
"對於數字 ``x`` 和 ``y``，可能是不同型別，當 ``x == y`` 時，``hash(x) == "
"hash(y)`` 是一個要求（ 詳見 :meth:`~object.__hash__` method 的文件以獲得更多"
"細節）。為了實作的便利性和效率跨越各種數值型別（包括 :class:`int`、:class:"
"`float`、:class:`decimal.Decimal` 和 :class:`fractions.Fraction`）Python 的數"
"值型別的雜湊是基於一個數學函式，它對於任何有理數都是定義的，因此適用於所有 :"
"class:`int` 和 :class:`fractions.Fraction` 的實例，以及所有有限的 :class:"
"`float` 和 :class:`decimal.Decimal` 的實例。基本上，這個函式是由簡化的 modulo"
"（模數） ``P`` 給出的一個固定的質數 ``P``。``P`` 的值作為 :data:`sys."
"hash_info` 的 :attr:`~sys.hash_info.modulus` 屬性提供給 Python。"

#: ../../library/stdtypes.rst:726
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"目前在具有 32 位元 C longs 的機器上所使用的質數是 ``P = 2**31 - 1``，而在具"
"有 64 位元 C longs 的機器上為 ``P = 2**61 - 1`` 。"

#: ../../library/stdtypes.rst:729
msgid "Here are the rules in detail:"
msgstr "以下是詳細的規則："

#: ../../library/stdtypes.rst:731
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"如果 ``x = m / n`` 是一個非負的有理數，並且 ``n`` 不可被 ``P`` 整除，則將 "
"``hash(x)`` 定義為 ``m * invmod(n, P) % P``。其中 ``invmod(n, P)`` 為 ``n`` "
"對模數 ``P`` 的倒數。"

#: ../../library/stdtypes.rst:735
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"如果 ``x = m / n`` 是一個非負的有理數，並且 ``n`` 可被 ``P`` 整除（但 ``m`` "
"不行），則 ``n`` 沒有 inverse modulo（模倒數） ``P`` ，並且不適用於上述規則；"
"在這種情況下，將 ``hash(x)`` 定義為常數值 ``sys.hash_info.inf``。"

#: ../../library/stdtypes.rst:740
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"如果 ``x = m / n`` 是一個負的有理數，則將 ``hash(x)`` 定義為 ``-hash(-x)``。"
"如果結果的雜湊是 ``-1``，則將其替換為 ``-2``。"

#: ../../library/stdtypes.rst:744
msgid ""
"The particular values ``sys.hash_info.inf`` and ``-sys.hash_info.inf`` are "
"used as hash values for positive infinity or negative infinity "
"(respectively)."
msgstr ""
"特定值 ``sys.hash_info.inf`` 和 ``-sys.hash_info.inf`` （分別）被用作正無窮大"
"或負無窮大的雜湊值。"

#: ../../library/stdtypes.rst:748
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"對於一個 :class:`complex` 值 ``z``，實部和虛部的雜湊值藉由 ``hash(z.real) + "
"sys.hash_info.imag * hash(z.imag)`` 的計算進行組合，對 ``2**sys.hash_info."
"width`` 取模數使其介於 ``range(-2**(sys.hash_info.width - 1), 2**(sys."
"hash_info.width - 1))``。同樣地，如果結果是 ``-1``，則將其替換為 ``-2``。"

#: ../../library/stdtypes.rst:756
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"為了闡明上述規則，這裡有一些 Python 程式碼範例，等同於內建的雜湊，用於計算有"
"理數、:class:`float` 或 :class:`complex` 的雜湊： ::"

#: ../../library/stdtypes.rst:812
msgid "Boolean Type - :class:`bool`"
msgstr "Boolean 型別 - :class:`bool`"

#: ../../library/stdtypes.rst:814
msgid ""
"Booleans represent truth values. The :class:`bool` type has exactly two "
"constant instances: ``True`` and ``False``."
msgstr ""
"Boolean 值代表 truth values（真值）。:class:`bool` 型別有兩個常數實例："
"``True`` 和 ``False``。"

#: ../../library/stdtypes.rst:822
msgid ""
"The built-in function :func:`bool`  converts any value to a boolean, if the "
"value can be interpreted as a truth value (see section :ref:`truth` above)."
msgstr ""
"內建函式 :func:`bool` 將任何值轉換為 boolean 值，如果該值可以被直譯為一個 "
"truth value（真值）（見上面的\\ :ref:`truth`\\ 章節）。"

#: ../../library/stdtypes.rst:825
msgid ""
"For logical operations, use the :ref:`boolean operators <boolean>` ``and``, "
"``or`` and ``not``. When applying the bitwise operators ``&``, ``|``, ``^`` "
"to two booleans, they return a bool equivalent to the logical operations "
"\"and\", \"or\", \"xor\". However, the logical operators ``and``, ``or`` and "
"``!=`` should be preferred over ``&``, ``|`` and ``^``."
msgstr ""
"對於邏輯運算，使用 :ref:`boolean 運算子 <boolean>` ``and``、``or`` 和 "
"``not``。當將位元運算子 ``&``、``|``、``^`` 應用於兩個 boolean 值時，它們會回"
"傳一個等同於邏輯運算 \"and\"、\"or\"、\"xor\" 的 boolean 值。然而，應該優先使"
"用邏輯運算子 ``and``、``or`` 和 ``!=`` 而不是 ``&``、``|`` 和 ``^``。"

#: ../../library/stdtypes.rst:834
msgid ""
"The use of the bitwise inversion operator ``~`` is deprecated and will raise "
"an error in Python 3.14."
msgstr "位元反轉運算子 ``~`` 的使用已被棄用並且將在 Python 3.14 中引發錯誤。"

#: ../../library/stdtypes.rst:837
msgid ""
":class:`bool` is a subclass of :class:`int` (see :ref:`typesnumeric`). In "
"many numeric contexts, ``False`` and ``True`` behave like the integers 0 and "
"1, respectively. However, relying on this is discouraged; explicitly convert "
"using :func:`int` instead."
msgstr ""
":class:`bool` 是 :class:`int` 的子類別（見\\ :ref:`typesnumeric`）。在許多數"
"值情境中，``False`` 和 ``True`` 分別像整數 0 和 1 一樣。然而，不鼓勵依賴這一"
"點；請使用 :func:`int` 進行顯式轉換。"

#: ../../library/stdtypes.rst:845
msgid "Iterator Types"
msgstr "疊代器型別"

#: ../../library/stdtypes.rst:853
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python 支援對容器的疊代概念。這是實作兩種不同的 methods；這些方法被用於允許使"
"用者自定義的 classes 以支援疊代。序列則總是支援這些疊代 methods，在下方有更詳"
"細的描述。"

#: ../../library/stdtypes.rst:858
msgid ""
"One method needs to be defined for container objects to provide :term:"
"`iterable` support:"
msgstr ""
"需要為容器物件定義一個 method 來提供\\ :term:`可疊代物件 <iterable>`\\ 支援："

#: ../../library/stdtypes.rst:865
msgid ""
"Return an :term:`iterator` object.  The object is required to support the "
"iterator protocol described below.  If a container supports different types "
"of iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
"回傳一個\\ :term:`疊代器 <iterator>`\\ 物件。該物件需要支援下述的疊代器協定。"
"如果一個容器支援不同型別的疊代，則可以提供額外的 methods 來專門請求這些疊代型"
"別的疊代器。（支援多種形式疊代的物件的一個例子是支援廣度優先和深度優先遍歷的"
"樹結構。）此 method 對應 Python/C API 中 Python 物件的型別結構的 :c:member:"
"`~PyTypeObject.tp_iter` 插槽。"

#: ../../library/stdtypes.rst:874
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"疊代器物件本身需要支援下列兩個 methods，他們一起形成了 :dfn:`疊代器協定`："

#: ../../library/stdtypes.rst:880
msgid ""
"Return the :term:`iterator` object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements.  This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
"回傳\\ :term:`疊代器 <iterator>`\\ 物件本身。這是為了允許容器和疊代器都可以"
"與 :keyword:`for` 和 :keyword:`in` 在陳述式中使用。此 method 對應於 Python/C "
"API 中 Python 物件的型別結構的 :c:member:`~PyTypeObject.tp_iter` 插槽。"

#: ../../library/stdtypes.rst:889
msgid ""
"Return the next item from the :term:`iterator`.  If there are no further "
"items, raise the :exc:`StopIteration` exception.  This method corresponds to "
"the :c:member:`~PyTypeObject.tp_iternext` slot of the type structure for "
"Python objects in the Python/C API."
msgstr ""
"從\\ :term:`疊代器 <iterator>`\\ 回傳下一個項目。如果沒有更多項目，則引發 :"
"exc:`StopIteration` 例外。此 method 對應於 Python/C API 中Python 物件的型別結"
"構的 :c:member:`~PyTypeObject.tp_iternext` 插槽。"

#: ../../library/stdtypes.rst:894
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"Python 定義了幾個疊代器物件來支援對一般和特定序列型別、字典和其他更專門的形式"
"的疊代。這些特定型別除了實作疊代器協定外並不重要。"

#: ../../library/stdtypes.rst:899
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"一旦疊代器的 :meth:`~iterator.__next__` method 引發 :exc:`StopIteration`，則"
"它必須在後續呼叫中繼續這樣做。不遵守此屬性的實作被認為是有問題的。"

#: ../../library/stdtypes.rst:907
msgid "Generator Types"
msgstr ""

#: ../../library/stdtypes.rst:909
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`~iterator.__iter__` "
"method is implemented as a generator, it will automatically return an "
"iterator object (technically, a generator object) supplying the :meth:`!"
"__iter__` and :meth:`~generator.__next__` methods. More information about "
"generators can be found in :ref:`the documentation for the yield expression "
"<yieldexpr>`."
msgstr ""

#: ../../library/stdtypes.rst:921
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr ""

#: ../../library/stdtypes.rst:923
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""

#: ../../library/stdtypes.rst:932
msgid "Common Sequence Operations"
msgstr ""

#: ../../library/stdtypes.rst:936
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""

#: ../../library/stdtypes.rst:941
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""

#: ../../library/stdtypes.rst:946
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""

#: ../../library/stdtypes.rst:967
msgid "``x in s``"
msgstr "``x in s``"

#: ../../library/stdtypes.rst:967
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr ""

#: ../../library/stdtypes.rst:970
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../../library/stdtypes.rst:970
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr ""

#: ../../library/stdtypes.rst:973
msgid "``s + t``"
msgstr "``s + t``"

#: ../../library/stdtypes.rst:973
msgid "the concatenation of *s* and *t*"
msgstr ""

#: ../../library/stdtypes.rst:973
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../../library/stdtypes.rst:976
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` 或 ``n * s``"

#: ../../library/stdtypes.rst:976
msgid "equivalent to adding *s* to itself *n* times"
msgstr ""

#: ../../library/stdtypes.rst:976
msgid "(2)(7)"
msgstr "(2)(7)"

#: ../../library/stdtypes.rst:979
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../library/stdtypes.rst:979
msgid "*i*\\ th item of *s*, origin 0"
msgstr ""

#: ../../library/stdtypes.rst:981
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../../library/stdtypes.rst:981
msgid "slice of *s* from *i* to *j*"
msgstr ""

#: ../../library/stdtypes.rst:981
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../../library/stdtypes.rst:983
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../../library/stdtypes.rst:983
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr ""

#: ../../library/stdtypes.rst:983
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../../library/stdtypes.rst:986
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../library/stdtypes.rst:986
msgid "length of *s*"
msgstr ""

#: ../../library/stdtypes.rst:988
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../../library/stdtypes.rst:988
msgid "smallest item of *s*"
msgstr ""

#: ../../library/stdtypes.rst:990
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../../library/stdtypes.rst:990
msgid "largest item of *s*"
msgstr ""

#: ../../library/stdtypes.rst:992
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../../library/stdtypes.rst:992
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr ""

#: ../../library/stdtypes.rst:992 ../../library/stdtypes.rst:3650
msgid "\\(8)"
msgstr "\\(8)"

#: ../../library/stdtypes.rst:996
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../../library/stdtypes.rst:996
msgid "total number of occurrences of *x* in *s*"
msgstr ""

#: ../../library/stdtypes.rst:1000
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""

#: ../../library/stdtypes.rst:1010
msgid ""
"Forward and reversed iterators over mutable sequences access values using an "
"index.  That index will continue to march forward (or backward) even if the "
"underlying sequence is mutated.  The iterator terminates only when an :exc:"
"`IndexError` or a :exc:`StopIteration` is encountered (or when the index "
"drops below zero)."
msgstr ""

#: ../../library/stdtypes.rst:1019
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""

#: ../../library/stdtypes.rst:1028
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""

#: ../../library/stdtypes.rst:1040
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""

#: ../../library/stdtypes.rst:1052
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr ""

#: ../../library/stdtypes.rst:1056
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""

#: ../../library/stdtypes.rst:1061
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""

#: ../../library/stdtypes.rst:1068
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""

#: ../../library/stdtypes.rst:1079
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""

#: ../../library/stdtypes.rst:1084
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""

#: ../../library/stdtypes.rst:1088
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""

#: ../../library/stdtypes.rst:1093
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""

#: ../../library/stdtypes.rst:1095
msgid "for other types, investigate the relevant class documentation"
msgstr ""

#: ../../library/stdtypes.rst:1099
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""

#: ../../library/stdtypes.rst:1104
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only "
"without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""

#: ../../library/stdtypes.rst:1115
msgid "Immutable Sequence Types"
msgstr ""

#: ../../library/stdtypes.rst:1122
msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr ""

#: ../../library/stdtypes.rst:1126
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr ""

#: ../../library/stdtypes.rst:1130
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""

#: ../../library/stdtypes.rst:1137
msgid "Mutable Sequence Types"
msgstr ""

#: ../../library/stdtypes.rst:1144
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""

#: ../../library/stdtypes.rst:1148
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""

#: ../../library/stdtypes.rst:1172
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../library/stdtypes.rst:1172
msgid "item *i* of *s* is replaced by *x*"
msgstr ""

#: ../../library/stdtypes.rst:1175
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../library/stdtypes.rst:1175
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""

#: ../../library/stdtypes.rst:1179
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../library/stdtypes.rst:1179
msgid "same as ``s[i:j] = []``"
msgstr ""

#: ../../library/stdtypes.rst:1181
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../library/stdtypes.rst:1181
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr ""

#: ../../library/stdtypes.rst:1184
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../library/stdtypes.rst:1184
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr ""

#: ../../library/stdtypes.rst:1187
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../../library/stdtypes.rst:1187
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr ""

#: ../../library/stdtypes.rst:1191
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../../library/stdtypes.rst:1191
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr ""

#: ../../library/stdtypes.rst:1194
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../../library/stdtypes.rst:1194
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr ""

#: ../../library/stdtypes.rst:1197
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` 或 ``s += t``"

#: ../../library/stdtypes.rst:1197
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr ""

#: ../../library/stdtypes.rst:1202
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../../library/stdtypes.rst:1202
msgid "updates *s* with its contents repeated *n* times"
msgstr ""

#: ../../library/stdtypes.rst:1205
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../../library/stdtypes.rst:1205
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr ""

#: ../../library/stdtypes.rst:1209
msgid "``s.pop()`` or ``s.pop(i)``"
msgstr "``s.pop()`` 或 ``s.pop(i)``"

#: ../../library/stdtypes.rst:1209
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr ""

#: ../../library/stdtypes.rst:1212
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../library/stdtypes.rst:1212
msgid "removes the first item from *s* where ``s[i]`` is equal to *x*"
msgstr ""

#: ../../library/stdtypes.rst:1216
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../library/stdtypes.rst:1216
msgid "reverses the items of *s* in place"
msgstr ""

#: ../../library/stdtypes.rst:1224
msgid ""
"If *k* is not equal to ``1``, *t* must have the same length as the slice it "
"is replacing."
msgstr ""

#: ../../library/stdtypes.rst:1227
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""

#: ../../library/stdtypes.rst:1231
msgid ":meth:`remove` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ""

#: ../../library/stdtypes.rst:1234
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""

#: ../../library/stdtypes.rst:1239
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such "
"as :class:`dict` and :class:`set`). :meth:`!copy` is not part of the :class:"
"`collections.abc.MutableSequence` ABC, but most concrete mutable sequence "
"classes provide it."
msgstr ""

#: ../../library/stdtypes.rst:1245
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr ""

#: ../../library/stdtypes.rst:1249
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""

#: ../../library/stdtypes.rst:1258
msgid "Lists"
msgstr "List（串列）"

#: ../../library/stdtypes.rst:1262
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""

#: ../../library/stdtypes.rst:1268
msgid "Lists may be constructed in several ways:"
msgstr ""

#: ../../library/stdtypes.rst:1270
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr ""

#: ../../library/stdtypes.rst:1271
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""

#: ../../library/stdtypes.rst:1272
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr ""

#: ../../library/stdtypes.rst:1273
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr ""

#: ../../library/stdtypes.rst:1275
msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""

#: ../../library/stdtypes.rst:1284
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr ""

#: ../../library/stdtypes.rst:1287
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""

#: ../../library/stdtypes.rst:1293
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""

#: ../../library/stdtypes.rst:1298
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""

#: ../../library/stdtypes.rst:1301
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""

#: ../../library/stdtypes.rst:1308
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""

#: ../../library/stdtypes.rst:1311
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""

#: ../../library/stdtypes.rst:1314
msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""

#: ../../library/stdtypes.rst:1319
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""

#: ../../library/stdtypes.rst:1324
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""

#: ../../library/stdtypes.rst:1328
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""

#: ../../library/stdtypes.rst:1337
msgid "Tuples"
msgstr ""

#: ../../library/stdtypes.rst:1341
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""

#: ../../library/stdtypes.rst:1349
msgid "Tuples may be constructed in a number of ways:"
msgstr ""

#: ../../library/stdtypes.rst:1351
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr ""

#: ../../library/stdtypes.rst:1352
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr ""

#: ../../library/stdtypes.rst:1353
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr ""

#: ../../library/stdtypes.rst:1354
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr ""

#: ../../library/stdtypes.rst:1356
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""

#: ../../library/stdtypes.rst:1364
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""

#: ../../library/stdtypes.rst:1370
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""

#: ../../library/stdtypes.rst:1373
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""

#: ../../library/stdtypes.rst:1381
msgid "Ranges"
msgstr ""

#: ../../library/stdtypes.rst:1385
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""

#: ../../library/stdtypes.rst:1392
msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the :meth:`~object.__index__` "
"special method).  If the *step* argument is omitted, it defaults to ``1``. "
"If the *start* argument is omitted, it defaults to ``0``. If *step* is "
"zero, :exc:`ValueError` is raised."
msgstr ""

#: ../../library/stdtypes.rst:1398
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""

#: ../../library/stdtypes.rst:1402
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""

#: ../../library/stdtypes.rst:1406
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""

#: ../../library/stdtypes.rst:1411
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""

#: ../../library/stdtypes.rst:1415
msgid "Range examples::"
msgstr ""

#: ../../library/stdtypes.rst:1432
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""

#: ../../library/stdtypes.rst:1439
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr ""

#: ../../library/stdtypes.rst:1444
msgid "The value of the *stop* parameter"
msgstr ""

#: ../../library/stdtypes.rst:1448
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr ""

#: ../../library/stdtypes.rst:1451
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""

#: ../../library/stdtypes.rst:1457
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""

#: ../../library/stdtypes.rst:1477
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""

#: ../../library/stdtypes.rst:1484
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""

#: ../../library/stdtypes.rst:1490
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""

#: ../../library/stdtypes.rst:1495
msgid ""
"Added the :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""

#: ../../library/stdtypes.rst:1500
msgid ""
"The `linspace recipe <https://code.activestate.com/recipes/579000-equally-"
"spaced-numbers-linspace/>`_ shows how to implement a lazy version of range "
"suitable for floating-point applications."
msgstr ""

#: ../../library/stdtypes.rst:1512
msgid "Text Sequence Type --- :class:`str`"
msgstr ""

#: ../../library/stdtypes.rst:1514
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""

#: ../../library/stdtypes.rst:1519
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr ""

#: ../../library/stdtypes.rst:1520
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``"
msgstr ""

#: ../../library/stdtypes.rst:1521
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"
msgstr ""

#: ../../library/stdtypes.rst:1523
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""

#: ../../library/stdtypes.rst:1526
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""

#: ../../library/stdtypes.rst:1530
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported :ref:`escape sequences <escape-sequences>`, and the "
"``r`` (\"raw\") prefix that disables most escape sequence processing."
msgstr ""

#: ../../library/stdtypes.rst:1534
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""

#: ../../library/stdtypes.rst:1537
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""

#: ../../library/stdtypes.rst:1543
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr ""

#: ../../library/stdtypes.rst:1547
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""

#: ../../library/stdtypes.rst:1559
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""

#: ../../library/stdtypes.rst:1563
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`type(object).__str__(object) <object.__str__>`, which is the \"informal\" "
"or nicely printable string representation of *object*.  For string objects, "
"this is the string itself.  If *object* does not have a :meth:`~object."
"__str__` method, then :func:`str` falls back to returning :func:"
"`repr(object) <repr>`."
msgstr ""

#: ../../library/stdtypes.rst:1575
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""

#: ../../library/stdtypes.rst:1584
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""

#: ../../library/stdtypes.rst:1592
msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""

#: ../../library/stdtypes.rst:1604
msgid "String Methods"
msgstr ""

#: ../../library/stdtypes.rst:1609
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""

#: ../../library/stdtypes.rst:1612
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""

#: ../../library/stdtypes.rst:1619
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""

#: ../../library/stdtypes.rst:1625
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""

#: ../../library/stdtypes.rst:1628
msgid ""
"The first character is now put into titlecase rather than uppercase. This "
"means that characters like digraphs will only have their first letter "
"capitalized, instead of the full character."
msgstr ""

#: ../../library/stdtypes.rst:1635
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""

#: ../../library/stdtypes.rst:1638
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""

#: ../../library/stdtypes.rst:1644
msgid ""
"The casefolding algorithm is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode15.0.0/ch03.pdf>`__."
msgstr ""

#: ../../library/stdtypes.rst:1653
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:1661
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""

#: ../../library/stdtypes.rst:1665
msgid ""
"If *sub* is empty, returns the number of empty strings between characters "
"which is the length of the string plus one."
msgstr ""

#: ../../library/stdtypes.rst:1671
msgid "Return the string encoded to :class:`bytes`."
msgstr ""

#: ../../library/stdtypes.rst:1673 ../../library/stdtypes.rst:2815
msgid ""
"*encoding* defaults to ``'utf-8'``; see :ref:`standard-encodings` for "
"possible values."
msgstr ""

#: ../../library/stdtypes.rst:1676
msgid ""
"*errors* controls how encoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` and any other name registered via :func:`codecs."
"register_error`. See :ref:`error-handlers` for details."
msgstr ""

#: ../../library/stdtypes.rst:1683
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless an encoding error actually occurs, :ref:`devmode` is enabled or a :"
"ref:`debug build <debug-build>` is used."
msgstr ""

#: ../../library/stdtypes.rst:1688 ../../library/stdtypes.rst:2834
msgid "Added support for keyword arguments."
msgstr "新增關鍵字引數的支援。"

#: ../../library/stdtypes.rst:1691 ../../library/stdtypes.rst:2837
msgid ""
"The value of the *errors* argument is now checked in :ref:`devmode` and in :"
"ref:`debug mode <debug-build>`."
msgstr ""

#: ../../library/stdtypes.rst:1698
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""

#: ../../library/stdtypes.rst:1706
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline "
"(``\\n``) or return (``\\r``), it is copied and the current column is reset "
"to zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed."
msgstr ""

#: ../../library/stdtypes.rst:1727
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""

#: ../../library/stdtypes.rst:1733
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""

#: ../../library/stdtypes.rst:1743
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""

#: ../../library/stdtypes.rst:1753
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""

#: ../../library/stdtypes.rst:1757
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to "
"the ``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` "
"fields of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, "
"and the ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  "
"This temporary change affects other threads."
msgstr ""

#: ../../library/stdtypes.rst:1766
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""

#: ../../library/stdtypes.rst:1774
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""

#: ../../library/stdtypes.rst:1790
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ""

#: ../../library/stdtypes.rst:1796
msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there "
"is at least one character, ``False`` otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""

#: ../../library/stdtypes.rst:1804
msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is "
"at least one character, ``False`` otherwise.  Alphabetic characters are "
"those characters defined in the Unicode character database as \"Letter\", i."
"e., those with general category property being one of \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", or \"Lo\".  Note that this is different from the `Alphabetic "
"property defined in the section 4.10 'Letters, Alphabetic, and Ideographic' "
"of the Unicode Standard <https://www.unicode.org/versions/Unicode15.0.0/ch04."
"pdf>`_."
msgstr ""

#: ../../library/stdtypes.rst:1815
msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range "
"U+0000-U+007F."
msgstr ""

#: ../../library/stdtypes.rst:1824
msgid ""
"Return ``True`` if all characters in the string are decimal characters and "
"there is at least one character, ``False`` otherwise. Decimal characters are "
"those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO.  Formally a decimal character is a character in the Unicode "
"General Category \"Nd\"."
msgstr ""

#: ../../library/stdtypes.rst:1834
msgid ""
"Return ``True`` if all characters in the string are digits and there is at "
"least one character, ``False`` otherwise.  Digits include decimal characters "
"and digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""

#: ../../library/stdtypes.rst:1844
msgid ""
"Return ``True`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`."
msgstr ""

#: ../../library/stdtypes.rst:1847
msgid ""
":func:`keyword.iskeyword` can be used to test whether string ``s`` is a "
"reserved identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""

#: ../../library/stdtypes.rst:1850
msgid "Example: ::"
msgstr "範例： ::"

#: ../../library/stdtypes.rst:1863
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1869
msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode numeric "
"value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""

#: ../../library/stdtypes.rst:1879
msgid ""
"Return ``True`` if all characters in the string are printable or the string "
"is empty, ``False`` otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling "
"of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""

#: ../../library/stdtypes.rst:1890
msgid ""
"Return ``True`` if there are only whitespace characters in the string and "
"there is at least one character, ``False`` otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1893
msgid ""
"A character is *whitespace* if in the Unicode character database (see :mod:"
"`unicodedata`), either its general category is ``Zs`` (\"Separator, "
"space\"), or its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""

#: ../../library/stdtypes.rst:1901
msgid ""
"Return ``True`` if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return ``False`` "
"otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1908
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1926
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""

#: ../../library/stdtypes.rst:1934
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:1941
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""

#: ../../library/stdtypes.rst:1944
msgid ""
"The lowercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode15.0.0/ch03.pdf>`__."
msgstr ""

#: ../../library/stdtypes.rst:1951
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""

#: ../../library/stdtypes.rst:1961
msgid ""
"See :meth:`str.removeprefix` for a method that will remove a single prefix "
"string rather than all of a set of characters.  For example::"
msgstr ""

#: ../../library/stdtypes.rst:1972
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""

#: ../../library/stdtypes.rst:1974
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""

#: ../../library/stdtypes.rst:1979
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to ``None`` in the result."
msgstr ""

#: ../../library/stdtypes.rst:1987
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""

#: ../../library/stdtypes.rst:1995
msgid ""
"If the string starts with the *prefix* string, return "
"``string[len(prefix):]``. Otherwise, return a copy of the original string::"
msgstr ""

#: ../../library/stdtypes.rst:2009
msgid ""
"If the string ends with the *suffix* string and that *suffix* is not empty, "
"return ``string[:-len(suffix)]``. Otherwise, return a copy of the original "
"string::"
msgstr ""

#: ../../library/stdtypes.rst:2023
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""

#: ../../library/stdtypes.rst:2030
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""

#: ../../library/stdtypes.rst:2037
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""

#: ../../library/stdtypes.rst:2043
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:2050
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""

#: ../../library/stdtypes.rst:2058
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""

#: ../../library/stdtypes.rst:2067
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""

#: ../../library/stdtypes.rst:2077
msgid ""
"See :meth:`str.removesuffix` for a method that will remove a single suffix "
"string rather than all of a set of characters.  For example::"
msgstr ""

#: ../../library/stdtypes.rst:2087
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""

#: ../../library/stdtypes.rst:2093
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"as a single delimiter (to split with multiple delimiters, use :func:`re."
"split`). Splitting an empty string with a specified separator returns "
"``['']``."
msgstr ""

#: ../../library/stdtypes.rst:2100 ../../library/stdtypes.rst:2118
#: ../../library/stdtypes.rst:2170 ../../library/stdtypes.rst:2238
#: ../../library/stdtypes.rst:2306 ../../library/stdtypes.rst:3152
#: ../../library/stdtypes.rst:3170 ../../library/stdtypes.rst:3261
#: ../../library/stdtypes.rst:3277 ../../library/stdtypes.rst:3302
#: ../../library/stdtypes.rst:3316 ../../library/stdtypes.rst:3344
#: ../../library/stdtypes.rst:3358 ../../library/stdtypes.rst:3376
#: ../../library/stdtypes.rst:3403 ../../library/stdtypes.rst:3426
#: ../../library/stdtypes.rst:3453 ../../library/stdtypes.rst:3495
#: ../../library/stdtypes.rst:3519
msgid "For example::"
msgstr "舉例來說： ::"

#: ../../library/stdtypes.rst:2111
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""

#: ../../library/stdtypes.rst:2133
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""

#: ../../library/stdtypes.rst:2137
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""

#: ../../library/stdtypes.rst:2141
msgid "Representation"
msgstr ""

#: ../../library/stdtypes.rst:2141
msgid "Description"
msgstr "描述"

#: ../../library/stdtypes.rst:2143
msgid "``\\n``"
msgstr "``\\n``"

#: ../../library/stdtypes.rst:2143
msgid "Line Feed"
msgstr ""

#: ../../library/stdtypes.rst:2145
msgid "``\\r``"
msgstr "``\\r``"

#: ../../library/stdtypes.rst:2145
msgid "Carriage Return"
msgstr ""

#: ../../library/stdtypes.rst:2147
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../../library/stdtypes.rst:2147
msgid "Carriage Return + Line Feed"
msgstr ""

#: ../../library/stdtypes.rst:2149
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` 或 ``\\x0b``"

#: ../../library/stdtypes.rst:2149
msgid "Line Tabulation"
msgstr ""

#: ../../library/stdtypes.rst:2151
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` 或 ``\\x0c``"

#: ../../library/stdtypes.rst:2151
msgid "Form Feed"
msgstr ""

#: ../../library/stdtypes.rst:2153
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../../library/stdtypes.rst:2153
msgid "File Separator"
msgstr ""

#: ../../library/stdtypes.rst:2155
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../../library/stdtypes.rst:2155
msgid "Group Separator"
msgstr ""

#: ../../library/stdtypes.rst:2157
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../../library/stdtypes.rst:2157
msgid "Record Separator"
msgstr ""

#: ../../library/stdtypes.rst:2159
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../../library/stdtypes.rst:2159
msgid "Next Line (C1 Control Code)"
msgstr ""

#: ../../library/stdtypes.rst:2161
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../../library/stdtypes.rst:2161
msgid "Line Separator"
msgstr ""

#: ../../library/stdtypes.rst:2163
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../../library/stdtypes.rst:2163
msgid "Paragraph Separator"
msgstr ""

#: ../../library/stdtypes.rst:2168
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr ""

#: ../../library/stdtypes.rst:2177
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""

#: ../../library/stdtypes.rst:2186
msgid "For comparison, ``split('\\n')`` gives::"
msgstr ""

#: ../../library/stdtypes.rst:2196
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""

#: ../../library/stdtypes.rst:2204
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""

#: ../../library/stdtypes.rst:2215
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""

#: ../../library/stdtypes.rst:2228
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr ""

#: ../../library/stdtypes.rst:2235
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""

#: ../../library/stdtypes.rst:2243 ../../library/stdtypes.rst:3463
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""

#: ../../library/stdtypes.rst:2251
msgid ""
"The :func:`string.capwords` function does not have this problem, as it "
"splits words on spaces only."
msgstr ""

#: ../../library/stdtypes.rst:2254
msgid ""
"Alternatively, a workaround for apostrophes can be constructed using regular "
"expressions::"
msgstr ""

#: ../../library/stdtypes.rst:2269
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`~object.__getitem__`, typically a :term:`mapping` or :"
"term:`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""

#: ../../library/stdtypes.rst:2278
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""

#: ../../library/stdtypes.rst:2281
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""

#: ../../library/stdtypes.rst:2287
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""

#: ../../library/stdtypes.rst:2293
msgid ""
"The uppercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode15.0.0/ch03.pdf>`__."
msgstr ""

#: ../../library/stdtypes.rst:2300
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:2318
msgid "``printf``-style String Formatting"
msgstr ""

#: ../../library/stdtypes.rst:2331
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives "
"provides their own trade-offs and benefits of simplicity, flexibility, and/"
"or extensibility."
msgstr ""

#: ../../library/stdtypes.rst:2339
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""

#: ../../library/stdtypes.rst:2345
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""

#: ../../library/stdtypes.rst:2355 ../../library/stdtypes.rst:3574
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""

#: ../../library/stdtypes.rst:2358 ../../library/stdtypes.rst:3577
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr ""

#: ../../library/stdtypes.rst:2360 ../../library/stdtypes.rst:3579
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""

#: ../../library/stdtypes.rst:2363 ../../library/stdtypes.rst:3582
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""

#: ../../library/stdtypes.rst:2366 ../../library/stdtypes.rst:3585
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""

#: ../../library/stdtypes.rst:2370 ../../library/stdtypes.rst:3589
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""

#: ../../library/stdtypes.rst:2375 ../../library/stdtypes.rst:3594
msgid "Length modifier (optional)."
msgstr ""

#: ../../library/stdtypes.rst:2377 ../../library/stdtypes.rst:3596
msgid "Conversion type."
msgstr ""

#: ../../library/stdtypes.rst:2379
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""

#: ../../library/stdtypes.rst:2388 ../../library/stdtypes.rst:3607
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""

#: ../../library/stdtypes.rst:2391 ../../library/stdtypes.rst:3610
msgid "The conversion flag characters are:"
msgstr ""

#: ../../library/stdtypes.rst:2400 ../../library/stdtypes.rst:3619
msgid "Flag"
msgstr ""

#: ../../library/stdtypes.rst:2402 ../../library/stdtypes.rst:3621
msgid "``'#'``"
msgstr "``'#'``"

#: ../../library/stdtypes.rst:2402 ../../library/stdtypes.rst:3621
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""

#: ../../library/stdtypes.rst:2405 ../../library/stdtypes.rst:3624
msgid "``'0'``"
msgstr "``'0'``"

#: ../../library/stdtypes.rst:2405 ../../library/stdtypes.rst:3624
msgid "The conversion will be zero padded for numeric values."
msgstr ""

#: ../../library/stdtypes.rst:2407 ../../library/stdtypes.rst:3626
msgid "``'-'``"
msgstr "``'-'``"

#: ../../library/stdtypes.rst:2407 ../../library/stdtypes.rst:3626
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""

#: ../../library/stdtypes.rst:2410 ../../library/stdtypes.rst:3629
msgid "``' '``"
msgstr "``' '``"

#: ../../library/stdtypes.rst:2410 ../../library/stdtypes.rst:3629
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""

#: ../../library/stdtypes.rst:2413 ../../library/stdtypes.rst:3632
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/stdtypes.rst:2413 ../../library/stdtypes.rst:3632
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""

#: ../../library/stdtypes.rst:2417 ../../library/stdtypes.rst:3636
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""

#: ../../library/stdtypes.rst:2420 ../../library/stdtypes.rst:3639
msgid "The conversion types are:"
msgstr ""

#: ../../library/stdtypes.rst:2423 ../../library/stdtypes.rst:3642
msgid "Conversion"
msgstr ""

#: ../../library/stdtypes.rst:2425 ../../library/stdtypes.rst:3644
msgid "``'d'``"
msgstr "``'d'``"

#: ../../library/stdtypes.rst:2425 ../../library/stdtypes.rst:2427
#: ../../library/stdtypes.rst:3644 ../../library/stdtypes.rst:3646
msgid "Signed integer decimal."
msgstr ""

#: ../../library/stdtypes.rst:2427 ../../library/stdtypes.rst:3646
msgid "``'i'``"
msgstr "``'i'``"

#: ../../library/stdtypes.rst:2429 ../../library/stdtypes.rst:3648
msgid "``'o'``"
msgstr "``'o'``"

#: ../../library/stdtypes.rst:2429 ../../library/stdtypes.rst:3648
msgid "Signed octal value."
msgstr ""

#: ../../library/stdtypes.rst:2431 ../../library/stdtypes.rst:3650
msgid "``'u'``"
msgstr "``'u'``"

#: ../../library/stdtypes.rst:2431 ../../library/stdtypes.rst:3650
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr ""

#: ../../library/stdtypes.rst:2433 ../../library/stdtypes.rst:3652
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/stdtypes.rst:2433 ../../library/stdtypes.rst:3652
msgid "Signed hexadecimal (lowercase)."
msgstr ""

#: ../../library/stdtypes.rst:2435 ../../library/stdtypes.rst:3654
msgid "``'X'``"
msgstr "``'X'``"

#: ../../library/stdtypes.rst:2435 ../../library/stdtypes.rst:3654
msgid "Signed hexadecimal (uppercase)."
msgstr ""

#: ../../library/stdtypes.rst:2437 ../../library/stdtypes.rst:3656
msgid "``'e'``"
msgstr "``'e'``"

#: ../../library/stdtypes.rst:2437 ../../library/stdtypes.rst:3656
msgid "Floating-point exponential format (lowercase)."
msgstr ""

#: ../../library/stdtypes.rst:2439 ../../library/stdtypes.rst:3658
msgid "``'E'``"
msgstr "``'E'``"

#: ../../library/stdtypes.rst:2439 ../../library/stdtypes.rst:3658
msgid "Floating-point exponential format (uppercase)."
msgstr ""

#: ../../library/stdtypes.rst:2441 ../../library/stdtypes.rst:3660
msgid "``'f'``"
msgstr "``'f'``"

#: ../../library/stdtypes.rst:2441 ../../library/stdtypes.rst:2443
#: ../../library/stdtypes.rst:3660 ../../library/stdtypes.rst:3662
msgid "Floating-point decimal format."
msgstr ""

#: ../../library/stdtypes.rst:2443 ../../library/stdtypes.rst:3662
msgid "``'F'``"
msgstr "``'F'``"

#: ../../library/stdtypes.rst:2445 ../../library/stdtypes.rst:3664
msgid "``'g'``"
msgstr "``'g'``"

#: ../../library/stdtypes.rst:2445 ../../library/stdtypes.rst:3664
msgid ""
"Floating-point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""

#: ../../library/stdtypes.rst:2449 ../../library/stdtypes.rst:3668
msgid "``'G'``"
msgstr "``'G'``"

#: ../../library/stdtypes.rst:2449 ../../library/stdtypes.rst:3668
msgid ""
"Floating-point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""

#: ../../library/stdtypes.rst:2453 ../../library/stdtypes.rst:3672
msgid "``'c'``"
msgstr "``'c'``"

#: ../../library/stdtypes.rst:2453
msgid "Single character (accepts integer or single character string)."
msgstr ""

#: ../../library/stdtypes.rst:2456 ../../library/stdtypes.rst:3685
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/stdtypes.rst:2456
msgid "String (converts any Python object using :func:`repr`)."
msgstr ""

#: ../../library/stdtypes.rst:2459 ../../library/stdtypes.rst:3679
msgid "``'s'``"
msgstr "``'s'``"

#: ../../library/stdtypes.rst:2459
msgid "String (converts any Python object using :func:`str`)."
msgstr ""

#: ../../library/stdtypes.rst:2462 ../../library/stdtypes.rst:3682
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/stdtypes.rst:2462
msgid "String (converts any Python object using :func:`ascii`)."
msgstr ""

#: ../../library/stdtypes.rst:2465 ../../library/stdtypes.rst:3688
msgid "``'%'``"
msgstr "``'%'``"

#: ../../library/stdtypes.rst:2465 ../../library/stdtypes.rst:3688
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""

#: ../../library/stdtypes.rst:2472 ../../library/stdtypes.rst:3695
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""

#: ../../library/stdtypes.rst:2476 ../../library/stdtypes.rst:3699
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""

#: ../../library/stdtypes.rst:2480 ../../library/stdtypes.rst:3703
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""

#: ../../library/stdtypes.rst:2483 ../../library/stdtypes.rst:3706
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""

#: ../../library/stdtypes.rst:2487 ../../library/stdtypes.rst:3710
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""

#: ../../library/stdtypes.rst:2490 ../../library/stdtypes.rst:3713
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""

#: ../../library/stdtypes.rst:2494 ../../library/stdtypes.rst:3717
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr ""

#: ../../library/stdtypes.rst:2497 ../../library/stdtypes.rst:3726
msgid "See :pep:`237`."
msgstr "參閱 :pep:`237`。"

#: ../../library/stdtypes.rst:2499
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""

#: ../../library/stdtypes.rst:2504
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""

#: ../../library/stdtypes.rst:2515
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr ""

#: ../../library/stdtypes.rst:2523
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""

#: ../../library/stdtypes.rst:2528
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""

#: ../../library/stdtypes.rst:2534
msgid "Bytes Objects"
msgstr ""

#: ../../library/stdtypes.rst:2538
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""

#: ../../library/stdtypes.rst:2545
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""

#: ../../library/stdtypes.rst:2548
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr ""

#: ../../library/stdtypes.rst:2549
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``"
msgstr ""

#: ../../library/stdtypes.rst:2550
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""

#: ../../library/stdtypes.rst:2552
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""

#: ../../library/stdtypes.rst:2556
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""

#: ../../library/stdtypes.rst:2560
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""

#: ../../library/stdtypes.rst:2570
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr ""

#: ../../library/stdtypes.rst:2573
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr ""

#: ../../library/stdtypes.rst:2574
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr ""

#: ../../library/stdtypes.rst:2575
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""

#: ../../library/stdtypes.rst:2577
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr ""

#: ../../library/stdtypes.rst:2579
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""

#: ../../library/stdtypes.rst:2585
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""

#: ../../library/stdtypes.rst:2592
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""

#: ../../library/stdtypes.rst:2596
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""

#: ../../library/stdtypes.rst:2601 ../../library/stdtypes.rst:2686
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""

#: ../../library/stdtypes.rst:2607
msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default, "
"this separator will be included between each byte. A second optional "
"*bytes_per_sep* parameter controls the spacing. Positive values calculate "
"the separator position from the right, negative values from the left."
msgstr ""

#: ../../library/stdtypes.rst:2624
msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters "
"to insert separators between bytes in the hex output."
msgstr ""

#: ../../library/stdtypes.rst:2628
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""

#: ../../library/stdtypes.rst:2633
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""

#: ../../library/stdtypes.rst:2641
msgid "Bytearray Objects"
msgstr ""

#: ../../library/stdtypes.rst:2645
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""

#: ../../library/stdtypes.rst:2650
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""

#: ../../library/stdtypes.rst:2653
msgid "Creating an empty instance: ``bytearray()``"
msgstr ""

#: ../../library/stdtypes.rst:2654
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr ""

#: ../../library/stdtypes.rst:2655
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr ""

#: ../../library/stdtypes.rst:2656
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""

#: ../../library/stdtypes.rst:2658
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""

#: ../../library/stdtypes.rst:2662
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr ""

#: ../../library/stdtypes.rst:2664
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""

#: ../../library/stdtypes.rst:2670
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""

#: ../../library/stdtypes.rst:2677
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""

#: ../../library/stdtypes.rst:2681
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""

#: ../../library/stdtypes.rst:2694
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`bytearray.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""

#: ../../library/stdtypes.rst:2699
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""

#: ../../library/stdtypes.rst:2704
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""

#: ../../library/stdtypes.rst:2713
msgid "Bytes and Bytearray Operations"
msgstr ""

#: ../../library/stdtypes.rst:2718
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""

#: ../../library/stdtypes.rst:2726
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""

#: ../../library/stdtypes.rst:2733
msgid "and::"
msgstr "和： ::"

#: ../../library/stdtypes.rst:2738
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""

#: ../../library/stdtypes.rst:2743
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""

#: ../../library/stdtypes.rst:2746
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""

#: ../../library/stdtypes.rst:2752
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""

#: ../../library/stdtypes.rst:2756 ../../library/stdtypes.rst:2861
#: ../../library/stdtypes.rst:2883 ../../library/stdtypes.rst:2949
#: ../../library/stdtypes.rst:2962
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""

#: ../../library/stdtypes.rst:2759
msgid ""
"If *sub* is empty, returns the number of empty slices between characters "
"which is the length of the bytes object plus one."
msgstr ""

#: ../../library/stdtypes.rst:2762 ../../library/stdtypes.rst:2873
#: ../../library/stdtypes.rst:2886 ../../library/stdtypes.rst:2952
#: ../../library/stdtypes.rst:2965
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr ""

#: ../../library/stdtypes.rst:2769
msgid ""
"If the binary data starts with the *prefix* string, return "
"``bytes[len(prefix):]``. Otherwise, return a copy of the original binary "
"data::"
msgstr ""

#: ../../library/stdtypes.rst:2778
msgid "The *prefix* may be any :term:`bytes-like object`."
msgstr ""

#: ../../library/stdtypes.rst:2782 ../../library/stdtypes.rst:2804
#: ../../library/stdtypes.rst:2937 ../../library/stdtypes.rst:3030
#: ../../library/stdtypes.rst:3044 ../../library/stdtypes.rst:3075
#: ../../library/stdtypes.rst:3089 ../../library/stdtypes.rst:3131
#: ../../library/stdtypes.rst:3202 ../../library/stdtypes.rst:3220
#: ../../library/stdtypes.rst:3248 ../../library/stdtypes.rst:3387
#: ../../library/stdtypes.rst:3442 ../../library/stdtypes.rst:3485
#: ../../library/stdtypes.rst:3506 ../../library/stdtypes.rst:3528
#: ../../library/stdtypes.rst:3730
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""

#: ../../library/stdtypes.rst:2791
msgid ""
"If the binary data ends with the *suffix* string and that *suffix* is not "
"empty, return ``bytes[:-len(suffix)]``.  Otherwise, return a copy of the "
"original binary data::"
msgstr ""

#: ../../library/stdtypes.rst:2800
msgid "The *suffix* may be any :term:`bytes-like object`."
msgstr ""

#: ../../library/stdtypes.rst:2813
msgid "Return the bytes decoded to a :class:`str`."
msgstr ""

#: ../../library/stdtypes.rst:2818
msgid ""
"*errors* controls how decoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, and any other name registered via :func:"
"`codecs.register_error`. See :ref:`error-handlers` for details."
msgstr ""

#: ../../library/stdtypes.rst:2824
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless a decoding error actually occurs, :ref:`devmode` is enabled or a :ref:"
"`debug build <debug-build>` is used."
msgstr ""

#: ../../library/stdtypes.rst:2830
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary :class:`!"
"bytes` or :class:`!bytearray` object."
msgstr ""

#: ../../library/stdtypes.rst:2845
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""

#: ../../library/stdtypes.rst:2850
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr ""

#: ../../library/stdtypes.rst:2856
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""

#: ../../library/stdtypes.rst:2866
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""

#: ../../library/stdtypes.rst:2880
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""

#: ../../library/stdtypes.rst:2893
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""

#: ../../library/stdtypes.rst:2904
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""

#: ../../library/stdtypes.rst:2915
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed "
"by two empty bytes or bytearray objects."
msgstr ""

#: ../../library/stdtypes.rst:2922 ../../library/stdtypes.rst:2979
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr ""

#: ../../library/stdtypes.rst:2928
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""

#: ../../library/stdtypes.rst:2932
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""

#: ../../library/stdtypes.rst:2944
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""

#: ../../library/stdtypes.rst:2959
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""

#: ../../library/stdtypes.rst:2972
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""

#: ../../library/stdtypes.rst:2985
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""

#: ../../library/stdtypes.rst:2990
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr ""

#: ../../library/stdtypes.rst:2996
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""

#: ../../library/stdtypes.rst:3001
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""

#: ../../library/stdtypes.rst:3004
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""

#: ../../library/stdtypes.rst:3010
msgid "*delete* is now supported as a keyword argument."
msgstr ""

#: ../../library/stdtypes.rst:3014
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""

#: ../../library/stdtypes.rst:3023
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:3037
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:3051
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""

#: ../../library/stdtypes.rst:3063
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removeprefix` for a method that will remove a "
"single prefix string rather than all of a set of characters.  For example::"
msgstr ""

#: ../../library/stdtypes.rst:3082
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:3096
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""

#: ../../library/stdtypes.rst:3107
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""

#: ../../library/stdtypes.rst:3119
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removesuffix` for a method that will remove a "
"single suffix string rather than all of a set of characters.  For example::"
msgstr ""

#: ../../library/stdtypes.rst:3138
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""

#: ../../library/stdtypes.rst:3144
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence as a single delimiter. Splitting an empty sequence with a "
"specified separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on "
"the type of object being split.  The *sep* argument may be any :term:`bytes-"
"like object`."
msgstr ""

#: ../../library/stdtypes.rst:3163
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""

#: ../../library/stdtypes.rst:3184
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""

#: ../../library/stdtypes.rst:3197
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""

#: ../../library/stdtypes.rst:3206
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""

#: ../../library/stdtypes.rst:3214
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr ""

#: ../../library/stdtypes.rst:3227
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""

#: ../../library/stdtypes.rst:3255
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, ``False`` "
"otherwise. Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""

#: ../../library/stdtypes.rst:3272
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters "
"and the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""

#: ../../library/stdtypes.rst:3288
msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are "
"ASCII, ``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""

#: ../../library/stdtypes.rst:3298
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and "
"the sequence is not empty, ``False`` otherwise. ASCII decimal digits are "
"those byte values in the sequence ``b'0123456789'``."
msgstr ""

#: ../../library/stdtypes.rst:3313
msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr ""

#: ../../library/stdtypes.rst:3323 ../../library/stdtypes.rst:3365
#: ../../library/stdtypes.rst:3381 ../../library/stdtypes.rst:3431
#: ../../library/stdtypes.rst:3500
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""

#: ../../library/stdtypes.rst:3331
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""

#: ../../library/stdtypes.rst:3340
msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""

#: ../../library/stdtypes.rst:3355
msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII "
"character in the sequence and no lowercase ASCII characters, ``False`` "
"otherwise."
msgstr ""

#: ../../library/stdtypes.rst:3373
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""

#: ../../library/stdtypes.rst:3398
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""

#: ../../library/stdtypes.rst:3410
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""

#: ../../library/stdtypes.rst:3423
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""

#: ../../library/stdtypes.rst:3435
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""

#: ../../library/stdtypes.rst:3449
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""

#: ../../library/stdtypes.rst:3458
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""

#: ../../library/stdtypes.rst:3471
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""

#: ../../library/stdtypes.rst:3492
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""

#: ../../library/stdtypes.rst:3513
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""

#: ../../library/stdtypes.rst:3535
msgid "``printf``-style Bytes Formatting"
msgstr ""

#: ../../library/stdtypes.rst:3552
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""

#: ../../library/stdtypes.rst:3557
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""

#: ../../library/stdtypes.rst:3564
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""

#: ../../library/stdtypes.rst:3598
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""

#: ../../library/stdtypes.rst:3672
msgid "Single byte (accepts integer or single byte objects)."
msgstr ""

#: ../../library/stdtypes.rst:3675
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/stdtypes.rst:3675
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`~object.__bytes__`)."
msgstr ""

#: ../../library/stdtypes.rst:3679
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""

#: ../../library/stdtypes.rst:3682
msgid ""
"Bytes (converts any Python object using ``repr(obj).encode('ascii', "
"'backslashreplace')``)."
msgstr ""

#: ../../library/stdtypes.rst:3685
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""

#: ../../library/stdtypes.rst:3685
msgid "\\(7)"
msgstr "\\(7)"

#: ../../library/stdtypes.rst:3720
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr ""

#: ../../library/stdtypes.rst:3723
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr ""

#: ../../library/stdtypes.rst:3735
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ""

#: ../../library/stdtypes.rst:3742
msgid "Memory Views"
msgstr ""

#: ../../library/stdtypes.rst:3744
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""

#: ../../library/stdtypes.rst:3750
msgid ""
"Create a :class:`memoryview` that references *object*.  *object* must "
"support the buffer protocol.  Built-in objects that support the buffer "
"protocol include :class:`bytes` and :class:`bytearray`."
msgstr ""

#: ../../library/stdtypes.rst:3754
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating *object*.  For many simple types such "
"as :class:`bytes` and :class:`bytearray`, an element is a single byte, but "
"other types such as :class:`array.array` may have bigger elements."
msgstr ""

#: ../../library/stdtypes.rst:3759
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`, which "
"is the nested list representation of the view. If ``view.ndim = 1``, this is "
"equal to the number of elements in the view."
msgstr ""

#: ../../library/stdtypes.rst:3763
msgid ""
"If ``view.ndim == 0``, ``len(view)`` now raises :exc:`TypeError` instead of "
"returning 1."
msgstr ""

#: ../../library/stdtypes.rst:3766
msgid ""
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""

#: ../../library/stdtypes.rst:3769
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""

#: ../../library/stdtypes.rst:3782
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""

#: ../../library/stdtypes.rst:3791
msgid "Here is an example with a non-byte format::"
msgstr ""

#: ../../library/stdtypes.rst:3803
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""

#: ../../library/stdtypes.rst:3824
msgid ""
"One-dimensional memoryviews of :term:`hashable` (read-only) types with "
"formats 'B', 'b' or 'c' are also hashable. The hash is defined as ``hash(m) "
"== hash(m.tobytes())``::"
msgstr ""

#: ../../library/stdtypes.rst:3836
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now :term:`hashable`."
msgstr ""

#: ../../library/stdtypes.rst:3840
msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr ""

#: ../../library/stdtypes.rst:3844
msgid "memoryviews can now be indexed with tuple of integers."
msgstr ""

#: ../../library/stdtypes.rst:3847
msgid ":class:`memoryview` has several methods:"
msgstr ""

#: ../../library/stdtypes.rst:3851
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""

#: ../../library/stdtypes.rst:3855
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""

#: ../../library/stdtypes.rst:3874
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""

#: ../../library/stdtypes.rst:3890
msgid ""
"Note that, as with floating-point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""

#: ../../library/stdtypes.rst:3893
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""

#: ../../library/stdtypes.rst:3899
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""

#: ../../library/stdtypes.rst:3908
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""

#: ../../library/stdtypes.rst:3913
msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the "
"original array is converted to C or Fortran order. For contiguous views, 'A' "
"returns an exact copy of the physical memory. In particular, in-memory "
"Fortran order is preserved. For non-contiguous views, the data is converted "
"to C first. *order=None* is the same as *order='C'*."
msgstr ""

#: ../../library/stdtypes.rst:3922
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr ""

#: ../../library/stdtypes.rst:3931
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`memoryview.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""

#: ../../library/stdtypes.rst:3938
msgid "Return the data in the buffer as a list of elements. ::"
msgstr ""

#: ../../library/stdtypes.rst:3948
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ""

#: ../../library/stdtypes.rst:3955
msgid ""
"Return a readonly version of the memoryview object.  The original memoryview "
"object is unchanged. ::"
msgstr ""

#: ../../library/stdtypes.rst:3974
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""

#: ../../library/stdtypes.rst:3980
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""

#: ../../library/stdtypes.rst:3991
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""

#: ../../library/stdtypes.rst:4007
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""

#: ../../library/stdtypes.rst:4013
msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length. "
"Note that all byte lengths may depend on the operating system."
msgstr ""

#: ../../library/stdtypes.rst:4019
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr ""

#: ../../library/stdtypes.rst:4042
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr ""

#: ../../library/stdtypes.rst:4055
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr ""

#: ../../library/stdtypes.rst:4081
msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr ""

#: ../../library/stdtypes.rst:4095
msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""

#: ../../library/stdtypes.rst:4098
msgid "There are also several readonly attributes available:"
msgstr ""

#: ../../library/stdtypes.rst:4102
msgid "The underlying object of the memoryview::"
msgstr ""

#: ../../library/stdtypes.rst:4113
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""

#: ../../library/stdtypes.rst:4132
msgid "Multi-dimensional arrays::"
msgstr ""

#: ../../library/stdtypes.rst:4149
msgid "A bool indicating whether the memory is read only."
msgstr ""

#: ../../library/stdtypes.rst:4153
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""

#: ../../library/stdtypes.rst:4158
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""

#: ../../library/stdtypes.rst:4164
msgid "The size in bytes of each element of the memoryview::"
msgstr ""

#: ../../library/stdtypes.rst:4177
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""

#: ../../library/stdtypes.rst:4182
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""

#: ../../library/stdtypes.rst:4185 ../../library/stdtypes.rst:4193
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr ""

#: ../../library/stdtypes.rst:4190
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""

#: ../../library/stdtypes.rst:4198
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr ""

#: ../../library/stdtypes.rst:4202
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr ""

#: ../../library/stdtypes.rst:4208
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr ""

#: ../../library/stdtypes.rst:4214
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr ""

#: ../../library/stdtypes.rst:4222
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr ""

#: ../../library/stdtypes.rst:4226
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""

#: ../../library/stdtypes.rst:4233
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""

#: ../../library/stdtypes.rst:4238
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""

#: ../../library/stdtypes.rst:4246
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""

#: ../../library/stdtypes.rst:4250
msgid "The constructors for both classes work the same:"
msgstr ""

#: ../../library/stdtypes.rst:4255
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""

#: ../../library/stdtypes.rst:4261
msgid "Sets can be created by several means:"
msgstr ""

#: ../../library/stdtypes.rst:4263
msgid ""
"Use a comma-separated list of elements within braces: ``{'jack', 'sjoerd'}``"
msgstr ""

#: ../../library/stdtypes.rst:4264
msgid ""
"Use a set comprehension: ``{c for c in 'abracadabra' if c not in 'abc'}``"
msgstr ""

#: ../../library/stdtypes.rst:4265
msgid ""
"Use the type constructor: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"
msgstr ""

#: ../../library/stdtypes.rst:4267
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""

#: ../../library/stdtypes.rst:4272
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr ""

#: ../../library/stdtypes.rst:4276
msgid "Test *x* for membership in *s*."
msgstr ""

#: ../../library/stdtypes.rst:4280
msgid "Test *x* for non-membership in *s*."
msgstr ""

#: ../../library/stdtypes.rst:4284
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""

#: ../../library/stdtypes.rst:4290
msgid "Test whether every element in the set is in *other*."
msgstr ""

#: ../../library/stdtypes.rst:4294
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""

#: ../../library/stdtypes.rst:4300
msgid "Test whether every element in *other* is in the set."
msgstr ""

#: ../../library/stdtypes.rst:4304
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""

#: ../../library/stdtypes.rst:4310
msgid "Return a new set with elements from the set and all others."
msgstr ""

#: ../../library/stdtypes.rst:4315
msgid "Return a new set with elements common to the set and all others."
msgstr ""

#: ../../library/stdtypes.rst:4320
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""

#: ../../library/stdtypes.rst:4325
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""

#: ../../library/stdtypes.rst:4329
msgid "Return a shallow copy of the set."
msgstr ""

#: ../../library/stdtypes.rst:4332
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, :meth:`symmetric_difference`, :meth:`issubset`, and :meth:"
"`issuperset` methods will accept any iterable as an argument.  In contrast, "
"their operator based counterparts require their arguments to be sets.  This "
"precludes error-prone constructions like ``set('abc') & 'cbs'`` in favor of "
"the more readable ``set('abc').intersection('cbs')``."
msgstr ""

#: ../../library/stdtypes.rst:4339
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""

#: ../../library/stdtypes.rst:4346
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""

#: ../../library/stdtypes.rst:4350
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""

#: ../../library/stdtypes.rst:4355
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""

#: ../../library/stdtypes.rst:4358
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""

#: ../../library/stdtypes.rst:4360
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""

#: ../../library/stdtypes.rst:4364
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""

#: ../../library/stdtypes.rst:4370
msgid "Update the set, adding elements from all others."
msgstr ""

#: ../../library/stdtypes.rst:4375
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""

#: ../../library/stdtypes.rst:4380
msgid "Update the set, removing elements found in others."
msgstr ""

#: ../../library/stdtypes.rst:4385
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""

#: ../../library/stdtypes.rst:4389
msgid "Add element *elem* to the set."
msgstr ""

#: ../../library/stdtypes.rst:4393
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""

#: ../../library/stdtypes.rst:4398
msgid "Remove element *elem* from the set if it is present."
msgstr ""

#: ../../library/stdtypes.rst:4402
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""

#: ../../library/stdtypes.rst:4407
msgid "Remove all elements from the set."
msgstr ""

#: ../../library/stdtypes.rst:4410
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""

#: ../../library/stdtypes.rst:4415
msgid ""
"Note, the *elem* argument to the :meth:`~object.__contains__`, :meth:"
"`remove`, and :meth:`discard` methods may be a set.  To support searching "
"for an equivalent frozenset, a temporary one is created from *elem*."
msgstr ""

#: ../../library/stdtypes.rst:4424
msgid "Mapping Types --- :class:`dict`"
msgstr ""

#: ../../library/stdtypes.rst:4434
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""

#: ../../library/stdtypes.rst:4440
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys. Values that compare equal (such as ``1``, ``1.0``, "
"and ``True``) can be used interchangeably to index the same dictionary entry."
msgstr ""

#: ../../library/stdtypes.rst:4451
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""

#: ../../library/stdtypes.rst:4454
msgid "Dictionaries can be created by several means:"
msgstr ""

#: ../../library/stdtypes.rst:4456
msgid ""
"Use a comma-separated list of ``key: value`` pairs within braces: ``{'jack': "
"4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``"
msgstr ""

#: ../../library/stdtypes.rst:4458
msgid "Use a dict comprehension: ``{}``, ``{x: x ** 2 for x in range(10)}``"
msgstr ""

#: ../../library/stdtypes.rst:4459
msgid ""
"Use the type constructor: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"
msgstr ""

#: ../../library/stdtypes.rst:4462
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the "
"positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""

#: ../../library/stdtypes.rst:4472
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""

#: ../../library/stdtypes.rst:4477
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""

#: ../../library/stdtypes.rst:4489
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""

#: ../../library/stdtypes.rst:4493
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""

#: ../../library/stdtypes.rst:4498
msgid "Return a list of all the keys used in the dictionary *d*."
msgstr ""

#: ../../library/stdtypes.rst:4502
msgid "Return the number of items in the dictionary *d*."
msgstr ""

#: ../../library/stdtypes.rst:4506
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""

#: ../../library/stdtypes.rst:4511
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""

#: ../../library/stdtypes.rst:4530
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""

#: ../../library/stdtypes.rst:4536
msgid "Set ``d[key]`` to *value*."
msgstr ""

#: ../../library/stdtypes.rst:4540
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""

#: ../../library/stdtypes.rst:4545
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr ""

#: ../../library/stdtypes.rst:4549
msgid "Equivalent to ``not key in d``."
msgstr ""

#: ../../library/stdtypes.rst:4553
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""

#: ../../library/stdtypes.rst:4558
msgid "Remove all items from the dictionary."
msgstr ""

#: ../../library/stdtypes.rst:4562
msgid "Return a shallow copy of the dictionary."
msgstr ""

#: ../../library/stdtypes.rst:4566
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""

#: ../../library/stdtypes.rst:4568
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so "
"it generally doesn't make sense for *value* to be a mutable object such as "
"an empty list.  To get distinct values, use a :ref:`dict comprehension "
"<dict>` instead."
msgstr ""

#: ../../library/stdtypes.rst:4576
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""

#: ../../library/stdtypes.rst:4582
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""

#: ../../library/stdtypes.rst:4587
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""

#: ../../library/stdtypes.rst:4592
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""

#: ../../library/stdtypes.rst:4598
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""

#: ../../library/stdtypes.rst:4601
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""

#: ../../library/stdtypes.rst:4605
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr ""

#: ../../library/stdtypes.rst:4611
msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a "
"shortcut for ``reversed(d.keys())``."
msgstr ""

#: ../../library/stdtypes.rst:4618
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""

#: ../../library/stdtypes.rst:4624
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""

#: ../../library/stdtypes.rst:4627
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""

#: ../../library/stdtypes.rst:4634
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""

#: ../../library/stdtypes.rst:4637
msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` "
"to itself::"
msgstr ""

#: ../../library/stdtypes.rst:4647
msgid ""
"Create a new dictionary with the merged keys and values of *d* and *other*, "
"which must both be dictionaries. The values of *other* take priority when "
"*d* and *other* share keys."
msgstr ""

#: ../../library/stdtypes.rst:4655
msgid ""
"Update the dictionary *d* with keys and values from *other*, which may be "
"either a :term:`mapping` or an :term:`iterable` of key/value pairs. The "
"values of *other* take priority when *d* and *other* share keys."
msgstr ""

#: ../../library/stdtypes.rst:4661
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs (regardless of ordering). Order comparisons ('<', '<=', '>=', "
"'>') raise :exc:`TypeError`."
msgstr ""

#: ../../library/stdtypes.rst:4665
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""

#: ../../library/stdtypes.rst:4683
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""

#: ../../library/stdtypes.rst:4687
msgid "Dictionaries and dictionary views are reversible. ::"
msgstr ""

#: ../../library/stdtypes.rst:4699
msgid "Dictionaries are now reversible."
msgstr ""

#: ../../library/stdtypes.rst:4704
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""

#: ../../library/stdtypes.rst:4711
msgid "Dictionary view objects"
msgstr "字典視圖物件"

#: ../../library/stdtypes.rst:4713
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""

#: ../../library/stdtypes.rst:4718
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""

#: ../../library/stdtypes.rst:4723
msgid "Return the number of entries in the dictionary."
msgstr ""

#: ../../library/stdtypes.rst:4727
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""

#: ../../library/stdtypes.rst:4730
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``.  Another way to create the same list is ``pairs = "
"[(v, k) for (k, v) in d.items()]``."
msgstr ""

#: ../../library/stdtypes.rst:4735
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""

#: ../../library/stdtypes.rst:4738
msgid "Dictionary order is guaranteed to be insertion order."
msgstr ""

#: ../../library/stdtypes.rst:4743
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""

#: ../../library/stdtypes.rst:4748
msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. "
"The view will be iterated in reverse order of the insertion."
msgstr ""

#: ../../library/stdtypes.rst:4751
msgid "Dictionary views are now reversible."
msgstr ""

#: ../../library/stdtypes.rst:4756
msgid ""
"Return a :class:`types.MappingProxyType` that wraps the original dictionary "
"to which the view refers."
msgstr ""

#: ../../library/stdtypes.rst:4761
msgid ""
"Keys views are set-like since their entries are unique and :term:`hashable`. "
"Items views also have set-like operations since the (key, value) pairs are "
"unique and the keys are hashable. If all values in an items view are "
"hashable as well, then the items view can interoperate with other sets. "
"(Values views are not treated as set-like since the entries are generally "
"not unique.)  For set-like views, all of the operations defined for the "
"abstract base class :class:`collections.abc.Set` are available (for example, "
"``==``, ``<``, or ``^``).  While using set operators, set-like views accept "
"any iterable as the other operand, unlike sets which only accept sets as the "
"input."
msgstr ""

#: ../../library/stdtypes.rst:4773
msgid "An example of dictionary view usage::"
msgstr ""

#: ../../library/stdtypes.rst:4817
msgid "Context Manager Types"
msgstr "情境管理器型別"

#: ../../library/stdtypes.rst:4824
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"Python 的 :keyword:`with` 陳述式支援了由情境管理器定義之 runtime 情境的概念，"
"要使用兩個方法來實作，該方法讓使用者定義類別能夠去定義 runtime 情境，且該情境"
"在執行陳述式主體 (statement body) 之前進入、在陳述式結束時退出："

#: ../../library/stdtypes.rst:4832
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"輸入 runtime 情境並回傳此物件或者與 runtime 情境相關的另一個物件。此方法回傳"
"的值有被綁定到使用此情境管理器的 :keyword:`with` 陳述式的 :keyword:`!as` 子句"
"中的識別字。"

#: ../../library/stdtypes.rst:4837
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""
"一個會回傳自己的情境管理器範例是 :term:`file object`。檔案物件從 __enter__() "
"回傳自己，以允許將 :func:`open` 用作 :keyword:`with` 陳述式中的情境運算式。"

#: ../../library/stdtypes.rst:4841
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`!with` statement."
msgstr ""
"一個會回傳相關物件的情境管理器範例是由 :func:`decimal.localcontext` 回傳的管"
"理器。這些管理器將有效的十進位情境設定為原始十進位情境的副本，然後回傳該副"
"本。這允許對 :keyword:`with` 陳述式主體中的當前十進位情境進行更改，而不會影"
"響 :keyword:`!with` 陳述式外部的程式碼。"

#: ../../library/stdtypes.rst:4851
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"退出 runtime 情境並回傳布林旗標以表示是否應抑制曾發生的任何例外。如果在執行 :"
"keyword:`with` 陳述式主體時發生例外，則引數包含例外型別、值和回溯 "
"(traceback) 資訊。否則，所有三個引數都是 ``None``。"

#: ../../library/stdtypes.rst:4856
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""
"從此方法回傳 true 值將導致 :keyword:`with` 陳述式抑制例外並繼續執行緊接著 :"
"keyword:`!with` 陳述式之後的陳述式。否則，該例外將在該方法執行完畢後繼續傳播 "
"(propagate)。執行此方法期間發生的例外會取代 :keyword:`!with` 陳述式主體中發生"
"的任何例外。"

#: ../../library/stdtypes.rst:4863
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`~object."
"__exit__` method has actually failed."
msgstr ""
"傳入的例外不應明確重新引發 - 取而代之的是，此方法應回傳 false 值以指示該方法"
"已成功完成且不希望抑制引發的例外。這讓情境管理程式碼能輕鬆檢測 :meth:"
"`__exit__` 方法是否曾實際失敗過。"

#: ../../library/stdtypes.rst:4869
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python 定義了多個情境管理器來支援簡單的執行緒同步、檔案或其他物件的提示關閉以"
"及對有效十進位算術情境的更簡單操作。除了情境管理協定的實作之外，不會對特定型"
"別進行特殊處理。更多範例請參閱 :mod:`contextlib` 模組。"

#: ../../library/stdtypes.rst:4875
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`~contextmanager.__enter__` and :meth:`~contextmanager.__exit__` methods, "
"rather than the iterator produced by an undecorated generator function."
msgstr ""
"Python 的 :term:`generator` 和 :class:`contextlib.contextmanager` 裝飾器提供"
"了一種便捷的方法來實作這些協定。如果產生器函式以 :class:`contextlib."
"contextmanager` 裝飾器裝飾，它將回傳一個有實作出需要的 :meth:"
"`~contextmanager.__enter__` 和 :meth:`~contextmanager.__exit__` 方法的情境管"
"理器，而不是由未裝飾產生器函式產生的疊代器。"

#: ../../library/stdtypes.rst:4882
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"請注意，Python/C API 中 Python 物件的型別結構中的任何方法都沒有特定的槽。想要"
"定義這些方法的擴充型別必須將它們作為普通的 Python 可存取方法提供。與設定 "
"runtime 情境的開銷相比，單一類別字典查找的開銷可以忽略不計。"

#: ../../library/stdtypes.rst:4890
msgid ""
"Type Annotation Types --- :ref:`Generic Alias <types-genericalias>`, :ref:"
"`Union <types-union>`"
msgstr ""
"型別註釋的型別 --- :ref:`泛型別名 (Generic Alias) <types-genericalias>`、:"
"ref:`聯合 (Union) <types-union>`"

#: ../../library/stdtypes.rst:4895
msgid ""
"The core built-in types for :term:`type annotations <annotation>` are :ref:"
"`Generic Alias <types-genericalias>` and :ref:`Union <types-union>`."
msgstr ""
":term:`型別註釋 <annotation>` 的核心內建型別是\\ :ref:`泛型別名 <types-"
"genericalias>`\\ 和\\ :ref:`聯合 <types-union>`。"

#: ../../library/stdtypes.rst:4902
msgid "Generic Alias Type"
msgstr "泛型別名型別"

#: ../../library/stdtypes.rst:4908
msgid ""
"``GenericAlias`` objects are generally created by :ref:`subscripting "
"<subscriptions>` a class. They are most often used with :ref:`container "
"classes <sequence-types>`, such as :class:`list` or :class:`dict`. For "
"example, ``list[int]`` is a ``GenericAlias`` object created by subscripting "
"the ``list`` class with the argument :class:`int`. ``GenericAlias`` objects "
"are intended primarily for use with :term:`type annotations <annotation>`."
msgstr ""
"``GenericAlias`` 物件通常是透過\\ :ref:`下標 (subscripting) <subscriptions>` "
"一個類別來建立的。它們最常與\\ :ref:`容器類別 <sequence-types>` 一起使用，像"
"是 :class:`list` 或 :class:`dict`。例如 ``list[int]`` 是一個``GenericAlias`` "
"物件，它是透過使用引數 :class:`int` 來下標 ``list`` 類別而建立的。"
"``GenericAlias`` 物件主要會與\\ :term:`型別註釋 <annotation>` 一起使用。"

#: ../../library/stdtypes.rst:4918
msgid ""
"It is generally only possible to subscript a class if the class implements "
"the special method :meth:`~object.__class_getitem__`."
msgstr ""
"通常只有當類別有實作特殊方法 :meth:`~object.__class_getitem__` 時才可以去下標"
"該類別。"

#: ../../library/stdtypes.rst:4921
msgid ""
"A ``GenericAlias`` object acts as a proxy for a :term:`generic type`, "
"implementing *parameterized generics*."
msgstr ""
"將一個 ``GenericAlias`` 物件用作 :term:`generic type` 的代理，實作\\ *參數化"
"泛型 (parameterized generics)*。"

#: ../../library/stdtypes.rst:4924
msgid ""
"For a container class, the argument(s) supplied to a :ref:`subscription "
"<subscriptions>` of the class may indicate the type(s) of the elements an "
"object contains. For example, ``set[bytes]`` can be used in type annotations "
"to signify a :class:`set` in which all the elements are of type :class:"
"`bytes`."
msgstr ""
"對於一個容器類別，提供給該類別的\\ :ref:`下標 <subscriptions>`\\ 引數可以代表"
"物件所包含元素的型別。例如 ``set[bytes]`` 可以用於型別註釋來表示一個 :class:"
"`set`，其中所有元素的型別都是 :class:`bytes`。"

#: ../../library/stdtypes.rst:4930
msgid ""
"For a class which defines :meth:`~object.__class_getitem__` but is not a "
"container, the argument(s) supplied to a subscription of the class will "
"often indicate the return type(s) of one or more methods defined on an "
"object. For example, :mod:`regular expressions <re>` can be used on both "
"the :class:`str` data type and the :class:`bytes` data type:"
msgstr ""
"對於定義 :meth:`~object.__class_getitem__` 但不是容器的類別，提供給該類別的下"
"標引數通常會指示物件上有定義的一個或多個方法的回傳型別。例如\\ :mod:`正規表示"
"式 <re>`\\ 可以用於 :class:`str` 和 :class:`bytes` 資料型別："

#: ../../library/stdtypes.rst:4936
msgid ""
"If ``x = re.search('foo', 'foo')``, ``x`` will be a :ref:`re.Match <match-"
"objects>` object where the return values of ``x.group(0)`` and ``x[0]`` will "
"both be of type :class:`str`. We can represent this kind of object in type "
"annotations with the ``GenericAlias`` ``re.Match[str]``."
msgstr ""
"如果 ``x = re.search('foo', 'foo')``，``x`` 將會是一個 :ref:`re.Match <match-"
"objects>` 物件，其中 ``x.group(0)`` 和 ``x[0]`` 的回傳值都是 :class:`str` 型"
"別。我們就可以用 ``GenericAlias`` ``re.Match[str]`` 在型別註釋中表示這種物"
"件。"

#: ../../library/stdtypes.rst:4942
msgid ""
"If ``y = re.search(b'bar', b'bar')``, (note the ``b`` for :class:`bytes`), "
"``y`` will also be an instance of ``re.Match``, but the return values of ``y."
"group(0)`` and ``y[0]`` will both be of type :class:`bytes`. In type "
"annotations, we would represent this variety of :ref:`re.Match <match-"
"objects>` objects with ``re.Match[bytes]``."
msgstr ""
"如果 ``y = re.search(b'bar', b'bar')``\\ （注意 :class:`bytes` 的 ``b``）， "
"``y`` 也會是 ``re.Match`` 的實例，但 ``y.group(0)`` 和 ``y[0]`` 的回傳值的型"
"別都是 :class:`bytes`。在型別註釋中，我們將用 ``re.Match[bytes]`` 來表示各"
"種 :ref:`re.Match <match-objects>` 物件。"

#: ../../library/stdtypes.rst:4948
msgid ""
"``GenericAlias`` objects are instances of the class :class:`types."
"GenericAlias`, which can also be used to create ``GenericAlias`` objects "
"directly."
msgstr ""
"``GenericAlias`` 物件是 :class:`types.GenericAlias` 類別的實例，也可以用來直"
"接建立 ``GenericAlias`` 物件。"

#: ../../library/stdtypes.rst:4954
msgid ""
"Creates a ``GenericAlias`` representing a type ``T`` parameterized by types "
"*X*, *Y*, and more depending on the ``T`` used. For example, a function "
"expecting a :class:`list` containing :class:`float` elements::"
msgstr ""
"建立一個 ``GenericAlias`` 來表示一個型別 ``T``，其以型別 *X*、*Y* 等（取決於"
"所使用的 ``T``）來參數化。例如，一個函式需要一個包含 :class:`float` 元素的 :"
"class:`list`： ::"

#: ../../library/stdtypes.rst:4962
msgid ""
"Another example for :term:`mapping` objects, using a :class:`dict`, which is "
"a generic type expecting two type parameters representing the key type and "
"the value type.  In this example, the function expects a ``dict`` with keys "
"of type :class:`str` and values of type :class:`int`::"
msgstr ""
":term:`對映 <mapping>`\\ 物件的另一個範例，使用 :class:`dict`，它是一個泛型型"
"別，需要兩個型別參數，分別表示鍵型別和值型別。在此範例中，函式需要一個 "
"``dict``，其帶有 :class:`str` 型別的鍵和 :class:`int` 型別的值： ::"

#: ../../library/stdtypes.rst:4970
msgid ""
"The builtin functions :func:`isinstance` and :func:`issubclass` do not "
"accept ``GenericAlias`` types for their second argument::"
msgstr ""
"內建函式 :func:`isinstance` 和 :func:`issubclass` 不接受 ``GenericAlias`` 型"
"別作為第二個引數： ::"

#: ../../library/stdtypes.rst:4978
msgid ""
"The Python runtime does not enforce :term:`type annotations <annotation>`. "
"This extends to generic types and their type parameters. When creating a "
"container object from a ``GenericAlias``, the elements in the container are "
"not checked against their type. For example, the following code is "
"discouraged, but will run without errors::"
msgstr ""
"Python runtime 不強制執行\\ :term:`型別註釋 <annotation>`。這也擴展到泛型型別"
"及其型別參數。當從 ``GenericAlias`` 建立容器物件時，不會檢查容器中元素的型"
"別。例如，不鼓勵使用以下程式碼，但 runtime 不會出現錯誤： ::"

#: ../../library/stdtypes.rst:4988
msgid ""
"Furthermore, parameterized generics erase type parameters during object "
"creation::"
msgstr "此外，參數化泛型在物件建立期間會擦除 (erase) 型別參數： ::"

#: ../../library/stdtypes.rst:4999
msgid ""
"Calling :func:`repr` or :func:`str` on a generic shows the parameterized "
"type::"
msgstr "在泛型上呼叫 :func:`repr` 或 :func:`str` 會顯示參數化型別： ::"

#: ../../library/stdtypes.rst:5007
msgid ""
"The :meth:`~object.__getitem__` method of generic containers will raise an "
"exception to disallow mistakes like ``dict[str][str]``::"
msgstr ""
"為防止像是 ``dict[str][str]`` 的錯誤出現，泛型容器的 :meth:`~object."
"__getitem__` 方法會在這種情況下引發例外： ::"

#: ../../library/stdtypes.rst:5015
msgid ""
"However, such expressions are valid when :ref:`type variables <generics>` "
"are used.  The index must have as many elements as there are type variable "
"items in the ``GenericAlias`` object's :attr:`~genericalias.__args__`. ::"
msgstr ""
"然而當使用\\ :ref:`型別變數 (type variable) <generics>` 時，此類運算式是有效"
"的。索引的元素數量必須與 ``GenericAlias`` 物件的 :attr:`~genericalias."
"__args__` 中的型別變數項目一樣多： ::"

#: ../../library/stdtypes.rst:5026
msgid "Standard Generic Classes"
msgstr "標準泛型類別"

#: ../../library/stdtypes.rst:5028
msgid ""
"The following standard library classes support parameterized generics. This "
"list is non-exhaustive."
msgstr "以下標準函式庫類別有支援參數化泛型。此列表並非詳盡無遺。"

#: ../../library/stdtypes.rst:5031
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: ../../library/stdtypes.rst:5032
msgid ":class:`list`"
msgstr ":class:`list`"

#: ../../library/stdtypes.rst:5033
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: ../../library/stdtypes.rst:5034
msgid ":class:`set`"
msgstr ":class:`set`"

#: ../../library/stdtypes.rst:5035
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: ../../library/stdtypes.rst:5036
msgid ":class:`type`"
msgstr ":class:`type`"

#: ../../library/stdtypes.rst:5037
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: ../../library/stdtypes.rst:5038
msgid ":class:`collections.defaultdict`"
msgstr ":class:`collections.defaultdict`"

#: ../../library/stdtypes.rst:5039
msgid ":class:`collections.OrderedDict`"
msgstr ":class:`collections.OrderedDict`"

#: ../../library/stdtypes.rst:5040
msgid ":class:`collections.Counter`"
msgstr ":class:`collections.Counter`"

#: ../../library/stdtypes.rst:5041
msgid ":class:`collections.ChainMap`"
msgstr ":class:`collections.ChainMap`"

#: ../../library/stdtypes.rst:5042
msgid ":class:`collections.abc.Awaitable`"
msgstr ":class:`collections.abc.Awaitable`"

#: ../../library/stdtypes.rst:5043
msgid ":class:`collections.abc.Coroutine`"
msgstr ":class:`collections.abc.Coroutine`"

#: ../../library/stdtypes.rst:5044
msgid ":class:`collections.abc.AsyncIterable`"
msgstr ":class:`collections.abc.AsyncIterable`"

#: ../../library/stdtypes.rst:5045
msgid ":class:`collections.abc.AsyncIterator`"
msgstr ":class:`collections.abc.AsyncIterator`"

#: ../../library/stdtypes.rst:5046
msgid ":class:`collections.abc.AsyncGenerator`"
msgstr ":class:`collections.abc.AsyncGenerator`"

#: ../../library/stdtypes.rst:5047
msgid ":class:`collections.abc.Iterable`"
msgstr ":class:`collections.abc.Iterable`"

#: ../../library/stdtypes.rst:5048
msgid ":class:`collections.abc.Iterator`"
msgstr ":class:`collections.abc.Iterator`"

#: ../../library/stdtypes.rst:5049
msgid ":class:`collections.abc.Generator`"
msgstr ":class:`collections.abc.Generator`"

#: ../../library/stdtypes.rst:5050
msgid ":class:`collections.abc.Reversible`"
msgstr ":class:`collections.abc.Reversible`"

#: ../../library/stdtypes.rst:5051
msgid ":class:`collections.abc.Container`"
msgstr ":class:`collections.abc.Container`"

#: ../../library/stdtypes.rst:5052
msgid ":class:`collections.abc.Collection`"
msgstr ":class:`collections.abc.Collection`"

#: ../../library/stdtypes.rst:5053
msgid ":class:`collections.abc.Callable`"
msgstr ":class:`collections.abc.Callable`"

#: ../../library/stdtypes.rst:5054
msgid ":class:`collections.abc.Set`"
msgstr ":class:`collections.abc.Set`"

#: ../../library/stdtypes.rst:5055
msgid ":class:`collections.abc.MutableSet`"
msgstr ":class:`collections.abc.MutableSet`"

#: ../../library/stdtypes.rst:5056
msgid ":class:`collections.abc.Mapping`"
msgstr ":class:`collections.abc.Mapping`"

#: ../../library/stdtypes.rst:5057
msgid ":class:`collections.abc.MutableMapping`"
msgstr ":class:`collections.abc.MutableMapping`"

#: ../../library/stdtypes.rst:5058
msgid ":class:`collections.abc.Sequence`"
msgstr ":class:`collections.abc.Sequence`"

#: ../../library/stdtypes.rst:5059
msgid ":class:`collections.abc.MutableSequence`"
msgstr ":class:`collections.abc.MutableSequence`"

#: ../../library/stdtypes.rst:5060
msgid ":class:`collections.abc.ByteString`"
msgstr ":class:`collections.abc.ByteString`"

#: ../../library/stdtypes.rst:5061
msgid ":class:`collections.abc.MappingView`"
msgstr ":class:`collections.abc.MappingView`"

#: ../../library/stdtypes.rst:5062
msgid ":class:`collections.abc.KeysView`"
msgstr ":class:`collections.abc.KeysView`"

#: ../../library/stdtypes.rst:5063
msgid ":class:`collections.abc.ItemsView`"
msgstr ":class:`collections.abc.ItemsView`"

#: ../../library/stdtypes.rst:5064
msgid ":class:`collections.abc.ValuesView`"
msgstr ":class:`collections.abc.ValuesView`"

#: ../../library/stdtypes.rst:5065
msgid ":class:`contextlib.AbstractContextManager`"
msgstr ":class:`contextlib.AbstractContextManager`"

#: ../../library/stdtypes.rst:5066
msgid ":class:`contextlib.AbstractAsyncContextManager`"
msgstr ":class:`contextlib.AbstractAsyncContextManager`"

#: ../../library/stdtypes.rst:5067
msgid ":class:`dataclasses.Field`"
msgstr ":class:`dataclasses.Field`"

#: ../../library/stdtypes.rst:5068
msgid ":class:`functools.cached_property`"
msgstr ":class:`functools.cached_property`"

#: ../../library/stdtypes.rst:5069
msgid ":class:`functools.partialmethod`"
msgstr ":class:`functools.partialmethod`"

#: ../../library/stdtypes.rst:5070
msgid ":class:`os.PathLike`"
msgstr ":class:`os.PathLike`"

#: ../../library/stdtypes.rst:5071
msgid ":class:`queue.LifoQueue`"
msgstr ":class:`queue.LifoQueue`"

#: ../../library/stdtypes.rst:5072
msgid ":class:`queue.Queue`"
msgstr ":class:`queue.Queue`"

#: ../../library/stdtypes.rst:5073
msgid ":class:`queue.PriorityQueue`"
msgstr ":class:`queue.PriorityQueue`"

#: ../../library/stdtypes.rst:5074
msgid ":class:`queue.SimpleQueue`"
msgstr ":class:`queue.SimpleQueue`"

#: ../../library/stdtypes.rst:5075
msgid ":ref:`re.Pattern <re-objects>`"
msgstr ":ref:`re.Pattern <re-objects>`"

#: ../../library/stdtypes.rst:5076
msgid ":ref:`re.Match <match-objects>`"
msgstr ":ref:`re.Match <match-objects>`"

#: ../../library/stdtypes.rst:5077
msgid ":class:`shelve.BsdDbShelf`"
msgstr ":class:`shelve.BsdDbShelf`"

#: ../../library/stdtypes.rst:5078
msgid ":class:`shelve.DbfilenameShelf`"
msgstr ":class:`shelve.DbfilenameShelf`"

#: ../../library/stdtypes.rst:5079
msgid ":class:`shelve.Shelf`"
msgstr ":class:`shelve.Shelf`"

#: ../../library/stdtypes.rst:5080
msgid ":class:`types.MappingProxyType`"
msgstr ":class:`types.MappingProxyType`"

#: ../../library/stdtypes.rst:5081
msgid ":class:`weakref.WeakKeyDictionary`"
msgstr ":class:`weakref.WeakKeyDictionary`"

#: ../../library/stdtypes.rst:5082
msgid ":class:`weakref.WeakMethod`"
msgstr ":class:`weakref.WeakMethod`"

#: ../../library/stdtypes.rst:5083
msgid ":class:`weakref.WeakSet`"
msgstr ":class:`weakref.WeakSet`"

#: ../../library/stdtypes.rst:5084
msgid ":class:`weakref.WeakValueDictionary`"
msgstr ":class:`weakref.WeakValueDictionary`"

#: ../../library/stdtypes.rst:5089
msgid "Special Attributes of ``GenericAlias`` objects"
msgstr "``GenericAlias`` 物件的特殊屬性"

#: ../../library/stdtypes.rst:5091
msgid "All parameterized generics implement special read-only attributes."
msgstr "所有參數化泛型都有實作特殊的唯讀屬性。"

#: ../../library/stdtypes.rst:5095
msgid "This attribute points at the non-parameterized generic class::"
msgstr "此屬性指向非參數化泛型類別： ::"

#: ../../library/stdtypes.rst:5103
msgid ""
"This attribute is a :class:`tuple` (possibly of length 1) of generic types "
"passed to the original :meth:`~object.__class_getitem__` of the generic "
"class::"
msgstr ""
"此屬性是傳遞給泛型類別之原始 :meth:`~object.__class_getitem__` 的泛型型別 :"
"class:`tuple`\\ （長度可以為 1）： ::"

#: ../../library/stdtypes.rst:5113
msgid ""
"This attribute is a lazily computed tuple (possibly empty) of unique type "
"variables found in ``__args__``::"
msgstr ""
"此屬性是個會被延遲計算 (lazily computed) 的元組（可能為空），包含了在 "
"``__args__`` 中找得到的不重複型別變數： ::"

#: ../../library/stdtypes.rst:5124
msgid ""
"A ``GenericAlias`` object with :class:`typing.ParamSpec` parameters may not "
"have correct ``__parameters__`` after substitution because :class:`typing."
"ParamSpec` is intended primarily for static type checking."
msgstr ""
"具有 :class:`typing.ParamSpec` 參數的一個 ``GenericAlias`` 物件在替換後可能沒"
"有正確的 ``__parameters__``，因為 :class:`typing.ParamSpec` 主要用於靜態型別"
"檢查。"

#: ../../library/stdtypes.rst:5131
msgid ""
"A boolean that is true if the alias has been unpacked using the ``*`` "
"operator (see :data:`~typing.TypeVarTuple`)."
msgstr ""
"如果別名已使用 ``*`` 運算子解包 (unpack) 則為 true 的布林值（請參閱 :data:"
"`~typing.TypeVarTuple`\\ ）。"

#: ../../library/stdtypes.rst:5139
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - 型別提示"

#: ../../library/stdtypes.rst:5140
msgid "Introducing Python's framework for type annotations."
msgstr "引入 Python 的型別註釋框架。"

#: ../../library/stdtypes.rst:5142
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` - 標準集合 (Standard Collections) 中的型別提示泛型"

#: ../../library/stdtypes.rst:5143
msgid ""
"Introducing the ability to natively parameterize standard-library classes, "
"provided they implement the special class method :meth:`~object."
"__class_getitem__`."
msgstr ""
"引入原生參數化標準函式庫類別的能力，前提是它們有實作特殊的類別方法 :meth:"
"`~object.__class_getitem__`。"

#: ../../library/stdtypes.rst:5147
msgid ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""
":ref:`Generics`、:ref:`使用者定義泛型 <user-defined-generics>`\\ 和 :class:"
"`typing.Generic`"

#: ../../library/stdtypes.rst:5148
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"有關如何實作可以在 runtime 參數化並能被靜態型別檢查器理解的泛型類別的文件。"

#: ../../library/stdtypes.rst:5157
msgid "Union Type"
msgstr "聯合型別 (Union Type)"

#: ../../library/stdtypes.rst:5163
msgid ""
"A union object holds the value of the ``|`` (bitwise or) operation on "
"multiple :ref:`type objects <bltin-type-objects>`.  These types are intended "
"primarily for :term:`type annotations <annotation>`. The union type "
"expression enables cleaner type hinting syntax compared to :data:`typing."
"Union`."
msgstr ""
"一個聯合物件可以保存多個\\ :ref:`型別物件 (type object) <bltin-type-"
"objects>`\\ 之 ``|``\\ （位元 or）運算的值。這些型別主要用於\\ :term:`型別註"
"釋 (type annotation) <annotation>`。與 :data:`typing.Union` 相比，聯合型別運"
"算式可以讓型別提示語法更清晰簡潔。"

#: ../../library/stdtypes.rst:5170
msgid ""
"Defines a union object which holds types *X*, *Y*, and so forth. ``X | Y`` "
"means either X or Y.  It is equivalent to ``typing.Union[X, Y]``. For "
"example, the following function expects an argument of type :class:`int` or :"
"class:`float`::"
msgstr ""
"定義一個包含 *X*、*Y* 等型別的聯合物件。``X | Y`` 表示 X 或 Y。它相當於 "
"``typing.Union[X, Y]``。舉例來說，下列函式需要一個型別為 :class:`int` 或 :"
"class:`float` 的引數： ::"

#: ../../library/stdtypes.rst:5180
msgid ""
"The ``|`` operand cannot be used at runtime to define unions where one or "
"more members is a forward reference. For example, ``int | \"Foo\"``, where "
"``\"Foo\"`` is a reference to a class not yet defined, will fail at runtime. "
"For unions which include forward references, present the whole expression as "
"a string, e.g. ``\"int | Foo\"``."
msgstr ""
"不能在 runtime 使用 ``|`` 運算元 (operand) 來定義有一個以上的成員為向前參照 "
"(forward reference) 的聯合。例如 ``int | \"Foo\"``，其中 ``\"Foo\"`` 是對未定"
"義類別的參照，將在 runtime 失敗。對於包含向前參照的聯合，請將整個運算式以字串"
"呈現，例如 ``\"int | Foo\"``。"

#: ../../library/stdtypes.rst:5188
msgid ""
"Union objects can be tested for equality with other union objects.  Details:"
msgstr "聯合物件可以與其他聯合物件一起進行相等性測試。細節如下："

#: ../../library/stdtypes.rst:5190
msgid "Unions of unions are flattened::"
msgstr "聯合的聯合會被扁平化： ::"

#: ../../library/stdtypes.rst:5194
msgid "Redundant types are removed::"
msgstr "冗餘型別會被刪除： ::"

#: ../../library/stdtypes.rst:5198
msgid "When comparing unions, the order is ignored::"
msgstr "比較聯合時，順序會被忽略： ::"

#: ../../library/stdtypes.rst:5202
msgid "It is compatible with :data:`typing.Union`::"
msgstr "它與 :data:`typing.Union` 相容： ::"

#: ../../library/stdtypes.rst:5206
msgid "Optional types can be spelled as a union with ``None``::"
msgstr "可選型別可以表示為與 ``None`` 的聯合： ::"

#: ../../library/stdtypes.rst:5213
msgid ""
"Calls to :func:`isinstance` and :func:`issubclass` are also supported with a "
"union object::"
msgstr "聯合物件也支援 :func:`isinstance` 和 :func:`issubclass` 的呼叫： ::"

#: ../../library/stdtypes.rst:5219
msgid ""
"However, :ref:`parameterized generics <types-genericalias>` in union objects "
"cannot be checked::"
msgstr ""
"然而聯合物件中的\\ :ref:`參數化泛型 <types-genericalias>`\\ 則無法被檢查： ::"

#: ../../library/stdtypes.rst:5229
msgid ""
"The user-exposed type for the union object can be accessed from :data:`types."
"UnionType` and used for :func:`isinstance` checks.  An object cannot be "
"instantiated from the type::"
msgstr ""
"構成聯合物件的對使用者公開型別 (user-exposed type) 可以透過 :data:`types."
"UnionType` 存取並用於 :func:`isinstance` 檢查。物件不能以型別來實例化： ::"

#: ../../library/stdtypes.rst:5242
msgid ""
"The :meth:`!__or__` method for type objects was added to support the syntax "
"``X | Y``.  If a metaclass implements :meth:`!__or__`, the Union may "
"override it:"
msgstr ""
"新增了型別物件的 :meth:`!__or__` 方法來支援 ``X | Y`` 語法。如果元類別有實"
"作 :meth:`!__or__`，則 Union 可以覆寫 (override) 它： ::"

#: ../../library/stdtypes.rst:5262
msgid ":pep:`604` -- PEP proposing the ``X | Y`` syntax and the Union type."
msgstr ":pep:`604` -- PEP 提出 ``X | Y`` 語法和聯合型別。"

#: ../../library/stdtypes.rst:5270
msgid "Other Built-in Types"
msgstr ""

#: ../../library/stdtypes.rst:5272
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""

#: ../../library/stdtypes.rst:5279
msgid "Modules"
msgstr "模組"

#: ../../library/stdtypes.rst:5281
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""

#: ../../library/stdtypes.rst:5288
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""

#: ../../library/stdtypes.rst:5296
msgid ""
"Modules built into the interpreter are written like this: ``<module 'sys' "
"(built-in)>``.  If loaded from a file, they are written as ``<module 'os' "
"from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""

#: ../../library/stdtypes.rst:5304
msgid "Classes and Class Instances"
msgstr ""

#: ../../library/stdtypes.rst:5306
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr ""

#: ../../library/stdtypes.rst:5312
msgid "Functions"
msgstr "函式"

#: ../../library/stdtypes.rst:5314
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""

#: ../../library/stdtypes.rst:5317
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""

#: ../../library/stdtypes.rst:5321
msgid "See :ref:`function` for more information."
msgstr "更多資訊請見 :ref:`function`。"

#: ../../library/stdtypes.rst:5327
msgid "Methods"
msgstr ""

#: ../../library/stdtypes.rst:5331
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: :ref:`built-in methods <builtin-methods>` (such as :meth:"
"`append` on lists) and :ref:`class instance method <instance-methods>`. "
"Built-in methods are described with the types that support them."
msgstr ""

#: ../../library/stdtypes.rst:5336
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :ref:"
"`instance method <instance-methods>`) object. When called, it will add the "
"``self`` argument to the argument list.  Bound methods have two special read-"
"only attributes: :attr:`m.__self__ <method.__self__>` is the object on which "
"the method operates, and :attr:`m.__func__ <method.__func__>` is the "
"function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-n)`` "
"is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""

#: ../../library/stdtypes.rst:5347
msgid ""
"Like :ref:`function objects <user-defined-funcs>`, bound method objects "
"support getting arbitrary attributes.  However, since method attributes are "
"actually stored on the underlying function object (:attr:`method.__func__`), "
"setting method attributes on bound methods is disallowed.  Attempting to set "
"an attribute on a method results in an :exc:`AttributeError` being raised.  "
"In order to set a method attribute, you need to explicitly set it on the "
"underlying function object:"
msgstr ""

#: ../../library/stdtypes.rst:5370
msgid "See :ref:`instance-methods` for more information."
msgstr "更多資訊請見 :ref:`instance-methods`。"

#: ../../library/stdtypes.rst:5378
msgid "Code Objects"
msgstr ""

#: ../../library/stdtypes.rst:5384
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`~function.__code__` attribute. See also the :mod:`code` module."
msgstr ""

#: ../../library/stdtypes.rst:5391
msgid ""
"Accessing :attr:`~function.__code__` raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and "
"``\"__code__\"``."
msgstr ""
"存取 :attr:`~function.__code__` 會引發一個附帶引數 ``obj`` 與 "
"``\"__code__\"`` 的\\ :ref:`稽核事件 <auditing>` ``object.__getattr__``。"

#: ../../library/stdtypes.rst:5398
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""

#: ../../library/stdtypes.rst:5401
msgid "See :ref:`types` for more information."
msgstr "更多資訊請見 :ref:`types`。"

#: ../../library/stdtypes.rst:5407
msgid "Type Objects"
msgstr ""

#: ../../library/stdtypes.rst:5413
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""

#: ../../library/stdtypes.rst:5418
msgid "Types are written like this: ``<class 'int'>``."
msgstr ""

#: ../../library/stdtypes.rst:5424
msgid "The Null Object"
msgstr ""

#: ../../library/stdtypes.rst:5426
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""

#: ../../library/stdtypes.rst:5430
msgid "It is written as ``None``."
msgstr ""

#: ../../library/stdtypes.rst:5437
msgid "The Ellipsis Object"
msgstr ""

#: ../../library/stdtypes.rst:5439
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""

#: ../../library/stdtypes.rst:5444
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr ""

#: ../../library/stdtypes.rst:5450
msgid "The NotImplemented Object"
msgstr ""

#: ../../library/stdtypes.rst:5452
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one :data:`NotImplemented` object. :code:"
"`type(NotImplemented)()` produces the singleton instance."
msgstr ""

#: ../../library/stdtypes.rst:5457
msgid "It is written as :code:`NotImplemented`."
msgstr ""

#: ../../library/stdtypes.rst:5463
msgid "Internal Objects"
msgstr ""

#: ../../library/stdtypes.rst:5465
msgid ""
"See :ref:`types` for this information.  It describes :ref:`stack frame "
"objects <frame-objects>`, :ref:`traceback objects <traceback-objects>`, and "
"slice objects."
msgstr ""

#: ../../library/stdtypes.rst:5473
msgid "Special Attributes"
msgstr ""

#: ../../library/stdtypes.rst:5475
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""

#: ../../library/stdtypes.rst:5482
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""

#: ../../library/stdtypes.rst:5488
msgid "The class to which a class instance belongs."
msgstr ""

#: ../../library/stdtypes.rst:5493
msgid "The tuple of base classes of a class object."
msgstr ""

#: ../../library/stdtypes.rst:5498
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr ""

#: ../../library/stdtypes.rst:5504
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""

#: ../../library/stdtypes.rst:5512
msgid ""
"The :ref:`type parameters <type-params>` of generic classes, functions, and :"
"ref:`type aliases <type-aliases>`."
msgstr ""

#: ../../library/stdtypes.rst:5520
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""

#: ../../library/stdtypes.rst:5526
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""

#: ../../library/stdtypes.rst:5533
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive.  The list is "
"in definition order.  Example::"
msgstr ""

#: ../../library/stdtypes.rst:5544
msgid "Integer string conversion length limitation"
msgstr ""

#: ../../library/stdtypes.rst:5546
msgid ""
"CPython has a global limit for converting between :class:`int` and :class:"
"`str` to mitigate denial of service attacks. This limit *only* applies to "
"decimal or other non-power-of-two number bases. Hexadecimal, octal, and "
"binary conversions are unlimited. The limit can be configured."
msgstr ""

#: ../../library/stdtypes.rst:5551
msgid ""
"The :class:`int` type in CPython is an arbitrary length number stored in "
"binary form (commonly known as a \"bignum\"). There exists no algorithm that "
"can convert a string to a binary integer or a binary integer to a string in "
"linear time, *unless* the base is a power of 2. Even the best known "
"algorithms for base 10 have sub-quadratic complexity. Converting a large "
"value such as ``int('1' * 500_000)`` can take over a second on a fast CPU."
msgstr ""

#: ../../library/stdtypes.rst:5558
msgid ""
"Limiting conversion size offers a practical way to avoid :cve:`2020-10735`."
msgstr ""

#: ../../library/stdtypes.rst:5560
msgid ""
"The limit is applied to the number of digit characters in the input or "
"output string when a non-linear conversion algorithm would be involved.  "
"Underscores and the sign are not counted towards the limit."
msgstr ""

#: ../../library/stdtypes.rst:5564
msgid ""
"When an operation would exceed the limit, a :exc:`ValueError` is raised:"
msgstr ""

#: ../../library/stdtypes.rst:5586
msgid ""
"The default limit is 4300 digits as provided in :data:`sys.int_info."
"default_max_str_digits <sys.int_info>`. The lowest limit that can be "
"configured is 640 digits as provided in :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."
msgstr ""

#: ../../library/stdtypes.rst:5591
msgid "Verification:"
msgstr ""

#: ../../library/stdtypes.rst:5606
msgid "Affected APIs"
msgstr ""

#: ../../library/stdtypes.rst:5608
msgid ""
"The limitation only applies to potentially slow conversions between :class:"
"`int` and :class:`str` or :class:`bytes`:"
msgstr ""

#: ../../library/stdtypes.rst:5611
msgid "``int(string)`` with default base 10."
msgstr ""

#: ../../library/stdtypes.rst:5612
msgid "``int(string, base)`` for all bases that are not a power of 2."
msgstr ""

#: ../../library/stdtypes.rst:5613
msgid "``str(integer)``."
msgstr "``str(integer)``。"

#: ../../library/stdtypes.rst:5614
msgid "``repr(integer)``."
msgstr "``repr(integer)``。"

#: ../../library/stdtypes.rst:5615
msgid ""
"any other string conversion to base 10, for example ``f\"{integer}\"``, "
"``\"{}\".format(integer)``, or ``b\"%d\" % integer``."
msgstr ""

#: ../../library/stdtypes.rst:5618
msgid "The limitations do not apply to functions with a linear algorithm:"
msgstr ""

#: ../../library/stdtypes.rst:5620
msgid "``int(string, base)`` with base 2, 4, 8, 16, or 32."
msgstr ""

#: ../../library/stdtypes.rst:5621
msgid ":func:`int.from_bytes` and :func:`int.to_bytes`."
msgstr ""

#: ../../library/stdtypes.rst:5622
msgid ":func:`hex`, :func:`oct`, :func:`bin`."
msgstr ""

#: ../../library/stdtypes.rst:5623
msgid ":ref:`formatspec` for hex, octal, and binary numbers."
msgstr ""

#: ../../library/stdtypes.rst:5624
msgid ":class:`str` to :class:`float`."
msgstr ""

#: ../../library/stdtypes.rst:5625
msgid ":class:`str` to :class:`decimal.Decimal`."
msgstr ""

#: ../../library/stdtypes.rst:5628
msgid "Configuring the limit"
msgstr ""

#: ../../library/stdtypes.rst:5630
msgid ""
"Before Python starts up you can use an environment variable or an "
"interpreter command line flag to configure the limit:"
msgstr ""

#: ../../library/stdtypes.rst:5633
msgid ""
":envvar:`PYTHONINTMAXSTRDIGITS`, e.g. ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"to set the limit to 640 or ``PYTHONINTMAXSTRDIGITS=0 python3`` to disable "
"the limitation."
msgstr ""

#: ../../library/stdtypes.rst:5636
msgid ""
":option:`-X int_max_str_digits <-X>`, e.g. ``python3 -X "
"int_max_str_digits=640``"
msgstr ""

#: ../../library/stdtypes.rst:5638
msgid ""
":data:`sys.flags.int_max_str_digits` contains the value of :envvar:"
"`PYTHONINTMAXSTRDIGITS` or :option:`-X int_max_str_digits <-X>`. If both the "
"env var and the ``-X`` option are set, the ``-X`` option takes precedence. A "
"value of *-1* indicates that both were unset, thus a value of :data:`sys."
"int_info.default_max_str_digits` was used during initialization."
msgstr ""

#: ../../library/stdtypes.rst:5644
msgid ""
"From code, you can inspect the current limit and set a new one using these :"
"mod:`sys` APIs:"
msgstr ""

#: ../../library/stdtypes.rst:5647
msgid ""
":func:`sys.get_int_max_str_digits` and :func:`sys.set_int_max_str_digits` "
"are a getter and setter for the interpreter-wide limit. Subinterpreters have "
"their own limit."
msgstr ""

#: ../../library/stdtypes.rst:5651
msgid ""
"Information about the default and minimum can be found in :data:`sys."
"int_info`:"
msgstr ""

#: ../../library/stdtypes.rst:5653
msgid ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` is the compiled-"
"in default limit."
msgstr ""

#: ../../library/stdtypes.rst:5655
msgid ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` is the lowest "
"accepted value for the limit (other than 0 which disables it)."
msgstr ""

#: ../../library/stdtypes.rst:5662
msgid ""
"Setting a low limit *can* lead to problems. While rare, code exists that "
"contains integer constants in decimal in their source that exceed the "
"minimum threshold. A consequence of setting the limit is that Python source "
"code containing decimal integer literals longer than the limit will "
"encounter an error during parsing, usually at startup time or import time or "
"even at installation time - anytime an up to date ``.pyc`` does not already "
"exist for the code. A workaround for source that contains such large "
"constants is to convert them to ``0x`` hexadecimal form as it has no limit."
msgstr ""

#: ../../library/stdtypes.rst:5671
msgid ""
"Test your application thoroughly if you use a low limit. Ensure your tests "
"run with the limit set early via the environment or flag so that it applies "
"during startup and even during any installation step that may invoke Python "
"to precompile ``.py`` sources to ``.pyc`` files."
msgstr ""

#: ../../library/stdtypes.rst:5677
msgid "Recommended configuration"
msgstr ""

#: ../../library/stdtypes.rst:5679
msgid ""
"The default :data:`sys.int_info.default_max_str_digits` is expected to be "
"reasonable for most applications. If your application requires a different "
"limit, set it from your main entry point using Python version agnostic code "
"as these APIs were added in security patch releases in versions before 3.12."
msgstr ""

#: ../../library/stdtypes.rst:5684
msgid "Example::"
msgstr "範例： ::"

#: ../../library/stdtypes.rst:5696
msgid "If you need to disable it entirely, set it to ``0``."
msgstr ""

#: ../../library/stdtypes.rst:5700
msgid "Footnotes"
msgstr "註腳"

#: ../../library/stdtypes.rst:5701
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""

#: ../../library/stdtypes.rst:5704
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""

#: ../../library/stdtypes.rst:5707
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""

#: ../../library/stdtypes.rst:5709
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""

#: ../../library/stdtypes.rst:5712
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""

#: ../../library/stdtypes.rst:13
msgid "built-in"
msgstr "built-in（內建）"

#: ../../library/stdtypes.rst:13 ../../library/stdtypes.rst:316
#: ../../library/stdtypes.rst:393 ../../library/stdtypes.rst:950
#: ../../library/stdtypes.rst:1117 ../../library/stdtypes.rst:1139
#: ../../library/stdtypes.rst:1154 ../../library/stdtypes.rst:4426
#: ../../library/stdtypes.rst:5409
msgid "types"
msgstr "type（型別）"

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:1154
#: ../../library/stdtypes.rst:4426
msgid "statement"
msgstr "statement（陳述式）"

#: ../../library/stdtypes.rst:34
msgid "if"
msgstr "if"

#: ../../library/stdtypes.rst:34
msgid "while"
msgstr "while"

#: ../../library/stdtypes.rst:34
msgid "truth"
msgstr "truth（真）"

#: ../../library/stdtypes.rst:34
msgid "value"
msgstr "value"

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:81
#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:817
msgid "Boolean"
msgstr "Boolean（布林）"

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:81
#: ../../library/stdtypes.rst:393
msgid "operations"
msgstr "operations（操作）"

#: ../../library/stdtypes.rst:34
msgid "false"
msgstr "false"

#: ../../library/stdtypes.rst:44
msgid "true"
msgstr "true"

#: ../../library/stdtypes.rst:52
msgid "None (Built-in object)"
msgstr "None（內建物件）"

#: ../../library/stdtypes.rst:52
msgid "False (Built-in object)"
msgstr "False（內建物件）"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:98
#: ../../library/stdtypes.rst:123 ../../library/stdtypes.rst:195
#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:393
#: ../../library/stdtypes.rst:950
msgid "operator"
msgstr "operator（運算子）"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:98
msgid "or"
msgstr "or"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:98
msgid "and"
msgstr "and"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:817
msgid "False"
msgstr "False"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:817
msgid "True"
msgstr "True"

#: ../../library/stdtypes.rst:98
msgid "not"
msgstr "not"

#: ../../library/stdtypes.rst:123
msgid "chaining"
msgstr "chaining（鏈結）"

#: ../../library/stdtypes.rst:123
msgid "comparisons"
msgstr "comparisons（比較）"

#: ../../library/stdtypes.rst:123
msgid "comparison"
msgstr "comparison（比較）"

#: ../../library/stdtypes.rst:123
msgid "=="
msgstr "=="

#: ../../library/stdtypes.rst:123
msgid "< (less)"
msgstr "< （小於）"

#: ../../library/stdtypes.rst:123
msgid "<="
msgstr "<="

#: ../../library/stdtypes.rst:123
msgid "> (greater)"
msgstr "> （大於）"

#: ../../library/stdtypes.rst:123
msgid ">="
msgstr ">="

#: ../../library/stdtypes.rst:123
msgid "!="
msgstr "!="

#: ../../library/stdtypes.rst:123
msgid "is"
msgstr "is"

#: ../../library/stdtypes.rst:123
msgid "is not"
msgstr "is not"

#: ../../library/stdtypes.rst:163 ../../library/stdtypes.rst:208
#: ../../library/stdtypes.rst:934 ../../library/stdtypes.rst:1117
#: ../../library/stdtypes.rst:1139 ../../library/stdtypes.rst:1260
#: ../../library/stdtypes.rst:1339 ../../library/stdtypes.rst:1383
#: ../../library/stdtypes.rst:1504 ../../library/stdtypes.rst:1540
#: ../../library/stdtypes.rst:2517 ../../library/stdtypes.rst:2536
#: ../../library/stdtypes.rst:2643 ../../library/stdtypes.rst:4224
#: ../../library/stdtypes.rst:4426 ../../library/stdtypes.rst:4904
#: ../../library/stdtypes.rst:5159 ../../library/stdtypes.rst:5329
#: ../../library/stdtypes.rst:5373
msgid "object"
msgstr "object（物件）"

#: ../../library/stdtypes.rst:163 ../../library/stdtypes.rst:208
#: ../../library/stdtypes.rst:229 ../../library/stdtypes.rst:316
#: ../../library/stdtypes.rst:335
msgid "numeric"
msgstr "numeric（數值）"

#: ../../library/stdtypes.rst:163
msgid "objects"
msgstr "objects（物件）"

#: ../../library/stdtypes.rst:163
msgid "comparing"
msgstr "comparing（比較）"

#: ../../library/stdtypes.rst:173
msgid "__eq__() (instance method)"
msgstr "__eq__()（實例方法）"

#: ../../library/stdtypes.rst:173
msgid "__ne__() (instance method)"
msgstr "__ne__()（實例方法）"

#: ../../library/stdtypes.rst:173
msgid "__lt__() (instance method)"
msgstr "__lt__()（實例方法）"

#: ../../library/stdtypes.rst:173
msgid "__le__() (instance method)"
msgstr "__le__()（實例方法）"

#: ../../library/stdtypes.rst:173
msgid "__gt__() (instance method)"
msgstr "__gt__()（實例方法）"

#: ../../library/stdtypes.rst:173
msgid "__ge__() (instance method)"
msgstr "__ge__()（實例方法）"

#: ../../library/stdtypes.rst:195 ../../library/stdtypes.rst:950
msgid "in"
msgstr "in"

#: ../../library/stdtypes.rst:195 ../../library/stdtypes.rst:950
msgid "not in"
msgstr "not in"

#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:229
#: ../../library/stdtypes.rst:393
msgid "integer"
msgstr "integer（整數）"

#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:229
msgid "floating-point"
msgstr "floating-point（浮點數）"

#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:229
msgid "complex number"
msgstr "complex number（複數）"

#: ../../library/stdtypes.rst:208
msgid "C"
msgstr "C"

#: ../../library/stdtypes.rst:208
msgid "language"
msgstr "language（語言）"

#: ../../library/stdtypes.rst:229
msgid "literals"
msgstr "literals（字面值）"

#: ../../library/stdtypes.rst:229
msgid "hexadecimal"
msgstr "hexadecimal（十六進位）"

#: ../../library/stdtypes.rst:229
msgid "octal"
msgstr "octal（八進位）"

#: ../../library/stdtypes.rst:229
msgid "binary"
msgstr "binary（二進位）"

#: ../../library/stdtypes.rst:246
msgid "arithmetic"
msgstr "arithmetic（算術）"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:950
#: ../../library/stdtypes.rst:1117 ../../library/stdtypes.rst:4426
#: ../../library/stdtypes.rst:5380 ../../library/stdtypes.rst:5394
#: ../../library/stdtypes.rst:5409
msgid "built-in function"
msgstr "built-in function（內建函式）"

#: ../../library/stdtypes.rst:246
msgid "int"
msgstr "int"

#: ../../library/stdtypes.rst:246
msgid "float"
msgstr "float"

#: ../../library/stdtypes.rst:246
msgid "complex"
msgstr "complex（複數）"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:2393
#: ../../library/stdtypes.rst:3612
msgid "+ (plus)"
msgstr "+ （加號）"

#: ../../library/stdtypes.rst:246
msgid "unary operator"
msgstr "unary operator（一元運算子）"

#: ../../library/stdtypes.rst:246
msgid "binary operator"
msgstr "binary operator（二元運算子）"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:2393
#: ../../library/stdtypes.rst:3612
msgid "- (minus)"
msgstr "- （減號）"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:2350
#: ../../library/stdtypes.rst:3569
msgid "* (asterisk)"
msgstr "* （星號）"

#: ../../library/stdtypes.rst:246
msgid "/ (slash)"
msgstr "/ （斜線）"

#: ../../library/stdtypes.rst:246
msgid "//"
msgstr "//"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:2320
#: ../../library/stdtypes.rst:3537
msgid "% (percent)"
msgstr "% （百分號）"

#: ../../library/stdtypes.rst:246
msgid "**"
msgstr "**"

#: ../../library/stdtypes.rst:316 ../../library/stdtypes.rst:393
#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:1154
#: ../../library/stdtypes.rst:4426
msgid "operations on"
msgstr "operations on（操作於）"

#: ../../library/stdtypes.rst:316
msgid "conjugate() (complex number method)"
msgstr "conjugate()（複數方法）"

#: ../../library/stdtypes.rst:335 ../../library/stdtypes.rst:1606
#: ../../library/stdtypes.rst:2517 ../../library/stdtypes.rst:5409
msgid "module"
msgstr "模組"

#: ../../library/stdtypes.rst:335
msgid "math"
msgstr "math"

#: ../../library/stdtypes.rst:335
msgid "floor() (in module math)"
msgstr "floor()（於 math 模組）"

#: ../../library/stdtypes.rst:335
msgid "ceil() (in module math)"
msgstr "ceil()（於 math 模組）"

#: ../../library/stdtypes.rst:335
msgid "trunc() (in module math)"
msgstr "trunc()（於 math 模組）"

#: ../../library/stdtypes.rst:335
msgid "conversions"
msgstr "conversions（轉換）"

#: ../../library/stdtypes.rst:393
msgid "bitwise"
msgstr "bitwise（位元）"

#: ../../library/stdtypes.rst:393
msgid "shifting"
msgstr "shifting（移位）"

#: ../../library/stdtypes.rst:393
msgid "masking"
msgstr "masking（遮罩）"

#: ../../library/stdtypes.rst:393
msgid "| (vertical bar)"
msgstr "| （垂直線）"

#: ../../library/stdtypes.rst:393
msgid "^ (caret)"
msgstr "^ （插入符號）"

#: ../../library/stdtypes.rst:393
msgid "& (ampersand)"
msgstr "& （和號）"

#: ../../library/stdtypes.rst:393
msgid "<<"
msgstr "<<"

#: ../../library/stdtypes.rst:393
msgid ">>"
msgstr ">>"

#: ../../library/stdtypes.rst:393
msgid "~ (tilde)"
msgstr "~ （波浪號）"

#: ../../library/stdtypes.rst:817
msgid "values"
msgstr "values"

#: ../../library/stdtypes.rst:847
msgid "iterator protocol"
msgstr "iterator protocol（疊代器協定）"

#: ../../library/stdtypes.rst:847 ../../library/stdtypes.rst:4819
msgid "protocol"
msgstr "protocol（協定）"

#: ../../library/stdtypes.rst:847
msgid "iterator"
msgstr "iterator（疊代器）"

#: ../../library/stdtypes.rst:847 ../../library/stdtypes.rst:934
#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:1117
#: ../../library/stdtypes.rst:1139 ../../library/stdtypes.rst:1154
msgid "sequence"
msgstr "sequence（序列）"

#: ../../library/stdtypes.rst:847
msgid "iteration"
msgstr "iteration（疊代）"

#: ../../library/stdtypes.rst:847
msgid "container"
msgstr "container（容器）"

#: ../../library/stdtypes.rst:847
msgid "iteration over"
msgstr "iteration over（疊代於）"

#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:4426
msgid "len"
msgstr "len"

#: ../../library/stdtypes.rst:950
msgid "min"
msgstr "min"

#: ../../library/stdtypes.rst:950
msgid "max"
msgstr "max"

#: ../../library/stdtypes.rst:950
msgid "concatenation"
msgstr "concatenation（串接）"

#: ../../library/stdtypes.rst:950
msgid "operation"
msgstr "operation（操作）"

#: ../../library/stdtypes.rst:950
msgid "repetition"
msgstr "repetition（重複）"

#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:1154
msgid "subscript"
msgstr "subscript（下標）"

#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:1154
msgid "slice"
msgstr "slice（切片）"

#: ../../library/stdtypes.rst:950
msgid "count() (sequence method)"
msgstr "count()（序列方法）"

#: ../../library/stdtypes.rst:950
msgid "index() (sequence method)"
msgstr "index()（序列方法）"

#: ../../library/stdtypes.rst:1006
msgid "loop"
msgstr "loop（迴圈）"

#: ../../library/stdtypes.rst:1006
msgid "over mutable sequence"
msgstr "over mutable sequence（於可變序列）"

#: ../../library/stdtypes.rst:1006
msgid "mutable sequence"
msgstr "mutable sequence（可變序列）"

#: ../../library/stdtypes.rst:1006
msgid "loop over"
msgstr "loop over（迴圈）"

#: ../../library/stdtypes.rst:1117
msgid "immutable"
msgstr "immutable（不可變）"

#: ../../library/stdtypes.rst:1117 ../../library/stdtypes.rst:1339
msgid "tuple"
msgstr "tuple（元組）"

#: ../../library/stdtypes.rst:1117
msgid "hash"
msgstr "hash（雜湊）"

#: ../../library/stdtypes.rst:1139
msgid "mutable"
msgstr "mutable（可變）"

#: ../../library/stdtypes.rst:1139 ../../library/stdtypes.rst:1154
#: ../../library/stdtypes.rst:1260
msgid "list"
msgstr "list（串列）"

#: ../../library/stdtypes.rst:1139 ../../library/stdtypes.rst:2517
#: ../../library/stdtypes.rst:2643 ../../library/stdtypes.rst:2715
#: ../../library/stdtypes.rst:3537
msgid "bytearray"
msgstr "bytearray（位元組陣列）"

#: ../../library/stdtypes.rst:1154 ../../library/stdtypes.rst:4426
#: ../../library/stdtypes.rst:5159 ../../library/stdtypes.rst:5409
msgid "type"
msgstr "type（型別）"

#: ../../library/stdtypes.rst:1154
msgid "assignment"
msgstr "assignment（賦值）"

#: ../../library/stdtypes.rst:1154 ../../library/stdtypes.rst:4426
msgid "del"
msgstr "del"

#: ../../library/stdtypes.rst:1154
msgid "append() (sequence method)"
msgstr "append()（序列方法）"

#: ../../library/stdtypes.rst:1154
msgid "clear() (sequence method)"
msgstr "clear()（序列方法）"

#: ../../library/stdtypes.rst:1154
msgid "copy() (sequence method)"
msgstr "copy()（序列方法）"

#: ../../library/stdtypes.rst:1154
msgid "extend() (sequence method)"
msgstr "extend()（序列方法）"

#: ../../library/stdtypes.rst:1154
msgid "insert() (sequence method)"
msgstr "insert()（序列方法）"

#: ../../library/stdtypes.rst:1154
msgid "pop() (sequence method)"
msgstr "pop()（序列方法）"

#: ../../library/stdtypes.rst:1154
msgid "remove() (sequence method)"
msgstr "remove()（序列方法）"

#: ../../library/stdtypes.rst:1154
msgid "reverse() (sequence method)"
msgstr "reverse()（序列方法）"

#: ../../library/stdtypes.rst:1383
msgid "range"
msgstr "range"

#: ../../library/stdtypes.rst:1504 ../../library/stdtypes.rst:1553
#: ../../library/stdtypes.rst:1598 ../../library/stdtypes.rst:2320
msgid "string"
msgstr "string（字串）"

#: ../../library/stdtypes.rst:1504
msgid "text sequence type"
msgstr "text sequence type（文字序列型別）"

#: ../../library/stdtypes.rst:1504 ../../library/stdtypes.rst:1553
#: ../../library/stdtypes.rst:1571
msgid "str (built-in class)"
msgstr "str（內建類別）"

#: ../../library/stdtypes.rst:1504
msgid "(see also string)"
msgstr "（亦請見 string）"

#: ../../library/stdtypes.rst:1540
msgid "io.StringIO"
msgstr "io.StringIO"

#: ../../library/stdtypes.rst:1571 ../../library/stdtypes.rst:2509
msgid "buffer protocol"
msgstr "buffer protocol（緩衝區協定）"

#: ../../library/stdtypes.rst:1571 ../../library/stdtypes.rst:2517
#: ../../library/stdtypes.rst:2536 ../../library/stdtypes.rst:2715
#: ../../library/stdtypes.rst:3537
msgid "bytes"
msgstr "bytes（位元組）"

#: ../../library/stdtypes.rst:1598 ../../library/stdtypes.rst:2715
msgid "methods"
msgstr "methods（方法）"

#: ../../library/stdtypes.rst:1606
msgid "re"
msgstr "re"

#: ../../library/stdtypes.rst:2128 ../../library/stdtypes.rst:3391
msgid "universal newlines"
msgstr "universal newlines"

#: ../../library/stdtypes.rst:2128
msgid "str.splitlines method"
msgstr "str.splitlines 方法"

#: ../../library/stdtypes.rst:2320
msgid "formatting, string (%)"
msgstr "formatting（格式化）、字串 (%)"

#: ../../library/stdtypes.rst:2320
msgid "interpolation, string (%)"
msgstr "interpolation（插值）、字串 (%)"

#: ../../library/stdtypes.rst:2320
msgid "formatting, printf"
msgstr "formatting（格式化）、printf"

#: ../../library/stdtypes.rst:2320
msgid "interpolation, printf"
msgstr "interpolation（插值）、printf"

#: ../../library/stdtypes.rst:2320 ../../library/stdtypes.rst:3537
msgid "printf-style formatting"
msgstr "printf 風格格式化"

#: ../../library/stdtypes.rst:2320 ../../library/stdtypes.rst:3537
msgid "sprintf-style formatting"
msgstr "sprintf 風格格式化"

#: ../../library/stdtypes.rst:2350 ../../library/stdtypes.rst:3569
msgid "() (parentheses)"
msgstr "() （圓括號）"

#: ../../library/stdtypes.rst:2350 ../../library/stdtypes.rst:2393
#: ../../library/stdtypes.rst:3569 ../../library/stdtypes.rst:3612
msgid "in printf-style formatting"
msgstr "於 printf 風格格式化"

#: ../../library/stdtypes.rst:2350 ../../library/stdtypes.rst:3569
msgid ". (dot)"
msgstr ". （點）"

#: ../../library/stdtypes.rst:2393 ../../library/stdtypes.rst:3612
msgid "# (hash)"
msgstr "# （井字號）"

#: ../../library/stdtypes.rst:2393 ../../library/stdtypes.rst:3612
msgid "space"
msgstr "space（空白）"

#: ../../library/stdtypes.rst:2509
msgid "binary sequence types"
msgstr "binary sequence types（二進位序列型別）"

#: ../../library/stdtypes.rst:2517
msgid "memoryview"
msgstr "memoryview（記憶體視圖）"

#: ../../library/stdtypes.rst:2517
msgid "array"
msgstr "array（陣列）"

#: ../../library/stdtypes.rst:3391
msgid "bytes.splitlines method"
msgstr "bytes.splitlines 方法"

#: ../../library/stdtypes.rst:3391
msgid "bytearray.splitlines method"
msgstr "bytearray.splitlines 方法"

#: ../../library/stdtypes.rst:3537
msgid "formatting"
msgstr "formatting（格式化）"

#: ../../library/stdtypes.rst:3537
msgid "bytes (%)"
msgstr "bytes (%)"

#: ../../library/stdtypes.rst:3537
msgid "bytearray (%)"
msgstr "bytearray (%)"

#: ../../library/stdtypes.rst:3537
msgid "interpolation"
msgstr "interpolation（插值）"

#: ../../library/stdtypes.rst:4224
msgid "set"
msgstr "set（集合）"

#: ../../library/stdtypes.rst:4426
msgid "mapping"
msgstr "mapping（對映）"

#: ../../library/stdtypes.rst:4426
msgid "dictionary"
msgstr "dictionary（字典）"

#: ../../library/stdtypes.rst:4509
msgid "__missing__()"
msgstr "__missing__()"

#: ../../library/stdtypes.rst:4819
msgid "context manager"
msgstr "context manager（情境管理器）"

#: ../../library/stdtypes.rst:4819
msgid "context management protocol"
msgstr "context management protocol（情境管理協定）"

#: ../../library/stdtypes.rst:4819
msgid "context management"
msgstr "context management（情境管理）"

#: ../../library/stdtypes.rst:4892
msgid "annotation"
msgstr "annotation（註記）"

#: ../../library/stdtypes.rst:4892
msgid "type annotation; type hint"
msgstr "type annotation（型別註記）；type hint（型別提示）"

#: ../../library/stdtypes.rst:4904
msgid "GenericAlias"
msgstr "GenericAlias（泛型別名）"

#: ../../library/stdtypes.rst:4904
msgid "Generic"
msgstr "Generic（泛型）"

#: ../../library/stdtypes.rst:4904
msgid "Alias"
msgstr "Alias（別名）"

#: ../../library/stdtypes.rst:5159
msgid "Union"
msgstr "Union（聯合）"

#: ../../library/stdtypes.rst:5159
msgid "union"
msgstr "union（聯集）"

#: ../../library/stdtypes.rst:5329
msgid "method"
msgstr "method（方法）"

#: ../../library/stdtypes.rst:5373
msgid "code"
msgstr "code（程式碼）"

#: ../../library/stdtypes.rst:5373
msgid "code object"
msgstr "code object（程式碼物件）"

#: ../../library/stdtypes.rst:5380
msgid "compile"
msgstr "compile（編譯）"

#: ../../library/stdtypes.rst:5380
msgid "__code__ (function object attribute)"
msgstr "__code__（函式物件屬性）"

#: ../../library/stdtypes.rst:5394
msgid "exec"
msgstr "exec"

#: ../../library/stdtypes.rst:5394
msgid "eval"
msgstr "eval"

#: ../../library/stdtypes.rst:5433
msgid "..."
msgstr "..."

#: ../../library/stdtypes.rst:5433
msgid "ellipsis literal"
msgstr "ellipsis literal（刪節號）"
