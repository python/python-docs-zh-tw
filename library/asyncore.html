<!DOCTYPE html>

<html lang="zh-TW">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>asyncore --- 非同步 socket 處理函式 &#8212; Python 3.11.4 說明文件</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=845a48175c3935ba0d7ff16b8ed0072d62fd099f" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.11.4 說明文件 中搜尋"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="關於這些文件" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="copyright" title="版權" href="../copyright.html" />
    <link rel="next" title="audioop --- 操作原始聲音檔案" href="audioop.html" />
    <link rel="prev" title="asynchat --- 非同步 socket 指令/回應處理函式" href="asynchat.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/asyncore.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" />
                <input type="submit" value="前往"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目錄</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncore</span></code> --- 非同步 socket 處理函式</a><ul>
<li><a class="reference internal" href="#asyncore.loop"><code class="docutils literal notranslate"><span class="pre">loop()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher"><code class="docutils literal notranslate"><span class="pre">dispatcher</span></code></a><ul>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_read"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_read()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_write"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_write()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_expt"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_expt()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_connect"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_connect()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_close"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_close()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_error"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_error()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_accept"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_accept()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_accepted"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_accepted()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.readable"><code class="docutils literal notranslate"><span class="pre">dispatcher.readable()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.writable"><code class="docutils literal notranslate"><span class="pre">dispatcher.writable()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.create_socket"><code class="docutils literal notranslate"><span class="pre">dispatcher.create_socket()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.connect"><code class="docutils literal notranslate"><span class="pre">dispatcher.connect()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.send"><code class="docutils literal notranslate"><span class="pre">dispatcher.send()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.recv"><code class="docutils literal notranslate"><span class="pre">dispatcher.recv()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.listen"><code class="docutils literal notranslate"><span class="pre">dispatcher.listen()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.bind"><code class="docutils literal notranslate"><span class="pre">dispatcher.bind()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.accept"><code class="docutils literal notranslate"><span class="pre">dispatcher.accept()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.close"><code class="docutils literal notranslate"><span class="pre">dispatcher.close()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#asyncore.dispatcher_with_send"><code class="docutils literal notranslate"><span class="pre">dispatcher_with_send</span></code></a></li>
<li><a class="reference internal" href="#asyncore.file_dispatcher"><code class="docutils literal notranslate"><span class="pre">file_dispatcher</span></code></a></li>
<li><a class="reference internal" href="#asyncore.file_wrapper"><code class="docutils literal notranslate"><span class="pre">file_wrapper</span></code></a></li>
<li><a class="reference internal" href="#asyncore-example-basic-http-client">asyncore Example basic HTTP client</a></li>
<li><a class="reference internal" href="#asyncore-example-basic-echo-server">asyncore Example basic echo server</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="asynchat.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asynchat</span></code> --- 非同步 socket 指令/回應處理函式</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="audioop.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code> --- 操作原始聲音檔案</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/asyncore.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="audioop.html" title="audioop --- 操作原始聲音檔案"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="asynchat.html" title="asynchat --- 非同步 socket 指令/回應處理函式"
             accesskey="P">上一頁</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準函式庫 (Standard Library)</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="superseded.html" accesskey="U">已被取代的模組</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncore</span></code> --- 非同步 socket 處理函式</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-asyncore">
<span id="asyncore-asynchronous-socket-handler"></span><h1><a class="reference internal" href="#module-asyncore" title="asyncore: A base class for developing asynchronous socket handling services.（已棄用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncore</span></code></a> --- 非同步 socket 處理函式<a class="headerlink" href="#module-asyncore" title="本標頭的永久連結">¶</a></h1>
<p><strong>原始碼：</strong><a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/asyncore.py">Lib/asyncore.py</a></p>
<div class="deprecated-removed">
<p><span class="versionmodified">自從版本 3.6 後不推薦使用，將會自版本 3.12 中移除。: </span><a class="reference internal" href="#module-asyncore" title="asyncore: A base class for developing asynchronous socket handling services.（已棄用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncore</span></code></a> 已被棄用（詳情請見:pep:<cite>PEP 594 &lt;594#asyncore&gt;</cite>）。請改用 <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>。</p>
</div>
<hr class="docutils" />
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>This module exists for backwards compatibility only.  For new code we
recommend using <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>.</p>
</div>
<p>This module provides the basic infrastructure for writing asynchronous  socket
service clients and servers.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not Emscripten, not WASI.</p>
<p>This module does not work or is not available on WebAssembly platforms
<code class="docutils literal notranslate"><span class="pre">wasm32-emscripten</span></code> and <code class="docutils literal notranslate"><span class="pre">wasm32-wasi</span></code>. See
<a class="reference internal" href="intro.html#wasm-availability"><span class="std std-ref">WebAssembly 平台</span></a> for more information.</p>
</div>
<p>There are only two ways to have a program on a single processor do  &quot;more than
one thing at a time.&quot; Multi-threaded programming is the  simplest and most
popular way to do it, but there is another very different technique, that lets
you have nearly all the advantages of  multi-threading, without actually using
multiple threads.  It's really  only practical if your program is largely I/O
bound.  If your program is processor bound, then pre-emptive scheduled threads
are probably what you really need.  Network servers are rarely processor
bound, however.</p>
<p>If your operating system supports the <code class="xref c c-func docutils literal notranslate"><span class="pre">select()</span></code> system call in its I/O
library (and nearly all do), then you can use it to juggle multiple
communication channels at once; doing other work while your I/O is taking
place in the &quot;background.&quot;  Although this strategy can seem strange and
complex, especially at first, it is in many ways easier to understand and
control than multi-threaded programming.  The <a class="reference internal" href="#module-asyncore" title="asyncore: A base class for developing asynchronous socket handling services.（已棄用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncore</span></code></a> module solves
many of the difficult problems for you, making the task of building
sophisticated high-performance network servers and clients a snap.  For
&quot;conversational&quot; applications and protocols the companion <a class="reference internal" href="asynchat.html#module-asynchat" title="asynchat: Support for asynchronous command/response protocols.（已棄用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asynchat</span></code></a>
module is invaluable.</p>
<p>The basic idea behind both modules is to create one or more network
<em>channels</em>, instances of class <a class="reference internal" href="#asyncore.dispatcher" title="asyncore.dispatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncore.dispatcher</span></code></a> and
<a class="reference internal" href="asynchat.html#asynchat.async_chat" title="asynchat.async_chat"><code class="xref py py-class docutils literal notranslate"><span class="pre">asynchat.async_chat</span></code></a>.  Creating the channels adds them to a global
map, used by the <a class="reference internal" href="#asyncore.loop" title="asyncore.loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">loop()</span></code></a> function if you do not provide it with your own
<em>map</em>.</p>
<p>Once the initial channel(s) is(are) created, calling the <a class="reference internal" href="#asyncore.loop" title="asyncore.loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">loop()</span></code></a> function
activates channel service, which continues until the last channel (including
any that have been added to the map during asynchronous service) is closed.</p>
<dl class="py function">
<dt class="sig sig-object py" id="asyncore.loop">
<span class="sig-prename descclassname"><span class="pre">asyncore.</span></span><span class="sig-name descname"><span class="pre">loop</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">use_poll</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">map</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">count</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.loop" title="本定義的永久連結">¶</a></dt>
<dd><p>Enter a polling loop that terminates after count passes or all open
channels have been closed.  All arguments are optional.  The <em>count</em>
parameter defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>, resulting in the loop terminating only when all
channels have been closed.  The <em>timeout</em> argument sets the timeout
parameter for the appropriate <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> or <a class="reference internal" href="select.html#select.poll" title="select.poll"><code class="xref py py-func docutils literal notranslate"><span class="pre">poll()</span></code></a>
call, measured in seconds; the default is 30 seconds.  The <em>use_poll</em>
parameter, if true, indicates that <a class="reference internal" href="select.html#select.poll" title="select.poll"><code class="xref py py-func docutils literal notranslate"><span class="pre">poll()</span></code></a> should be used in
preference to <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> (the default is <code class="docutils literal notranslate"><span class="pre">False</span></code>).</p>
<p>The <em>map</em> parameter is a dictionary whose items are the channels to watch.
As channels are closed they are deleted from their map.  If <em>map</em> is
omitted, a global map is used. Channels (instances of
<a class="reference internal" href="#asyncore.dispatcher" title="asyncore.dispatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncore.dispatcher</span></code></a>, <a class="reference internal" href="asynchat.html#asynchat.async_chat" title="asynchat.async_chat"><code class="xref py py-class docutils literal notranslate"><span class="pre">asynchat.async_chat</span></code></a> and subclasses
thereof) can freely be mixed in the map.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncore.dispatcher">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncore.</span></span><span class="sig-name descname"><span class="pre">dispatcher</span></span><a class="headerlink" href="#asyncore.dispatcher" title="本定義的永久連結">¶</a></dt>
<dd><p>The <a class="reference internal" href="#asyncore.dispatcher" title="asyncore.dispatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">dispatcher</span></code></a> class is a thin wrapper around a low-level socket
object. To make it more useful, it has a few methods for event-handling
which are called from the asynchronous loop.   Otherwise, it can be treated
as a normal non-blocking socket object.</p>
<p>The firing of low-level events at certain times or in certain connection
states tells the asynchronous loop that certain higher-level events have
taken place.  For example, if we have asked for a socket to connect to
another host, we know that the connection has been made when the socket
becomes writable for the first time (at this point you know that you may
write to it with the expectation of success).  The implied higher-level
events are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Event</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">handle_connect()</span></code></p></td>
<td><p>Implied by the first read or write
event</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">handle_close()</span></code></p></td>
<td><p>Implied by a read event with no data
available</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">handle_accepted()</span></code></p></td>
<td><p>Implied by a read event on a listening
socket</p></td>
</tr>
</tbody>
</table>
<p>During asynchronous processing, each mapped channel's <a class="reference internal" href="#asyncore.dispatcher.readable" title="asyncore.dispatcher.readable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readable()</span></code></a> and
<a class="reference internal" href="#asyncore.dispatcher.writable" title="asyncore.dispatcher.writable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writable()</span></code></a> methods are used to determine whether the channel's socket
should be added to the list of channels <code class="xref c c-func docutils literal notranslate"><span class="pre">select()</span></code>ed or
<code class="xref c c-func docutils literal notranslate"><span class="pre">poll()</span></code>ed for read and write events.</p>
<p>Thus, the set of channel events is larger than the basic socket events.  The
full set of methods that can be overridden in your subclass follows:</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.handle_read">
<span class="sig-name descname"><span class="pre">handle_read</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.handle_read" title="本定義的永久連結">¶</a></dt>
<dd><p>Called when the asynchronous loop detects that a <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> call on the
channel's socket will succeed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.handle_write">
<span class="sig-name descname"><span class="pre">handle_write</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.handle_write" title="本定義的永久連結">¶</a></dt>
<dd><p>Called when the asynchronous loop detects that a writable socket can be
written.  Often this method will implement the necessary buffering for
performance.  For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">handle_write</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">[</span><span class="n">sent</span><span class="p">:]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.handle_expt">
<span class="sig-name descname"><span class="pre">handle_expt</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.handle_expt" title="本定義的永久連結">¶</a></dt>
<dd><p>Called when there is out of band (OOB) data for a socket connection.  This
will almost never happen, as OOB is tenuously supported and rarely used.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.handle_connect">
<span class="sig-name descname"><span class="pre">handle_connect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.handle_connect" title="本定義的永久連結">¶</a></dt>
<dd><p>Called when the active opener's socket actually makes a connection.  Might
send a &quot;welcome&quot; banner, or initiate a protocol negotiation with the
remote endpoint, for example.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.handle_close">
<span class="sig-name descname"><span class="pre">handle_close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.handle_close" title="本定義的永久連結">¶</a></dt>
<dd><p>Called when the socket is closed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.handle_error">
<span class="sig-name descname"><span class="pre">handle_error</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.handle_error" title="本定義的永久連結">¶</a></dt>
<dd><p>Called when an exception is raised and not otherwise handled.  The default
version prints a condensed traceback.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.handle_accept">
<span class="sig-name descname"><span class="pre">handle_accept</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.handle_accept" title="本定義的永久連結">¶</a></dt>
<dd><p>Called on listening channels (passive openers) when a connection can be
established with a new remote endpoint that has issued a <a class="reference internal" href="#asyncore.dispatcher.connect" title="asyncore.dispatcher.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a>
call for the local endpoint. Deprecated in version 3.2; use
<a class="reference internal" href="#asyncore.dispatcher.handle_accepted" title="asyncore.dispatcher.handle_accepted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle_accepted()</span></code></a> instead.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.2 版之後被棄用.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.handle_accepted">
<span class="sig-name descname"><span class="pre">handle_accepted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">addr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.handle_accepted" title="本定義的永久連結">¶</a></dt>
<dd><p>Called on listening channels (passive openers) when a connection has been
established with a new remote endpoint that has issued a <a class="reference internal" href="#asyncore.dispatcher.connect" title="asyncore.dispatcher.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a>
call for the local endpoint.  <em>sock</em> is a <em>new</em> socket object usable to
send and receive data on the connection, and <em>addr</em> is the address
bound to the socket on the other end of the connection.</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.2 版新加入.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.readable">
<span class="sig-name descname"><span class="pre">readable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.readable" title="本定義的永久連結">¶</a></dt>
<dd><p>Called each time around the asynchronous loop to determine whether a
channel's socket should be added to the list on which read events can
occur.  The default method simply returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, indicating that by
default, all channels will be interested in read events.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.writable">
<span class="sig-name descname"><span class="pre">writable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.writable" title="本定義的永久連結">¶</a></dt>
<dd><p>Called each time around the asynchronous loop to determine whether a
channel's socket should be added to the list on which write events can
occur.  The default method simply returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, indicating that by
default, all channels will be interested in write events.</p>
</dd></dl>

<p>In addition, each channel delegates or extends many of the socket methods.
Most of these are nearly identical to their socket partners.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.create_socket">
<span class="sig-name descname"><span class="pre">create_socket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">socket.AF_INET</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">socket.SOCK_STREAM</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.create_socket" title="本定義的永久連結">¶</a></dt>
<dd><p>This is identical to the creation of a normal socket, and will use the
same options for creation.  Refer to the <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> documentation for
information on creating sockets.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版的變更: </span><em>family</em> and <em>type</em> arguments can be omitted.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.connect">
<span class="sig-name descname"><span class="pre">connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.connect" title="本定義的永久連結">¶</a></dt>
<dd><p>As with the normal socket object, <em>address</em> is a tuple with the first
element the host to connect to, and the second the port number.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.send">
<span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.send" title="本定義的永久連結">¶</a></dt>
<dd><p>Send <em>data</em> to the remote end-point of the socket.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.recv">
<span class="sig-name descname"><span class="pre">recv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.recv" title="本定義的永久連結">¶</a></dt>
<dd><p>Read at most <em>buffer_size</em> bytes from the socket's remote end-point.  An
empty bytes object implies that the channel has been closed from the
other end.</p>
<p>Note that <a class="reference internal" href="#asyncore.dispatcher.recv" title="asyncore.dispatcher.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a> may raise <a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a> , even though
<a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select.select()</span></code></a> or <a class="reference internal" href="select.html#select.poll" title="select.poll"><code class="xref py py-func docutils literal notranslate"><span class="pre">select.poll()</span></code></a> has reported the socket
ready for reading.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.listen">
<span class="sig-name descname"><span class="pre">listen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backlog</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.listen" title="本定義的永久連結">¶</a></dt>
<dd><p>Listen for connections made to the socket.  The <em>backlog</em> argument
specifies the maximum number of queued connections and should be at least
1; the maximum value is system-dependent (usually 5).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.bind">
<span class="sig-name descname"><span class="pre">bind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.bind" title="本定義的永久連結">¶</a></dt>
<dd><p>Bind the socket to <em>address</em>.  The socket must not already be bound.  (The
format of <em>address</em> depends on the address family --- refer to the
<a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> documentation for more information.)  To mark
the socket as re-usable (setting the <code class="xref py py-const docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> option), call
the <a class="reference internal" href="#asyncore.dispatcher" title="asyncore.dispatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">dispatcher</span></code></a> object's <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_reuse_addr()</span></code> method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.accept">
<span class="sig-name descname"><span class="pre">accept</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.accept" title="本定義的永久連結">¶</a></dt>
<dd><p>Accept a connection.  The socket must be bound to an address and listening
for connections.  The return value can be either <code class="docutils literal notranslate"><span class="pre">None</span></code> or a pair
<code class="docutils literal notranslate"><span class="pre">(conn,</span> <span class="pre">address)</span></code> where <em>conn</em> is a <em>new</em> socket object usable to send
and receive data on the connection, and <em>address</em> is the address bound to
the socket on the other end of the connection.
When <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned it means the connection didn't take place, in
which case the server should just ignore this event and keep listening
for further incoming connections.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncore.dispatcher.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncore.dispatcher.close" title="本定義的永久連結">¶</a></dt>
<dd><p>Close the socket.  All future operations on the socket object will fail.
The remote end-point will receive no more data (after queued data is
flushed).  Sockets are automatically closed when they are
garbage-collected.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncore.dispatcher_with_send">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncore.</span></span><span class="sig-name descname"><span class="pre">dispatcher_with_send</span></span><a class="headerlink" href="#asyncore.dispatcher_with_send" title="本定義的永久連結">¶</a></dt>
<dd><p>A <a class="reference internal" href="#asyncore.dispatcher" title="asyncore.dispatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">dispatcher</span></code></a> subclass which adds simple buffered output capability,
useful for simple clients. For more sophisticated usage use
<a class="reference internal" href="asynchat.html#asynchat.async_chat" title="asynchat.async_chat"><code class="xref py py-class docutils literal notranslate"><span class="pre">asynchat.async_chat</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncore.file_dispatcher">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncore.</span></span><span class="sig-name descname"><span class="pre">file_dispatcher</span></span><a class="headerlink" href="#asyncore.file_dispatcher" title="本定義的永久連結">¶</a></dt>
<dd><p>A file_dispatcher takes a file descriptor or <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> along
with an optional map argument and wraps it for use with the <code class="xref c c-func docutils literal notranslate"><span class="pre">poll()</span></code>
or <code class="xref c c-func docutils literal notranslate"><span class="pre">loop()</span></code> functions.  If provided a file object or anything with a
<code class="xref c c-func docutils literal notranslate"><span class="pre">fileno()</span></code> method, that method will be called and passed to the
<a class="reference internal" href="#asyncore.file_wrapper" title="asyncore.file_wrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">file_wrapper</span></code></a> constructor.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">適用</span></a>：Unix。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncore.file_wrapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncore.</span></span><span class="sig-name descname"><span class="pre">file_wrapper</span></span><a class="headerlink" href="#asyncore.file_wrapper" title="本定義的永久連結">¶</a></dt>
<dd><p>A file_wrapper takes an integer file descriptor and calls <a class="reference internal" href="os.html#os.dup" title="os.dup"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.dup()</span></code></a> to
duplicate the handle so that the original handle may be closed independently
of the file_wrapper.  This class implements sufficient methods to emulate a
socket for use by the <a class="reference internal" href="#asyncore.file_dispatcher" title="asyncore.file_dispatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">file_dispatcher</span></code></a> class.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">適用</span></a>：Unix。</p>
</div>
</dd></dl>

<section id="asyncore-example-basic-http-client">
<span id="asyncore-example-1"></span><h2>asyncore Example basic HTTP client<a class="headerlink" href="#asyncore-example-basic-http-client" title="本標頭的永久連結">¶</a></h2>
<p>Here is a very basic HTTP client that uses the <a class="reference internal" href="#asyncore.dispatcher" title="asyncore.dispatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">dispatcher</span></code></a> class to
implement its socket handling:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncore</span>

<span class="k">class</span> <span class="nc">HTTPClient</span><span class="p">(</span><span class="n">asyncore</span><span class="o">.</span><span class="n">dispatcher</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="n">asyncore</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_socket</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span> <span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="s1">&#39;GET </span><span class="si">%s</span><span class="s1"> HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: </span><span class="si">%s</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">host</span><span class="p">),</span> <span class="s1">&#39;ascii&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">handle_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">handle_read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8192</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_write</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">[</span><span class="n">sent</span><span class="p">:]</span>


<span class="n">client</span> <span class="o">=</span> <span class="n">HTTPClient</span><span class="p">(</span><span class="s1">&#39;www.python.org&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="n">asyncore</span><span class="o">.</span><span class="n">loop</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="asyncore-example-basic-echo-server">
<span id="asyncore-example-2"></span><h2>asyncore Example basic echo server<a class="headerlink" href="#asyncore-example-basic-echo-server" title="本標頭的永久連結">¶</a></h2>
<p>Here is a basic echo server that uses the <a class="reference internal" href="#asyncore.dispatcher" title="asyncore.dispatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">dispatcher</span></code></a> class to accept
connections and dispatches the incoming connections to a handler:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncore</span>

<span class="k">class</span> <span class="nc">EchoHandler</span><span class="p">(</span><span class="n">asyncore</span><span class="o">.</span><span class="n">dispatcher_with_send</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">handle_read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">EchoServer</span><span class="p">(</span><span class="n">asyncore</span><span class="o">.</span><span class="n">dispatcher</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
        <span class="n">asyncore</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_socket</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_reuse_addr</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_accepted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Incoming connection from </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
        <span class="n">handler</span> <span class="o">=</span> <span class="n">EchoHandler</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">EchoServer</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">)</span>
<span class="n">asyncore</span><span class="o">.</span><span class="n">loop</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目錄</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncore</span></code> --- 非同步 socket 處理函式</a><ul>
<li><a class="reference internal" href="#asyncore.loop"><code class="docutils literal notranslate"><span class="pre">loop()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher"><code class="docutils literal notranslate"><span class="pre">dispatcher</span></code></a><ul>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_read"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_read()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_write"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_write()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_expt"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_expt()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_connect"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_connect()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_close"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_close()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_error"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_error()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_accept"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_accept()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.handle_accepted"><code class="docutils literal notranslate"><span class="pre">dispatcher.handle_accepted()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.readable"><code class="docutils literal notranslate"><span class="pre">dispatcher.readable()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.writable"><code class="docutils literal notranslate"><span class="pre">dispatcher.writable()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.create_socket"><code class="docutils literal notranslate"><span class="pre">dispatcher.create_socket()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.connect"><code class="docutils literal notranslate"><span class="pre">dispatcher.connect()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.send"><code class="docutils literal notranslate"><span class="pre">dispatcher.send()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.recv"><code class="docutils literal notranslate"><span class="pre">dispatcher.recv()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.listen"><code class="docutils literal notranslate"><span class="pre">dispatcher.listen()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.bind"><code class="docutils literal notranslate"><span class="pre">dispatcher.bind()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.accept"><code class="docutils literal notranslate"><span class="pre">dispatcher.accept()</span></code></a></li>
<li><a class="reference internal" href="#asyncore.dispatcher.close"><code class="docutils literal notranslate"><span class="pre">dispatcher.close()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#asyncore.dispatcher_with_send"><code class="docutils literal notranslate"><span class="pre">dispatcher_with_send</span></code></a></li>
<li><a class="reference internal" href="#asyncore.file_dispatcher"><code class="docutils literal notranslate"><span class="pre">file_dispatcher</span></code></a></li>
<li><a class="reference internal" href="#asyncore.file_wrapper"><code class="docutils literal notranslate"><span class="pre">file_wrapper</span></code></a></li>
<li><a class="reference internal" href="#asyncore-example-basic-http-client">asyncore Example basic HTTP client</a></li>
<li><a class="reference internal" href="#asyncore-example-basic-echo-server">asyncore Example basic echo server</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="asynchat.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asynchat</span></code> --- 非同步 socket 指令/回應處理函式</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="audioop.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code> --- 操作原始聲音檔案</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/asyncore.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="收合側邊欄">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="audioop.html" title="audioop --- 操作原始聲音檔案"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="asynchat.html" title="asynchat --- 非同步 socket 指令/回應處理函式"
             >上一頁</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準函式庫 (Standard Library)</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="superseded.html" >已被取代的模組</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncore</span></code> --- 非同步 socket 處理函式</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版權</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最後更新於 6月 23, 2023。
    <a href="/bugs.html">Found a bug</a>?
    <br />

    使用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.0.1 建立。
    </div>

  </body>
</html>