# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Leon H., 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-23 07:52+0800\n"
"PO-Revision-Date: 2024-09-17 09:18+0800\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: ../../library/exceptions.rst:4
msgid "Built-in Exceptions"
msgstr "內建的例外"

#: ../../library/exceptions.rst:10
msgid ""
"In Python, all exceptions must be instances of a class that derives from :"
"class:`BaseException`.  In a :keyword:`try` statement with an :keyword:"
"`except` clause that mentions a particular class, that clause also handles "
"any exception classes derived from that class (but not exception classes "
"from which *it* is derived).  Two exception classes that are not related via "
"subclassing are never equivalent, even if they have the same name."
msgstr ""
"在 Python 中，所有例外必須是從 :class:`BaseException` 衍生的類別的實例。在陳"
"述式 :keyword:`try` 搭配 :keyword:`except` 子句裡提到一個特定的類別時，那個子"
"句也會處理任何從該類別衍生的例外類別（但不會處理該類別\\ *衍生自*\\ 的例外類"
"別）。兩個不是由子類別關係關聯起來的例外類別永遠不相等，就算它們有相同的名稱"
"也是如此。"

#: ../../library/exceptions.rst:19
msgid ""
"The built-in exceptions listed in this chapter can be generated by the "
"interpreter or built-in functions.  Except where mentioned, they have an "
"\"associated value\" indicating the detailed cause of the error.  This may "
"be a string or a tuple of several items of information (e.g., an error code "
"and a string explaining the code).  The associated value is usually passed "
"as arguments to the exception class's constructor."
msgstr ""
"此章節裡列出的內建例外可以從直譯器或內建函式產生。除了特別提到的地方之外，它"
"們會有一個\\ *關聯值*\\ 表示錯誤發生的詳細原因。這可能是一個字串，或者是一些"
"資訊項目組成的元組（例如一個錯誤代碼及一個解釋該代碼的字串）。這個關聯值通常"
"當作引數傳遞給例外類別的建構函式。"

#: ../../library/exceptions.rst:26
msgid ""
"User code can raise built-in exceptions.  This can be used to test an "
"exception handler or to report an error condition \"just like\" the "
"situation in which the interpreter raises the same exception; but beware "
"that there is nothing to prevent user code from raising an inappropriate "
"error."
msgstr ""
"使用者的程式碼可以引發內建例外。這可以用來測試例外處理器或者用來回報一個錯誤"
"條件，*就像*\\ 直譯器會引發相同例外的情況；但需要注意的是沒有任何方式可以避免"
"使用者的程式碼引發不適當的錯誤。"

#: ../../library/exceptions.rst:31
msgid ""
"The built-in exception classes can be subclassed to define new exceptions; "
"programmers are encouraged to derive new exceptions from the :exc:"
"`Exception` class or one of its subclasses, and not from :exc:"
"`BaseException`.  More information on defining exceptions is available in "
"the Python Tutorial under :ref:`tut-userexceptions`."
msgstr ""
"可以從內建的例外類別定義新的例外子類別；程式設計師被鼓勵從 :exc:`Exception` "
"類別或其子類別衍生新的例外，而不是從 :exc:`BaseException` 來衍生。更多關於定"
"義例外的資訊可以在 Python 教學中的\\ :ref:`tut-userexceptions`\\ 裡取得。"

#: ../../library/exceptions.rst:39
msgid "Exception context"
msgstr "例外的情境"

#: ../../library/exceptions.rst:46
msgid ""
"Three attributes on exception objects provide information about the context "
"in which the exception was raised:"
msgstr "三個例外物件上的屬性提供關於引發此例外的情境的資訊："

#: ../../library/exceptions.rst:53
msgid ""
"When raising a new exception while another exception is already being "
"handled, the new exception's :attr:`!__context__` attribute is automatically "
"set to the handled exception.  An exception may be handled when an :keyword:"
"`except` or :keyword:`finally` clause, or a :keyword:`with` statement, is "
"used."
msgstr ""
"當引發一個新的例外而同時有另一個例外已經正在被處理時，這個新例外的 :attr:`!"
"__context__` 屬性會自動被設成那個已處理的例外。當使用 :keyword:`except` 或 :"
"keyword:`finally` 子句或 :keyword:`with` 陳述式的時候例外會被處理。"

#: ../../library/exceptions.rst:59
msgid ""
"This implicit exception context can be supplemented with an explicit cause "
"by using :keyword:`!from` with :keyword:`raise`::"
msgstr ""
"這個隱含的例外情境可以透過使用 :keyword:`!from` 搭配 :keyword:`raise` 來補充"
"明確的原因： ::"

#: ../../library/exceptions.rst:63
msgid "raise new_exc from original_exc"
msgstr "raise new_exc from original_exc"

#: ../../library/exceptions.rst:65
msgid ""
"The expression following :keyword:`from<raise>` must be an exception or "
"``None``. It will be set as :attr:`!__cause__` on the raised exception. "
"Setting :attr:`!__cause__` also implicitly sets the :attr:`!"
"__suppress_context__` attribute to ``True``, so that using ``raise new_exc "
"from None`` effectively replaces the old exception with the new one for "
"display purposes (e.g. converting :exc:`KeyError` to :exc:`AttributeError`), "
"while leaving the old exception available in :attr:`!__context__` for "
"introspection when debugging."
msgstr ""
"在 :keyword:`from<raise>` 後面的運算式必須是一個例外或 ``None``。它將會被設定"
"成所引發例外的 :attr:`!__cause__`。設定 :attr:`!__cause__` 也隱含地設定 :"
"attr:`!__suppress_context__` 屬性為 ``True``，因此使用 ``raise new_exc from "
"None`` 實際上會以新的例外取代舊的例外以利於顯示（例如轉換 :exc:`KeyError` "
"為 :exc:`AttributeError`），同時保持舊的例外可以透過 :attr:`!__context__` 取"
"得以方便 debug 的時候檢查。"

#: ../../library/exceptions.rst:74
msgid ""
"The default traceback display code shows these chained exceptions in "
"addition to the traceback for the exception itself. An explicitly chained "
"exception in :attr:`!__cause__` is always shown when present. An implicitly "
"chained exception in :attr:`!__context__` is shown only if :attr:`!"
"__cause__` is :const:`None` and :attr:`!__suppress_context__` is false."
msgstr ""
"預設的回溯 (traceback) 顯示程式碼會顯示這些連鎖的例外 (chained exception) 加"
"上例外本身的回溯。當存在的時候，在 :attr:`!__cause__` 中明確地連鎖的例外總是"
"會被顯示。而在 :attr:`!__context__` 中隱含地連鎖的例外只有當 :attr:`!"
"__cause__` 是 :const:`None` 且 :attr:`!__suppress_context__` 是 false 時才會"
"顯示。"

#: ../../library/exceptions.rst:80
msgid ""
"In either case, the exception itself is always shown after any chained "
"exceptions so that the final line of the traceback always shows the last "
"exception that was raised."
msgstr ""
"在任一種情況下，例外本身總是會顯示在任何連鎖例外的後面，因此回溯的最後一列總"
"是顯示最後一個被引發的例外。"

#: ../../library/exceptions.rst:86
msgid "Inheriting from built-in exceptions"
msgstr "繼承自內建的例外"

#: ../../library/exceptions.rst:88
msgid ""
"User code can create subclasses that inherit from an exception type. It's "
"recommended to only subclass one exception type at a time to avoid any "
"possible conflicts between how the bases handle the ``args`` attribute, as "
"well as due to possible memory layout incompatibilities."
msgstr ""
"使用者的程式碼可以建立繼承自例外類型的子類別。建議一次只繼承一種例外類型以避"
"免在基底類別之間如何處理 ``args`` 屬性的任何可能衝突，以及可能的記憶體佈局 "
"(memory layout) 不相容。"

#: ../../library/exceptions.rst:95
msgid ""
"Most built-in exceptions are implemented in C for efficiency, see: :source:"
"`Objects/exceptions.c`.  Some have custom memory layouts which makes it "
"impossible to create a subclass that inherits from multiple exception types. "
"The memory layout of a type is an implementation detail and might change "
"between Python versions, leading to new conflicts in the future.  Therefore, "
"it's recommended to avoid subclassing multiple exception types altogether."
msgstr ""
"為了效率，大部分的內建例外使用 C 來實作，參考 :source:`Objects/exceptions."
"c`。一些例外有客製化的記憶體佈局，使其不可能建立一個繼承多種例外類型的子類"
"別。類型的記憶體佈局是實作細節且可能會在不同 Python 版本間改變，造成未來新的"
"衝突。因此，總之建議避免繼承多種例外類型。"

#: ../../library/exceptions.rst:105
msgid "Base classes"
msgstr "基底類別 (base classes)"

#: ../../library/exceptions.rst:107
msgid ""
"The following exceptions are used mostly as base classes for other "
"exceptions."
msgstr "以下的例外大部分被用在當作其他例外的基底類別。"

#: ../../library/exceptions.rst:111
msgid ""
"The base class for all built-in exceptions.  It is not meant to be directly "
"inherited by user-defined classes (for that, use :exc:`Exception`).  If :"
"func:`str` is called on an instance of this class, the representation of the "
"argument(s) to the instance are returned, or the empty string when there "
"were no arguments."
msgstr ""
"所有內建例外的基底類別。這不是為了讓使用者定義的類別直接繼承（可以使用 :exc:"
"`Exception`）。如果在這個類別的實例上呼叫 :func:`str`，會回傳實例的引數的表"
"示，或者沒有引數的時候會回傳空字串。"

#: ../../library/exceptions.rst:119
msgid ""
"The tuple of arguments given to the exception constructor.  Some built-in "
"exceptions (like :exc:`OSError`) expect a certain number of arguments and "
"assign a special meaning to the elements of this tuple, while others are "
"usually called only with a single string giving an error message."
msgstr ""
"提供給該例外建構函式的引數元組。一些內建的例外（像是 :exc:`OSError`）預期接受"
"特定數量的引數並賦予該元組的每一個元素一個特別的意義，其他例外則通常用一個提"
"供錯誤訊息的單一字串來呼叫。"

#: ../../library/exceptions.rst:126
msgid ""
"This method sets *tb* as the new traceback for the exception and returns the "
"exception object.  It was more commonly used before the exception chaining "
"features of :pep:`3134` became available.  The following example shows how "
"we can convert an instance of ``SomeException`` into an instance of "
"``OtherException`` while preserving the traceback.  Once raised, the current "
"frame is pushed onto the traceback of the ``OtherException``, as would have "
"happened to the traceback of the original ``SomeException`` had we allowed "
"it to propagate to the caller. ::"
msgstr ""
"此方法設定 *tb* 為該例外的新的回溯並回傳該例外物件。在 :pep:`3134` 的例外連鎖"
"功能變得可用之前，此方法曾被更普遍使用。下面的範例顯示我們如何將 "
"``SomeException`` 的實例轉換為 ``OtherException`` 的實例同時保留回溯。一旦被"
"引發，目前的 frame 會被加進 ``OtherException`` 的回溯，就像原來 "
"``SomeException`` 的回溯會發生的一樣，我們允許它被傳遞給呼叫者： ::"

#: ../../library/exceptions.rst:135
msgid ""
"try:\n"
"    ...\n"
"except SomeException:\n"
"    tb = sys.exception().__traceback__\n"
"    raise OtherException(...).with_traceback(tb)"
msgstr ""
"try:\n"
"    ...\n"
"except SomeException:\n"
"    tb = sys.exception().__traceback__\n"
"    raise OtherException(...).with_traceback(tb)"

#: ../../library/exceptions.rst:143
msgid ""
"A writable field that holds the :ref:`traceback object <traceback-objects>` "
"associated with this exception. See also: :ref:`raise`."
msgstr ""
"可寫入的欄位，儲存關聯到該例外的\\ :ref:`回溯物件 <traceback-objects>`。也可"
"以參考 :ref:`raise`。"

#: ../../library/exceptions.rst:149
msgid ""
"Add the string ``note`` to the exception's notes which appear in the "
"standard traceback after the exception string. A :exc:`TypeError` is raised "
"if ``note`` is not a string."
msgstr ""
"新增字串 ``note`` 到例外的備註，在標準的回溯裡，備註出現在例外字串的後面。如"
"果 ``note`` 不是字串則引發 :exc:`TypeError`。"

#: ../../library/exceptions.rst:157
msgid ""
"A list of the notes of this exception, which were added with :meth:"
"`add_note`. This attribute is created when :meth:`add_note` is called."
msgstr ""
"該例外的備註串列，使用 :meth:`add_note` 來新增。此屬性在 :meth:`add_note` 被"
"呼叫的時候建立。"

#: ../../library/exceptions.rst:165
msgid ""
"All built-in, non-system-exiting exceptions are derived from this class.  "
"All user-defined exceptions should also be derived from this class."
msgstr ""
"所有內建、非系統退出 (non-system-exiting) 的例外都衍生自此類別。所有使用者定"
"義的例外應該也要衍生自此類別。"

#: ../../library/exceptions.rst:171
msgid ""
"The base class for those built-in exceptions that are raised for various "
"arithmetic errors: :exc:`OverflowError`, :exc:`ZeroDivisionError`, :exc:"
"`FloatingPointError`."
msgstr ""
"各種運算錯誤所引發的那些內建例外：:exc:`OverflowError`、:exc:"
"`ZeroDivisionError`、:exc:`FloatingPointError` 的基底類別。"

#: ../../library/exceptions.rst:178
msgid ""
"Raised when a :ref:`buffer <bufferobjects>` related operation cannot be "
"performed."
msgstr ""
"當\\ :ref:`緩衝 (buffer) <bufferobjects>` 相關的操作無法被執行時會引發此例"
"外。"

#: ../../library/exceptions.rst:184
msgid ""
"The base class for the exceptions that are raised when a key or index used "
"on a mapping or sequence is invalid: :exc:`IndexError`, :exc:`KeyError`.  "
"This can be raised directly by :func:`codecs.lookup`."
msgstr ""
"當使用在對映或序列上的鍵或索引是無效的時候所引發的例外：:exc:`IndexError`、:"
"exc:`KeyError` 的基底類別。這可以被 :func:`codecs.lookup` 直接引發。"

#: ../../library/exceptions.rst:190
msgid "Concrete exceptions"
msgstr "實體例外"

#: ../../library/exceptions.rst:192
msgid "The following exceptions are the exceptions that are usually raised."
msgstr "以下的例外是通常會被引發的例外。"

#: ../../library/exceptions.rst:198
msgid "Raised when an :keyword:`assert` statement fails."
msgstr "當 :keyword:`assert` 陳述式失敗的時候被引發。"

#: ../../library/exceptions.rst:203
msgid ""
"Raised when an attribute reference (see :ref:`attribute-references`) or "
"assignment fails.  (When an object does not support attribute references or "
"attribute assignments at all, :exc:`TypeError` is raised.)"
msgstr ""
"當屬性參照（參考 :ref:`attribute-references`）或賦值失敗的時候被引發。（當物"
"件根本不支援屬性參照或屬性賦值的時候，:exc:`TypeError` 會被引發。）"

#: ../../library/exceptions.rst:207
msgid ""
"The :attr:`name` and :attr:`obj` attributes can be set using keyword-only "
"arguments to the constructor. When set they represent the name of the "
"attribute that was attempted to be accessed and the object that was accessed "
"for said attribute, respectively."
msgstr ""
":attr:`name` 和 :attr:`obj` 屬性可以使用建構函式的僅限關鍵字 (keyword-only) "
"引數來設定。當被設定的時候，它們分別代表被嘗試存取的屬性名稱以及被以該屬性存"
"取的物件。"

#: ../../library/exceptions.rst:212
msgid "Added the :attr:`name` and :attr:`obj` attributes."
msgstr "新增 :attr:`name` 與 :attr:`obj` 屬性。"

#: ../../library/exceptions.rst:217
msgid ""
"Raised when the :func:`input` function hits an end-of-file condition (EOF) "
"without reading any data. (N.B.: the :meth:`io.IOBase.read` and :meth:`io."
"IOBase.readline` methods return an empty string when they hit EOF.)"
msgstr ""
"當 :func:`input` 函式在沒有讀到任何資料而到達檔案結尾 (end-of-file, EOF) 條件"
"的時候被引發。（注意：:meth:`io.IOBase.read` 和 :meth:`io.IOBase.readline` 方"
"法當達到 EOF 時會回傳空字串。）"

#: ../../library/exceptions.rst:224
msgid "Not currently used."
msgstr "目前沒有被使用。"

#: ../../library/exceptions.rst:229
msgid ""
"Raised when a :term:`generator` or :term:`coroutine` is closed; see :meth:"
"`generator.close` and :meth:`coroutine.close`.  It directly inherits from :"
"exc:`BaseException` instead of :exc:`Exception` since it is technically not "
"an error."
msgstr ""
"當 :term:`generator` 或 :term:`coroutine` 被關閉的時候被引發；參考 :meth:"
"`generator.close` 和 :meth:`coroutine.close`。此例外直接繼承自 :exc:"
"`BaseException` 而不是 :exc:`Exception`，因為技術上來說這不是一個錯誤。"

#: ../../library/exceptions.rst:237
msgid ""
"Raised when the :keyword:`import` statement has troubles trying to load a "
"module.  Also raised when the \"from list\" in ``from ... import`` has a "
"name that cannot be found."
msgstr ""
"當 :keyword:`import` 陳述式嘗試載入模組遇到問題的時候會被引發。當 ``from ... "
"import`` 裡的 \"from list\" 包含找不到的名稱時也會被引發。"

#: ../../library/exceptions.rst:241
msgid ""
"The optional *name* and *path* keyword-only arguments set the corresponding "
"attributes:"
msgstr "可選的僅限關鍵字引數 *name* 和 *path* 設定對應的屬性："

#: ../../library/exceptions.rst:246
msgid "The name of the module that was attempted to be imported."
msgstr "嘗試引入 (import) 的模組名稱。"

#: ../../library/exceptions.rst:250
msgid "The path to any file which triggered the exception."
msgstr "觸發此例外的任何檔案的路徑。"

#: ../../library/exceptions.rst:252
msgid "Added the :attr:`name` and :attr:`path` attributes."
msgstr "新增 :attr:`name` 與 :attr:`path` 屬性。"

#: ../../library/exceptions.rst:257
msgid ""
"A subclass of :exc:`ImportError` which is raised by :keyword:`import` when a "
"module could not be located.  It is also raised when ``None`` is found in :"
"data:`sys.modules`."
msgstr ""
":exc:`ImportError` 的子類別，當模組不能被定位的時候會被 :keyword:`import` 所"
"引發。當在 :data:`sys.modules` 裡找到 ``None`` 時也會被引發。"

#: ../../library/exceptions.rst:266
msgid ""
"Raised when a sequence subscript is out of range.  (Slice indices are "
"silently truncated to fall in the allowed range; if an index is not an "
"integer, :exc:`TypeError` is raised.)"
msgstr ""
"當序列的索引超出範圍的時候會被引發。（切片索引 (slice indices) 會默默地被截短"
"使其能落在允許的範圍內；如果索引不是整數，:exc:`TypeError` 會被引發。）"

#: ../../library/exceptions.rst:275
msgid ""
"Raised when a mapping (dictionary) key is not found in the set of existing "
"keys."
msgstr "當對映（字典）的鍵無法在已存在的鍵的集合中被找到時會被引發。"

#: ../../library/exceptions.rst:282
msgid ""
"Raised when the user hits the interrupt key (normally :kbd:`Control-C` or :"
"kbd:`Delete`).  During execution, a check for interrupts is made regularly. "
"The exception inherits from :exc:`BaseException` so as to not be "
"accidentally caught by code that catches :exc:`Exception` and thus prevent "
"the interpreter from exiting."
msgstr ""
"當使用者輸入中斷鍵 (interrupt key)（一般來說是 :kbd:`Control-C` 或 :kbd:"
"`Delete`）時會被引發。在執行過程中，會定期檢查是否產生中斷。此例外繼承自 :"
"exc:`BaseException` 以防止意外地被捕捉 :exc:`Exception` 的程式碼所捕捉，而因"
"此讓直譯器無法結束。"

#: ../../library/exceptions.rst:290
msgid ""
"Catching a :exc:`KeyboardInterrupt` requires special consideration. Because "
"it can be raised at unpredictable points, it may, in some circumstances, "
"leave the running program in an inconsistent state. It is generally best to "
"allow :exc:`KeyboardInterrupt` to end the program as quickly as possible or "
"avoid raising it entirely. (See :ref:`handlers-and-exceptions`.)"
msgstr ""
"捕捉 :exc:`KeyboardInterrupt` 需要特殊的考量。因為它可以在無法預期的時間點被"
"引發，可能在某些情況下讓正在跑的程式處在一個不一致的狀態。一般來說最好讓 :"
"exc:`KeyboardInterrupt` 越快結束程式越好，或者完全避免引發它。（參考 :ref:"
"`handlers-and-exceptions`。）"

#: ../../library/exceptions.rst:300
msgid ""
"Raised when an operation runs out of memory but the situation may still be "
"rescued (by deleting some objects).  The associated value is a string "
"indicating what kind of (internal) operation ran out of memory. Note that "
"because of the underlying memory management architecture (C's :c:func:"
"`malloc` function), the interpreter may not always be able to completely "
"recover from this situation; it nevertheless raises an exception so that a "
"stack traceback can be printed, in case a run-away program was the cause."
msgstr ""
"當一個操作用光了記憶體但情況還可能被修復 (rescued)（透過刪除一些物件）的時候"
"被引發。關聯值是一個字串，表示什麼類型的（內部）操作用光了記憶體。需注意的是"
"因為底層的記憶體管理架構（C 的 :c:func:`malloc` 函式），直譯器可能無法總是完"
"整地從該情況中修復；僅管如此，它還是引發例外以讓堆疊回溯可以被印出，以防原因"
"出在失控的程式。"

#: ../../library/exceptions.rst:311
msgid ""
"Raised when a local or global name is not found.  This applies only to "
"unqualified names.  The associated value is an error message that includes "
"the name that could not be found."
msgstr ""
"當找不到本地或全域的名稱時會被引發。這只應用在不合格的名稱 (unqualified "
"name) 上。關聯值是一個錯誤訊息，包含那個無法被找到的名稱。"

#: ../../library/exceptions.rst:315
msgid ""
"The :attr:`name` attribute can be set using a keyword-only argument to the "
"constructor. When set it represent the name of the variable that was "
"attempted to be accessed."
msgstr ""
":attr:`name` 屬性可以使用僅限關鍵字引數來設定到建構函式。當被設定的時候它代表"
"被嘗試存取的變數名稱。"

#: ../../library/exceptions.rst:319
msgid "Added the :attr:`name` attribute."
msgstr "新增 :attr:`name` 屬性。"

#: ../../library/exceptions.rst:325
msgid ""
"This exception is derived from :exc:`RuntimeError`.  In user defined base "
"classes, abstract methods should raise this exception when they require "
"derived classes to override the method, or while the class is being "
"developed to indicate that the real implementation still needs to be added."
msgstr ""
"此例外衍生自 :exc:`RuntimeError`。在使用者定義的基礎類別裡，當抽象方法要求衍"
"生類別覆寫該方法時應該要引發此例外，或者當類別正在開發中，可用此例外表示還需"
"要加入真正的實作。"

#: ../../library/exceptions.rst:332
msgid ""
"It should not be used to indicate that an operator or method is not meant to "
"be supported at all -- in that case either leave the operator / method "
"undefined or, if a subclass, set it to :data:`None`."
msgstr ""
"此例外不應該用來表示根本沒有要支援的運算子或方法 ── 在這個情況下可以讓該運算"
"子或方法保持未定義，或者如果是子類別的話將其設成 :data:`None`。"

#: ../../library/exceptions.rst:338
msgid ""
"``NotImplementedError`` and :data:`NotImplemented` are not interchangeable, "
"even though they have similar names and purposes.  See :data:`!"
"NotImplemented` for details on when to use it."
msgstr ""
"``NotImplementedError`` 和 :data:`NotImplemented` 雖然有相似的名稱和目的但並"
"不是可互換的。參考 :data:`!NotImplemented` 裡關於何時使用的細節。"

#: ../../library/exceptions.rst:347
msgid ""
"This exception is raised when a system function returns a system-related "
"error, including I/O failures such as \"file not found\" or \"disk full\" "
"(not for illegal argument types or other incidental errors)."
msgstr ""
"當系統函式回傳系統相關錯誤，包含像\"找不到檔案\"或\"硬碟已滿\"的 I/O 失敗會引"
"發此例外（而非不合法的引數或其他次要的錯誤）。"

#: ../../library/exceptions.rst:351
msgid ""
"The second form of the constructor sets the corresponding attributes, "
"described below.  The attributes default to :const:`None` if not specified.  "
"For backwards compatibility, if three arguments are passed, the :attr:"
"`~BaseException.args` attribute contains only a 2-tuple of the first two "
"constructor arguments."
msgstr ""
"建構函式的第二種形式會設定以下描述的相對應屬性。如果沒有給定則屬性預設為 :"
"const:`None`。為了向後相容，如果傳入三個引數，:attr:`~BaseException.args` 屬"
"性只會是包含建構函式前兩個引數的雙元素元組。"

#: ../../library/exceptions.rst:357
msgid ""
"The constructor often actually returns a subclass of :exc:`OSError`, as "
"described in `OS exceptions`_ below.  The particular subclass depends on the "
"final :attr:`.errno` value.  This behaviour only occurs when constructing :"
"exc:`OSError` directly or via an alias, and is not inherited when "
"subclassing."
msgstr ""
"如同下面的\\ `作業系統例外 <OS exceptions_>`_\\ 所描述，實際上建構函式通常回"
"傳 :exc:`OSError` 的子類別。會依據最後 :attr:`.errno` 的值決定特定子類別。這"
"個行為只發生在直接建構 :exc:`OSError` 或透過別名，且產生子類別的時候不會被繼"
"承。"

#: ../../library/exceptions.rst:365
msgid "A numeric error code from the C variable :c:data:`errno`."
msgstr "從 C 變數 :c:data:`errno` 而來的數值錯誤代碼。"

#: ../../library/exceptions.rst:369
msgid ""
"Under Windows, this gives you the native Windows error code.  The :attr:`."
"errno` attribute is then an approximate translation, in POSIX terms, of that "
"native error code."
msgstr ""
"在 Windows 下，這會提供你原生的 Windows 錯誤代碼。而 :attr:`.errno` 屬性是一"
"個該原生錯誤代碼對於 POSIX 來說的近似翻譯。"

#: ../../library/exceptions.rst:373
msgid ""
"Under Windows, if the *winerror* constructor argument is an integer, the :"
"attr:`.errno` attribute is determined from the Windows error code, and the "
"*errno* argument is ignored.  On other platforms, the *winerror* argument is "
"ignored, and the :attr:`winerror` attribute does not exist."
msgstr ""
"在 Windows 下，如果建構函式引數 *winerror* 是整數，則 :attr:`.errno` 屬性會根"
"據該 Windows 錯誤代碼來決定，且 *errno* 引數會被忽略。在其他平台上，"
"*winerror* 引數會被忽略，而 :attr:`winerror` 屬性會不存在。"

#: ../../library/exceptions.rst:381
msgid ""
"The corresponding error message, as provided by the operating system.  It is "
"formatted by the C functions :c:func:`perror` under POSIX, and :c:func:"
"`FormatMessage` under Windows."
msgstr ""
"作業系統提供的對應錯誤訊息。在 POSIX 下會使用 C 函式 :c:func:`perror` 做格式"
"化，而在 Windows 下會使用 :c:func:`FormatMessage`。"

#: ../../library/exceptions.rst:389
msgid ""
"For exceptions that involve a file system path (such as :func:`open` or :"
"func:`os.unlink`), :attr:`filename` is the file name passed to the function. "
"For functions that involve two file system paths (such as :func:`os."
"rename`), :attr:`filename2` corresponds to the second file name passed to "
"the function."
msgstr ""
"對於包含檔案系統路徑的例外（像是 :func:`open` 或 :func:`os.unlink`），:attr:"
"`filename` 是傳入函式的檔案名稱。對於包含兩個檔案系統路徑的函式（像是 :func:"
"`os.rename`），:attr:`filename2` 對應到傳入函式的第二個檔案名稱。"

#: ../../library/exceptions.rst:396
msgid ""
":exc:`EnvironmentError`, :exc:`IOError`, :exc:`WindowsError`, :exc:`socket."
"error`, :exc:`select.error` and :exc:`mmap.error` have been merged into :exc:"
"`OSError`, and the constructor may return a subclass."
msgstr ""
":exc:`EnvironmentError`、:exc:`IOError`、:exc:`WindowsError`、:exc:`socket."
"error`、:exc:`select.error` 及 :exc:`mmap.error` 已合併進 :exc:`OSError`，而"
"建構函式可能會回傳子類別。"

#: ../../library/exceptions.rst:402
msgid ""
"The :attr:`filename` attribute is now the original file name passed to the "
"function, instead of the name encoded to or decoded from the :term:"
"`filesystem encoding and error handler`. Also, the *filename2* constructor "
"argument and attribute was added."
msgstr ""
":attr:`filename` 屬性現在是傳入函式的原始檔名，而不是從\\ :term:`檔案系統編碼"
"和錯誤處理函式 <filesystem encoding and error handler>`\\ 編碼或解碼過的名"
"稱。並且新增 *filename2* 建構函式引數與屬性。"

#: ../../library/exceptions.rst:411
msgid ""
"Raised when the result of an arithmetic operation is too large to be "
"represented.  This cannot occur for integers (which would rather raise :exc:"
"`MemoryError` than give up).  However, for historical reasons, OverflowError "
"is sometimes raised for integers that are outside a required range.   "
"Because of the lack of standardization of floating-point exception handling "
"in C, most floating-point operations are not checked."
msgstr ""
"當運算操作的結果太大而無法表示的時候會引發此例外。這不會發生在整數上（會改成"
"引發 :exc:`MemoryError` 而不是放棄）。然而，因為一些歷史因素，OverflowError "
"有時候會因為整數在要求範圍之外而引發。因為在 C 裡面缺乏浮點數例外處理的標準"
"化，大部分的浮點數運算都沒有被檢查。"

#: ../../library/exceptions.rst:421
#, fuzzy
msgid ""
"This exception is derived from :exc:`RuntimeError`.  It is raised when an "
"operation is blocked during interpreter shutdown also known as :term:`Python "
"finalization <interpreter shutdown>`."
msgstr ""
"此例外衍生自 :exc:`RuntimeError`。當直譯器偵測到超過最大的遞迴深度（參考 :"
"func:`sys.getrecursionlimit`）時會引發此例外。"

#: ../../library/exceptions.rst:425
msgid ""
"Examples of operations which can be blocked with a :exc:"
"`PythonFinalizationError` during the Python finalization:"
msgstr ""

#: ../../library/exceptions.rst:428
msgid "Creating a new Python thread."
msgstr ""

#: ../../library/exceptions.rst:429
msgid ":func:`os.fork`."
msgstr ":func:`os.fork`。"

#: ../../library/exceptions.rst:431
msgid "See also the :func:`sys.is_finalizing` function."
msgstr ""

#: ../../library/exceptions.rst:433 ../../library/exceptions.rst:443
msgid "Previously, a plain :exc:`RuntimeError` was raised."
msgstr "在之前，會引發一般的 :exc:`RuntimeError`。"

#: ../../library/exceptions.rst:439
msgid ""
"This exception is derived from :exc:`RuntimeError`.  It is raised when the "
"interpreter detects that the maximum recursion depth (see :func:`sys."
"getrecursionlimit`) is exceeded."
msgstr ""
"此例外衍生自 :exc:`RuntimeError`。當直譯器偵測到超過最大的遞迴深度（參考 :"
"func:`sys.getrecursionlimit`）時會引發此例外。"

#: ../../library/exceptions.rst:449
msgid ""
"This exception is raised when a weak reference proxy, created by the :func:"
"`weakref.proxy` function, is used to access an attribute of the referent "
"after it has been garbage collected. For more information on weak "
"references, see the :mod:`weakref` module."
msgstr ""
"當一個被 :func:`weakref.proxy` 函式建立的弱參照代理 (weak reference proxy) 被"
"用來存取已經被垃圾回收 (garbage collected) 的參照物屬性時會引發此例外。更多關"
"於弱參照的資訊參考 :mod:`weakref` 模組。"

#: ../../library/exceptions.rst:457
msgid ""
"Raised when an error is detected that doesn't fall in any of the other "
"categories.  The associated value is a string indicating what precisely went "
"wrong."
msgstr ""
"當偵測到一個不屬於任何其他種類的錯誤時會引發此例外。關聯值是一個表示確切什麼"
"地方出錯的字串。"

#: ../../library/exceptions.rst:464
msgid ""
"Raised by built-in function :func:`next` and an :term:`iterator`\\'s :meth:"
"`~iterator.__next__` method to signal that there are no further items "
"produced by the iterator."
msgstr ""
"會被內建函式 :func:`next` 及 :term:`iterator` 的 :meth:`~iterator.__next__` "
"方法引發，用來表示疊代器沒有更多項目可以產生。"

#: ../../library/exceptions.rst:470
msgid ""
"The exception object has a single attribute :attr:`!value`, which is given "
"as an argument when constructing the exception, and defaults to :const:"
"`None`."
msgstr ""
"此例外物件有單一屬性 :attr:`!value`，當建構此例外時會以引數給定，預設為 :"
"const:`None`。"

#: ../../library/exceptions.rst:474
msgid ""
"When a :term:`generator` or :term:`coroutine` function returns, a new :exc:"
"`StopIteration` instance is raised, and the value returned by the function "
"is used as the :attr:`value` parameter to the constructor of the exception."
msgstr ""
"當 :term:`generator` 或 :term:`coroutine` 函式回傳時，新的 :exc:"
"`StopIteration` 實例會被引發，而該函式的回傳值會被用來當作此例外建構函式的 :"
"attr:`value` 參數。"

#: ../../library/exceptions.rst:479
msgid ""
"If a generator code directly or indirectly raises :exc:`StopIteration`, it "
"is converted into a :exc:`RuntimeError` (retaining the :exc:`StopIteration` "
"as the new exception's cause)."
msgstr ""
"如果產生器程式直接或間接引發 :exc:`StopIteration`，則其會被轉換成 :exc:"
"`RuntimeError`\\ （保留 :exc:`StopIteration` 作為新例外的成因）。"

#: ../../library/exceptions.rst:483
msgid ""
"Added ``value`` attribute and the ability for generator functions to use it "
"to return a value."
msgstr "新增 ``value`` 屬性且產生器函式可以用它來回傳值。"

#: ../../library/exceptions.rst:487
msgid ""
"Introduced the RuntimeError transformation via ``from __future__ import "
"generator_stop``, see :pep:`479`."
msgstr ""
"透過 ``from __future__ import generator_stop`` 引入 RuntimeError 的轉換，參"
"考 :pep:`479`。"

#: ../../library/exceptions.rst:491
msgid ""
"Enable :pep:`479` for all code by default: a :exc:`StopIteration` error "
"raised in a generator is transformed into a :exc:`RuntimeError`."
msgstr ""
"預設對所有程式啟用 :pep:`479`：在產生器引發的 :exc:`StopIteration` 錯誤會轉換"
"成 :exc:`RuntimeError`。"

#: ../../library/exceptions.rst:497
msgid ""
"Must be raised by :meth:`~object.__anext__` method of an :term:`asynchronous "
"iterator` object to stop the iteration."
msgstr ""
"此例外必須被 :term:`asynchronous iterator` 物件的 :meth:`~object.__anext__` "
"方法引發來停止疊代。"

#: ../../library/exceptions.rst:504
msgid ""
"Raised when the parser encounters a syntax error.  This may occur in an :"
"keyword:`import` statement, in a call to the built-in functions :func:"
"`compile`, :func:`exec`, or :func:`eval`, or when reading the initial script "
"or standard input (also interactively)."
msgstr ""
"當剖析器遇到語法錯誤時會引發此例外。這可能發生在 :keyword:`import` 陳述式、在"
"呼叫內建函式 :func:`compile`、:func:`exec` 或 :func:`eval` 的時候，或者在讀取"
"初始腳本或標準輸入（也包含互動式）的時候。"

#: ../../library/exceptions.rst:510
msgid ""
"The :func:`str` of the exception instance returns only the error message. "
"Details is a tuple whose members are also available as separate attributes."
msgstr ""
"例外實例的 :func:`str` 只回傳錯誤訊息。Details 是個元組，其成員也能夠以分開的"
"屬性取得。"

#: ../../library/exceptions.rst:515
msgid "The name of the file the syntax error occurred in."
msgstr "發生語法錯誤所在的檔案名稱。"

#: ../../library/exceptions.rst:519
msgid ""
"Which line number in the file the error occurred in. This is 1-indexed: the "
"first line in the file has a ``lineno`` of 1."
msgstr ""
"發生錯誤所在檔案的列號。這是以 1 開始的索引：檔案第一列的 ``lineno`` 是 1。"

#: ../../library/exceptions.rst:524
msgid ""
"The column in the line where the error occurred. This is 1-indexed: the "
"first character in the line has an ``offset`` of 1."
msgstr ""
"發生錯誤所在該列的欄號 (column)。這是以 1 開始的索引：該列第一個字元的 "
"``offset`` 是 1。"

#: ../../library/exceptions.rst:529
msgid "The source code text involved in the error."
msgstr "涉及該錯誤的原始程式碼文字。"

#: ../../library/exceptions.rst:533
msgid ""
"Which line number in the file the error occurred ends in. This is 1-indexed: "
"the first line in the file has a ``lineno`` of 1."
msgstr ""
"發生錯誤所在檔案的結束列號。這是以 1 開始的索引：檔案第一列的 ``lineno`` 是 "
"1。"

#: ../../library/exceptions.rst:538
msgid ""
"The column in the end line where the error occurred finishes. This is 1-"
"indexed: the first character in the line has an ``offset`` of 1."
msgstr ""
"發生錯誤所在該結束列的欄號。這是以 1 開始的索引：該列第一個字元的 ``offset`` "
"是 1。"

#: ../../library/exceptions.rst:541
msgid ""
"For errors in f-string fields, the message is prefixed by \"f-string: \" and "
"the offsets are offsets in a text constructed from the replacement "
"expression.  For example, compiling f'Bad {a b} field' results in this args "
"attribute: ('f-string: ...', ('', 1, 2, '(a b)\\n', 1, 5))."
msgstr ""
"對於發生在 f-string 欄位的錯誤，訊息會以 \"f-string: \" 為前綴，而偏移量 "
"(offset) 是從替代表達式建構的文字的偏移量。例如編譯 f'Bad {a b} field' 會得到"
"這個 args 屬性：('f-string: ...', ('', 1, 2, '(a b)\\n', 1, 5))。"

#: ../../library/exceptions.rst:546
msgid "Added the :attr:`end_lineno` and :attr:`end_offset` attributes."
msgstr "新增 :attr:`end_lineno` 與 :attr:`end_offset` 屬性。"

#: ../../library/exceptions.rst:551
msgid ""
"Base class for syntax errors related to incorrect indentation.  This is a "
"subclass of :exc:`SyntaxError`."
msgstr ""
"與不正確的縮排有關的語法錯誤的基礎類別。這是 :exc:`SyntaxError` 的子類別。"

#: ../../library/exceptions.rst:557
msgid ""
"Raised when indentation contains an inconsistent use of tabs and spaces. "
"This is a subclass of :exc:`IndentationError`."
msgstr ""
"當縮排包含製表符號 (tab) 和空白的不一致用法時會引發此例外。這是 :exc:"
"`IndentationError` 的子類別。"

#: ../../library/exceptions.rst:563
msgid ""
"Raised when the interpreter finds an internal error, but the situation does "
"not look so serious to cause it to abandon all hope. The associated value is "
"a string indicating what went wrong (in low-level terms)."
msgstr ""
"當直譯器找到一個內部錯誤，但該情況看起來沒有嚴重到要讓它放棄所有的希望時會引"
"發此例外。關聯值是一個表示什麼地方出錯的字串（以低階的方式表達）。"

#: ../../library/exceptions.rst:567
msgid ""
"You should report this to the author or maintainer of your Python "
"interpreter. Be sure to report the version of the Python interpreter (``sys."
"version``; it is also printed at the start of an interactive Python "
"session), the exact error message (the exception's associated value) and if "
"possible the source of the program that triggered the error."
msgstr ""
"你應該向你的 Python 直譯器作者或維護者回報此錯誤。務必要回報該 Python 直譯器"
"的版本（``sys.version``；這也會在互動式 Python 會話的開頭被印出）、確切的錯誤"
"訊息（該例外的關聯值）及如果可能的話，觸發此錯誤的程式來源。"

#: ../../library/exceptions.rst:576
msgid ""
"This exception is raised by the :func:`sys.exit` function.  It inherits "
"from :exc:`BaseException` instead of :exc:`Exception` so that it is not "
"accidentally caught by code that catches :exc:`Exception`.  This allows the "
"exception to properly propagate up and cause the interpreter to exit.  When "
"it is not handled, the Python interpreter exits; no stack traceback is "
"printed.  The constructor accepts the same optional argument passed to :func:"
"`sys.exit`. If the value is an integer, it specifies the system exit status "
"(passed to C's :c:func:`exit` function); if it is ``None``, the exit status "
"is zero; if it has another type (such as a string), the object's value is "
"printed and the exit status is one."
msgstr ""
"此例外會被 :func:`sys.exit` 函式引發。它繼承自 :exc:`BaseException` 而不是 :"
"exc:`Exception` 因此不會被捕捉 :exc:`Exception` 的程式意外地捕捉。這允許例外"
"可以正確地向上傳遞並導致直譯器結束。當它未被處理時，Python 直譯器會結束；不會"
"印出堆疊回溯。建構函式接受跟傳入 :func:`sys.exit` 一樣的可選引數。如果該值是"
"整數，它會指定系統的結束狀態（傳入 C 的 :c:func:`exit` 函式 ）；如果它是 "
"``None``，結束狀態會是 0；如果它是其他類型（例如字串），則物件的值會被印出而"
"結束狀態是 1。"

#: ../../library/exceptions.rst:587
msgid ""
"A call to :func:`sys.exit` is translated into an exception so that clean-up "
"handlers (:keyword:`finally` clauses of :keyword:`try` statements) can be "
"executed, and so that a debugger can execute a script without running the "
"risk of losing control.  The :func:`os._exit` function can be used if it is "
"absolutely positively necessary to exit immediately (for example, in the "
"child process after a call to :func:`os.fork`)."
msgstr ""
"對 :func:`sys.exit` 的呼叫會轉譯成例外讓負責清理的處理函式（:keyword:`try` 陳"
"述式的 :keyword:`finally` 子句）可以被執行，且讓除錯器可以在不冒著失去控制的"
"風險下執行腳本。如果在絕對有必要立即結束的情況（例如在子行程呼叫完 :func:`os."
"fork` 之後 ）可以使用 :func:`os._exit` 函式。"

#: ../../library/exceptions.rst:596
msgid ""
"The exit status or error message that is passed to the constructor. "
"(Defaults to ``None``.)"
msgstr "傳入建構函式的結束狀態或錯誤訊息。（預設是 ``None``。 ）"

#: ../../library/exceptions.rst:602
msgid ""
"Raised when an operation or function is applied to an object of "
"inappropriate type.  The associated value is a string giving details about "
"the type mismatch."
msgstr ""
"當一個操作或函式被用在不適合的類型的物件時會引發此例外。關聯值是一個字串，提"
"供關於不相符類型的細節。"

#: ../../library/exceptions.rst:605
msgid ""
"This exception may be raised by user code to indicate that an attempted "
"operation on an object is not supported, and is not meant to be. If an "
"object is meant to support a given operation but has not yet provided an "
"implementation, :exc:`NotImplementedError` is the proper exception to raise."
msgstr ""
"此例外可能被使用者程式碼引發，以表示並不支援物件上所嘗試的操作，且本來就無意"
"這樣做。如果一個物件有意要支援某個給定的操作但尚未提供實作，該引發的正確例外"
"是 :exc:`NotImplementedError`。"

#: ../../library/exceptions.rst:610
msgid ""
"Passing arguments of the wrong type (e.g. passing a :class:`list` when an :"
"class:`int` is expected) should result in a :exc:`TypeError`, but passing "
"arguments with the wrong value (e.g. a number outside expected boundaries) "
"should result in a :exc:`ValueError`."
msgstr ""
"傳入錯誤類型的引數（例如當預期傳入 :class:`int` 卻傳入 :class:`list`）應該要"
"導致 :exc:`TypeError`，但傳入帶有錯誤值的引數（例如超出預期範圍的數值）應該要"
"導致 :exc:`ValueError`。"

#: ../../library/exceptions.rst:617
msgid ""
"Raised when a reference is made to a local variable in a function or method, "
"but no value has been bound to that variable.  This is a subclass of :exc:"
"`NameError`."
msgstr ""
"當在函式或方法裡引用某個區域變數，但該變數尚未被繫結到任何值的時候會引發此例"
"外。這是 :exc:`NameError` 的子類別。"

#: ../../library/exceptions.rst:624
msgid ""
"Raised when a Unicode-related encoding or decoding error occurs.  It is a "
"subclass of :exc:`ValueError`."
msgstr ""
"當 Unicode 相關的編碼或解碼錯誤發生時會引發此例外。這是 :exc:`ValueError` 的"
"子類別。"

#: ../../library/exceptions.rst:627
msgid ""
":exc:`UnicodeError` has attributes that describe the encoding or decoding "
"error.  For example, ``err.object[err.start:err.end]`` gives the particular "
"invalid input that the codec failed on."
msgstr ""
":exc:`UnicodeError` 有屬性描述編碼或解碼錯誤。例如 ``err.object[err.start:"
"err.end]`` 會提供讓編解碼器失敗的具體無效輸入。"

#: ../../library/exceptions.rst:633
msgid "The name of the encoding that raised the error."
msgstr "引發錯誤的編碼名稱。"

#: ../../library/exceptions.rst:637
msgid "A string describing the specific codec error."
msgstr "描述特定編解碼器錯誤的字串。"

#: ../../library/exceptions.rst:641
msgid "The object the codec was attempting to encode or decode."
msgstr "編解碼器嘗試編碼或解碼的物件。"

#: ../../library/exceptions.rst:645
msgid "The first index of invalid data in :attr:`object`."
msgstr "在 :attr:`object` 中無效資料的開始索引。"

#: ../../library/exceptions.rst:649
msgid "The index after the last invalid data in :attr:`object`."
msgstr "在 :attr:`object` 中最後的無效資料後的索引。"

#: ../../library/exceptions.rst:654
msgid ""
"Raised when a Unicode-related error occurs during encoding.  It is a "
"subclass of :exc:`UnicodeError`."
msgstr ""
"在編碼當中發生 Unicode 相關錯誤時會引發此例外。這是 :exc:`UnicodeError` 的子"
"類別。"

#: ../../library/exceptions.rst:660
msgid ""
"Raised when a Unicode-related error occurs during decoding.  It is a "
"subclass of :exc:`UnicodeError`."
msgstr ""
"在解碼當中發生 Unicode 相關錯誤時會引發此例外。這是 :exc:`UnicodeError` 的子"
"類別。"

#: ../../library/exceptions.rst:666
msgid ""
"Raised when a Unicode-related error occurs during translating.  It is a "
"subclass of :exc:`UnicodeError`."
msgstr ""
"在轉譯當中發生 Unicode 相關錯誤時會引發此例外。這是 :exc:`UnicodeError` 的子"
"類別。"

#: ../../library/exceptions.rst:672
msgid ""
"Raised when an operation or function receives an argument that has the right "
"type but an inappropriate value, and the situation is not described by a "
"more precise exception such as :exc:`IndexError`."
msgstr ""
"當一個操作或函式收到引數是正確類型但是不適合的值，且該情況無法被更精確的例外"
"例如 :exc:`IndexError` 所描述時會引發此例外。"

#: ../../library/exceptions.rst:679
msgid ""
"Raised when the second argument of a division or modulo operation is zero.  "
"The associated value is a string indicating the type of the operands and the "
"operation."
msgstr ""
"當除法或模數運算 (modulo operation) 的第二個引數是 0 的時候會引發此例外。關聯"
"值是一個字串，表示運算元及運算的類型。"

#: ../../library/exceptions.rst:684
msgid ""
"The following exceptions are kept for compatibility with previous versions; "
"starting from Python 3.3, they are aliases of :exc:`OSError`."
msgstr ""
"以下例外是為了相容於之前版本而保留；從 Python 3.3 開始，它們是 :exc:"
"`OSError` 的別名。"

#: ../../library/exceptions.rst:693
msgid "Only available on Windows."
msgstr "僅限於在 Windows 中使用。"

#: ../../library/exceptions.rst:697
msgid "OS exceptions"
msgstr "作業系統例外"

#: ../../library/exceptions.rst:699
msgid ""
"The following exceptions are subclasses of :exc:`OSError`, they get raised "
"depending on the system error code."
msgstr "以下的例外是 :exc:`OSError` 的子類別，它們根據系統錯誤代碼來引發。"

#: ../../library/exceptions.rst:704
msgid ""
"Raised when an operation would block on an object (e.g. socket) set for non-"
"blocking operation. Corresponds to :c:data:`errno` :py:const:`~errno."
"EAGAIN`, :py:const:`~errno.EALREADY`, :py:const:`~errno.EWOULDBLOCK` and :py:"
"const:`~errno.EINPROGRESS`."
msgstr ""
"當設置為非阻塞操作的物件（例如 socket）上的操作將要阻塞時會引發此例外。對應"
"到 :c:data:`errno` :py:const:`~errno.EAGAIN`、:py:const:`~errno.EALREADY`、:"
"py:const:`~errno.EWOULDBLOCK` 及 :py:const:`~errno.EINPROGRESS`。"

#: ../../library/exceptions.rst:709
msgid ""
"In addition to those of :exc:`OSError`, :exc:`BlockingIOError` can have one "
"more attribute:"
msgstr ""
"除了 :exc:`OSError` 的那些屬性之外，:exc:`BlockingIOError` 有多一個屬性："

#: ../../library/exceptions.rst:714
msgid ""
"An integer containing the number of characters written to the stream before "
"it blocked.  This attribute is available when using the buffered I/O classes "
"from the :mod:`io` module."
msgstr ""
"一個整數，內容為在其阻塞之前，已寫進串流的字元數。當使用 :mod:`io` 模組裡的緩"
"衝 I/O 類別時這個屬性是可用的。"

#: ../../library/exceptions.rst:720
msgid ""
"Raised when an operation on a child process failed. Corresponds to :c:data:"
"`errno` :py:const:`~errno.ECHILD`."
msgstr ""
"當子行程上的操作失敗時會引發此例外。對應到 :c:data:`errno` :py:const:`~errno."
"ECHILD`。"

#: ../../library/exceptions.rst:725
msgid "A base class for connection-related issues."
msgstr "連線相關問題的基礎類別。"

#: ../../library/exceptions.rst:727
msgid ""
"Subclasses are :exc:`BrokenPipeError`, :exc:`ConnectionAbortedError`, :exc:"
"`ConnectionRefusedError` and :exc:`ConnectionResetError`."
msgstr ""
"子類別有 :exc:`BrokenPipeError`、:exc:`ConnectionAbortedError`、:exc:"
"`ConnectionRefusedError` 及 :exc:`ConnectionResetError`。"

#: ../../library/exceptions.rst:732
msgid ""
"A subclass of :exc:`ConnectionError`, raised when trying to write on a pipe "
"while the other end has been closed, or trying to write on a socket which "
"has been shutdown for writing. Corresponds to :c:data:`errno` :py:const:"
"`~errno.EPIPE` and :py:const:`~errno.ESHUTDOWN`."
msgstr ""
":exc:`ConnectionError` 的子類別，當嘗試寫入管道 (pipe) 同時另一端已經被關閉時"
"會引發此例外，或者當嘗試寫入已關閉寫入的 socket 時也會引發。對應到 :c:data:"
"`errno` :py:const:`~errno.EPIPE` 及 :py:const:`~errno.ESHUTDOWN`。"

#: ../../library/exceptions.rst:739
msgid ""
"A subclass of :exc:`ConnectionError`, raised when a connection attempt is "
"aborted by the peer. Corresponds to :c:data:`errno` :py:const:`~errno."
"ECONNABORTED`."
msgstr ""
":exc:`ConnectionError` 的子類別。當一個連線的嘗試被對等端點 (peer) 中斷時會引"
"發此例外。對應到 :c:data:`errno` :py:const:`~errno.ECONNABORTED`。"

#: ../../library/exceptions.rst:745
msgid ""
"A subclass of :exc:`ConnectionError`, raised when a connection attempt is "
"refused by the peer. Corresponds to :c:data:`errno` :py:const:`~errno."
"ECONNREFUSED`."
msgstr ""
":exc:`ConnectionError` 的子類別。當一個連線的嘗試被對等端點拒絕時會引發此例"
"外。對應到 :c:data:`errno` :py:const:`~errno.ECONNREFUSED`。"

#: ../../library/exceptions.rst:751
msgid ""
"A subclass of :exc:`ConnectionError`, raised when a connection is reset by "
"the peer. Corresponds to :c:data:`errno` :py:const:`~errno.ECONNRESET`."
msgstr ""
":exc:`ConnectionError` 的子類別。當一個連線被對等端點重置時會引發此例外。對應"
"到 :c:data:`errno` :py:const:`~errno.ECONNRESET`。"

#: ../../library/exceptions.rst:757
msgid ""
"Raised when trying to create a file or directory which already exists. "
"Corresponds to :c:data:`errno` :py:const:`~errno.EEXIST`."
msgstr ""
"當嘗試建立已存在的檔案或目錄時會引發此例外。對應到 :c:data:`errno` :py:const:"
"`~errno.EEXIST`。"

#: ../../library/exceptions.rst:762
msgid ""
"Raised when a file or directory is requested but doesn't exist. Corresponds "
"to :c:data:`errno` :py:const:`~errno.ENOENT`."
msgstr ""
"當請求不存在的檔案或目錄時會引發此例外。對應到 :c:data:`errno` :py:const:"
"`~errno.ENOENT`。"

#: ../../library/exceptions.rst:767
msgid ""
"Raised when a system call is interrupted by an incoming signal. Corresponds "
"to :c:data:`errno` :py:const:`~errno.EINTR`."
msgstr ""
"當系統呼叫被傳入的信號中斷時會引發此例外。對應到 :c:data:`errno` :py:const:"
"`~errno.EINTR`。"

#: ../../library/exceptions.rst:770
msgid ""
"Python now retries system calls when a syscall is interrupted by a signal, "
"except if the signal handler raises an exception (see :pep:`475` for the "
"rationale), instead of raising :exc:`InterruptedError`."
msgstr ""
"現在當 syscall 被信號中斷時 Python 會重試系統呼叫而不會引發 :exc:"
"`InterruptedError`，除非信號處理器引發例外（理由可參考 :pep:`475`）。"

#: ../../library/exceptions.rst:777
msgid ""
"Raised when a file operation (such as :func:`os.remove`) is requested on a "
"directory. Corresponds to :c:data:`errno` :py:const:`~errno.EISDIR`."
msgstr ""
"當在目錄上請求檔案操作（例如 :func:`os.remove`）時會引發此例外。對應到 :c:"
"data:`errno` :py:const:`~errno.EISDIR`。"

#: ../../library/exceptions.rst:783
msgid ""
"Raised when a directory operation (such as :func:`os.listdir`) is requested "
"on something which is not a directory.  On most POSIX platforms, it may also "
"be raised if an operation attempts to open or traverse a non-directory file "
"as if it were a directory. Corresponds to :c:data:`errno` :py:const:`~errno."
"ENOTDIR`."
msgstr ""
"當在某個不是目錄的東西上請求目錄操作（例如 :func:`os.listdir`）時會引發此例"
"外。在大多數的 POSIX 平台上，如果嘗試操作開啟或遍歷一個當作目錄的非目錄檔案也"
"會引發此例外。對應到 :c:data:`errno` :py:const:`~errno.ENOTDIR`。"

#: ../../library/exceptions.rst:791
msgid ""
"Raised when trying to run an operation without the adequate access rights - "
"for example filesystem permissions. Corresponds to :c:data:`errno` :py:const:"
"`~errno.EACCES`, :py:const:`~errno.EPERM`, and :py:const:`~errno."
"ENOTCAPABLE`."
msgstr ""
"當嘗試執行一個沒有合乎存取權限的操作時會引發此例外 — 例如檔案系統權限。對應"
"到 :c:data:`errno` :py:const:`~errno.EACCES`、:py:const:`~errno.EPERM` 及 :"
"py:const:`~errno.ENOTCAPABLE`。"

#: ../../library/exceptions.rst:796
msgid ""
"WASI's :py:const:`~errno.ENOTCAPABLE` is now mapped to :exc:"
"`PermissionError`."
msgstr ""
"WASI 的 :py:const:`~errno.ENOTCAPABLE` 現在對應到 :exc:`PermissionError`。"

#: ../../library/exceptions.rst:802
msgid ""
"Raised when a given process doesn't exist. Corresponds to :c:data:`errno` :"
"py:const:`~errno.ESRCH`."
msgstr ""
"當給定的行程不存在時會引發此例外。對應到 :c:data:`errno` :py:const:`~errno."
"ESRCH`。"

#: ../../library/exceptions.rst:807
msgid ""
"Raised when a system function timed out at the system level. Corresponds to :"
"c:data:`errno` :py:const:`~errno.ETIMEDOUT`."
msgstr ""
"當系統函式在系統層級超時會引發此例外。對應到 :c:data:`errno` :py:const:"
"`~errno.ETIMEDOUT`。"

#: ../../library/exceptions.rst:810
msgid "All the above :exc:`OSError` subclasses were added."
msgstr "加入以上所有的 :exc:`OSError` 子類別。"

#: ../../library/exceptions.rst:816
msgid ":pep:`3151` - Reworking the OS and IO exception hierarchy"
msgstr ":pep:`3151` — 改寫作業系統與 IO 例外階層"

#: ../../library/exceptions.rst:822
msgid "Warnings"
msgstr "警告"

#: ../../library/exceptions.rst:824
msgid ""
"The following exceptions are used as warning categories; see the :ref:"
"`warning-categories` documentation for more details."
msgstr ""
"以下的例外是當作警告的種類使用；更多細節參考 :ref:`warning-categories` 文件。"

#: ../../library/exceptions.rst:829
msgid "Base class for warning categories."
msgstr "警告種類的基礎類別。"

#: ../../library/exceptions.rst:834
msgid "Base class for warnings generated by user code."
msgstr "使用者程式碼產生的警告的基礎類別。"

#: ../../library/exceptions.rst:839
msgid ""
"Base class for warnings about deprecated features when those warnings are "
"intended for other Python developers."
msgstr "關於已棄用功能的警告的基礎類別，且當那些警告是針對其他 Python 開發者。"

#: ../../library/exceptions.rst:842
msgid ""
"Ignored by the default warning filters, except in the ``__main__`` module (:"
"pep:`565`). Enabling the :ref:`Python Development Mode <devmode>` shows this "
"warning."
msgstr ""
"會被預設的警告過濾器忽略，在 ``__main__`` 模組裡除外 (:pep:`565`)。啟用 :ref:"
"`Python 開發模式 <devmode>`\\ 會顯示此警告。"

#: ../../library/exceptions.rst:846 ../../library/exceptions.rst:862
msgid "The deprecation policy is described in :pep:`387`."
msgstr "棄用原則描述在 :pep:`387` 裡。"

#: ../../library/exceptions.rst:851
msgid ""
"Base class for warnings about features which are obsolete and expected to be "
"deprecated in the future, but are not deprecated at the moment."
msgstr "關於過時且預期未來要被棄用，但目前尚未被棄用的功能的警告的基礎類別。"

#: ../../library/exceptions.rst:855
msgid ""
"This class is rarely used as emitting a warning about a possible upcoming "
"deprecation is unusual, and :exc:`DeprecationWarning` is preferred for "
"already active deprecations."
msgstr ""
"因為發出關於可能即將被棄用的警告是不尋常的，此類別很少被使用，而對已經被棄用"
"的情況會優先使用 :exc:`DeprecationWarning`。"

#: ../../library/exceptions.rst:859 ../../library/exceptions.rst:885
#: ../../library/exceptions.rst:912
msgid ""
"Ignored by the default warning filters. Enabling the :ref:`Python "
"Development Mode <devmode>` shows this warning."
msgstr ""
"會被預設的警告過濾器忽略。啟用 :ref:`Python 開發模式 <devmode>`\\ 會顯示此警"
"告。"

#: ../../library/exceptions.rst:867
msgid "Base class for warnings about dubious syntax."
msgstr "關於可疑語法的警告的基礎類別。"

#: ../../library/exceptions.rst:872
msgid "Base class for warnings about dubious runtime behavior."
msgstr "關於可疑執行環境行為的警告的基礎類別。"

#: ../../library/exceptions.rst:877
msgid ""
"Base class for warnings about deprecated features when those warnings are "
"intended for end users of applications that are written in Python."
msgstr ""
"關於已棄用功能的警告的基礎類別，且當那些警告是針對以 Python 寫的應用程式的終"
"端使用者。"

#: ../../library/exceptions.rst:883
msgid "Base class for warnings about probable mistakes in module imports."
msgstr "關於在模組引入的可能錯誤的警告的基礎類別。"

#: ../../library/exceptions.rst:891
msgid "Base class for warnings related to Unicode."
msgstr "Unicode 相關警告的基礎類別。"

#: ../../library/exceptions.rst:896
msgid "Base class for warnings related to encodings."
msgstr "編碼相關警告的基礎類別。"

#: ../../library/exceptions.rst:898
msgid "See :ref:`io-encoding-warning` for details."
msgstr "細節參考\\ :ref:`io-encoding-warning`。"

#: ../../library/exceptions.rst:905
msgid ""
"Base class for warnings related to :class:`bytes` and :class:`bytearray`."
msgstr ":class:`bytes` 及 :class:`bytearray` 相關警告的基礎類別。"

#: ../../library/exceptions.rst:910
msgid "Base class for warnings related to resource usage."
msgstr "資源用法相關警告的基礎類別。"

#: ../../library/exceptions.rst:921
msgid "Exception groups"
msgstr "例外群組"

#: ../../library/exceptions.rst:923
msgid ""
"The following are used when it is necessary to raise multiple unrelated "
"exceptions. They are part of the exception hierarchy so they can be handled "
"with :keyword:`except` like all other exceptions. In addition, they are "
"recognised by :keyword:`except*<except_star>`, which matches their subgroups "
"based on the types of the contained exceptions."
msgstr ""
"當需要引發多個不相關例外時會使用下列的類別。它們是例外階層的一部分所以可以像"
"所有其他例外一樣使用 :keyword:`except` 來處理。此外，它們會以包含的例外類型為"
"基礎來比對其子群組而被 :keyword:`except*<except_star>` 辨認出來。"

#: ../../library/exceptions.rst:932
msgid ""
"Both of these exception types wrap the exceptions in the sequence ``excs``. "
"The ``msg`` parameter must be a string. The difference between the two "
"classes is that :exc:`BaseExceptionGroup` extends :exc:`BaseException` and "
"it can wrap any exception, while :exc:`ExceptionGroup` extends :exc:"
"`Exception` and it can only wrap subclasses of :exc:`Exception`. This design "
"is so that ``except Exception`` catches an :exc:`ExceptionGroup` but not :"
"exc:`BaseExceptionGroup`."
msgstr ""
"這兩個例外類型都將例外包裝在序列 ``excs`` 中。``msg`` 參數必須是字串。這兩個"
"類別的差異是 :exc:`BaseExceptionGroup` 擴充了 :exc:`BaseException` 且可以包裝"
"任何例外，而 :exc:`ExceptionGroup` 擴充了 :exc:`Exception` 且只能包裝 :exc:"
"`Exception` 的子類別。這個設計使得 ``except Exception`` 可以捕捉 :exc:"
"`ExceptionGroup` 但不能捕捉 :exc:`BaseExceptionGroup`。"

#: ../../library/exceptions.rst:940
msgid ""
"The :exc:`BaseExceptionGroup` constructor returns an :exc:`ExceptionGroup` "
"rather than a :exc:`BaseExceptionGroup` if all contained exceptions are :exc:"
"`Exception` instances, so it can be used to make the selection automatic. "
"The :exc:`ExceptionGroup` constructor, on the other hand, raises a :exc:"
"`TypeError` if any contained exception is not an :exc:`Exception` subclass."
msgstr ""
"如果所有包含的例外都是 :exc:`Exception` 實例，:exc:`BaseExceptionGroup` 建構"
"函式會回傳 :exc:`ExceptionGroup` 而不是 :exc:`BaseExceptionGroup`，因此可以被"
"使用來讓這樣的選擇自動化。另一方面來說，如果任何包含的例外不是 :exc:"
"`Exception` 的子類別，:exc:`ExceptionGroup` 建構函式會引發 :exc:`TypeError`。"

#: ../../library/exceptions.rst:949
msgid "The ``msg`` argument to the constructor. This is a read-only attribute."
msgstr "建構函式的 ``msg`` 引數。這是一個唯讀的屬性。"

#: ../../library/exceptions.rst:953
msgid ""
"A tuple of the exceptions in the ``excs`` sequence given to the constructor. "
"This is a read-only attribute."
msgstr "指定給建構函式 ``excs`` 序列中的例外組成的元組。這是一個唯讀的屬性。"

#: ../../library/exceptions.rst:958
msgid ""
"Returns an exception group that contains only the exceptions from the "
"current group that match *condition*, or ``None`` if the result is empty."
msgstr ""
"回傳只包含從現有群組比對到 *condition* 的例外的例外群組，或者當結果為空時回"
"傳 ``None``。"

#: ../../library/exceptions.rst:961
msgid ""
"The condition can be an exception type or tuple of exception types, in which "
"case each exception is checked for a match using the same check that is used "
"in an ``except`` clause.  The condition can also be a callable (other than a "
"type object) that accepts an exception as its single argument and returns "
"true for the exceptions that should be in the subgroup."
msgstr ""

#: ../../library/exceptions.rst:967
msgid ""
"The nesting structure of the current exception is preserved in the result, "
"as are the values of its :attr:`message`, :attr:`~BaseException."
"__traceback__`, :attr:`~BaseException.__cause__`, :attr:`~BaseException."
"__context__` and :attr:`~BaseException.__notes__` fields. Empty nested "
"groups are omitted from the result."
msgstr ""
"現有例外的巢狀結構會保留在結果裡，其 :attr:`message`、:attr:`~BaseException."
"__traceback__`、:attr:`~BaseException.__cause__`、:attr:`~BaseException."
"__context__` 及 :attr:`~BaseException.__notes__` 欄位的值也一樣。空的巢狀群組"
"會從結果裡排除。"

#: ../../library/exceptions.rst:974
msgid ""
"The condition is checked for all exceptions in the nested exception group, "
"including the top-level and any nested exception groups. If the condition is "
"true for such an exception group, it is included in the result in full."
msgstr ""
"條件會對巢狀例外群組裡的所有例外做檢查，包括頂層及任何巢狀的例外群組。如果條"
"件對這樣的例外群組為 true，它會被完整包含在結果裡。"

#: ../../library/exceptions.rst:978
msgid "``condition`` can be any callable which is not a type object."
msgstr ""

#: ../../library/exceptions.rst:983
msgid ""
"Like :meth:`subgroup`, but returns the pair ``(match, rest)`` where "
"``match`` is ``subgroup(condition)`` and ``rest`` is the remaining non-"
"matching part."
msgstr ""
"像 :meth:`subgroup` 一樣，但回傳一對 ``(match, rest)``，其中 ``match`` 是 "
"``subgroup(condition)`` 而 ``rest`` 是剩下沒有比對到的部分。"

#: ../../library/exceptions.rst:989
msgid ""
"Returns an exception group with the same :attr:`message`, but which wraps "
"the exceptions in ``excs``."
msgstr "回傳有相同 :attr:`message` 但將例外包裝在 ``excs`` 的例外群組。"

#: ../../library/exceptions.rst:992
msgid ""
"This method is used by :meth:`subgroup` and :meth:`split`, which are used in "
"various contexts to break up an exception group. A subclass needs to "
"override it in order to make :meth:`subgroup` and :meth:`split` return "
"instances of the subclass rather than :exc:`ExceptionGroup`."
msgstr ""
"此方法被 :meth:`subgroup` 及 :meth:`split` 使用，被用來在各種情境下拆分例外群"
"組。子類別需要覆寫它來讓 :meth:`subgroup` 及 :meth:`split` 回傳子類別而不是 :"
"exc:`ExceptionGroup` 的實例。"

#: ../../library/exceptions.rst:998
msgid ""
":meth:`subgroup` and :meth:`split` copy the :attr:`~BaseException."
"__traceback__`, :attr:`~BaseException.__cause__`, :attr:`~BaseException."
"__context__` and :attr:`~BaseException.__notes__` fields from the original "
"exception group to the one returned by :meth:`derive`, so these fields do "
"not need to be updated by :meth:`derive`."
msgstr ""
":meth:`subgroup` 及 :meth:`split` 會從原始的例外群組複製 :attr:"
"`~BaseException.__traceback__`、:attr:`~BaseException.__cause__`、:attr:"
"`~BaseException.__context__` 和 :attr:`~BaseException.__notes__` 欄位到 :"
"meth:`derive` 所回傳的例外群組上，因此這些欄位不需要被 :meth:`derive` 更新。"

#: ../../library/exceptions.rst:1005
msgid ""
">>> class MyGroup(ExceptionGroup):\n"
"...     def derive(self, excs):\n"
"...         return MyGroup(self.message, excs)\n"
"...\n"
">>> e = MyGroup(\"eg\", [ValueError(1), TypeError(2)])\n"
">>> e.add_note(\"a note\")\n"
">>> e.__context__ = Exception(\"context\")\n"
">>> e.__cause__ = Exception(\"cause\")\n"
">>> try:\n"
"...    raise e\n"
"... except Exception as e:\n"
"...    exc = e\n"
"...\n"
">>> match, rest = exc.split(ValueError)\n"
">>> exc, exc.__context__, exc.__cause__, exc.__notes__\n"
"(MyGroup('eg', [ValueError(1), TypeError(2)]), Exception('context'), "
"Exception('cause'), ['a note'])\n"
">>> match, match.__context__, match.__cause__, match.__notes__\n"
"(MyGroup('eg', [ValueError(1)]), Exception('context'), Exception('cause'), "
"['a note'])\n"
">>> rest, rest.__context__, rest.__cause__, rest.__notes__\n"
"(MyGroup('eg', [TypeError(2)]), Exception('context'), Exception('cause'), "
"['a note'])\n"
">>> exc.__traceback__ is match.__traceback__ is rest.__traceback__\n"
"True"
msgstr ""
">>> class MyGroup(ExceptionGroup):\n"
"...     def derive(self, excs):\n"
"...         return MyGroup(self.message, excs)\n"
"...\n"
">>> e = MyGroup(\"eg\", [ValueError(1), TypeError(2)])\n"
">>> e.add_note(\"a note\")\n"
">>> e.__context__ = Exception(\"context\")\n"
">>> e.__cause__ = Exception(\"cause\")\n"
">>> try:\n"
"...    raise e\n"
"... except Exception as e:\n"
"...    exc = e\n"
"...\n"
">>> match, rest = exc.split(ValueError)\n"
">>> exc, exc.__context__, exc.__cause__, exc.__notes__\n"
"(MyGroup('eg', [ValueError(1), TypeError(2)]), Exception('context'), "
"Exception('cause'), ['a note'])\n"
">>> match, match.__context__, match.__cause__, match.__notes__\n"
"(MyGroup('eg', [ValueError(1)]), Exception('context'), Exception('cause'), "
"['a note'])\n"
">>> rest, rest.__context__, rest.__cause__, rest.__notes__\n"
"(MyGroup('eg', [TypeError(2)]), Exception('context'), Exception('cause'), "
"['a note'])\n"
">>> exc.__traceback__ is match.__traceback__ is rest.__traceback__\n"
"True"

#: ../../library/exceptions.rst:1031
msgid ""
"Note that :exc:`BaseExceptionGroup` defines :meth:`~object.__new__`, so "
"subclasses that need a different constructor signature need to override that "
"rather than :meth:`~object.__init__`. For example, the following defines an "
"exception group subclass which accepts an exit_code and and constructs the "
"group's message from it. ::"
msgstr ""
"需注意 :exc:`BaseExceptionGroup` 定義了 :meth:`~object.__new__`，因此需要不同"
"建構函式簽名的子類別需要覆寫它而不是 :meth:`~object.__init__`。例如下面定義了"
"一個例外群組子類別接受 exit_code 並從中建構群組的訊息。： ::"

#: ../../library/exceptions.rst:1037
msgid ""
"class Errors(ExceptionGroup):\n"
"   def __new__(cls, errors, exit_code):\n"
"      self = super().__new__(Errors, f\"exit code: {exit_code}\", errors)\n"
"      self.exit_code = exit_code\n"
"      return self\n"
"\n"
"   def derive(self, excs):\n"
"      return Errors(excs, self.exit_code)"
msgstr ""
"class Errors(ExceptionGroup):\n"
"   def __new__(cls, errors, exit_code):\n"
"      self = super().__new__(Errors, f\"exit code: {exit_code}\", errors)\n"
"      self.exit_code = exit_code\n"
"      return self\n"
"\n"
"   def derive(self, excs):\n"
"      return Errors(excs, self.exit_code)"

#: ../../library/exceptions.rst:1046
msgid ""
"Like :exc:`ExceptionGroup`, any subclass of :exc:`BaseExceptionGroup` which "
"is also a subclass of :exc:`Exception` can only wrap instances of :exc:"
"`Exception`."
msgstr ""
"像 :exc:`ExceptionGroup` 一樣，任何 :exc:`BaseExceptionGroup` 的子類別且也"
"是 :exc:`Exception` 的子類別只能包裝 :exc:`Exception` 的實例。"

#: ../../library/exceptions.rst:1054
msgid "Exception hierarchy"
msgstr "例外階層"

#: ../../library/exceptions.rst:1056
msgid "The class hierarchy for built-in exceptions is:"
msgstr "內建例外的類別階層如下："

#: ../../library/exceptions.rst:1058
#, fuzzy
msgid ""
"BaseException\n"
" ├── BaseExceptionGroup\n"
" ├── GeneratorExit\n"
" ├── KeyboardInterrupt\n"
" ├── SystemExit\n"
" └── Exception\n"
"      ├── ArithmeticError\n"
"      │    ├── FloatingPointError\n"
"      │    ├── OverflowError\n"
"      │    └── ZeroDivisionError\n"
"      ├── AssertionError\n"
"      ├── AttributeError\n"
"      ├── BufferError\n"
"      ├── EOFError\n"
"      ├── ExceptionGroup [BaseExceptionGroup]\n"
"      ├── ImportError\n"
"      │    └── ModuleNotFoundError\n"
"      ├── LookupError\n"
"      │    ├── IndexError\n"
"      │    └── KeyError\n"
"      ├── MemoryError\n"
"      ├── NameError\n"
"      │    └── UnboundLocalError\n"
"      ├── OSError\n"
"      │    ├── BlockingIOError\n"
"      │    ├── ChildProcessError\n"
"      │    ├── ConnectionError\n"
"      │    │    ├── BrokenPipeError\n"
"      │    │    ├── ConnectionAbortedError\n"
"      │    │    ├── ConnectionRefusedError\n"
"      │    │    └── ConnectionResetError\n"
"      │    ├── FileExistsError\n"
"      │    ├── FileNotFoundError\n"
"      │    ├── InterruptedError\n"
"      │    ├── IsADirectoryError\n"
"      │    ├── NotADirectoryError\n"
"      │    ├── PermissionError\n"
"      │    ├── ProcessLookupError\n"
"      │    └── TimeoutError\n"
"      ├── ReferenceError\n"
"      ├── RuntimeError\n"
"      │    ├── NotImplementedError\n"
"      │    ├── PythonFinalizationError\n"
"      │    └── RecursionError\n"
"      ├── StopAsyncIteration\n"
"      ├── StopIteration\n"
"      ├── SyntaxError\n"
"      │    └── IndentationError\n"
"      │         └── TabError\n"
"      ├── SystemError\n"
"      ├── TypeError\n"
"      ├── ValueError\n"
"      │    └── UnicodeError\n"
"      │         ├── UnicodeDecodeError\n"
"      │         ├── UnicodeEncodeError\n"
"      │         └── UnicodeTranslateError\n"
"      └── Warning\n"
"           ├── BytesWarning\n"
"           ├── DeprecationWarning\n"
"           ├── EncodingWarning\n"
"           ├── FutureWarning\n"
"           ├── ImportWarning\n"
"           ├── PendingDeprecationWarning\n"
"           ├── ResourceWarning\n"
"           ├── RuntimeWarning\n"
"           ├── SyntaxWarning\n"
"           ├── UnicodeWarning\n"
"           └── UserWarning\n"
msgstr ""
"BaseException\n"
" ├── BaseExceptionGroup\n"
" ├── GeneratorExit\n"
" ├── KeyboardInterrupt\n"
" ├── SystemExit\n"
" └── Exception\n"
"      ├── ArithmeticError\n"
"      │    ├── FloatingPointError\n"
"      │    ├── OverflowError\n"
"      │    └── ZeroDivisionError\n"
"      ├── AssertionError\n"
"      ├── AttributeError\n"
"      ├── BufferError\n"
"      ├── EOFError\n"
"      ├── ExceptionGroup [BaseExceptionGroup]\n"
"      ├── ImportError\n"
"      │    └── ModuleNotFoundError\n"
"      ├── LookupError\n"
"      │    ├── IndexError\n"
"      │    └── KeyError\n"
"      ├── MemoryError\n"
"      ├── NameError\n"
"      │    └── UnboundLocalError\n"
"      ├── OSError\n"
"      │    ├── BlockingIOError\n"
"      │    ├── ChildProcessError\n"
"      │    ├── ConnectionError\n"
"      │    │    ├── BrokenPipeError\n"
"      │    │    ├── ConnectionAbortedError\n"
"      │    │    ├── ConnectionRefusedError\n"
"      │    │    └── ConnectionResetError\n"
"      │    ├── FileExistsError\n"
"      │    ├── FileNotFoundError\n"
"      │    ├── InterruptedError\n"
"      │    ├── IsADirectoryError\n"
"      │    ├── NotADirectoryError\n"
"      │    ├── PermissionError\n"
"      │    ├── ProcessLookupError\n"
"      │    └── TimeoutError\n"
"      ├── ReferenceError\n"
"      ├── RuntimeError\n"
"      │    ├── NotImplementedError\n"
"      │    └── RecursionError\n"
"      ├── StopAsyncIteration\n"
"      ├── StopIteration\n"
"      ├── SyntaxError\n"
"      │    └── IndentationError\n"
"      │         └── TabError\n"
"      ├── SystemError\n"
"      ├── TypeError\n"
"      ├── ValueError\n"
"      │    └── UnicodeError\n"
"      │         ├── UnicodeDecodeError\n"
"      │         ├── UnicodeEncodeError\n"
"      │         └── UnicodeTranslateError\n"
"      └── Warning\n"
"           ├── BytesWarning\n"
"           ├── DeprecationWarning\n"
"           ├── EncodingWarning\n"
"           ├── FutureWarning\n"
"           ├── ImportWarning\n"
"           ├── PendingDeprecationWarning\n"
"           ├── ResourceWarning\n"
"           ├── RuntimeWarning\n"
"           ├── SyntaxWarning\n"
"           ├── UnicodeWarning\n"
"           └── UserWarning\n"

#: ../../library/exceptions.rst:6 ../../library/exceptions.rst:17
#: ../../library/exceptions.rst:196
msgid "statement"
msgstr "statement（陳述式）"

#: ../../library/exceptions.rst:6
msgid "try"
msgstr "try"

#: ../../library/exceptions.rst:6
msgid "except"
msgstr "except"

#: ../../library/exceptions.rst:17
msgid "raise"
msgstr "raise"

#: ../../library/exceptions.rst:41
msgid "exception"
msgstr "exception（例外）"

#: ../../library/exceptions.rst:41
msgid "chaining"
msgstr "chaining"

#: ../../library/exceptions.rst:41
msgid "__cause__ (exception attribute)"
msgstr "__cause__（例外屬性）"

#: ../../library/exceptions.rst:41
msgid "__context__ (exception attribute)"
msgstr "__context__（例外屬性）"

#: ../../library/exceptions.rst:41
msgid "__suppress_context__ (exception attribute)"
msgstr "__suppress_context__（例外屬性）"

#: ../../library/exceptions.rst:196
msgid "assert"
msgstr "assert"

#: ../../library/exceptions.rst:345
msgid "module"
msgstr "module（模組）"

#: ../../library/exceptions.rst:345
msgid "errno"
msgstr "errno"

#~ msgid ""
#~ "The condition can be either a function that accepts an exception and "
#~ "returns true for those that should be in the subgroup, or it can be an "
#~ "exception type or a tuple of exception types, which is used to check for "
#~ "a match using the same check that is used in an ``except`` clause."
#~ msgstr ""
#~ "條件可以是一個函式，接受一個例外並對那些應該要在子群組裡的例外回傳 true，"
#~ "或者可以是一個例外類型或例外類型的元組，並使用與 ``except`` 子句所使用的相"
#~ "同檢查來檢查是否有比對到。"
