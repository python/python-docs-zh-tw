# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-03 11:11+0800\n"
"PO-Revision-Date: 2024-02-19 21:27+0800\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: ../../library/unittest.mock.rst:2
msgid ":mod:`!unittest.mock` --- mock object library"
msgstr ":mod:`!unittest.mock` — mock 物件函式庫"

#: ../../library/unittest.mock.rst:12
msgid "**Source code:** :source:`Lib/unittest/mock.py`"
msgstr "**原始碼：**\\ :source:`Lib/unittest/mock.py`"

#: ../../library/unittest.mock.rst:16
msgid ""
":mod:`unittest.mock` is a library for testing in Python. It allows you to "
"replace parts of your system under test with mock objects and make "
"assertions about how they have been used."
msgstr ""
":mod:`unittest.mock` 在 Python 中是一個用於進行測試的函式庫。 它允許你用 "
"mock 物件在測試中替換部分系統，並判定它們是如何被使用的。"

#: ../../library/unittest.mock.rst:20
msgid ""
":mod:`unittest.mock` provides a core :class:`Mock` class removing the need "
"to create a host of stubs throughout your test suite. After performing an "
"action, you can make assertions about which methods / attributes were used "
"and arguments they were called with. You can also specify return values and "
"set needed attributes in the normal way."
msgstr ""
":mod:`unittest.mock` 提供了一個以 :class:`Mock` 為核心的類別，去除在測試中建"
"立大量 stubs 的需求。 在執行動作之後，你可以判定哪些 method （方法）／屬性被"
"使用，以及有哪些引數被呼叫。 你還可以用常規的方式指定回傳值與設定所需的屬性。"

#: ../../library/unittest.mock.rst:26
msgid ""
"Additionally, mock provides a :func:`patch` decorator that handles patching "
"module and class level attributes within the scope of a test, along with :"
"const:`sentinel` for creating unique objects. See the `quick guide`_ for "
"some examples of how to use :class:`Mock`, :class:`MagicMock` and :func:"
"`patch`."
msgstr ""
"此外，mock 還提供了一個 :func:`patch` 裝飾器，用於 patching 測試範圍內對 "
"module（模組）以及 class（類別）級別的屬性，以及用於建立唯一物件的 :const:"
"`sentinel`。有關如何使用 :class:`Mock`\\、:class:`MagicMock` 和 :func:"
"`patch` 的一些範例，請參閱\\ `快速導引 <quick guide_>`_。"

#: ../../library/unittest.mock.rst:32
msgid ""
"Mock is designed for use with :mod:`unittest` and is based on the 'action -> "
"assertion' pattern instead of 'record -> replay' used by many mocking "
"frameworks."
msgstr ""
"Mock 被設計用於與 :mod:`unittest` 一起使用，並且基於 「action（操作） -> "
"assertion（判定）」 模式，而不是許多 mocking 框架使用的 「record（記錄） -> "
"replay（重播）」 模式。"

#: ../../library/unittest.mock.rst:36
msgid ""
"There is a backport of :mod:`unittest.mock` for earlier versions of Python, "
"available as :pypi:`mock` on PyPI."
msgstr ""
"對於早期版本的 Python，有一個 backport（向後移植的）\\ :mod:`unittest.mock` "
"可以使用，可從 PyPI 下載 :pypi:`mock`。"

#: ../../library/unittest.mock.rst:41
msgid "Quick Guide"
msgstr "快速導引"

#: ../../library/unittest.mock.rst:59
msgid ""
":class:`Mock` and :class:`MagicMock` objects create all attributes and "
"methods as you access them and store details of how they have been used. You "
"can configure them, to specify return values or limit what attributes are "
"available, and then make assertions about how they have been used:"
msgstr ""
":class:`Mock` 和 :class:`MagicMock` 物件在你存取它們時建立所有屬性和 method"
"（方法），並儲存它們如何被使用的詳細訊息。你可以配置它們，以指定回傳值或限制"
"可用的屬性，然後對它們的使用方式做出判定："

#: ../../library/unittest.mock.rst:71
msgid ""
":attr:`side_effect` allows you to perform side effects, including raising an "
"exception when a mock is called:"
msgstr ""
":attr:`side_effect` 允許你執行 side effects，包含在 mock 被呼叫時引發例外："

#: ../../library/unittest.mock.rst:92
msgid ""
"Mock has many other ways you can configure it and control its behaviour. For "
"example the *spec* argument configures the mock to take its specification "
"from another object. Attempting to access attributes or methods on the mock "
"that don't exist on the spec will fail with an :exc:`AttributeError`."
msgstr ""
"Mock 有許多其他方法可以讓你配置與控制它的行為。例如，*spec* 引數可以配置 "
"mock ，讓其從另一個物件獲取規格。嘗試讀取 mock 中不存在於規格中的屬性或方法將"
"會失敗，並出現 :exc:`AttributeError`。"

#: ../../library/unittest.mock.rst:97
msgid ""
"The :func:`patch` decorator / context manager makes it easy to mock classes "
"or objects in a module under test. The object you specify will be replaced "
"with a mock (or other object) during the test and restored when the test "
"ends::"
msgstr ""
":func:`patch` 裝飾器／情境管理器可以在測試中簡單的 mock 模組中的類別或物件。"
"被指定的物件在測試期間會被替換為 mock（或其他物件），並在測試結束時恢復： ::"

#: ../../library/unittest.mock.rst:101
msgid ""
">>> from unittest.mock import patch\n"
">>> @patch('module.ClassName2')\n"
"... @patch('module.ClassName1')\n"
"... def test(MockClass1, MockClass2):\n"
"...     module.ClassName1()\n"
"...     module.ClassName2()\n"
"...     assert MockClass1 is module.ClassName1\n"
"...     assert MockClass2 is module.ClassName2\n"
"...     assert MockClass1.called\n"
"...     assert MockClass2.called\n"
"...\n"
">>> test()"
msgstr ""
">>> from unittest.mock import patch\n"
">>> @patch('module.ClassName2')\n"
"... @patch('module.ClassName1')\n"
"... def test(MockClass1, MockClass2):\n"
"...     module.ClassName1()\n"
"...     module.ClassName2()\n"
"...     assert MockClass1 is module.ClassName1\n"
"...     assert MockClass2 is module.ClassName2\n"
"...     assert MockClass1.called\n"
"...     assert MockClass2.called\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock.rst:116
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``module.ClassName1`` is passed in first."
msgstr ""
"當你巢狀使用 patch 裝飾器時，mock 傳遞到被裝飾函式的順序會跟其被應用的順序相"
"同（一般 *Python* 應用裝飾器的順序）。這意味著由下而上，因此在上面的範例中，"
"``module.ClassName1`` 的 mock 會先被傳入。"

#: ../../library/unittest.mock.rst:121
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"使用 :func:`patch` 時，需注意的是你得在被查找物件的命名空間中（in the "
"namespace where they are looked up）patch 物件。這通常很直接，但若需要快速導"
"引，請參閱\\ :ref:`該 patch 何處 <where-to-patch>`。"

#: ../../library/unittest.mock.rst:125
msgid ""
"As well as a decorator :func:`patch` can be used as a context manager in a "
"with statement:"
msgstr "裝飾器 :func:`patch` 也可以在 with 陳述式中被用來作為情境管理器："

#: ../../library/unittest.mock.rst:135
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr ""
"也有 :func:`patch.dict`，用於在測試範圍中設定 dictionary（字典）內的值，並在"
"測試結束時將其恢復為原始狀態："

#: ../../library/unittest.mock.rst:146
msgid ""
"Mock supports the mocking of Python :ref:`magic methods <magic-methods>`. "
"The easiest way of using magic methods is with the :class:`MagicMock` class. "
"It allows you to do things like:"
msgstr ""
"Mock 支援對 Python 的\\ :ref:`魔術方法 <magic-methods>`\\ 的 mocking。最簡單"
"使用魔術方法的方式是使用 :class:`MagicMock` 類別。它允許你執行以下操作："

#: ../../library/unittest.mock.rst:156
msgid ""
"Mock allows you to assign functions (or other Mock instances) to magic "
"methods and they will be called appropriately. The :class:`MagicMock` class "
"is just a Mock variant that has all of the magic methods pre-created for you "
"(well, all the useful ones anyway)."
msgstr ""
"Mock 允許你將函式（或其他 Mock 實例）分配給魔術方法，並且它們將被適當地呼"
"叫。:class:`MagicMock` 類別是一個 Mock 的變體，它為你預先建好了所有魔術方法"
"（好吧，所有有用的方法）。"

#: ../../library/unittest.mock.rst:161
msgid ""
"The following is an example of using magic methods with the ordinary Mock "
"class:"
msgstr "以下是在一般 Mock 類別中使用魔術方法的範例："

#: ../../library/unittest.mock.rst:169
msgid ""
"For ensuring that the mock objects in your tests have the same api as the "
"objects they are replacing, you can use :ref:`auto-speccing <auto-"
"speccing>`. Auto-speccing can be done through the *autospec* argument to "
"patch, or the :func:`create_autospec` function. Auto-speccing creates mock "
"objects that have the same attributes and methods as the objects they are "
"replacing, and any functions and methods (including constructors) have the "
"same call signature as the real object."
msgstr ""
"為了確保測試中的 mock 物件與它們要替換的物件具有相同的 api，你可以使用\\ :"
"ref:`自動規格 <auto-speccing>`。自動規格（auto-speccing）可以通過 patch 的 "
"*autospec* 引數或 :func:`create_autospec` 函式來完成。自動規格建立的 mock 物"
"件與它們要替換的物件具有相同的屬性和方法，並且任何函式和方法（包括建構函式）"
"都具有與真實物件相同的呼叫簽名（call signature）。"

#: ../../library/unittest.mock.rst:177
msgid ""
"This ensures that your mocks will fail in the same way as your production "
"code if they are used incorrectly:"
msgstr "這可以確保如果使用方法錯誤，你的 mock 會跟實際程式碼以相同的方式失敗："

#: ../../library/unittest.mock.rst:193
msgid ""
":func:`create_autospec` can also be used on classes, where it copies the "
"signature of the ``__init__`` method, and on callable objects where it "
"copies the signature of the ``__call__`` method."
msgstr ""
":func:`create_autospec` 也可以用在類別上，它複製了 ``__init__`` 方法的簽名，"
"它也可以用在可呼叫物件上，其複製了 ``__call__`` 方法的簽名。"

#: ../../library/unittest.mock.rst:200
msgid "The Mock Class"
msgstr "Mock 類別"

#: ../../library/unittest.mock.rst:211
msgid ""
":class:`Mock` is a flexible mock object intended to replace the use of stubs "
"and test doubles throughout your code. Mocks are callable and create "
"attributes as new mocks when you access them [#]_. Accessing the same "
"attribute will always return the same mock. Mocks record how you use them, "
"allowing you to make assertions about what your code has done to them."
msgstr ""
":class:`Mock` 是一個彈性的的 mock 物件，旨在代替程式碼中 stubs 和 test "
"doubles （測試替身）的使用。Mock 是可呼叫的，並在你存取它們時將屬性建立為新"
"的 mock [#]_。存取相同的屬性將永遠回傳相同的 mock。Mock 記錄了你如何使用它"
"們，允許你判定你的程式碼對 mock 的行為。"

#: ../../library/unittest.mock.rst:217
msgid ""
":class:`MagicMock` is a subclass of :class:`Mock` with all the magic methods "
"pre-created and ready to use. There are also non-callable variants, useful "
"when you are mocking out objects that aren't callable: :class:"
"`NonCallableMock` and :class:`NonCallableMagicMock`"
msgstr ""
":class:`MagicMock` 是 :class:`Mock` 的子類別，其中所有魔術方法均已預先建立並"
"可供使用。也有不可呼叫的變體，在你 mock 無法呼叫的物件時很有用：:class:"
"`NonCallableMock` 和 :class:`NonCallableMagicMock`"

#: ../../library/unittest.mock.rst:222
msgid ""
"The :func:`patch` decorators makes it easy to temporarily replace classes in "
"a particular module with a :class:`Mock` object. By default :func:`patch` "
"will create a :class:`MagicMock` for you. You can specify an alternative "
"class of :class:`Mock` using the *new_callable* argument to :func:`patch`."
msgstr ""
":func:`patch` 裝飾器可以輕鬆地用 :class:`Mock` 物件臨時替換特定模組中的類別。"
"預設情況下，:func:`patch` 會為你建立一個 :class:`MagicMock`。你可以使用 :"
"func:`patch` 的 *new_callable* 引數指定 :class:`Mock` 的替代類別。"

#: ../../library/unittest.mock.rst:230
msgid ""
"Create a new :class:`Mock` object. :class:`Mock` takes several optional "
"arguments that specify the behaviour of the Mock object:"
msgstr ""
"建立一個新的 :class:`Mock` 物件。:class:`Mock` 接受數個可選的引數來指定 Mock "
"物件的行為："

#: ../../library/unittest.mock.rst:233
msgid ""
"*spec*: This can be either a list of strings or an existing object (a class "
"or instance) that acts as the specification for the mock object. If you pass "
"in an object then a list of strings is formed by calling dir on the object "
"(excluding unsupported magic attributes and methods). Accessing any "
"attribute not in this list will raise an :exc:`AttributeError`."
msgstr ""
"*spec*：這可以是字串的 list（串列），也可以是充當 mock 物件規格的現有物件（類"
"別或實例）。如果傳入一個物件，則通過對該物件呼叫 dir 來形成字串的串列（不包括"
"不支援的魔術屬性和方法）。存取不在此串列中的任何屬性都會引發 :exc:"
"`AttributeError`。"

#: ../../library/unittest.mock.rst:239
msgid ""
"If *spec* is an object (rather than a list of strings) then :attr:`~instance."
"__class__` returns the class of the spec object. This allows mocks to pass :"
"func:`isinstance` tests."
msgstr ""
"如果 *spec* 是一個物件（而不是一個字串的串列），那麼 :attr:`~instance."
"__class__` 會回傳 spec 物件的類別。這允許 mocks 通過 :func:`isinstance` 測"
"試。"

#: ../../library/unittest.mock.rst:243
msgid ""
"*spec_set*: A stricter variant of *spec*. If used, attempting to *set* or "
"get an attribute on the mock that isn't on the object passed as *spec_set* "
"will raise an :exc:`AttributeError`."
msgstr ""
"*spec_set*：*spec* 的一個更嚴格的變體。如果使用 *spec_set*，在 mock 上嘗試 "
"*set* 或取得不在傳遞給 *spec_set* 的物件上的屬性將會引發 :exc:"
"`AttributeError`。"

#: ../../library/unittest.mock.rst:247
msgid ""
"*side_effect*: A function to be called whenever the Mock is called. See the :"
"attr:`~Mock.side_effect` attribute. Useful for raising exceptions or "
"dynamically changing return values. The function is called with the same "
"arguments as the mock, and unless it returns :data:`DEFAULT`, the return "
"value of this function is used as the return value."
msgstr ""
"*side_effect*：每當呼叫 Mock 時要呼叫的函式，參見 :attr:`~Mock.side_effect` "
"屬性，用於引發例外或動態變更回傳值。該函式使用與 mock 相同的引數呼叫，且除非"
"它回傳 :data:`DEFAULT`，否則此函式的回傳值將用作回傳值。"

#: ../../library/unittest.mock.rst:253
msgid ""
"Alternatively *side_effect* can be an exception class or instance. In this "
"case the exception will be raised when the mock is called."
msgstr ""
"*side_effect* 也可以是一個例外的類別或實例。在這種情況下，當呼叫 mock 時，該"
"例外將被引發。"

#: ../../library/unittest.mock.rst:256
msgid ""
"If *side_effect* is an iterable then each call to the mock will return the "
"next value from the iterable."
msgstr ""
"如果 *side_effect* 是一個可疊代物件，那麼對 mock 的每次呼叫將回傳可疊代物件中"
"的下一個值。"

#: ../../library/unittest.mock.rst:259
msgid "A *side_effect* can be cleared by setting it to ``None``."
msgstr "*side_effect* 可以通過將其設置為 ``None`` 來清除。"

#: ../../library/unittest.mock.rst:261
msgid ""
"*return_value*: The value returned when the mock is called. By default this "
"is a new Mock (created on first access). See the :attr:`return_value` "
"attribute."
msgstr ""
"*return_value*：當呼叫 mock 時回傳的值。預設情況下，這是一個新的 Mock（在首次"
"存取時建立）。參見 :attr:`return_value` 屬性。"

#: ../../library/unittest.mock.rst:265
msgid ""
"*unsafe*: By default, accessing any attribute whose name starts with "
"*assert*, *assret*, *asert*, *aseert* or *assrt* will raise an :exc:"
"`AttributeError`. Passing ``unsafe=True`` will allow access to these "
"attributes."
msgstr ""
"*unsafe*：預設情況下，存取任何以 *assert*、*assret*、*asert*、*aseert* 或 "
"*assrt* 開頭的屬性將引發 :exc:`AttributeError`。如果傳遞 ``unsafe=True``，將"
"會允許存取這些屬性。"

#: ../../library/unittest.mock.rst:272
msgid ""
"*wraps*: Item for the mock object to wrap. If *wraps* is not ``None`` then "
"calling the Mock will pass the call through to the wrapped object (returning "
"the real result). Attribute access on the mock will return a Mock object "
"that wraps the corresponding attribute of the wrapped object (so attempting "
"to access an attribute that doesn't exist will raise an :exc:"
"`AttributeError`)."
msgstr ""
"*wraps*：被 mock 物件包裝的項目。如果 *wraps* 不是 ``None``，那麼呼叫 Mock 將"
"通過被包裝的物件（回傳真實結果）。存取 mock 的屬性將會回傳一個 Mock 物件，該"
"物件包裝了被包裝物件的對應屬性（因此嘗試存取不存在的屬性將引發 :exc:"
"`AttributeError`\\ ）。"

#: ../../library/unittest.mock.rst:279
msgid ""
"If the mock has an explicit *return_value* set then calls are not passed to "
"the wrapped object and the *return_value* is returned instead."
msgstr ""
"如果 mock 已經明確設定了 *return_value*，那麼呼叫並不會被傳遞到被包裝的物件，"
"而是回傳已設定好的 *return_value*。"

#: ../../library/unittest.mock.rst:282
msgid ""
"*name*: If the mock has a name then it will be used in the repr of the mock. "
"This can be useful for debugging. The name is propagated to child mocks."
msgstr ""
"*name*：如果 mock 有一個名稱，那麼它會被用於 mock 的 repr。這對於除錯很有用。"
"此名稱將被傳播到子 mocks。"

#: ../../library/unittest.mock.rst:286
msgid ""
"Mocks can also be called with arbitrary keyword arguments. These will be "
"used to set attributes on the mock after it is created. See the :meth:"
"`configure_mock` method for details."
msgstr ""
"Mocks 還可以使用任意的關鍵字引數進行呼叫。這些關鍵字引數將在建立 mock 之後用"
"於設定 mock 的屬性。欲知更多，請參見 :meth:`configure_mock` 方法。"

#: ../../library/unittest.mock.rst:292
msgid "Assert that the mock was called at least once."
msgstr "確認 mock 至少被呼叫一次。"

#: ../../library/unittest.mock.rst:303
msgid "Assert that the mock was called exactly once."
msgstr "確認 mock 只被呼叫一次。"

#: ../../library/unittest.mock.rst:321
msgid ""
"This method is a convenient way of asserting that the last call has been "
"made in a particular way:"
msgstr "這個方法是一個便利的方式，用來斷言最後一次呼叫是以特定方式進行的："

#: ../../library/unittest.mock.rst:331
msgid ""
"Assert that the mock was called exactly once and that call was with the "
"specified arguments."
msgstr "確認 mock 只被呼叫一次，且該次呼叫使用了指定的引數。"

#: ../../library/unittest.mock.rst:346
msgid "assert the mock has been called with the specified arguments."
msgstr "斷言 mock 已經被使用指定的引數呼叫。"

#: ../../library/unittest.mock.rst:348
msgid ""
"The assert passes if the mock has *ever* been called, unlike :meth:"
"`assert_called_with` and :meth:`assert_called_once_with` that only pass if "
"the call is the most recent one, and in the case of :meth:"
"`assert_called_once_with` it must also be the only call."
msgstr ""
"這個斷言在 mock 曾經被呼叫過時通過，不同於 :meth:`assert_called_with` 和 :"
"meth:`assert_called_once_with`，他們針對的是最近的一次的呼叫，而且對於 :meth:"
"`assert_called_once_with`，最近一次的呼叫還必須也是唯一一次的呼叫。"

#: ../../library/unittest.mock.rst:361
msgid ""
"assert the mock has been called with the specified calls. The :attr:"
"`mock_calls` list is checked for the calls."
msgstr ""
"斷言 mock 已經使用指定的呼叫方式來呼叫。此斷言會檢查 :attr:`mock_calls` 串列"
"中的呼叫。"

#: ../../library/unittest.mock.rst:364
msgid ""
"If *any_order* is false then the calls must be sequential. There can be "
"extra calls before or after the specified calls."
msgstr ""
"如果 *any_order* 為 false，那麼這些呼叫必須按照順序。在指定的呼叫之前或之後可"
"以有額外的呼叫。"

#: ../../library/unittest.mock.rst:368
msgid ""
"If *any_order* is true then the calls can be in any order, but they must all "
"appear in :attr:`mock_calls`."
msgstr ""
"如果 *any_order* 為 true，那麼這些呼叫可以以任何順序出現，但它們必須全部出現"
"在 :attr:`mock_calls` 中。"

#: ../../library/unittest.mock.rst:383
msgid "Assert the mock was never called."
msgstr "斷言 mock 從未被呼叫。"

#: ../../library/unittest.mock.rst:398
msgid "The reset_mock method resets all the call attributes on a mock object:"
msgstr "reset_mock 方法重置 mock 物件上的所有呼叫屬性："

#: ../../library/unittest.mock.rst:408
msgid "Added two keyword-only arguments to the reset_mock function."
msgstr "reset_mock 函式新增了兩個僅限關鍵字引數 (keyword-only arguments)。"

#: ../../library/unittest.mock.rst:411
msgid ""
"This can be useful where you want to make a series of assertions that reuse "
"the same object. Note that :meth:`reset_mock` *doesn't* clear the :attr:"
"`return_value`, :attr:`side_effect` or any child attributes you have set "
"using normal assignment by default. In case you want to reset :attr:"
"`return_value` or :attr:`side_effect`, then pass the corresponding parameter "
"as ``True``. Child mocks and the return value mock (if any) are reset as "
"well."
msgstr ""
"這在你想要進行一系列重複使用同一物件的斷言時非常有用。請注意，預設情況下，:"
"meth:`reset_mock` *不會*\\ 清除 :attr:`return_value`、:attr:`side_effect` 或"
"使用普通賦值設定的任何子屬性。如果你想要重置 :attr:`return_value` 或 :attr:"
"`side_effect`，則將相應的參數設置為 ``True``。Child mock 和回傳值 mock（如果"
"有的話）也會被重置。"

#: ../../library/unittest.mock.rst:419
msgid "*return_value*, and *side_effect* are keyword-only arguments."
msgstr "*return_value* 和 *side_effect* 是僅限關鍵字引數。"

#: ../../library/unittest.mock.rst:425
msgid ""
"Add a spec to a mock. *spec* can either be an object or a list of strings. "
"Only attributes on the *spec* can be fetched as attributes from the mock."
msgstr ""
"向 mock 增加一個規格 (spec)。*spec* 可以是一個物件或一個字串串列 (list of "
"strings)。只有在 *spec* 上的屬性才能作為 mock 的屬性被取得。"

#: ../../library/unittest.mock.rst:429
msgid "If *spec_set* is true then only attributes on the spec can be set."
msgstr "如果 *spec_set* 為 true，那麼只能設定在規格中的屬性。"

#: ../../library/unittest.mock.rst:434
msgid ""
"Attach a mock as an attribute of this one, replacing its name and parent. "
"Calls to the attached mock will be recorded in the :attr:`method_calls` and :"
"attr:`mock_calls` attributes of this one."
msgstr ""
"將一個 mock 作為這個 Mock 的屬性附加，取代它的名稱和上代 (parent)。對附加的 "
"mock 的呼叫將被記錄在這個 Mock 的 :attr:`method_calls` 和 :attr:`mock_calls` "
"屬性中。"

#: ../../library/unittest.mock.rst:441
msgid "Set attributes on the mock through keyword arguments."
msgstr "透過關鍵字引數在 mock 上設定屬性。"

#: ../../library/unittest.mock.rst:443
msgid ""
"Attributes plus return values and side effects can be set on child mocks "
"using standard dot notation and unpacking a dictionary in the method call:"
msgstr ""
"可以在使用 method（方法）呼叫時，使用標準點記法 (dot notation) 並將字典拆開，"
"為 child mock 設定屬性、回傳值和 side effects："

#: ../../library/unittest.mock.rst:457
msgid "The same thing can be achieved in the constructor call to mocks:"
msgstr "同樣的事情可以在 mock 的建構函式呼叫中實現："

#: ../../library/unittest.mock.rst:470
msgid ""
":meth:`configure_mock` exists to make it easier to do configuration after "
"the mock has been created."
msgstr ""
":meth:`configure_mock` 的存在是為了在 mock 被建立後更容易進行組態設定。"

#: ../../library/unittest.mock.rst:476
msgid ""
":class:`Mock` objects limit the results of ``dir(some_mock)`` to useful "
"results. For mocks with a *spec* this includes all the permitted attributes "
"for the mock."
msgstr ""
":class:`Mock` 物件限制了 ``dir(some_mock)`` 僅顯示有用的結果。對於具有 "
"*spec* 的 mock，這包含所有被允許的 mock 屬性。"

#: ../../library/unittest.mock.rst:480
msgid ""
"See :data:`FILTER_DIR` for what this filtering does, and how to switch it "
"off."
msgstr "請參閱 :data:`FILTER_DIR` 以了解這種過濾行為的作用，以及如何關閉它。"

#: ../../library/unittest.mock.rst:486
msgid ""
"Create the child mocks for attributes and return value. By default child "
"mocks will be the same type as the parent. Subclasses of Mock may want to "
"override this to customize the way child mocks are made."
msgstr ""
"建立為了得到屬性和回傳值的 child mock。預設情況下，child mock 將與其上代是相"
"同的型別。Mock 的子類別可能會想要置換此行為，以自定義 child mock 的建立方式。"

#: ../../library/unittest.mock.rst:491
msgid ""
"For non-callable mocks the callable variant will be used (rather than any "
"custom subclass)."
msgstr "對於不可呼叫的 mock，將使用可呼叫的變體，而不是任何的自定義子類別。"

#: ../../library/unittest.mock.rst:497
msgid "A boolean representing whether or not the mock object has been called:"
msgstr "一個 boolean（布林），表述 mock 物件是否已經被呼叫："

#: ../../library/unittest.mock.rst:508
msgid "An integer telling you how many times the mock object has been called:"
msgstr "一個整數，告訴你 mock 物件被呼叫的次數："

#: ../../library/unittest.mock.rst:520
msgid "Set this to configure the value returned by calling the mock:"
msgstr "設定此值以配置呼叫 mock 時回傳的值："

#: ../../library/unittest.mock.rst:527
msgid ""
"The default return value is a mock object and you can configure it in the "
"normal way:"
msgstr "預設的回傳值是一個 mock 物件，你也可以按照正常的方式配置它："

#: ../../library/unittest.mock.rst:536
msgid ":attr:`return_value` can also be set in the constructor:"
msgstr ":attr:`return_value` 也可以在建構函式中設定："

#: ../../library/unittest.mock.rst:547
msgid ""
"This can either be a function to be called when the mock is called, an "
"iterable or an exception (class or instance) to be raised."
msgstr ""
"這可以是一個在呼叫 mock 時要呼叫的函式、一個可疊代物件，或者要引發的例外（類"
"別或實例）。"

#: ../../library/unittest.mock.rst:550
msgid ""
"If you pass in a function it will be called with same arguments as the mock "
"and unless the function returns the :data:`DEFAULT` singleton the call to "
"the mock will then return whatever the function returns. If the function "
"returns :data:`DEFAULT` then the mock will return its normal value (from "
"the :attr:`return_value`)."
msgstr ""
"如果你傳遞一個函式，它將被呼叫，其引數與 mock 相同，且除非該函式回傳 :data:"
"`DEFAULT` 單例 (singleton)，否則對 mock 的呼叫將回傳函式回傳的任何值。如果函"
"式回傳 :data:`DEFAULT`，那麼 mock 將回傳其正常的回傳值（從 :attr:"
"`return_value` 得到）。"

#: ../../library/unittest.mock.rst:556
msgid ""
"If you pass in an iterable, it is used to retrieve an iterator which must "
"yield a value on every call.  This value can either be an exception instance "
"to be raised, or a value to be returned from the call to the mock (:data:"
"`DEFAULT` handling is identical to the function case)."
msgstr ""
"如果你傳遞一個可疊代物件，它將被用於檢索一個疊代器，該疊代器必須在每次呼叫時"
"產出 (yield) 一個值。這個值可以是要引發的例外實例，或者是對 mock 呼叫時要回傳"
"的值（處理 :data:`DEFAULT` 的方式與函式的狀況相同）。"

#: ../../library/unittest.mock.rst:561
msgid ""
"An example of a mock that raises an exception (to test exception handling of "
"an API):"
msgstr "以下是一個引發例外的 mock 的範例（用於測試 API 的例外處理）："

#: ../../library/unittest.mock.rst:571
msgid "Using :attr:`side_effect` to return a sequence of values:"
msgstr "使用 :attr:`side_effect` 回傳一連串值的範例："

#: ../../library/unittest.mock.rst:578
msgid "Using a callable:"
msgstr "使用可被呼叫物件的範例："

#: ../../library/unittest.mock.rst:588
msgid ""
":attr:`side_effect` can be set in the constructor. Here's an example that "
"adds one to the value the mock is called with and returns it:"
msgstr ""
":attr:`side_effect` 可以在建構函式中設定。以下是一個範例，它將 mock 被呼叫時"
"給的值加一並回傳："

#: ../../library/unittest.mock.rst:598
msgid "Setting :attr:`side_effect` to ``None`` clears it:"
msgstr "將 :attr:`side_effect` 設定為 ``None`` 可以清除它："

#: ../../library/unittest.mock.rst:612
msgid ""
"This is either ``None`` (if the mock hasn't been called), or the arguments "
"that the mock was last called with. This will be in the form of a tuple: the "
"first member, which can also be accessed through the ``args`` property, is "
"any ordered arguments the mock was called with (or an empty tuple) and the "
"second member, which can also be accessed through the ``kwargs`` property, "
"is any keyword arguments (or an empty dictionary)."
msgstr ""
"這會是 ``None``\\ （如果 mock 尚未被呼叫），或是 mock 上次被呼叫時使用的引"
"數。這將以元組的形式呈現：第一個成員 (member)，其可以通過 ``args`` 屬性訪問，"
"是 mock 被呼叫時傳遞的所有有序引數（或一個空元組）。第二個成員，其可以通過 "
"``kwargs`` 屬性訪問，是所有關鍵字引數（或一個空字典）。"

#: ../../library/unittest.mock.rst:645
msgid ""
":attr:`call_args`, along with members of the lists :attr:`call_args_list`, :"
"attr:`method_calls` and :attr:`mock_calls` are :data:`call` objects. These "
"are tuples, so they can be unpacked to get at the individual arguments and "
"make more complex assertions. See :ref:`calls as tuples <calls-as-tuples>`."
msgstr ""
":attr:`call_args`，以及串列 :attr:`call_args_list`、:attr:`method_calls` 和 :"
"attr:`mock_calls` 的成員都是 :data:`call` 物件。這些都是元組，因此可以解包以"
"獲取各個引數並進行更複雜的斷言。參見 :ref:`calls as tuples <calls-as-"
"tuples>`。"

#: ../../library/unittest.mock.rst:651
msgid "Added ``args`` and ``kwargs`` properties."
msgstr "新增 ``args`` 與 ``kwargs`` 特性。"

#: ../../library/unittest.mock.rst:657
msgid ""
"This is a list of all the calls made to the mock object in sequence (so the "
"length of the list is the number of times it has been called). Before any "
"calls have been made it is an empty list. The :data:`call` object can be "
"used for conveniently constructing lists of calls to compare with :attr:"
"`call_args_list`."
msgstr ""
"這是按順序列出所有呼叫 mock 物件的串列（因此串列的長度表示它被呼叫的次數）。"
"在任何呼叫發生之前，它會是一個空的串列。 :data:`call` 物件可用於方便地建構呼"
"叫的串列，以便與 :attr:`call_args_list` 進行比較。"

#: ../../library/unittest.mock.rst:673
msgid ""
"Members of :attr:`call_args_list` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
":attr:`call_args_list` 的成員都是 :data:`call` 物件。這些物件可以被拆包為元"
"組，以取得各個引數。參見 :ref:`calls as tuples <calls-as-tuples>`。"

#: ../../library/unittest.mock.rst:680
msgid ""
"As well as tracking calls to themselves, mocks also track calls to methods "
"and attributes, and *their* methods and attributes:"
msgstr ""
"除了追蹤對自身的呼叫之外，mock 還會追蹤對方法和屬性的呼叫，以及\\ *它們（這些"
"方法和屬性）*\\ 的方法和屬性："

#: ../../library/unittest.mock.rst:691
msgid ""
"Members of :attr:`method_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
":attr:`method_calls` 的成員都是 :data:`call` 物件。這些物件可以拆包為元組，以"
"取得各個引數。參見 :ref:`calls as tuples <calls-as-tuples>`。"

#: ../../library/unittest.mock.rst:698
msgid ""
":attr:`mock_calls` records *all* calls to the mock object, its methods, "
"magic methods *and* return value mocks."
msgstr ""
":attr:`mock_calls` 記錄了 *所有* 對 mock 物件的呼叫，包含其方法、魔術方法以及"
"回傳值 mock。"

#: ../../library/unittest.mock.rst:716
msgid ""
"Members of :attr:`mock_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
":attr:`method_calls` 的成員都是 :data:`call` 物件。這些物件可以拆包為元組，以"
"取得各個引數。參見 :ref:`calls as tuples <calls-as-tuples>`。"

#: ../../library/unittest.mock.rst:722
msgid ""
"The way :attr:`mock_calls` are recorded means that where nested calls are "
"made, the parameters of ancestor calls are not recorded and so will always "
"compare equal:"
msgstr ""
":attr:`mock_calls` 記錄的方式意味著在進行巢狀呼叫時，上代 (ancestor) 呼叫的參"
"數不會被記錄，因此在比較時它們將始終相等："

#: ../../library/unittest.mock.rst:736
msgid ""
"Normally the :attr:`__class__` attribute of an object will return its type. "
"For a mock object with a :attr:`spec`, ``__class__`` returns the spec class "
"instead. This allows mock objects to pass :func:`isinstance` tests for the "
"object they are replacing / masquerading as:"
msgstr ""
"通常，物件的 :attr:`__class__` 屬性會回傳它的型別。但對於擁有 :attr:`spec` "
"的 mock 物件，``__class__`` 會回傳 spec 的類別。這允許 mock 物件通過對它們所"
"替代或偽裝的物件進行的 :func:`isinstance` 測試："

#: ../../library/unittest.mock.rst:745
msgid ""
":attr:`__class__` is assignable to, this allows a mock to pass an :func:"
"`isinstance` check without forcing you to use a spec:"
msgstr ""
":attr:`__class__` 可以被指定，這允許 mock 通過 :func:`isinstance` 檢查，而不"
"需要強制使用 spec："

#: ../../library/unittest.mock.rst:755
msgid ""
"A non-callable version of :class:`Mock`. The constructor parameters have the "
"same meaning of :class:`Mock`, with the exception of *return_value* and "
"*side_effect* which have no meaning on a non-callable mock."
msgstr ""
":class:`Mock` 的一個不可呼叫版本。建構函式參數的意義與 :class:`Mock` 相同，其"
"例外為 *return_value* 和 *side_effect* 在不可呼叫的 mock 上無意義。"

#: ../../library/unittest.mock.rst:759
msgid ""
"Mock objects that use a class or an instance as a :attr:`spec` or :attr:"
"`spec_set` are able to pass :func:`isinstance` tests:"
msgstr ""
"使用類別或實例作為 :attr:`spec` 或 :attr:`spec_set` 的 mock 物件能夠通過 :"
"func:`isinstance` 測試："

#: ../../library/unittest.mock.rst:769
msgid ""
"The :class:`Mock` classes have support for mocking magic methods. See :ref:"
"`magic methods <magic-methods>` for the full details."
msgstr ""
":class:`Mock` 類別支援 mock 魔術方法。細節請參考\\ :ref:`魔術方法 <magic-"
"methods>`。"

#: ../../library/unittest.mock.rst:772
msgid ""
"The mock classes and the :func:`patch` decorators all take arbitrary keyword "
"arguments for configuration. For the :func:`patch` decorators the keywords "
"are passed to the constructor of the mock being created. The keyword "
"arguments are for configuring attributes of the mock:"
msgstr ""
"Mock類別和 :func:`patch` 裝飾器於組態時接受任意的關鍵字引數。對於 :func:"
"`patch` 裝飾器，這些關鍵字會傳遞給正在建立 mock 的建構函式。這些關鍵字引數用"
"於配置 mock 的屬性："

#: ../../library/unittest.mock.rst:783
msgid ""
"The return value and side effect of child mocks can be set in the same way, "
"using dotted notation. As you can't use dotted names directly in a call you "
"have to create a dictionary and unpack it using ``**``:"
msgstr ""
"Child mock 的回傳值和 side effect 可以使用使用點記法進行設置。由於你無法直接"
"在呼叫中使用帶有點 (.) 的名稱，因此你必須建立一個字典並使用 ``**`` 解包："

#: ../../library/unittest.mock.rst:798
msgid ""
"A callable mock which was created with a *spec* (or a *spec_set*) will "
"introspect the specification object's signature when matching calls to the "
"mock.  Therefore, it can match the actual call's arguments regardless of "
"whether they were passed positionally or by name::"
msgstr ""
"在匹配對 mock 的呼叫時，使用 *spec*\\ （或 *spec_set*\\ ）建立的可呼叫 mock "
"將會內省 (introspect) 規格物件的簽名 (signature)。因此，它可以匹配實際呼叫的"
"引數，無論它們是按位置傳遞還是按名稱傳遞： ::"

#: ../../library/unittest.mock.rst:803
msgid ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, c=3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(1, 2, 3)\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"
msgstr ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, c=3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(1, 2, 3)\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"

#: ../../library/unittest.mock.rst:811
msgid ""
"This applies to :meth:`~Mock.assert_called_with`, :meth:`~Mock."
"assert_called_once_with`, :meth:`~Mock.assert_has_calls` and :meth:`~Mock."
"assert_any_call`.  When :ref:`auto-speccing`, it will also apply to method "
"calls on the mock object."
msgstr ""
"這適用於 :meth:`~Mock.assert_called_with`、:meth:`~Mock."
"assert_called_once_with`、:meth:`~Mock.assert_has_calls` 和 :meth:`~Mock."
"assert_any_call`。在使用 :ref:`auto-speccing` 時，它還適用於 mock 物件的方法"
"呼叫。"

#: ../../library/unittest.mock.rst:816
msgid "Added signature introspection on specced and autospecced mock objects."
msgstr ""
"對於已經設置了規格（spec）和自動規格（autospec）的 mock 物件，新增簽名內省功"
"能。"

#: ../../library/unittest.mock.rst:822
msgid ""
"A mock intended to be used as a :class:`property`, or other :term:"
"`descriptor`, on a class. :class:`PropertyMock` provides :meth:`~object."
"__get__` and :meth:`~object.__set__` methods so you can specify a return "
"value when it is fetched."
msgstr ""
"一個理應在類別上當成 :class:`property` 或其他 :term:`descriptor` 的 mock。:"
"class:`PropertyMock` 提供了 :meth:`~object.__get__` 和 :meth:`~object."
"__set__` 方法，因此你可以在它被提取時指定回傳值。"

#: ../../library/unittest.mock.rst:827
msgid ""
"Fetching a :class:`PropertyMock` instance from an object calls the mock, "
"with no args. Setting it calls the mock with the value being set. ::"
msgstr ""
"從物件中提取 :class:`PropertyMock` 實例會不帶任何引數呼叫 mock。設定它則會用"
"設定的值來呼叫 mock： ::"

#: ../../library/unittest.mock.rst:830
msgid ""
">>> class Foo:\n"
"...     @property\n"
"...     def foo(self):\n"
"...         return 'something'\n"
"...     @foo.setter\n"
"...     def foo(self, value):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Foo.foo', new_callable=PropertyMock) as mock_foo:\n"
"...     mock_foo.return_value = 'mockity-mock'\n"
"...     this_foo = Foo()\n"
"...     print(this_foo.foo)\n"
"...     this_foo.foo = 6\n"
"...\n"
"mockity-mock\n"
">>> mock_foo.mock_calls\n"
"[call(), call(6)]"
msgstr ""
">>> class Foo:\n"
"...     @property\n"
"...     def foo(self):\n"
"...         return 'something'\n"
"...     @foo.setter\n"
"...     def foo(self, value):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Foo.foo', new_callable=PropertyMock) as mock_foo:\n"
"...     mock_foo.return_value = 'mockity-mock'\n"
"...     this_foo = Foo()\n"
"...     print(this_foo.foo)\n"
"...     this_foo.foo = 6\n"
"...\n"
"mockity-mock\n"
">>> mock_foo.mock_calls\n"
"[call(), call(6)]"

#: ../../library/unittest.mock.rst:848
msgid ""
"Because of the way mock attributes are stored you can't directly attach a :"
"class:`PropertyMock` to a mock object. Instead you can attach it to the mock "
"type object::"
msgstr ""
"由於 mock 屬性的儲存方式，你無法直接將 :class:`PropertyMock` 附加到 mock 物"
"件。但是你可以將其附加到 mock 型別的物件： ::"

#: ../../library/unittest.mock.rst:852
msgid ""
">>> m = MagicMock()\n"
">>> p = PropertyMock(return_value=3)\n"
">>> type(m).foo = p\n"
">>> m.foo\n"
"3\n"
">>> p.assert_called_once_with()"
msgstr ""
">>> m = MagicMock()\n"
">>> p = PropertyMock(return_value=3)\n"
">>> type(m).foo = p\n"
">>> m.foo\n"
"3\n"
">>> p.assert_called_once_with()"

#: ../../library/unittest.mock.rst:861
msgid ""
"If an :exc:`AttributeError` is raised by :class:`PropertyMock`, it will be "
"interpreted as a missing descriptor and :meth:`~object.__getattr__` will be "
"called on the parent mock::"
msgstr ""

#: ../../library/unittest.mock.rst:865
msgid ""
">>> m = MagicMock()\n"
">>> no_attribute = PropertyMock(side_effect=AttributeError)\n"
">>> type(m).my_property = no_attribute\n"
">>> m.my_property\n"
"<MagicMock name='mock.my_property' id='140165240345424'>"
msgstr ""
">>> m = MagicMock()\n"
">>> no_attribute = PropertyMock(side_effect=AttributeError)\n"
">>> type(m).my_property = no_attribute\n"
">>> m.my_property\n"
"<MagicMock name='mock.my_property' id='140165240345424'>"

#: ../../library/unittest.mock.rst:871
msgid "See :meth:`~object.__getattr__` for details."
msgstr "詳情請見 :meth:`~object.__getattr__`。"

#: ../../library/unittest.mock.rst:876
msgid ""
"An asynchronous version of :class:`MagicMock`. The :class:`AsyncMock` object "
"will behave so the object is recognized as an async function, and the result "
"of a call is an awaitable."
msgstr ""
":class:`MagicMock` 的非同步版本。:class:`AsyncMock` 物件的表現將被視為非同步"
"函式，並且呼叫的結果是一個可等待物件。"

#: ../../library/unittest.mock.rst:886
msgid ""
"The result of ``mock()`` is an async function which will have the outcome of "
"``side_effect`` or ``return_value`` after it has been awaited:"
msgstr ""
"``mock()`` 的結果是一個非同步函式，在它被等待後將具有 ``side_effect`` 或 "
"``return_value`` 的結果："

#: ../../library/unittest.mock.rst:889
msgid ""
"if ``side_effect`` is a function, the async function will return the result "
"of that function,"
msgstr "如果 ``side_effect`` 是一個函式，非同步函式將回傳該函式的結果，"

#: ../../library/unittest.mock.rst:891
msgid ""
"if ``side_effect`` is an exception, the async function will raise the "
"exception,"
msgstr "如果 ``side_effect`` 是一個例外，則非同步函式將引發該例外，"

#: ../../library/unittest.mock.rst:893
msgid ""
"if ``side_effect`` is an iterable, the async function will return the next "
"value of the iterable, however, if the sequence of result is exhausted, "
"``StopAsyncIteration`` is raised immediately,"
msgstr ""
"如果 ``side_effect`` 是一個可疊代物件，非同步函式將回傳可疊代物件的下一個值，"
"但如果結果序列耗盡，將立即引發 ``StopAsyncIteration``，"

#: ../../library/unittest.mock.rst:896
msgid ""
"if ``side_effect`` is not defined, the async function will return the value "
"defined by ``return_value``, hence, by default, the async function returns a "
"new :class:`AsyncMock` object."
msgstr ""
"如果 ``side_effect`` 沒有被定義，非同步函式將回傳由 ``return_value`` 定義的"
"值，因此在預設情況下，非同步函式回傳一個新的 :class:`AsyncMock` 物件。"

#: ../../library/unittest.mock.rst:901
msgid ""
"Setting the *spec* of a :class:`Mock` or :class:`MagicMock` to an async "
"function will result in a coroutine object being returned after calling."
msgstr ""
"將 :class:`Mock` 或 :class:`MagicMock` 的 *spec* 設定為非同步函式將導致在呼叫"
"後回傳一個協程物件。"

#: ../../library/unittest.mock.rst:913
msgid ""
"Setting the *spec* of a :class:`Mock`, :class:`MagicMock`, or :class:"
"`AsyncMock` to a class with asynchronous and synchronous functions will "
"automatically detect the synchronous functions and set them as :class:"
"`MagicMock` (if the parent mock is :class:`AsyncMock` or :class:`MagicMock`) "
"or :class:`Mock` (if the parent mock is :class:`Mock`). All asynchronous "
"functions will be :class:`AsyncMock`."
msgstr ""
"將 :class:`Mock`、:class:`MagicMock` 或 :class:`AsyncMock` 的 *spec* 設定為具"
"有同步和非同步函式的類別，會自動檢測同步函式並將其設定為 :class:"
"`MagicMock`\\ （如果上代 mock 為 :class:`AsyncMock` 或 :class:"
"`MagicMock`\\ ）或 :class:`Mock`\\ （如果上代 mock 為 :class:`Mock`\\ ）。所"
"有非同步函式將被設定為 :class:`AsyncMock`。"

#: ../../library/unittest.mock.rst:941
msgid ""
"Assert that the mock was awaited at least once. Note that this is separate "
"from the object having been called, the ``await`` keyword must be used:"
msgstr ""
"斷言 mock 至少被等待過一次。請注意這與物件是否被呼叫是分開的，``await`` 關鍵"
"字必須被使用："

#: ../../library/unittest.mock.rst:960
msgid "Assert that the mock was awaited exactly once."
msgstr "斷言 mock 正好被等待了一次。"

#: ../../library/unittest.mock.rst:976
msgid "Assert that the last await was with the specified arguments."
msgstr "斷言最後一次等待使用了指定的引數。"

#: ../../library/unittest.mock.rst:993
msgid ""
"Assert that the mock was awaited exactly once and with the specified "
"arguments."
msgstr "斷言 mock 只被等待了一次並使用了指定的引數。"

#: ../../library/unittest.mock.rst:1010
msgid "Assert the mock has ever been awaited with the specified arguments."
msgstr "斷言 mock 曾經被使用指定的引數等待過。"

#: ../../library/unittest.mock.rst:1026
msgid ""
"Assert the mock has been awaited with the specified calls. The :attr:"
"`await_args_list` list is checked for the awaits."
msgstr ""
"斷言 mock 已被使用指定的呼叫進行等待。:attr:`await_args_list` 串列將被檢查以"
"確認等待的內容。"

#: ../../library/unittest.mock.rst:1029
msgid ""
"If *any_order* is false then the awaits must be sequential. There can be "
"extra calls before or after the specified awaits."
msgstr ""
"如果 *any_order* 為 false，則等待必須按照順序。指定的等待之前或之後可以有額外"
"的呼叫。"

#: ../../library/unittest.mock.rst:1033
msgid ""
"If *any_order* is true then the awaits can be in any order, but they must "
"all appear in :attr:`await_args_list`."
msgstr ""
"如果 *any_order* 為 true，則等待可以以任何順序出現，但它們必須全部出現在 :"
"attr:`await_args_list` 中。"

#: ../../library/unittest.mock.rst:1053
msgid "Assert that the mock was never awaited."
msgstr "斷言 mock 從未被等待。"

#: ../../library/unittest.mock.rst:1060
msgid ""
"See :func:`Mock.reset_mock`. Also sets :attr:`await_count` to 0, :attr:"
"`await_args` to None, and clears the :attr:`await_args_list`."
msgstr ""
"參見 :func:`Mock.reset_mock`。同時將 :attr:`await_count` 設定為 0，:attr:"
"`await_args` 設定為 None，並清除 :attr:`await_args_list`。"

#: ../../library/unittest.mock.rst:1065
msgid ""
"An integer keeping track of how many times the mock object has been awaited."
msgstr "一個整數，用來記錄 mock 物件已被等待的次數。"

#: ../../library/unittest.mock.rst:1080
msgid ""
"This is either ``None`` (if the mock hasn’t been awaited), or the arguments "
"that the mock was last awaited with. Functions the same as :attr:`Mock."
"call_args`."
msgstr ""
"這可能是 ``None``\\ （如果 mock 尚未被等待），或者是上次等待 mock 時使用的引"
"數。與 :attr:`Mock.call_args` 的功能相同。"

#: ../../library/unittest.mock.rst:1098
msgid ""
"This is a list of all the awaits made to the mock object in sequence (so the "
"length of the list is the number of times it has been awaited). Before any "
"awaits have been made it is an empty list."
msgstr ""
"這是一個按照順序記錄 mock 物件所有等待的串列（因此串列的長度表示該物件已被等"
"待的次數）。在進行任何等待之前，此串列為空。"

#: ../../library/unittest.mock.rst:1117
msgid "Calling"
msgstr "呼叫"

#: ../../library/unittest.mock.rst:1119
msgid ""
"Mock objects are callable. The call will return the value set as the :attr:"
"`~Mock.return_value` attribute. The default return value is a new Mock "
"object; it is created the first time the return value is accessed (either "
"explicitly or by calling the Mock) - but it is stored and the same one "
"returned each time."
msgstr ""
"Mock 物件可被呼叫。呼叫將回傳設定為 :attr:`~Mock.return_value` 屬性的值。預設"
"的回傳值是一個新的 Mock 物件；它會在第一次存取回傳值時（無論是顯式存取還是透"
"過呼叫 Mock）被建立，但是這個回傳值會被儲存，之後每次都回傳同一個值。"

#: ../../library/unittest.mock.rst:1125
msgid ""
"Calls made to the object will be recorded in the attributes like :attr:"
"`~Mock.call_args` and :attr:`~Mock.call_args_list`."
msgstr ""
"對物件的呼叫會被記錄在如 :attr:`~Mock.call_args` 和 :attr:`~Mock."
"call_args_list` 等屬性中。"

#: ../../library/unittest.mock.rst:1128
msgid ""
"If :attr:`~Mock.side_effect` is set then it will be called after the call "
"has been recorded, so if :attr:`side_effect` raises an exception the call is "
"still recorded."
msgstr ""
"如果 :attr:`~Mock.side_effect` 被設定，那麼在呼叫被記錄後它才會被呼叫，所以如"
"果 :attr:`side_effect` 引發例外，呼叫仍然會被記錄。"

#: ../../library/unittest.mock.rst:1132
msgid ""
"The simplest way to make a mock raise an exception when called is to make :"
"attr:`~Mock.side_effect` an exception class or instance:"
msgstr ""
"呼叫 mock 時引發例外的最簡單方式是將 :attr:`~Mock.side_effect` 設定為例外類別"
"或實例："

#: ../../library/unittest.mock.rst:1150
msgid ""
"If :attr:`side_effect` is a function then whatever that function returns is "
"what calls to the mock return. The :attr:`side_effect` function is called "
"with the same arguments as the mock. This allows you to vary the return "
"value of the call dynamically, based on the input:"
msgstr ""
"如果 :attr:`side_effect` 是一個函式，則該函式回傳的東西就是對 mock 的呼叫所回"
"傳的值。:attr:`side_effect` 函式會使用與 mock 相同的引數被呼叫。這讓你可以根"
"據輸入動態地變更呼叫的回傳值："

#: ../../library/unittest.mock.rst:1166
msgid ""
"If you want the mock to still return the default return value (a new mock), "
"or any set return value, then there are two ways of doing this. Either "
"return :attr:`mock.return_value` from inside :attr:`side_effect`, or return :"
"data:`DEFAULT`:"
msgstr ""
"如果你希望 mock 仍然回傳預設的回傳值（一個新的 mock），或者是任何已設定的回傳"
"值，有兩種方法可以實現。從 :attr:`side_effect` 內部回傳 :attr:`mock."
"return_value`，或回傳 :data:`DEFAULT`："

#: ../../library/unittest.mock.rst:1185
msgid ""
"To remove a :attr:`side_effect`, and return to the default behaviour, set "
"the :attr:`side_effect` to ``None``:"
msgstr ""
"要刪除 :attr:`side_effect`，並恢復預設行為，將 :attr:`side_effect` 設為 "
"``None``："

#: ../../library/unittest.mock.rst:1199
msgid ""
"The :attr:`side_effect` can also be any iterable object. Repeated calls to "
"the mock will return values from the iterable (until the iterable is "
"exhausted and a :exc:`StopIteration` is raised):"
msgstr ""
":attr:`side_effect` 也可以是任何可疊代的物件。對 mock 的重複呼叫將從可疊代物"
"件中回傳值（直到疊代物件耗盡並引發 :exc:`StopIteration` 為止）："

#: ../../library/unittest.mock.rst:1215
msgid ""
"If any members of the iterable are exceptions they will be raised instead of "
"returned::"
msgstr "如果可疊代物件中的任何成員是例外，則它們將被引發而不是被回傳： ::"

#: ../../library/unittest.mock.rst:1218
msgid ""
">>> iterable = (33, ValueError, 66)\n"
">>> m = MagicMock(side_effect=iterable)\n"
">>> m()\n"
"33\n"
">>> m()\n"
"Traceback (most recent call last):\n"
" ...\n"
"ValueError\n"
">>> m()\n"
"66"
msgstr ""
">>> iterable = (33, ValueError, 66)\n"
">>> m = MagicMock(side_effect=iterable)\n"
">>> m()\n"
"33\n"
">>> m()\n"
"Traceback (most recent call last):\n"
" ...\n"
"ValueError\n"
">>> m()\n"
"66"

#: ../../library/unittest.mock.rst:1233
msgid "Deleting Attributes"
msgstr "刪除屬性"

#: ../../library/unittest.mock.rst:1235
msgid ""
"Mock objects create attributes on demand. This allows them to pretend to be "
"objects of any type."
msgstr "Mock 物件會在需要時建立屬性。這使得它們可以假裝成任何種類的物件。"

#: ../../library/unittest.mock.rst:1238
msgid ""
"You may want a mock object to return ``False`` to a :func:`hasattr` call, or "
"raise an :exc:`AttributeError` when an attribute is fetched. You can do this "
"by providing an object as a :attr:`spec` for a mock, but that isn't always "
"convenient."
msgstr ""
"你可能希望一個 mock 物件在 :func:`hasattr` 呼叫時回傳 ``False``，或者在屬性被"
"提取時引發 :exc:`AttributeError`。你可以通過將物件提供為 mock 的 :attr:"
"`spec` 來實現這一點，但這並不總是那麼好用。"

#: ../../library/unittest.mock.rst:1242
msgid ""
"You \"block\" attributes by deleting them. Once deleted, accessing an "
"attribute will raise an :exc:`AttributeError`."
msgstr ""
"你可以通過刪除屬性來「阻擋」它們。一旦刪除，再次存取該屬性將會引發 :exc:"
"`AttributeError`。"

#: ../../library/unittest.mock.rst:1259
msgid "Mock names and the name attribute"
msgstr "Mock 名稱與名稱屬性"

#: ../../library/unittest.mock.rst:1261
msgid ""
"Since \"name\" is an argument to the :class:`Mock` constructor, if you want "
"your mock object to have a \"name\" attribute you can't just pass it in at "
"creation time. There are two alternatives. One option is to use :meth:`~Mock."
"configure_mock`::"
msgstr ""
"由於 \"name\" 是傳遞給 :class:`Mock` 建構函式的引數，如果你想讓你的 mock 物件"
"擁有 \"name\" 屬性，你不能在建立時直接傳遞它。有兩種替代方法。其中一個選擇是"
"使用 :meth:`~Mock.configure_mock`： ::"

#: ../../library/unittest.mock.rst:1266
msgid ""
">>> mock = MagicMock()\n"
">>> mock.configure_mock(name='my_name')\n"
">>> mock.name\n"
"'my_name'"
msgstr ""
">>> mock = MagicMock()\n"
">>> mock.configure_mock(name='my_name')\n"
">>> mock.name\n"
"'my_name'"

#: ../../library/unittest.mock.rst:1271
msgid ""
"A simpler option is to simply set the \"name\" attribute after mock "
"creation::"
msgstr "更簡單的方法是在 mock 建立後直接設定 \"name\" 屬性： ::"

#: ../../library/unittest.mock.rst:1273
msgid ""
">>> mock = MagicMock()\n"
">>> mock.name = \"foo\""
msgstr ""
">>> mock = MagicMock()\n"
">>> mock.name = \"foo\""

#: ../../library/unittest.mock.rst:1278
msgid "Attaching Mocks as Attributes"
msgstr "如同屬性一般附加 mock"

#: ../../library/unittest.mock.rst:1280
msgid ""
"When you attach a mock as an attribute of another mock (or as the return "
"value) it becomes a \"child\" of that mock. Calls to the child are recorded "
"in the :attr:`~Mock.method_calls` and :attr:`~Mock.mock_calls` attributes of "
"the parent. This is useful for configuring child mocks and then attaching "
"them to the parent, or for attaching mocks to a parent that records all "
"calls to the children and allows you to make assertions about the order of "
"calls between mocks:"
msgstr ""
"當你將一個 mock 附加為另一個 mock 的屬性（或作為回傳值），它將成為該 mock 的"
"「子代 (child)」。對子代的呼叫將被記錄在上代的 :attr:`~Mock.method_calls` "
"和 :attr:`~Mock.mock_calls` 屬性中。這對於配置子代並將它們附加到上代，或將 "
"mock 附加到記錄所有對子代的呼叫的上代並允許你對 mock 間的呼叫順序進行斷言非常"
"有用："

#: ../../library/unittest.mock.rst:1298
msgid ""
"The exception to this is if the mock has a name. This allows you to prevent "
"the \"parenting\" if for some reason you don't want it to happen."
msgstr ""
"如果 mock 有 name 引數，則上述規則會有例外。這使你可以防止「親屬關係 "
"(parenting)」的建立，假設因為某些原因你不希望這種狀況發生。"

#: ../../library/unittest.mock.rst:1309
msgid ""
"Mocks created for you by :func:`patch` are automatically given names. To "
"attach mocks that have names to a parent you use the :meth:`~Mock."
"attach_mock` method::"
msgstr ""
"由 :func:`patch` 為你建立的 mock 會自動被賦予名稱。若要將具有名稱的 mock 附加"
"到上代，你可以使用 :meth:`~Mock.attach_mock` 方法： ::"

#: ../../library/unittest.mock.rst:1313
msgid ""
">>> thing1 = object()\n"
">>> thing2 = object()\n"
">>> parent = MagicMock()\n"
">>> with patch('__main__.thing1', return_value=None) as child1:\n"
"...     with patch('__main__.thing2', return_value=None) as child2:\n"
"...         parent.attach_mock(child1, 'child1')\n"
"...         parent.attach_mock(child2, 'child2')\n"
"...         child1('one')\n"
"...         child2('two')\n"
"...\n"
">>> parent.mock_calls\n"
"[call.child1('one'), call.child2('two')]"
msgstr ""
">>> thing1 = object()\n"
">>> thing2 = object()\n"
">>> parent = MagicMock()\n"
">>> with patch('__main__.thing1', return_value=None) as child1:\n"
"...     with patch('__main__.thing2', return_value=None) as child2:\n"
"...         parent.attach_mock(child1, 'child1')\n"
"...         parent.attach_mock(child2, 'child2')\n"
"...         child1('one')\n"
"...         child2('two')\n"
"...\n"
">>> parent.mock_calls\n"
"[call.child1('one'), call.child2('two')]"

#: ../../library/unittest.mock.rst:1327
msgid ""
"The only exceptions are magic methods and attributes (those that have "
"leading and trailing double underscores). Mock doesn't create these but "
"instead raises an :exc:`AttributeError`. This is because the interpreter "
"will often implicitly request these methods, and gets *very* confused to get "
"a new Mock object when it expects a magic method. If you need magic method "
"support see :ref:`magic methods <magic-methods>`."
msgstr ""
"唯一的例外是魔術方法和屬性（具有前後雙底線）。Mock 不會建立這些，而是會引發 :"
"exc:`AttributeError`。這是因為直譯器通常會隱式地要求這些方法，在期望得到一個"
"魔術方法卻獲得一個新的 Mock 物件時，會讓直譯器\\ *非常*\\ 困惑。如果你需要魔"
"術方法的支援，請參閱\\ :ref:`魔術方法 <magic-methods>`。"

#: ../../library/unittest.mock.rst:1336
msgid "The patchers"
msgstr "Patchers"

#: ../../library/unittest.mock.rst:1338
msgid ""
"The patch decorators are used for patching objects only within the scope of "
"the function they decorate. They automatically handle the unpatching for "
"you, even if exceptions are raised. All of these functions can also be used "
"in with statements or as class decorators."
msgstr ""
"patch 裝飾器僅用於在裝飾的函式範圍內對物件進行 patch。它們會自動為你處理 "
"patch 的中止，即使有異常被引發也是如此。所有這些函式也可以在 with 陳述式中使"
"用，或者作為類別裝飾器使用。"

#: ../../library/unittest.mock.rst:1345
msgid "patch"
msgstr "patch"

#: ../../library/unittest.mock.rst:1349
msgid ""
"The key is to do the patching in the right namespace. See the section `where "
"to patch`_."
msgstr "關鍵是要在正確的命名空間進行 patch。請參閱 `where to patch`_ 一節。"

#: ../../library/unittest.mock.rst:1353
msgid ""
":func:`patch` acts as a function decorator, class decorator or a context "
"manager. Inside the body of the function or with statement, the *target* is "
"patched with a *new* object. When the function/with statement exits the "
"patch is undone."
msgstr ""
":func:`patch` 充當函式裝飾器、類別裝飾器或情境管理器。在函式或 with 陳述式的"
"內部，*目標*\\ 會被 patch 成一個\\ *新的*\\ 物件。當函式或 with 陳述式結束"
"時，patch 就會被解除。"

#: ../../library/unittest.mock.rst:1358
msgid ""
"If *new* is omitted, then the target is replaced with an :class:`AsyncMock` "
"if the patched object is an async function or a :class:`MagicMock` "
"otherwise. If :func:`patch` is used as a decorator and *new* is omitted, the "
"created mock is passed in as an extra argument to the decorated function. "
"If :func:`patch` is used as a context manager the created mock is returned "
"by the context manager."
msgstr ""
"如果 *new* 被省略，則如果被 patch 的物件是非同步函式，目標會被替換為 :class:"
"`AsyncMock`，反之則替換為 :class:`MagicMock`。如果 :func:`patch` 做為裝飾器使"
"用且省略了 *new*，則所建立的 mock 會作為額外的引數傳遞給被裝飾的函式。如果 :"
"func:`patch` 作為情境管理器使用，則所建立的 mock 將由情境管理器回傳。"

#: ../../library/unittest.mock.rst:1366
msgid ""
"*target* should be a string in the form ``'package.module.ClassName'``. The "
"*target* is imported and the specified object replaced with the *new* "
"object, so the *target* must be importable from the environment you are "
"calling :func:`patch` from. The target is imported when the decorated "
"function is executed, not at decoration time."
msgstr ""
"*target* 應該是以 ``'package.module.ClassName'`` 形式出現的字串。*target* 會"
"被引入並用 *new* 物件替換指定的物件，因此 *target* 必須可從你呼叫 :func:"
"`patch` 的環境中引入。target 在執行被裝飾的函式時被引入，而不是在裝飾器作用"
"時 (decoration time)。"

#: ../../library/unittest.mock.rst:1372
msgid ""
"The *spec* and *spec_set* keyword arguments are passed to the :class:"
"`MagicMock` if patch is creating one for you."
msgstr ""
"*spec* 和 *spec_set* 關鍵字引數會傳遞給 :class:`MagicMock`，如果 patch 正在為"
"你建立一個。"

#: ../../library/unittest.mock.rst:1375
msgid ""
"In addition you can pass ``spec=True`` or ``spec_set=True``, which causes "
"patch to pass in the object being mocked as the spec/spec_set object."
msgstr ""
"此外，你還可以傳遞 ``spec=True`` 或 ``spec_set=True``，這將導致 patch 將被 "
"mock 的物件作為 spec/spec_set 物件傳遞。"

#: ../../library/unittest.mock.rst:1378
msgid ""
"*new_callable* allows you to specify a different class, or callable object, "
"that will be called to create the *new* object. By default :class:"
"`AsyncMock` is used for async functions and :class:`MagicMock` for the rest."
msgstr ""
"*new_callable* 允許你指定一個不同的類別或可呼叫的物件，用於被呼叫並建立 "
"*new* 物件。預設情況下，對於非同步函式使用 :class:`AsyncMock`，而對於其他情況"
"則使用 :class:`MagicMock`。"

#: ../../library/unittest.mock.rst:1382
msgid ""
"A more powerful form of *spec* is *autospec*. If you set ``autospec=True`` "
"then the mock will be created with a spec from the object being replaced. "
"All attributes of the mock will also have the spec of the corresponding "
"attribute of the object being replaced. Methods and functions being mocked "
"will have their arguments checked and will raise a :exc:`TypeError` if they "
"are called with the wrong signature. For mocks replacing a class, their "
"return value (the 'instance') will have the same spec as the class. See the :"
"func:`create_autospec` function and :ref:`auto-speccing`."
msgstr ""
"*spec* 的一種更強大的形式是 *autospec*。如果你設定 ``autospec=True``，則該 "
"mock 將使用被替換物件的規格來建立。該 mock 的所有屬性也將具有被替換物件的對應"
"屬性的規格。被 mock 的方法和函式將檢查其引數，如果呼叫時引數與規格不符（被使"
"用錯誤的簽名 (signature) 呼叫），將引發 :exc:`TypeError`。對於替換類別的 "
"mock，它們的回傳值（即 'instance'）將具有與類別相同的規格。請參閱 :func:"
"`create_autospec` 函式和 :ref:`auto-speccing`。"

#: ../../library/unittest.mock.rst:1392
msgid ""
"Instead of ``autospec=True`` you can pass ``autospec=some_object`` to use an "
"arbitrary object as the spec instead of the one being replaced."
msgstr ""
"你可以用 ``autospec=some_object`` 替代 ``autospec=True``，以使用任意物件作為"
"規格，而不是被替換的物件。"

#: ../../library/unittest.mock.rst:1395
msgid ""
"By default :func:`patch` will fail to replace attributes that don't exist. "
"If you pass in ``create=True``, and the attribute doesn't exist, patch will "
"create the attribute for you when the patched function is called, and delete "
"it again after the patched function has exited. This is useful for writing "
"tests against attributes that your production code creates at runtime. It is "
"off by default because it can be dangerous. With it switched on you can "
"write passing tests against APIs that don't actually exist!"
msgstr ""
"預設情況下，:func:`patch` 將無法取代不存在的屬性。如果你傳入 "
"``create=True``，且屬性不存在，則當被 patch 的函式被呼叫時，patch 將為你建立"
"該屬性，並在被 patch 的函式結束後再次刪除它。這對於撰寫針對你的生產程式碼在執"
"行環境建立的屬性的測試時非常有用。此功能預設為關閉，因為這可能會相當危險。開"
"啟這個功能後，你可以對於實際上不存在的 API 撰寫會通過的測試！"

#: ../../library/unittest.mock.rst:1405
msgid ""
"If you are patching builtins in a module then you don't need to pass "
"``create=True``, it will be added by default."
msgstr ""
"如果你正在 patch 模組中的內建函式，那麼你不需要傳遞 ``create=True``，它預設會"
"被加入。"

#: ../../library/unittest.mock.rst:1409
msgid ""
"Patch can be used as a :class:`TestCase` class decorator. It works by "
"decorating each test method in the class. This reduces the boilerplate code "
"when your test methods share a common patchings set. :func:`patch` finds "
"tests by looking for method names that start with ``patch.TEST_PREFIX``. By "
"default this is ``'test'``, which matches the way :mod:`unittest` finds "
"tests. You can specify an alternative prefix by setting ``patch."
"TEST_PREFIX``."
msgstr ""
"patch 可以做為 :class:`TestCase` 類別的裝飾器使用。它透過裝飾類別中的每個測試"
"方法來運作。當你的測試方法共享一組常見的 patch 時，這會減少繁冗的代碼。:func:"
"`patch` 通過搜尋以 ``patch.TEST_PREFIX`` 開頭的方法名來尋找測試。預設情況下會"
"是 ``'test'``，這與 :mod:`unittest` 尋找測試的方式相匹配。你可以通過設定 "
"``patch.TEST_PREFIX`` 來指定別的前綴。"

#: ../../library/unittest.mock.rst:1416
msgid ""
"Patch can be used as a context manager, with the with statement. Here the "
"patching applies to the indented block after the with statement. If you use "
"\"as\" then the patched object will be bound to the name after the \"as\"; "
"very useful if :func:`patch` is creating a mock object for you."
msgstr ""
"透過 with 陳述式，Patch 可以做為情境管理器使用。patch 適用於 with 陳述式之後"
"的縮排區塊。如果你使用 \"as\"，則被 patch 的物件將被綁定到 \"as\" 後面的名"
"稱；如果 :func:`patch` 正在為你建立一個 mock 物件，這會非常有用。"

#: ../../library/unittest.mock.rst:1421
msgid ""
":func:`patch` takes arbitrary keyword arguments. These will be passed to :"
"class:`AsyncMock` if the patched object is asynchronous, to :class:"
"`MagicMock` otherwise or to *new_callable* if specified."
msgstr ""
":func:`patch` 接受任意的關鍵字引數。如果被 patch 的物件是非同步的，這些將會被"
"傳遞給 :class:`AsyncMock`，如果是同步的則會傳遞給 :class:`MagicMock`，或如果"
"指定了 *new_callable*，則傳遞給它。"

#: ../../library/unittest.mock.rst:1425
msgid ""
"``patch.dict(...)``, ``patch.multiple(...)`` and ``patch.object(...)`` are "
"available for alternate use-cases."
msgstr ""
"``patch.dict(...)``、``patch.multiple(...)`` 和 ``patch.object(...)`` 可用於"
"其餘的使用情境。"

#: ../../library/unittest.mock.rst:1428
msgid ""
":func:`patch` as function decorator, creating the mock for you and passing "
"it into the decorated function::"
msgstr ""
":func:`patch` 作為函式裝飾器，為你建立 mock 並將其傳遞給被裝飾的函式： ::"

#: ../../library/unittest.mock.rst:1431
msgid ""
">>> @patch('__main__.SomeClass')\n"
"... def function(normal_argument, mock_class):\n"
"...     print(mock_class is SomeClass)\n"
"...\n"
">>> function(None)\n"
"True"
msgstr ""
">>> @patch('__main__.SomeClass')\n"
"... def function(normal_argument, mock_class):\n"
"...     print(mock_class is SomeClass)\n"
"...\n"
">>> function(None)\n"
"True"

#: ../../library/unittest.mock.rst:1438
msgid ""
"Patching a class replaces the class with a :class:`MagicMock` *instance*. If "
"the class is instantiated in the code under test then it will be the :attr:"
"`~Mock.return_value` of the mock that will be used."
msgstr ""
"Patch 一個類別會以 :class:`MagicMock`\\  *實例*\\ 取代該類別。如果該類別在被"
"測試的程式碼中實例化，那麼它將是會被使用的 mock 的 :attr:`~Mock."
"return_value`。"

#: ../../library/unittest.mock.rst:1442
msgid ""
"If the class is instantiated multiple times you could use :attr:`~Mock."
"side_effect` to return a new mock each time. Alternatively you can set the "
"*return_value* to be anything you want."
msgstr ""
"如果該類別被實例化多次，你可以使用 :attr:`~Mock.side_effect` 來每次回傳一個新"
"的 mock。 或者你可以將 *return_value* 設定成你想要的任何值。"

#: ../../library/unittest.mock.rst:1446
msgid ""
"To configure return values on methods of *instances* on the patched class "
"you must do this on the :attr:`return_value`. For example::"
msgstr ""
"若要配置被 patch 的類別的\\ *實例*\\ 方法的回傳值，你必須在 :attr:"
"`return_value` 上進行配置。 例如： ::"

#: ../../library/unittest.mock.rst:1449
msgid ""
">>> class Class:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Class') as MockClass:\n"
"...     instance = MockClass.return_value\n"
"...     instance.method.return_value = 'foo'\n"
"...     assert Class() is instance\n"
"...     assert Class().method() == 'foo'\n"
"..."
msgstr ""
">>> class Class:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Class') as MockClass:\n"
"...     instance = MockClass.return_value\n"
"...     instance.method.return_value = 'foo'\n"
"...     assert Class() is instance\n"
"...     assert Class().method() == 'foo'\n"
"..."

#: ../../library/unittest.mock.rst:1460
msgid ""
"If you use *spec* or *spec_set* and :func:`patch` is replacing a *class*, "
"then the return value of the created mock will have the same spec. ::"
msgstr ""
"如果你使用 *spec* 或 *spec_set* 且 :func:`patch` 正在取代一個\\ *類別*，那麼"
"被建立的 mock 的回傳值將具有相同的規格。： ::"

#: ../../library/unittest.mock.rst:1463
msgid ""
">>> Original = Class\n"
">>> patcher = patch('__main__.Class', spec=True)\n"
">>> MockClass = patcher.start()\n"
">>> instance = MockClass()\n"
">>> assert isinstance(instance, Original)\n"
">>> patcher.stop()"
msgstr ""
">>> Original = Class\n"
">>> patcher = patch('__main__.Class', spec=True)\n"
">>> MockClass = patcher.start()\n"
">>> instance = MockClass()\n"
">>> assert isinstance(instance, Original)\n"
">>> patcher.stop()"

#: ../../library/unittest.mock.rst:1470
msgid ""
"The *new_callable* argument is useful where you want to use an alternative "
"class to the default :class:`MagicMock` for the created mock. For example, "
"if you wanted a :class:`NonCallableMock` to be used::"
msgstr ""
"當你想要為被建立的 mock 使用一個替代的類別取代預設的 :class:`MagicMock` 時，"
"*new_callable* 引數非常有用。例如，如果你想要一個 :class:`NonCallableMock` 被"
"使用： ::"

#: ../../library/unittest.mock.rst:1474
msgid ""
">>> thing = object()\n"
">>> with patch('__main__.thing', new_callable=NonCallableMock) as "
"mock_thing:\n"
"...     assert thing is mock_thing\n"
"...     thing()\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'NonCallableMock' object is not callable"
msgstr ""
">>> thing = object()\n"
">>> with patch('__main__.thing', new_callable=NonCallableMock) as "
"mock_thing:\n"
"...     assert thing is mock_thing\n"
"...     thing()\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'NonCallableMock' object is not callable"

#: ../../library/unittest.mock.rst:1483
msgid ""
"Another use case might be to replace an object with an :class:`io.StringIO` "
"instance::"
msgstr "另一個用法是用一個 :class:`io.StringIO` 實例替換一個物件： ::"

#: ../../library/unittest.mock.rst:1485
msgid ""
">>> from io import StringIO\n"
">>> def foo():\n"
"...     print('Something')\n"
"...\n"
">>> @patch('sys.stdout', new_callable=StringIO)\n"
"... def test(mock_stdout):\n"
"...     foo()\n"
"...     assert mock_stdout.getvalue() == 'Something\\n'\n"
"...\n"
">>> test()"
msgstr ""
">>> from io import StringIO\n"
">>> def foo():\n"
"...     print('Something')\n"
"...\n"
">>> @patch('sys.stdout', new_callable=StringIO)\n"
"... def test(mock_stdout):\n"
"...     foo()\n"
"...     assert mock_stdout.getvalue() == 'Something\\n'\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock.rst:1496
msgid ""
"When :func:`patch` is creating a mock for you, it is common that the first "
"thing you need to do is to configure the mock. Some of that configuration "
"can be done in the call to patch. Any arbitrary keywords you pass into the "
"call will be used to set attributes on the created mock::"
msgstr ""
"當 :func:`patch` 為你建立 mock 時，通常你需要做的第一件事就是配置 mock。其中"
"一些配置可以在對 patch 的呼叫中完成。你傳遞到呼叫中的任何關鍵字都將用於在被建"
"立的 mock 上設定屬性： ::"

#: ../../library/unittest.mock.rst:1501
msgid ""
">>> patcher = patch('__main__.thing', first='one', second='two')\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.first\n"
"'one'\n"
">>> mock_thing.second\n"
"'two'"
msgstr ""
">>> patcher = patch('__main__.thing', first='one', second='two')\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.first\n"
"'one'\n"
">>> mock_thing.second\n"
"'two'"

#: ../../library/unittest.mock.rst:1508
msgid ""
"As well as attributes on the created mock attributes, like the :attr:`~Mock."
"return_value` and :attr:`~Mock.side_effect`, of child mocks can also be "
"configured. These aren't syntactically valid to pass in directly as keyword "
"arguments, but a dictionary with these as keys can still be expanded into a :"
"func:`patch` call using ``**``::"
msgstr ""
"除了被建立的 mock 上的屬性外，還可以配置 child mock 的 :attr:`~Mock."
"return_value` 和 :attr:`~Mock.side_effect`。它們在語法上不能直接作為關鍵字引"
"數傳入，但是以它們作為鍵的字典仍然可以使用 ``**`` 擴充為一個 :func:`patch` 呼"
"叫： ::"

#: ../../library/unittest.mock.rst:1514
msgid ""
">>> config = {'method.return_value': 3, 'other.side_effect': KeyError}\n"
">>> patcher = patch('__main__.thing', **config)\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.method()\n"
"3\n"
">>> mock_thing.other()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError"
msgstr ""
">>> config = {'method.return_value': 3, 'other.side_effect': KeyError}\n"
">>> patcher = patch('__main__.thing', **config)\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.method()\n"
"3\n"
">>> mock_thing.other()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError"

#: ../../library/unittest.mock.rst:1524
msgid ""
"By default, attempting to patch a function in a module (or a method or an "
"attribute in a class) that does not exist will fail with :exc:"
"`AttributeError`::"
msgstr ""
"預設情況下，嘗試 patch 模組中不存在的函式（或類別中的方法或屬性）將會失敗，並"
"引發 :exc:`AttributeError`： ::"

#: ../../library/unittest.mock.rst:1527
msgid ""
">>> @patch('sys.non_existing_attribute', 42)\n"
"... def test():\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: <module 'sys' (built-in)> does not have the attribute "
"'non_existing_attribute'"
msgstr ""
">>> @patch('sys.non_existing_attribute', 42)\n"
"... def test():\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: <module 'sys' (built-in)> does not have the attribute "
"'non_existing_attribute'"

#: ../../library/unittest.mock.rst:1536
msgid ""
"but adding ``create=True`` in the call to :func:`patch` will make the "
"previous example work as expected::"
msgstr ""
"但是在對 :func:`patch` 的呼叫中增加 ``create=True`` 將使前面的範例按照預期運"
"作： ::"

#: ../../library/unittest.mock.rst:1539
msgid ""
">>> @patch('sys.non_existing_attribute', 42, create=True)\n"
"... def test(mock_stdout):\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()"
msgstr ""
">>> @patch('sys.non_existing_attribute', 42, create=True)\n"
"... def test(mock_stdout):\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock.rst:1547
msgid ""
":func:`patch` now returns an :class:`AsyncMock` if the target is an async "
"function."
msgstr ""
"如果目標是一個非同步函式，:func:`patch` 現在會回傳一個 :class:`AsyncMock`。"

#: ../../library/unittest.mock.rst:1551
msgid "patch.object"
msgstr "patch.object"

#: ../../library/unittest.mock.rst:1555
msgid ""
"patch the named member (*attribute*) on an object (*target*) with a mock "
"object."
msgstr ""
"使用一個 mock 物件 patch 一個物件（\\ *目標*\\ ）上的命名成員（\\ *屬性"
"*\\ ）。"

#: ../../library/unittest.mock.rst:1558
msgid ""
":func:`patch.object` can be used as a decorator, class decorator or a "
"context manager. Arguments *new*, *spec*, *create*, *spec_set*, *autospec* "
"and *new_callable* have the same meaning as for :func:`patch`. Like :func:"
"`patch`, :func:`patch.object` takes arbitrary keyword arguments for "
"configuring the mock object it creates."
msgstr ""
":func:`patch.object` 可以做為裝飾器、類別裝飾器或情境管理器使用。引數 *new*、"
"*spec*、*create*、*spec_set*、*autospec* 和 *new_callable* 與在 :func:"
"`patch` 中的引數具有相同的意義。與 :func:`patch` 一樣，:func:`patch.object` "
"接受任意關鍵字引數來配置它所建立的 mock 物件。"

#: ../../library/unittest.mock.rst:1564
msgid ""
"When used as a class decorator :func:`patch.object` honours ``patch."
"TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"當作為類別裝飾器使用時，:func:`patch.object` 會遵循 ``patch.TEST_PREFIX`` 來"
"選擇要包裝的方法。"

#: ../../library/unittest.mock.rst:1567
msgid ""
"You can either call :func:`patch.object` with three arguments or two "
"arguments. The three argument form takes the object to be patched, the "
"attribute name and the object to replace the attribute with."
msgstr ""
"你可以使用三個引數或兩個引數來呼叫 :func:`patch.object`。三個引數的形式接受要"
"被 patch 的物件、屬性名稱和要替換掉屬性的物件。"

#: ../../library/unittest.mock.rst:1571
msgid ""
"When calling with the two argument form you omit the replacement object, and "
"a mock is created for you and passed in as an extra argument to the "
"decorated function:"
msgstr ""
"當使用兩個引數的形式呼叫時，你會省略要替換的物件，一個 mock 會為你建立並將其"
"作為額外的引數傳遞給被裝飾的函式："

#: ../../library/unittest.mock.rst:1582
msgid ""
"*spec*, *create* and the other arguments to :func:`patch.object` have the "
"same meaning as they do for :func:`patch`."
msgstr ""
"*spec*、*create* 和 :func:`patch.object` 的其他引數與在 :func:`patch` 中的引"
"數具有相同的意義。"

#: ../../library/unittest.mock.rst:1587
msgid "patch.dict"
msgstr "patch.dict"

#: ../../library/unittest.mock.rst:1591
msgid ""
"Patch a dictionary, or dictionary like object, and restore the dictionary to "
"its original state after the test."
msgstr "Patch 字典或類字典的物件，並在測試後將字典回復到其原本的狀態。"

#: ../../library/unittest.mock.rst:1594
msgid ""
"*in_dict* can be a dictionary or a mapping like container. If it is a "
"mapping then it must at least support getting, setting and deleting items "
"plus iterating over keys."
msgstr ""
"*in_dict* 可以是一個字典或一個類對映的容器。如果它是一個對映，那麼它至少必須"
"支援獲取、設定、刪除項目以及對鍵的疊代。"

#: ../../library/unittest.mock.rst:1598
msgid ""
"*in_dict* can also be a string specifying the name of the dictionary, which "
"will then be fetched by importing it."
msgstr "*in_dict* 也可以是指定字典名稱的字串，然後透過 import 來取得該字典。"

#: ../../library/unittest.mock.rst:1601
msgid ""
"*values* can be a dictionary of values to set in the dictionary. *values* "
"can also be an iterable of ``(key, value)`` pairs."
msgstr ""
"*values* 可以是要設定的值的字典。*values* 也可以是 ``(key, value)`` 對 "
"(pairs) 的可疊代物件。"

#: ../../library/unittest.mock.rst:1604
msgid ""
"If *clear* is true then the dictionary will be cleared before the new values "
"are set."
msgstr "如果 *clear* 為 true，則在設定新值之前字典將被清除。"

#: ../../library/unittest.mock.rst:1607
msgid ""
":func:`patch.dict` can also be called with arbitrary keyword arguments to "
"set values in the dictionary."
msgstr "也可以使用任意關鍵字引數呼叫 :func:`patch.dict` 以在字典中設定值。"

#: ../../library/unittest.mock.rst:1612
msgid ""
":func:`patch.dict` now returns the patched dictionary when used as a context "
"manager."
msgstr ":func:`patch.dict` 現在在做為情境管理器使用時回傳被 patch 的字典。"

#: ../../library/unittest.mock.rst:1615
msgid ""
":func:`patch.dict` can be used as a context manager, decorator or class "
"decorator:"
msgstr ":func:`patch.dict` 可以做為情境管理器、裝飾器或類別裝飾器使用："

#: ../../library/unittest.mock.rst:1626
msgid ""
"When used as a class decorator :func:`patch.dict` honours ``patch."
"TEST_PREFIX`` (default to ``'test'``) for choosing which methods to wrap:"
msgstr ""
"當作為類別裝飾器使用時，:func:`patch.dict` 會遵循 ``patch.TEST_PREFIX``\\ "
"（預設為 ``'test'``\\ ）來選擇要包裝的方法："

#: ../../library/unittest.mock.rst:1637
msgid ""
"If you want to use a different prefix for your test, you can inform the "
"patchers of the different prefix by setting ``patch.TEST_PREFIX``. For more "
"details about how to change the value of see :ref:`test-prefix`."
msgstr ""
"如果你想在測試中使用不同的前綴，你可以透過設定 ``patch.TEST_PREFIX`` 來告知 "
"patcher 使用不同的前綴。請參閱 :ref:`test-prefix` 以得知如何修改前綴的更多內"
"容。"

#: ../../library/unittest.mock.rst:1641
msgid ""
":func:`patch.dict` can be used to add members to a dictionary, or simply let "
"a test change a dictionary, and ensure the dictionary is restored when the "
"test ends."
msgstr ""
":func:`patch.dict` 可用於在字典中新增成員，或單純地讓測試更改字典，並確保在測"
"試結束時將字典回復原狀。"

#: ../../library/unittest.mock.rst:1662
msgid ""
"Keywords can be used in the :func:`patch.dict` call to set values in the "
"dictionary:"
msgstr "可以在 :func:`patch.dict` 呼叫中使用關鍵字來設定字典中的值："

#: ../../library/unittest.mock.rst:1672
msgid ""
":func:`patch.dict` can be used with dictionary like objects that aren't "
"actually dictionaries. At the very minimum they must support item getting, "
"setting, deleting and either iteration or membership test. This corresponds "
"to the magic methods :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__delitem__` and either :meth:`~container."
"__iter__` or :meth:`~object.__contains__`."
msgstr ""
":func:`patch.dict` 可以與實際上不是字典的類字典物件一起使用。最低限度它們必須"
"支援項目的獲取、設定、刪除以及疊代或隸屬資格檢測。這對應到魔術方法中的 :meth:"
"`~object.__getitem__`、:meth:`~object.__setitem__`、:meth:`~object."
"__delitem__` 以及 :meth:`~container.__iter__` 或 :meth:`~object."
"__contains__`。"

#: ../../library/unittest.mock.rst:1702
msgid "patch.multiple"
msgstr "patch.multiple"

#: ../../library/unittest.mock.rst:1706
msgid ""
"Perform multiple patches in a single call. It takes the object to be patched "
"(either as an object or a string to fetch the object by importing) and "
"keyword arguments for the patches::"
msgstr ""
"在一次呼叫中執行多個 patch。它接受被 patch 的物件（作為物件或透過 import 取得"
"物件的字串）和 patch 的關鍵字引數： ::"

#: ../../library/unittest.mock.rst:1710
msgid ""
"with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):\n"
"    ..."
msgstr ""
"with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):\n"
"    ..."

#: ../../library/unittest.mock.rst:1713
msgid ""
"Use :data:`DEFAULT` as the value if you want :func:`patch.multiple` to "
"create mocks for you. In this case the created mocks are passed into a "
"decorated function by keyword, and a dictionary is returned when :func:"
"`patch.multiple` is used as a context manager."
msgstr ""
"如果你想要 :func:`patch.multiple` 為你建立 mock，請使用 :data:`DEFAULT` 作為"
"值。在這種情況下，被建立的 mock 會透過關鍵字傳遞到被裝飾的函式中，並且當 :"
"func:`patch.multiple` 作為情境管理器時會回傳字典。"

#: ../../library/unittest.mock.rst:1718
msgid ""
":func:`patch.multiple` can be used as a decorator, class decorator or a "
"context manager. The arguments *spec*, *spec_set*, *create*, *autospec* and "
"*new_callable* have the same meaning as for :func:`patch`. These arguments "
"will be applied to *all* patches done by :func:`patch.multiple`."
msgstr ""
":func:`patch.multiple` 可以做為裝飾器、類別裝飾器或情境管理器使用。引數 "
"*spec*、*spec_set*、*create*、*autospec* 和 *new_callable* 與在 :func:"
"`patch` 中的引數具有相同的意義。這些引數將應用於由 :func:`patch.multiple` 完"
"成的\\ *所有* patch。"

#: ../../library/unittest.mock.rst:1723
msgid ""
"When used as a class decorator :func:`patch.multiple` honours ``patch."
"TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"當作為類別裝飾器使用時，:func:`patch.multiple` 遵循 ``patch.TEST_PREFIX`` 來"
"選擇要包裝的方法。"

#: ../../library/unittest.mock.rst:1726
msgid ""
"If you want :func:`patch.multiple` to create mocks for you, then you can "
"use :data:`DEFAULT` as the value. If you use :func:`patch.multiple` as a "
"decorator then the created mocks are passed into the decorated function by "
"keyword. ::"
msgstr ""
"如果你想要 :func:`patch.multiple` 為你建立 mock，那麼你可以使用 :data:"
"`DEFAULT` 作為值。如果你使用 :func:`patch.multiple` 作為裝飾器，那麼被建立的 "
"mock 將透過關鍵字傳遞到被裝飾的函式中。： ::"

#: ../../library/unittest.mock.rst:1730
msgid ""
">>> thing = object()\n"
">>> other = object()\n"
"\n"
">>> @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(thing, other):\n"
"...     assert isinstance(thing, MagicMock)\n"
"...     assert isinstance(other, MagicMock)\n"
"...\n"
">>> test_function()"
msgstr ""
">>> thing = object()\n"
">>> other = object()\n"
"\n"
">>> @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(thing, other):\n"
"...     assert isinstance(thing, MagicMock)\n"
"...     assert isinstance(other, MagicMock)\n"
"...\n"
">>> test_function()"

#: ../../library/unittest.mock.rst:1740
msgid ""
":func:`patch.multiple` can be nested with other ``patch`` decorators, but "
"put arguments passed by keyword *after* any of the standard arguments "
"created by :func:`patch`::"
msgstr ""
":func:`patch.multiple` 可以與其他 ``patch`` 裝飾器巢狀使用，但需要將透過關鍵"
"字傳遞的引數放在 :func:`patch` 建立的任何標準引數\\ *之後*： ::"

#: ../../library/unittest.mock.rst:1743
msgid ""
">>> @patch('sys.exit')\n"
"... @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(mock_exit, other, thing):\n"
"...     assert 'other' in repr(other)\n"
"...     assert 'thing' in repr(thing)\n"
"...     assert 'exit' in repr(mock_exit)\n"
"...\n"
">>> test_function()"
msgstr ""
">>> @patch('sys.exit')\n"
"... @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(mock_exit, other, thing):\n"
"...     assert 'other' in repr(other)\n"
"...     assert 'thing' in repr(thing)\n"
"...     assert 'exit' in repr(mock_exit)\n"
"...\n"
">>> test_function()"

#: ../../library/unittest.mock.rst:1752
msgid ""
"If :func:`patch.multiple` is used as a context manager, the value returned "
"by the context manager is a dictionary where created mocks are keyed by "
"name::"
msgstr ""
"如果 :func:`patch.multiple` 作為情境管理器使用，則情境管理器回傳的值是一個字"
"典，其中被建立的 mock 會按名稱作為其鍵值： ::"

#: ../../library/unittest.mock.rst:1755
msgid ""
">>> with patch.multiple('__main__', thing=DEFAULT, other=DEFAULT) as "
"values:\n"
"...     assert 'other' in repr(values['other'])\n"
"...     assert 'thing' in repr(values['thing'])\n"
"...     assert values['thing'] is thing\n"
"...     assert values['other'] is other\n"
"..."
msgstr ""
">>> with patch.multiple('__main__', thing=DEFAULT, other=DEFAULT) as "
"values:\n"
"...     assert 'other' in repr(values['other'])\n"
"...     assert 'thing' in repr(values['thing'])\n"
"...     assert values['thing'] is thing\n"
"...     assert values['other'] is other\n"
"..."

#: ../../library/unittest.mock.rst:1766
msgid "patch methods: start and stop"
msgstr "patch 方法：啟動與停止"

#: ../../library/unittest.mock.rst:1768
msgid ""
"All the patchers have :meth:`start` and :meth:`stop` methods. These make it "
"simpler to do patching in ``setUp`` methods or where you want to do multiple "
"patches without nesting decorators or with statements."
msgstr ""
"所有的 patcher 都有 :meth:`start` 與 :meth:`stop` 方法。這使得在 ``setUp`` 方"
"法中進行 patch 或在你想要在沒有巢狀使用裝飾器或 with 陳述式的情況下進行多個 "
"patch 時變得更簡單。"

#: ../../library/unittest.mock.rst:1772
msgid ""
"To use them call :func:`patch`, :func:`patch.object` or :func:`patch.dict` "
"as normal and keep a reference to the returned ``patcher`` object. You can "
"then call :meth:`start` to put the patch in place and :meth:`stop` to undo "
"it."
msgstr ""
"要使用它們，請像平常一樣呼叫 :func:`patch`、:func:`patch.object` 或 :func:"
"`patch.dict` ，並保留對回傳的 ``patcher`` 物件的參照。之後你就可以呼叫 :meth:"
"`start` 將 patch 準備就緒，並呼叫 :meth:`stop` 來取消 patch。"

#: ../../library/unittest.mock.rst:1776
msgid ""
"If you are using :func:`patch` to create a mock for you then it will be "
"returned by the call to ``patcher.start``. ::"
msgstr ""
"如果你使用 :func:`patch` 為你建立 mock，那麼它將透過呼叫 ``patcher.start`` 回"
"傳。： ::"

#: ../../library/unittest.mock.rst:1779
msgid ""
">>> patcher = patch('package.module.ClassName')\n"
">>> from package import module\n"
">>> original = module.ClassName\n"
">>> new_mock = patcher.start()\n"
">>> assert module.ClassName is not original\n"
">>> assert module.ClassName is new_mock\n"
">>> patcher.stop()\n"
">>> assert module.ClassName is original\n"
">>> assert module.ClassName is not new_mock"
msgstr ""
">>> patcher = patch('package.module.ClassName')\n"
">>> from package import module\n"
">>> original = module.ClassName\n"
">>> new_mock = patcher.start()\n"
">>> assert module.ClassName is not original\n"
">>> assert module.ClassName is new_mock\n"
">>> patcher.stop()\n"
">>> assert module.ClassName is original\n"
">>> assert module.ClassName is not new_mock"

#: ../../library/unittest.mock.rst:1790
msgid ""
"A typical use case for this might be for doing multiple patches in the "
"``setUp`` method of a :class:`TestCase`::"
msgstr ""
"一個典型的用法是在一個 :class:`TestCase` 的 ``setUp`` 方法中執行多個 "
"patch： ::"

#: ../../library/unittest.mock.rst:1793
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher1 = patch('package.module.Class1')\n"
"...         self.patcher2 = patch('package.module.Class2')\n"
"...         self.MockClass1 = self.patcher1.start()\n"
"...         self.MockClass2 = self.patcher2.start()\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher1.stop()\n"
"...         self.patcher2.stop()\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class1 is self.MockClass1\n"
"...         assert package.module.Class2 is self.MockClass2\n"
"...\n"
">>> MyTest('test_something').run()"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher1 = patch('package.module.Class1')\n"
"...         self.patcher2 = patch('package.module.Class2')\n"
"...         self.MockClass1 = self.patcher1.start()\n"
"...         self.MockClass2 = self.patcher2.start()\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher1.stop()\n"
"...         self.patcher2.stop()\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class1 is self.MockClass1\n"
"...         assert package.module.Class2 is self.MockClass2\n"
"...\n"
">>> MyTest('test_something').run()"

#: ../../library/unittest.mock.rst:1812
msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by "
"calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the ``setUp`` then ``tearDown`` is not called. :meth:"
"`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"如果你使用這個技巧，你必須確保透過呼叫 ``stop`` 來 \"取消\" patch。這可能會比"
"你想像的還要複雜一點，因為如果有例外在 ``setUp`` 中被引發，則 ``tearDown`` 就"
"不會被呼叫。:meth:`unittest.TestCase.addCleanup` 會讓這稍微簡單一點： ::"

#: ../../library/unittest.mock.rst:1817
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('package.module.Class')\n"
"...         self.MockClass = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class is self.MockClass\n"
"..."
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('package.module.Class')\n"
"...         self.MockClass = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class is self.MockClass\n"
"..."

#: ../../library/unittest.mock.rst:1827
msgid ""
"As an added bonus you no longer need to keep a reference to the ``patcher`` "
"object."
msgstr "作為額外的好處，你不再需要保留對 ``patcher`` 物件的參照。"

#: ../../library/unittest.mock.rst:1830
msgid ""
"It is also possible to stop all patches which have been started by using :"
"func:`patch.stopall`."
msgstr "也可以使用 :func:`patch.stopall` 來停止所有已啟動的 patch。"

#: ../../library/unittest.mock.rst:1835
msgid "Stop all active patches. Only stops patches started with ``start``."
msgstr "停止所有運作的 patch。只停止以 ``start`` 啟動的 patch。"

#: ../../library/unittest.mock.rst:1841
msgid "patch builtins"
msgstr "patch 內建函式"

#: ../../library/unittest.mock.rst:1842
msgid ""
"You can patch any builtins within a module. The following example patches "
"builtin :func:`ord`::"
msgstr ""
"你可以 patch 模組內的任何內建函式。以下範例 patch 內建函式 :func:`ord`： ::"

#: ../../library/unittest.mock.rst:1845
msgid ""
">>> @patch('__main__.ord')\n"
"... def test(mock_ord):\n"
"...     mock_ord.return_value = 101\n"
"...     print(ord('c'))\n"
"...\n"
">>> test()\n"
"101"
msgstr ""
">>> @patch('__main__.ord')\n"
"... def test(mock_ord):\n"
"...     mock_ord.return_value = 101\n"
"...     print(ord('c'))\n"
"...\n"
">>> test()\n"
"101"

#: ../../library/unittest.mock.rst:1857
msgid "TEST_PREFIX"
msgstr "TEST_PREFIX"

#: ../../library/unittest.mock.rst:1859
msgid ""
"All of the patchers can be used as class decorators. When used in this way "
"they wrap every test method on the class. The patchers recognise methods "
"that start with ``'test'`` as being test methods. This is the same way that "
"the :class:`unittest.TestLoader` finds test methods by default."
msgstr ""
"所有 patcher 都可以作為類別裝飾器使用。以這種方式使用時，它們包裝了類別上的每"
"個測試方法。Patcher 將 ``'test'`` 開頭的方法認定為測試方法。這與 :class:"
"`unittest.TestLoader` 預設尋找測試方法的方式相同。"

#: ../../library/unittest.mock.rst:1864
msgid ""
"It is possible that you want to use a different prefix for your tests. You "
"can inform the patchers of the different prefix by setting ``patch."
"TEST_PREFIX``::"
msgstr ""
"你可能會想為你的測試使用不同的前綴。你可以透過設定 ``patch.TEST_PREFIX`` 來告"
"知 patcher 使用不同的前綴： ::"

#: ../../library/unittest.mock.rst:1867
msgid ""
">>> patch.TEST_PREFIX = 'foo'\n"
">>> value = 3\n"
">>>\n"
">>> @patch('__main__.value', 'not three')\n"
"... class Thing:\n"
"...     def foo_one(self):\n"
"...         print(value)\n"
"...     def foo_two(self):\n"
"...         print(value)\n"
"...\n"
">>>\n"
">>> Thing().foo_one()\n"
"not three\n"
">>> Thing().foo_two()\n"
"not three\n"
">>> value\n"
"3"
msgstr ""
">>> patch.TEST_PREFIX = 'foo'\n"
">>> value = 3\n"
">>>\n"
">>> @patch('__main__.value', 'not three')\n"
"... class Thing:\n"
"...     def foo_one(self):\n"
"...         print(value)\n"
"...     def foo_two(self):\n"
"...         print(value)\n"
"...\n"
">>>\n"
">>> Thing().foo_one()\n"
"not three\n"
">>> Thing().foo_two()\n"
"not three\n"
">>> value\n"
"3"

#: ../../library/unittest.mock.rst:1887
msgid "Nesting Patch Decorators"
msgstr "巢狀使用 Patch 裝飾器"

#: ../../library/unittest.mock.rst:1889
msgid ""
"If you want to perform multiple patches then you can simply stack up the "
"decorators."
msgstr "如果你想執行多個 patch，那麼你可以簡單地堆疊裝飾器。"

#: ../../library/unittest.mock.rst:1892
msgid "You can stack up multiple patch decorators using this pattern:"
msgstr "你可以使用這個模式來堆疊多個 patch 裝飾器："

#: ../../library/unittest.mock.rst:1908
msgid ""
"Note that the decorators are applied from the bottom upwards. This is the "
"standard way that Python applies decorators. The order of the created mocks "
"passed into your test function matches this order."
msgstr ""
"請注意，裝飾器是從底部向上應用的。這是 Python 應用裝飾器的標準方式。被建立的 "
"mock 傳遞到測試函式中的順序與此順序相同。"

#: ../../library/unittest.mock.rst:1916
msgid "Where to patch"
msgstr "該 patch 何處"

#: ../../library/unittest.mock.rst:1918
msgid ""
":func:`patch` works by (temporarily) changing the object that a *name* "
"points to with another one. There can be many names pointing to any "
"individual object, so for patching to work you must ensure that you patch "
"the name used by the system under test."
msgstr ""
":func:`patch` 的工作原理是（暫時）將 *name* 指向的物件變更為另一個物件。可以"
"有許多 name 指向任何單一物件，因此為了使 patch 起作用，你必須確保你 patch 了"
"被測試系統使用的 name。"

#: ../../library/unittest.mock.rst:1923
msgid ""
"The basic principle is that you patch where an object is *looked up*, which "
"is not necessarily the same place as where it is defined. A couple of "
"examples will help to clarify this."
msgstr ""
"基本原則是在物件\\ *被查找*\\ 的位置進行 patch，該位置不一定與其被定義的位置"
"相同。幾個範例將有助於闡明這一點。"

#: ../../library/unittest.mock.rst:1927
msgid ""
"Imagine we have a project that we want to test with the following structure::"
msgstr "想像一下，我們想要測試一個專案，其結構如下： ::"

#: ../../library/unittest.mock.rst:1929
msgid ""
"a.py\n"
"    -> Defines SomeClass\n"
"\n"
"b.py\n"
"    -> from a import SomeClass\n"
"    -> some_function instantiates SomeClass"
msgstr ""

#: ../../library/unittest.mock.rst:1936
msgid ""
"Now we want to test ``some_function`` but we want to mock out ``SomeClass`` "
"using :func:`patch`. The problem is that when we import module b, which we "
"will have to do then it imports ``SomeClass`` from module a. If we use :func:"
"`patch` to mock out ``a.SomeClass`` then it will have no effect on our test; "
"module b already has a reference to the *real* ``SomeClass`` and it looks "
"like our patching had no effect."
msgstr ""
"現在我們想要測試 ``some_function``，但我們想使用 :func:`patch` mock "
"``SomeClass``。問題是，當我們 import 模組 b 時（我們必須這樣做），它會從模組 "
"a import ``SomeClass``。如果我們使用 :func:`patch` 來 mock ``a.SomeClass``，"
"那麼它對我們的測試就不會有任何影響；模組 b 已經有了一個\\ *真實的*\\  "
"``SomeClass`` 的參照 ，看起來我們的 patch 並沒有任何效果。"

#: ../../library/unittest.mock.rst:1943
msgid ""
"The key is to patch out ``SomeClass`` where it is used (or where it is "
"looked up). In this case ``some_function`` will actually look up "
"``SomeClass`` in module b, where we have imported it. The patching should "
"look like::"
msgstr ""
"關鍵是在使用（或查找它）的地方 patch ``SomeClass``。在這個情況下，"
"``some_function`` 實際上會在我們 import 它的模組 b 中查找 ``SomeClass``。這裡"
"的 patch 應該長得像這樣： ::"

#: ../../library/unittest.mock.rst:1947
msgid "@patch('b.SomeClass')"
msgstr "@patch('b.SomeClass')"

#: ../../library/unittest.mock.rst:1949
msgid ""
"However, consider the alternative scenario where instead of ``from a import "
"SomeClass`` module b does ``import a`` and ``some_function`` uses ``a."
"SomeClass``. Both of these import forms are common. In this case the class "
"we want to patch is being looked up in the module and so we have to patch "
"``a.SomeClass`` instead::"
msgstr ""
"然而，考慮另一種情況，其中模組 b 並不是使用 ``from a import SomeClass``，而"
"是 ``import a``，然後 ``some_function`` 使用 ``a.SomeClass``。這兩種 import "
"形式都很常見。在這種情況下，我們想要 patch 的類別正在其模組中被查找，因此我們"
"必須 patch ``a.SomeClass``： ::"

#: ../../library/unittest.mock.rst:1954
msgid "@patch('a.SomeClass')"
msgstr "@patch('a.SomeClass')"

#: ../../library/unittest.mock.rst:1958
msgid "Patching Descriptors and Proxy Objects"
msgstr "Patch 描述器與代理物件 (Proxy Objects)"

#: ../../library/unittest.mock.rst:1960
msgid ""
"Both patch_ and patch.object_ correctly patch and restore descriptors: class "
"methods, static methods and properties. You should patch these on the "
"*class* rather than an instance. They also work with *some* objects that "
"proxy attribute access, like the `django settings object <https://web."
"archive.org/web/20200603181648/http://www.voidspace.org.uk/python/weblog/"
"arch_d7_2010_12_04.shtml#e1198>`_."
msgstr ""
"patch_ 和 patch.object_ 都正確地 patch 和還原描述器：類別方法、靜態方法以及屬"
"性。你應該在 *類別* 而不是實例上 patch 它們。它們還可以使用代理屬性存取的\\ *"
"一些*\\ 物件，例如 `django 設定物件 <https://web.archive.org/"
"web/20200603181648/http://www.voidspace.org.uk/python/weblog/ "
"arch_d7_2010_12_04.shtml#e1198>`_。"

#: ../../library/unittest.mock.rst:1968
msgid "MagicMock and magic method support"
msgstr "MagicMock 以及魔術方法支援"

#: ../../library/unittest.mock.rst:1973
msgid "Mocking Magic Methods"
msgstr "Mock 魔術方法"

#: ../../library/unittest.mock.rst:1975
msgid ""
":class:`Mock` supports mocking the Python protocol methods, also known as :"
"term:`\"magic methods\" <magic method>`. This allows mock objects to replace "
"containers or other objects that implement Python protocols."
msgstr ""
":class:`Mock` 支援 mock Python 協定方法，其也被稱作 :term:`\"魔術方法\" "
"<magic method>`。這允許 mock 物件替換容器或實作 Python 協定的其他物件。"

#: ../../library/unittest.mock.rst:1979
msgid ""
"Because magic methods are looked up differently from normal methods [#]_, "
"this support has been specially implemented. This means that only specific "
"magic methods are supported. The supported list includes *almost* all of "
"them. If there are any missing that you need please let us know."
msgstr ""
"由於魔術方法被查找的方式與一般的方法 [#]_ 不同，因此專門實作了此支援方式。這"
"代表著僅有特定的魔術方法被此方式支援。現在已支援清單中已經\\ *幾乎*\\ 包含了"
"所有魔術方法。如果你需要 mock 任何魔術方法而其尚未被支援，請讓我們知道。"

#: ../../library/unittest.mock.rst:1984
msgid ""
"You mock magic methods by setting the method you are interested in to a "
"function or a mock instance. If you are using a function then it *must* take "
"``self`` as the first argument [#]_."
msgstr ""
"你可以透過將你感興趣的方法設定為函式或 mock 實例來 mock 魔術方法。如果你使用"
"函式，那麼它\\ *必須*\\ 將 ``self`` 作為第一個引數 [#]_。"

#: ../../library/unittest.mock.rst:2007
msgid ""
"One use case for this is for mocking objects used as context managers in a :"
"keyword:`with` statement:"
msgstr "一個用法是在 :keyword:`with` 陳述式中 mock 作為情境管理器使用的物件："

#: ../../library/unittest.mock.rst:2019
msgid ""
"Calls to magic methods do not appear in :attr:`~Mock.method_calls`, but they "
"are recorded in :attr:`~Mock.mock_calls`."
msgstr ""
"對魔術方法的呼叫並不會出現在 :attr:`~Mock.method_calls` 中，它們會被記錄在 :"
"attr:`~Mock.mock_calls` 內。"

#: ../../library/unittest.mock.rst:2024
msgid ""
"If you use the *spec* keyword argument to create a mock then attempting to "
"set a magic method that isn't in the spec will raise an :exc:"
"`AttributeError`."
msgstr ""
"如果你使用\\ *spec*\\ 關鍵字引數來建立一個 mock，則嘗試設定規格中未包含的魔術"
"方法將引發一個 :exc:`AttributeError`。"

#: ../../library/unittest.mock.rst:2027
msgid "The full list of supported magic methods is:"
msgstr "已支援的魔術方法的完整列表是："

#: ../../library/unittest.mock.rst:2029
msgid "``__hash__``, ``__sizeof__``, ``__repr__`` and ``__str__``"
msgstr "``__hash__``、``__sizeof__``、 ``__repr__`` 和 ``__str__``"

#: ../../library/unittest.mock.rst:2030
msgid "``__dir__``, ``__format__`` and ``__subclasses__``"
msgstr "``__dir__``、 ``__format__`` 和 ``__subclasses__``"

#: ../../library/unittest.mock.rst:2031
msgid "``__round__``, ``__floor__``, ``__trunc__`` and ``__ceil__``"
msgstr "``__round__``、``__floor__``、``__trunc__`` 和 ``__ceil__``"

#: ../../library/unittest.mock.rst:2032
msgid ""
"Comparisons: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__`` and "
"``__ne__``"
msgstr ""
"比較方法：``__lt__``、``__gt__``、``__le__``、``__ge__``、``__eq__`` 和 "
"``__ne__``"

#: ../../library/unittest.mock.rst:2034
msgid ""
"Container methods: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__`` and "
"``__missing__``"
msgstr ""
"容器方法：``__getitem__``、``__setitem__``、``__delitem__``、"
"``__contains__``、``__len__``、``__iter__``、``__reversed__`` 和 "
"``__missing__``"

#: ../../library/unittest.mock.rst:2037
msgid ""
"Context manager: ``__enter__``, ``__exit__``, ``__aenter__`` and "
"``__aexit__``"
msgstr ""
"情境管理器：``__enter__``、``__exit__``、``__aenter__`` 和 ``__aexit__``"

#: ../../library/unittest.mock.rst:2038
msgid "Unary numeric methods: ``__neg__``, ``__pos__`` and ``__invert__``"
msgstr "一元數值方法：``__neg__``、``__pos__`` 和 ``__invert__``"

#: ../../library/unittest.mock.rst:2039
msgid ""
"The numeric methods (including right hand and in-place variants): "
"``__add__``, ``__sub__``, ``__mul__``, ``__matmul__``, ``__truediv__``, "
"``__floordiv__``, ``__mod__``, ``__divmod__``, ``__lshift__``, "
"``__rshift__``, ``__and__``, ``__xor__``, ``__or__``, and ``__pow__``"
msgstr ""
"數值方法（包括右側 (right hand) 和原地 (in-place) 變體）：``__add__``、"
"``__sub__``、``__mul__``、``__matmul__``、``__truediv__``、``__floordiv__``、"
"``__mod__``、``__divmod__``、``__lshift__``、``__rshift__``、``__and__``、"
"``__xor__``、``__or__`` 和 ``__pow__``"

#: ../../library/unittest.mock.rst:2043
msgid ""
"Numeric conversion methods: ``__complex__``, ``__int__``, ``__float__`` and "
"``__index__``"
msgstr ""
"數值轉換方法：``__complex__``、``__int__``、``__float__`` 和 ``__index__``"

#: ../../library/unittest.mock.rst:2045
msgid "Descriptor methods: ``__get__``, ``__set__`` and ``__delete__``"
msgstr "描述器方法：``__get__``、``__set__`` 和 ``__delete__``"

#: ../../library/unittest.mock.rst:2046
msgid ""
"Pickling: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` and ``__setstate__``"
msgstr ""
"Pickling：``__reduce__``、``__reduce_ex__``、``__getinitargs__``、"
"``__getnewargs__``、``__getstate__`` 和 ``__setstate__``"

#: ../../library/unittest.mock.rst:2048
msgid "File system path representation: ``__fspath__``"
msgstr "檔案系統路徑表示法：``__fspath__``"

#: ../../library/unittest.mock.rst:2049
msgid "Asynchronous iteration methods: ``__aiter__`` and ``__anext__``"
msgstr "非同步疊代方法：``__aiter__`` 和 ``__anext__``"

#: ../../library/unittest.mock.rst:2051
msgid "Added support for :func:`os.PathLike.__fspath__`."
msgstr "新增對於 :func:`os.PathLike.__fspath__` 的支援。"

#: ../../library/unittest.mock.rst:2054
msgid ""
"Added support for ``__aenter__``, ``__aexit__``, ``__aiter__`` and "
"``__anext__``."
msgstr ""
"新增對於 ``__aenter__``、``__aexit__``、``__aiter__`` 和 ``__anext__`` 的支"
"援。"

#: ../../library/unittest.mock.rst:2058
msgid ""
"The following methods exist but are *not* supported as they are either in "
"use by mock, can't be set dynamically, or can cause problems:"
msgstr ""
"以下方法存在，但「不」被支援，因為它們在被 mock 使用時，會無法動態設定，或可"
"能導致問題："

#: ../../library/unittest.mock.rst:2061
msgid "``__getattr__``, ``__setattr__``, ``__init__`` and ``__new__``"
msgstr "``__getattr__``、``__setattr__``、``__init__`` 和 ``__new__``"

#: ../../library/unittest.mock.rst:2062
msgid ""
"``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"
msgstr ""
"``__prepare__``、``__instancecheck__``、``__subclasscheck__``、``__del__``"

#: ../../library/unittest.mock.rst:2067
msgid "Magic Mock"
msgstr "Magic Mock"

#: ../../library/unittest.mock.rst:2069
msgid ""
"There are two ``MagicMock`` variants: :class:`MagicMock` and :class:"
"`NonCallableMagicMock`."
msgstr ""
"``MagicMock`` 有兩個變體：:class:`MagicMock` 和 :class:"
"`NonCallableMagicMock`。"

#: ../../library/unittest.mock.rst:2074
msgid ""
"``MagicMock`` is a subclass of :class:`Mock` with default implementations of "
"most of the :term:`magic methods <magic method>`. You can use ``MagicMock`` "
"without having to configure the magic methods yourself."
msgstr ""
"``MagicMock`` 是 :class:`Mock` 的子類別，其預設具有大多數\\ :term:`魔術方法 "
"<magic method>`\\ 的實作。你可以使用 ``MagicMock``，而無需自行配置魔術方法。"

#: ../../library/unittest.mock.rst:2078
msgid "The constructor parameters have the same meaning as for :class:`Mock`."
msgstr "建構函式參數的意義與 :class:`Mock` 中的參數相同。"

#: ../../library/unittest.mock.rst:2080
msgid ""
"If you use the *spec* or *spec_set* arguments then *only* magic methods that "
"exist in the spec will be created."
msgstr ""
"如果你使用 *spec* 或 *spec_set* 引數，那麼\\ *只有*\\ 規格中存在的魔術方法會"
"被建立。"

#: ../../library/unittest.mock.rst:2086
msgid "A non-callable version of :class:`MagicMock`."
msgstr ":class:`MagicMock` 的不可呼叫版本。"

#: ../../library/unittest.mock.rst:2088
msgid ""
"The constructor parameters have the same meaning as for :class:`MagicMock`, "
"with the exception of *return_value* and *side_effect* which have no meaning "
"on a non-callable mock."
msgstr ""
"建構函式參數的意義與 :class:`MagicMock` 中的參數相同，但 *return_value* 和 "
"*side_effect* 除外，它們對不可呼叫的 mock 來說沒有任何意義。"

#: ../../library/unittest.mock.rst:2092
msgid ""
"The magic methods are setup with :class:`MagicMock` objects, so you can "
"configure them and use them in the usual way:"
msgstr ""
"魔術方法是使用 :class:`MagicMock` 物件設定的，因此你可以配置它們並以一般的方"
"法來使用它們："

#: ../../library/unittest.mock.rst:2102
msgid ""
"By default many of the protocol methods are required to return objects of a "
"specific type. These methods are preconfigured with a default return value, "
"so that they can be used without you having to do anything if you aren't "
"interested in the return value. You can still *set* the return value "
"manually if you want to change the default."
msgstr ""
"預設情況下，許多協定方法都需要回傳特定種類的物件。這些方法預先配置了預設回傳"
"值，因此如果你對回傳值不感興趣，則無需執行任何操作即可使用它們。如果你想更改"
"預設值，你仍然可以手動\\ *設定*\\ 回傳值。"

#: ../../library/unittest.mock.rst:2108
msgid "Methods and their defaults:"
msgstr "方法及其預設值："

#: ../../library/unittest.mock.rst:2110
msgid "``__lt__``: :data:`NotImplemented`"
msgstr "``__lt__``：:data:`NotImplemented`"

#: ../../library/unittest.mock.rst:2111
msgid "``__gt__``: :data:`!NotImplemented`"
msgstr "``__gt__``：:data:`!NotImplemented`"

#: ../../library/unittest.mock.rst:2112
msgid "``__le__``: :data:`!NotImplemented`"
msgstr "``__le__``：:data:`!NotImplemented`"

#: ../../library/unittest.mock.rst:2113
msgid "``__ge__``: :data:`!NotImplemented`"
msgstr "``__ge__``：:data:`!NotImplemented`"

#: ../../library/unittest.mock.rst:2114
msgid "``__int__``: ``1``"
msgstr "``__int__``：``1``"

#: ../../library/unittest.mock.rst:2115
msgid "``__contains__``: ``False``"
msgstr "``__contains__``：``False``"

#: ../../library/unittest.mock.rst:2116
msgid "``__len__``: ``0``"
msgstr "``__len__``：``0``"

#: ../../library/unittest.mock.rst:2117
msgid "``__iter__``: ``iter([])``"
msgstr "``__iter__``：``iter([])``"

#: ../../library/unittest.mock.rst:2118
msgid "``__exit__``: ``False``"
msgstr "``__exit__``：``False``"

#: ../../library/unittest.mock.rst:2119
msgid "``__aexit__``: ``False``"
msgstr "``__aexit__``：``False``"

#: ../../library/unittest.mock.rst:2120
msgid "``__complex__``: ``1j``"
msgstr "``__complex__``：``1j``"

#: ../../library/unittest.mock.rst:2121
msgid "``__float__``: ``1.0``"
msgstr "``__float__``：``1.0``"

#: ../../library/unittest.mock.rst:2122
msgid "``__bool__``: ``True``"
msgstr "``__bool__``：``True``"

#: ../../library/unittest.mock.rst:2123
msgid "``__index__``: ``1``"
msgstr "``__index__``：``1``"

#: ../../library/unittest.mock.rst:2124
msgid "``__hash__``: default hash for the mock"
msgstr "``__hash__``：mock 的預設雜湊"

#: ../../library/unittest.mock.rst:2125
msgid "``__str__``: default str for the mock"
msgstr "``__str__``：mock 的預設字串"

#: ../../library/unittest.mock.rst:2126
msgid "``__sizeof__``: default sizeof for the mock"
msgstr "``__sizeof__``：mock 的預設 sizeof"

#: ../../library/unittest.mock.rst:2128
msgid "For example:"
msgstr "舉例來說："

#: ../../library/unittest.mock.rst:2140
msgid ""
"The two equality methods, :meth:`!__eq__` and :meth:`!__ne__`, are special. "
"They do the default equality comparison on identity, using the :attr:`~Mock."
"side_effect` attribute, unless you change their return value to return "
"something else::"
msgstr ""
":meth:`!__eq__` 和 :meth:`!__ne__` 這兩個相等的方法是特別的。它們使用 :attr:"
"`~Mock.side_effect` 屬性對識別性 (identity) 進行預設的相等比較，除非你變更它"
"們的回傳值以回傳其他內容： ::"

#: ../../library/unittest.mock.rst:2145
msgid ""
">>> MagicMock() == 3\n"
"False\n"
">>> MagicMock() != 3\n"
"True\n"
">>> mock = MagicMock()\n"
">>> mock.__eq__.return_value = True\n"
">>> mock == 3\n"
"True"
msgstr ""
">>> MagicMock() == 3\n"
"False\n"
">>> MagicMock() != 3\n"
"True\n"
">>> mock = MagicMock()\n"
">>> mock.__eq__.return_value = True\n"
">>> mock == 3\n"
"True"

#: ../../library/unittest.mock.rst:2154
msgid ""
"The return value of :meth:`MagicMock.__iter__` can be any iterable object "
"and isn't required to be an iterator:"
msgstr ""
":meth:`MagicMock.__iter__` 的回傳值可以是任何可疊代物件，且不需是一個疊代器："

#: ../../library/unittest.mock.rst:2164
msgid ""
"If the return value *is* an iterator, then iterating over it once will "
"consume it and subsequent iterations will result in an empty list:"
msgstr ""
"如果回傳值\\ *是*\\ 一個疊代器，那麼對其進行一次疊代將消耗它，並且後續疊代將"
"產生一個空串列："

#: ../../library/unittest.mock.rst:2173
msgid ""
"``MagicMock`` has all of the supported magic methods configured except for "
"some of the obscure and obsolete ones. You can still set these up if you "
"want."
msgstr ""
"``MagicMock`` 配置了所有支援的魔術方法，除了一些少見和過時的方法。如果你想"
"要，你仍然可以設定這些魔術方法。"

#: ../../library/unittest.mock.rst:2176
msgid ""
"Magic methods that are supported but not setup by default in ``MagicMock`` "
"are:"
msgstr "``MagicMock`` 中支援但預設未設置的魔術方法包含："

#: ../../library/unittest.mock.rst:2178
msgid "``__subclasses__``"
msgstr "``__subclasses__``"

#: ../../library/unittest.mock.rst:2179
msgid "``__dir__``"
msgstr "``__dir__``"

#: ../../library/unittest.mock.rst:2180
msgid "``__format__``"
msgstr "``__format__``"

#: ../../library/unittest.mock.rst:2181
msgid "``__get__``, ``__set__`` and ``__delete__``"
msgstr "``__get__``、``__set__`` 和 ``__delete__``"

#: ../../library/unittest.mock.rst:2182
msgid "``__reversed__`` and ``__missing__``"
msgstr "``__reversed__`` 和 ``__missing__``"

#: ../../library/unittest.mock.rst:2183
msgid ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, ``__getnewargs__``, "
"``__getstate__`` and ``__setstate__``"
msgstr ""
"``__reduce__``、``__reduce_ex__``、``__getinitargs__``、``__getnewargs__``、"
"``__getstate__`` 和 ``__setstate__``"

#: ../../library/unittest.mock.rst:2185
msgid "``__getformat__``"
msgstr "``__getformat__``"

#: ../../library/unittest.mock.rst:2189
msgid ""
"Magic methods *should* be looked up on the class rather than the instance. "
"Different versions of Python are inconsistent about applying this rule. The "
"supported protocol methods should work with all supported versions of Python."
msgstr ""
"魔術方法\\ *應該*\\ 在類別而不是實例上被查找。不同版本的 Python 對於這條規則"
"的適用並不一致。支援的協定方法應適用於所有支援的 Python 版本。"

#: ../../library/unittest.mock.rst:2193
msgid ""
"The function is basically hooked up to the class, but each ``Mock`` instance "
"is kept isolated from the others."
msgstr "該函式基本上與類別掛鉤，但每個 ``Mock`` 實例都與其他實例保持隔離。"

#: ../../library/unittest.mock.rst:2198
msgid "Helpers"
msgstr "輔助函式"

#: ../../library/unittest.mock.rst:2201
msgid "sentinel"
msgstr "sentinel（哨兵）"

#: ../../library/unittest.mock.rst:2205
msgid ""
"The ``sentinel`` object provides a convenient way of providing unique "
"objects for your tests."
msgstr "``哨兵``\\ 物件提供了一種為你的測試提供獨特物件的便利方式。"

#: ../../library/unittest.mock.rst:2208
msgid ""
"Attributes are created on demand when you access them by name. Accessing the "
"same attribute will always return the same object. The objects returned have "
"a sensible repr so that test failure messages are readable."
msgstr ""
"當你使用名稱存取屬性時，屬性會根據需要被建立。存取相同的屬性將始終回傳相同的"
"物件。回傳的物件會具有合適的 repr，讓測試失敗的訊息是可閱讀的。"

#: ../../library/unittest.mock.rst:2212
msgid ""
"The ``sentinel`` attributes now preserve their identity when they are :mod:"
"`copied <copy>` or :mod:`pickled <pickle>`."
msgstr ""
"``哨兵``\\ 屬性現在當被\\ :mod:`複製 <copy>`\\ 或\\ :mod:`序列化 <pickle>`\\ "
"時會保留其識別性。"

#: ../../library/unittest.mock.rst:2216
msgid ""
"Sometimes when testing you need to test that a specific object is passed as "
"an argument to another method, or returned. It can be common to create named "
"sentinel objects to test this. :data:`sentinel` provides a convenient way of "
"creating and testing the identity of objects like this."
msgstr ""
"在測試時，有時你需要測試特定物件是否作為引數被傳遞給另一個方法或回傳。建立命"
"名的哨兵物件來測試這一點是常見的。:data:`sentinel` 提供了一種此類建立和測試物"
"件識別性的便利方式。"

#: ../../library/unittest.mock.rst:2221
msgid ""
"In this example we monkey patch ``method`` to return ``sentinel."
"some_object``:"
msgstr ""
"在這個例子中，我們 monkey patch ``method`` 以回傳 ``sentinel.some_object``："

#: ../../library/unittest.mock.rst:2233
msgid "DEFAULT"
msgstr "DEFAULT"

#: ../../library/unittest.mock.rst:2238
msgid ""
"The :data:`DEFAULT` object is a pre-created sentinel (actually ``sentinel."
"DEFAULT``). It can be used by :attr:`~Mock.side_effect` functions to "
"indicate that the normal return value should be used."
msgstr ""
":data:`DEFAULT` 物件是一個預先建立的哨兵（實際上是 ``sentinel."
"DEFAULT``\\ ）。它可以被 :attr:`~Mock.side_effect` 函式使用來表示正常的回傳值"
"應該被使用。"

#: ../../library/unittest.mock.rst:2244
msgid "call"
msgstr "call"

#: ../../library/unittest.mock.rst:2248
msgid ""
":func:`call` is a helper object for making simpler assertions, for comparing "
"with :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`, :attr:`~Mock."
"mock_calls` and :attr:`~Mock.method_calls`. :func:`call` can also be used "
"with :meth:`~Mock.assert_has_calls`."
msgstr ""
"與 :attr:`~Mock.call_args`、:attr:`~Mock.call_args_list`、:attr:`~Mock."
"mock_calls` 和 :attr:`~Mock.method_calls` 相比，:func:`call` 是一個用於進行更"
"簡單的斷言的輔助物件。:func:`call` 也可以與 :meth:`~Mock.assert_has_calls` 一"
"起使用。"

#: ../../library/unittest.mock.rst:2261
msgid ""
"For a call object that represents multiple calls, :meth:`call_list` returns "
"a list of all the intermediate calls as well as the final call."
msgstr ""
"對於表示多個呼叫的 call 物件，:meth:`call_list` 回傳所有中間呼叫以及最終呼叫"
"的串列。"

#: ../../library/unittest.mock.rst:2265
msgid ""
"``call_list`` is particularly useful for making assertions on \"chained "
"calls\". A chained call is multiple calls on a single line of code. This "
"results in multiple entries in :attr:`~Mock.mock_calls` on a mock. Manually "
"constructing the sequence of calls can be tedious."
msgstr ""
"``call_list`` 在對「鍊接呼叫 (chained calls)」進行斷言時特別有用。鍊接呼叫是"
"在單行程式碼進行的多次呼叫。這會導致 mock 上的 :attr:`~Mock.mock_calls` 中出"
"現多個項目。手動建構呼叫序列會相當單調乏味。"

#: ../../library/unittest.mock.rst:2270
msgid ""
":meth:`~call.call_list` can construct the sequence of calls from the same "
"chained call:"
msgstr ":meth:`~call.call_list` 可以從同一個鍊接呼叫建構呼叫序列："

#: ../../library/unittest.mock.rst:2287
msgid ""
"A ``call`` object is either a tuple of (positional args, keyword args) or "
"(name, positional args, keyword args) depending on how it was constructed. "
"When you construct them yourself this isn't particularly interesting, but "
"the ``call`` objects that are in the :attr:`Mock.call_args`, :attr:`Mock."
"call_args_list` and :attr:`Mock.mock_calls` attributes can be introspected "
"to get at the individual arguments they contain."
msgstr ""
"取決於它的建構方式，一個 ``call`` 物件會是（位置引數, 關鍵字引數）的元組，或"
"是 (名稱, 位置引數, 關鍵字引數) 的元組。當你自己建構它們時，這並不是那麼有"
"趣，但是 :attr:`Mock.call_args`、:attr:`Mock.call_args_list` 和 :attr:`Mock."
"mock_calls` 屬性中的 ``call`` 物件可以被內省以取得它們包含的各個引數。"

#: ../../library/unittest.mock.rst:2294
msgid ""
"The ``call`` objects in :attr:`Mock.call_args` and :attr:`Mock."
"call_args_list` are two-tuples of (positional args, keyword args) whereas "
"the ``call`` objects in :attr:`Mock.mock_calls`, along with ones you "
"construct yourself, are three-tuples of (name, positional args, keyword "
"args)."
msgstr ""
":attr:`Mock.call_args` 和 :attr:`Mock.call_args_list` 中的 ``call`` 物件是"
"（位置引數, 關鍵字引數）的二元組，而 :attr:`Mock.mock_calls` 中的 ``call`` 物"
"件以及你自己建立的 ``call`` 物件是（名稱, 位置引數, 關鍵字引數）的三元組。"

#: ../../library/unittest.mock.rst:2299
msgid ""
"You can use their \"tupleness\" to pull out the individual arguments for "
"more complex introspection and assertions. The positional arguments are a "
"tuple (an empty tuple if there are no positional arguments) and the keyword "
"arguments are a dictionary:"
msgstr ""
"你可以利用它們作為元組的特性來提取單個引數，以進行更複雜的內省和斷言。位置引"
"數是一個元組（如果沒有位置引數則為空元組），關鍵字引數是一個字典："

#: ../../library/unittest.mock.rst:2332
msgid "create_autospec"
msgstr "create_autospec"

#: ../../library/unittest.mock.rst:2336
msgid ""
"Create a mock object using another object as a spec. Attributes on the mock "
"will use the corresponding attribute on the *spec* object as their spec."
msgstr ""
"使用另一個物件作為規格建立一個 mock 物件。Mock 上的屬性將使用 *spec* 物件上的"
"對應屬性作為其規格。"

#: ../../library/unittest.mock.rst:2340
msgid ""
"Functions or methods being mocked will have their arguments checked to "
"ensure that they are called with the correct signature."
msgstr "被 mock 的函式或方法將檢查其引數，以確保他們被使用正確的簽名來呼叫。"

#: ../../library/unittest.mock.rst:2343
msgid ""
"If *spec_set* is ``True`` then attempting to set attributes that don't exist "
"on the spec object will raise an :exc:`AttributeError`."
msgstr ""
"如果 *spec_set* 為 ``True``，則嘗試設定規格物件上不存在的屬性將引發 :exc:"
"`AttributeError`。"

#: ../../library/unittest.mock.rst:2346
msgid ""
"If a class is used as a spec then the return value of the mock (the instance "
"of the class) will have the same spec. You can use a class as the spec for "
"an instance object by passing ``instance=True``. The returned mock will only "
"be callable if instances of the mock are callable."
msgstr ""
"如果一個類別作為規格使用，則 mock（該類別的實例）的回傳值將具有相同的規格。你"
"可以透過傳遞 ``instance=True`` 來使用一個類別作為一個實例物件的規格。只有當 "
"mock 的實例是可呼叫物件時，回傳的 mock 才會是可呼叫物件。"

#: ../../library/unittest.mock.rst:2351
msgid ""
":func:`create_autospec` also takes arbitrary keyword arguments that are "
"passed to the constructor of the created mock."
msgstr ""
":func:`create_autospec` 也接受任意的關鍵字引數，這些引數會傳遞給已建立的 "
"mock 的建構函式。"

#: ../../library/unittest.mock.rst:2354
msgid ""
"See :ref:`auto-speccing` for examples of how to use auto-speccing with :func:"
"`create_autospec` and the *autospec* argument to :func:`patch`."
msgstr ""
"請參閱 :ref:`auto-speccing` 以得知如何以 :func:`create_autospec` 使用自動規格"
"以及如何在 :func:`patch` 中使用 *autospec* 引數的範例。"

#: ../../library/unittest.mock.rst:2360
msgid ""
":func:`create_autospec` now returns an :class:`AsyncMock` if the target is "
"an async function."
msgstr ""
"如果目標是一個非同步函式，:func:`create_autospec` 現在會回傳一個 :class:"
"`AsyncMock`。"

#: ../../library/unittest.mock.rst:2365
msgid "ANY"
msgstr "ANY"

#: ../../library/unittest.mock.rst:2369
msgid ""
"Sometimes you may need to make assertions about *some* of the arguments in a "
"call to mock, but either not care about some of the arguments or want to "
"pull them individually out of :attr:`~Mock.call_args` and make more complex "
"assertions on them."
msgstr ""
"有時你可能需要對 mock 的呼叫中的\\ *某些*\\ 引數進行斷言，但你不在意其他的某"
"些引數，或想將它們單獨從 :attr:`~Mock.call_args` 中取出並進行更加複雜的斷言。"

#: ../../library/unittest.mock.rst:2374
msgid ""
"To ignore certain arguments you can pass in objects that compare equal to "
"*everything*. Calls to :meth:`~Mock.assert_called_with` and :meth:`~Mock."
"assert_called_once_with` will then succeed no matter what was passed in."
msgstr ""
"要忽略某些引數，你可以傳入對\\ *所有物件*\\ 來說都相等的物件。那麼無論傳入什"
"麼內容，對 :meth:`~Mock.assert_used_with` 和 :meth:`~Mock."
"assert_used_once_with` 的呼叫都會成功。"

#: ../../library/unittest.mock.rst:2383
msgid ""
":data:`ANY` can also be used in comparisons with call lists like :attr:"
"`~Mock.mock_calls`:"
msgstr ""
":data:`ANY` 也可以用來與呼叫串列進行比較，例如 :attr:`~Mock.mock_calls`："

#: ../../library/unittest.mock.rst:2393
msgid ""
":data:`ANY` is not limited to comparisons with call objects and so can also "
"be used in test assertions::"
msgstr ":data:`ANY` 不只能與呼叫物件比較，其也可以在測試斷言中使用： ::"

#: ../../library/unittest.mock.rst:2396
msgid ""
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', ANY])"
msgstr ""
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', ANY])"

#: ../../library/unittest.mock.rst:2404
msgid "FILTER_DIR"
msgstr "FILTER_DIR"

#: ../../library/unittest.mock.rst:2408
msgid ""
":data:`FILTER_DIR` is a module level variable that controls the way mock "
"objects respond to :func:`dir`. The default is ``True``, which uses the "
"filtering described below, to only show useful members. If you dislike this "
"filtering, or need to switch it off for diagnostic purposes, then set ``mock."
"FILTER_DIR = False``."
msgstr ""
":data:`FILTER_DIR` 是一個模組級別的變數，用於控制 mock 物件回應 :func:`dir` "
"的方式。其預設值為 ``True``，它使用以下描述的過濾方式來只顯示有用的成員。如果"
"你不喜歡這個過濾方式，或由於診斷意圖而需要將其關閉，請設定 ``mock.FILTER_DIR "
"= False``。"

#: ../../library/unittest.mock.rst:2414
msgid ""
"With filtering on, ``dir(some_mock)`` shows only useful attributes and will "
"include any dynamically created attributes that wouldn't normally be shown. "
"If the mock was created with a *spec* (or *autospec* of course) then all the "
"attributes from the original are shown, even if they haven't been accessed "
"yet:"
msgstr ""
"當過濾方式開啟時，``dir(some_mock)`` 僅會顯示有用的屬性，並將包括通常不會顯示"
"的任何動態建立的屬性。如果 mock 是使用 *spec*\\ （或 *autospec*\\ ）來建立"
"的，那麼源頭的所有屬性都會顯示，即使它們尚未被存取："

#: ../../library/unittest.mock.rst:2420
msgid ""
">>> dir(Mock())\n"
"['assert_any_call',\n"
" 'assert_called',\n"
" 'assert_called_once',\n"
" 'assert_called_once_with',\n"
" 'assert_called_with',\n"
" 'assert_has_calls',\n"
" 'assert_not_called',\n"
" 'attach_mock',\n"
" ...\n"
">>> from urllib import request\n"
">>> dir(Mock(spec=request))\n"
"['AbstractBasicAuthHandler',\n"
" 'AbstractDigestAuthHandler',\n"
" 'AbstractHTTPHandler',\n"
" 'BaseHandler',\n"
" ..."
msgstr ""
">>> dir(Mock())\n"
"['assert_any_call',\n"
" 'assert_called',\n"
" 'assert_called_once',\n"
" 'assert_called_once_with',\n"
" 'assert_called_with',\n"
" 'assert_has_calls',\n"
" 'assert_not_called',\n"
" 'attach_mock',\n"
" ...\n"
">>> from urllib import request\n"
">>> dir(Mock(spec=request))\n"
"['AbstractBasicAuthHandler',\n"
" 'AbstractDigestAuthHandler',\n"
" 'AbstractHTTPHandler',\n"
" 'BaseHandler',\n"
" ..."

#: ../../library/unittest.mock.rst:2441
msgid ""
"Many of the not-very-useful (private to :class:`Mock` rather than the thing "
"being mocked) underscore and double underscore prefixed attributes have been "
"filtered from the result of calling :func:`dir` on a :class:`Mock`. If you "
"dislike this behaviour you can switch it off by setting the module level "
"switch :data:`FILTER_DIR`:"
msgstr ""
"許多不是很有用的（對 :class:`Mock` 來說是私有的，而不是被 mock 的東西）底線和"
"雙底線前綴屬性已從在 :class:`Mock` 上呼叫 :func:`dir` 的結果中濾除。如果你不"
"喜歡這種特性，可以透過設定模組級別開關 :data:`FILTER_DIR` 來將其關閉："

#: ../../library/unittest.mock.rst:2447
msgid ""
">>> from unittest import mock\n"
">>> mock.FILTER_DIR = False\n"
">>> dir(mock.Mock())\n"
"['_NonCallableMock__get_return_value',\n"
" '_NonCallableMock__get_side_effect',\n"
" '_NonCallableMock__return_value_doc',\n"
" '_NonCallableMock__set_return_value',\n"
" '_NonCallableMock__set_side_effect',\n"
" '__call__',\n"
" '__class__',\n"
" ..."
msgstr ""
">>> from unittest import mock\n"
">>> mock.FILTER_DIR = False\n"
">>> dir(mock.Mock())\n"
"['_NonCallableMock__get_return_value',\n"
" '_NonCallableMock__get_side_effect',\n"
" '_NonCallableMock__return_value_doc',\n"
" '_NonCallableMock__set_return_value',\n"
" '_NonCallableMock__set_side_effect',\n"
" '__call__',\n"
" '__class__',\n"
" ..."

#: ../../library/unittest.mock.rst:2462
msgid ""
"Alternatively you can just use ``vars(my_mock)`` (instance members) and "
"``dir(type(my_mock))`` (type members) to bypass the filtering irrespective "
"of :const:`mock.FILTER_DIR`."
msgstr ""
"或者，你可以只使用 ``vars(my_mock)``\\ （實例成員）和 "
"``dir(type(my_mock))``\\ （型別成員）來略過過濾，而不考慮 :const:`mock."
"FILTER_DIR`。"

#: ../../library/unittest.mock.rst:2468
msgid "mock_open"
msgstr "mock_open"

#: ../../library/unittest.mock.rst:2472
msgid ""
"A helper function to create a mock to replace the use of :func:`open`. It "
"works for :func:`open` called directly or used as a context manager."
msgstr ""
"用於建立取代 :func:`open` 用途的 mock 的輔助函式。它適用於直接呼叫或用作情境"
"管理器的 :func:`open`。"

#: ../../library/unittest.mock.rst:2475
msgid ""
"The *mock* argument is the mock object to configure. If ``None`` (the "
"default) then a :class:`MagicMock` will be created for you, with the API "
"limited to methods or attributes available on standard file handles."
msgstr ""
"*mock* 引數是要配置的 mock 物件。如果其為 ``None``\\ （預設值），那麼就會為你"
"建立一個 :class:`MagicMock`，其 API 限制在標準檔案處理上可用的方法或屬性。"

#: ../../library/unittest.mock.rst:2479
msgid ""
"*read_data* is a string for the :meth:`~io.IOBase.read`, :meth:`~io.IOBase."
"readline`, and :meth:`~io.IOBase.readlines` methods of the file handle to "
"return.  Calls to those methods will take data from *read_data* until it is "
"depleted.  The mock of these methods is pretty simplistic: every time the "
"*mock* is called, the *read_data* is rewound to the start.  If you need more "
"control over the data that you are feeding to the tested code you will need "
"to customize this mock for yourself.  When that is insufficient, one of the "
"in-memory filesystem packages on `PyPI <https://pypi.org>`_ can offer a "
"realistic filesystem for testing."
msgstr ""
"*read_data* 是檔案處理方法 :meth:`~io.IOBase.read`、:meth:`~io.IOBase."
"readline` 和 :meth:`~io.IOBase.readlines` 的回傳字串。對這些方法的呼叫將從 "
"*read_data* 取得資料，直到資料耗盡。對這些方法的 mock 非常單純：每次呼叫 "
"*mock* 時，*read_data* 都會倒回到起點。如果你需要對提供給測試程式碼的資料進行"
"更多控制，你會需要自行客製化這個 mock。如果這樣還不夠，`PyPI <https://pypi."
"org>`_ 上的其中一個記憶體內檔案系統 (in-memory filesystem) 套件可以提供用於測"
"試的真實檔案系統。"

#: ../../library/unittest.mock.rst:2489
msgid ""
"Added :meth:`~io.IOBase.readline` and :meth:`~io.IOBase.readlines` support. "
"The mock of :meth:`~io.IOBase.read` changed to consume *read_data* rather "
"than returning it on each call."
msgstr ""
"新增對 :meth:`~io.IOBase.readline` 和 :meth:`~io.IOBase.readlines` 的支援。:"
"meth:`~io.IOBase.read` 的 mock 更改為消耗 *read_data* 而不是在每次呼叫時回傳"
"它。"

#: ../../library/unittest.mock.rst:2494
msgid "*read_data* is now reset on each call to the *mock*."
msgstr "現在，每次呼叫 *mock* 時都會重置 *read_data*。"

#: ../../library/unittest.mock.rst:2497
msgid ""
"Added :meth:`~container.__iter__` to implementation so that iteration (such "
"as in for loops) correctly consumes *read_data*."
msgstr ""
"新增 :meth:`~container.__iter__` 到實作中，以便使疊代（例如在 for 迴圈中）正"
"確地消耗 *read_data*。"

#: ../../library/unittest.mock.rst:2501
msgid ""
"Using :func:`open` as a context manager is a great way to ensure your file "
"handles are closed properly and is becoming common::"
msgstr ""
"使用 :func:`open` 作為情境管理器是確保檔案處理正確關閉的好方式，且這種方式正"
"在變得普遍： ::"

#: ../../library/unittest.mock.rst:2504
msgid ""
"with open('/some/path', 'w') as f:\n"
"    f.write('something')"
msgstr ""
"with open('/some/path', 'w') as f:\n"
"    f.write('something')"

#: ../../library/unittest.mock.rst:2507
msgid ""
"The issue is that even if you mock out the call to :func:`open` it is the "
"*returned object* that is used as a context manager (and has :meth:`~object."
"__enter__` and :meth:`~object.__exit__` called)."
msgstr ""
"問題是，即使你 mock 了對 :func:`open` 的呼叫，它也是作為情境管理器使用的\\ *"
"回傳物件*\\ （且其 :meth:`~object.__enter__` 和 :meth:`~ object.__exit__` 已"
"被呼叫）。"

#: ../../library/unittest.mock.rst:2511
msgid ""
"Mocking context managers with a :class:`MagicMock` is common enough and "
"fiddly enough that a helper function is useful. ::"
msgstr ""
"使用 :class:`MagicMock` mock 情境管理器相當常見並且精細，因此輔助函式就非常有"
"用： ::"

#: ../../library/unittest.mock.rst:2514
msgid ""
">>> m = mock_open()\n"
">>> with patch('__main__.open', m):\n"
"...     with open('foo', 'w') as h:\n"
"...         h.write('some stuff')\n"
"...\n"
">>> m.mock_calls\n"
"[call('foo', 'w'),\n"
" call().__enter__(),\n"
" call().write('some stuff'),\n"
" call().__exit__(None, None, None)]\n"
">>> m.assert_called_once_with('foo', 'w')\n"
">>> handle = m()\n"
">>> handle.write.assert_called_once_with('some stuff')"
msgstr ""
">>> m = mock_open()\n"
">>> with patch('__main__.open', m):\n"
"...     with open('foo', 'w') as h:\n"
"...         h.write('some stuff')\n"
"...\n"
">>> m.mock_calls\n"
"[call('foo', 'w'),\n"
" call().__enter__(),\n"
" call().write('some stuff'),\n"
" call().__exit__(None, None, None)]\n"
">>> m.assert_called_once_with('foo', 'w')\n"
">>> handle = m()\n"
">>> handle.write.assert_called_once_with('some stuff')"

#: ../../library/unittest.mock.rst:2528
msgid "And for reading files::"
msgstr "以及讀取檔案： ::"

#: ../../library/unittest.mock.rst:2530
msgid ""
">>> with patch('__main__.open', mock_open(read_data='bibble')) as m:\n"
"...     with open('foo') as h:\n"
"...         result = h.read()\n"
"...\n"
">>> m.assert_called_once_with('foo')\n"
">>> assert result == 'bibble'"
msgstr ""
">>> with patch('__main__.open', mock_open(read_data='bibble')) as m:\n"
"...     with open('foo') as h:\n"
"...         result = h.read()\n"
"...\n"
">>> m.assert_called_once_with('foo')\n"
">>> assert result == 'bibble'"

#: ../../library/unittest.mock.rst:2541
msgid "Autospeccing"
msgstr "Autospeccing（自動規格）"

#: ../../library/unittest.mock.rst:2543
msgid ""
"Autospeccing is based on the existing :attr:`spec` feature of mock. It "
"limits the api of mocks to the api of an original object (the spec), but it "
"is recursive (implemented lazily) so that attributes of mocks only have the "
"same api as the attributes of the spec. In addition mocked functions / "
"methods have the same call signature as the original so they raise a :exc:"
"`TypeError` if they are called incorrectly."
msgstr ""
"自動規格以 mock 現有的 :attr:`spec` 功能作為基礎。它將 mock 的 api 限制為原始"
"物件（規格）的 api，但它是遞迴的（惰性 (lazily) 實現），因此 mock 的屬性僅具"
"有與規格的屬性相同的 api。此外，被 mock 的函式/方法具有與原始的函式/方法相同"
"的呼叫簽名，因此如果它們被不正確地呼叫，就會引發 :exc:`TypeError`。"

#: ../../library/unittest.mock.rst:2550
msgid "Before I explain how auto-speccing works, here's why it is needed."
msgstr "在解釋自動規格如何運作之前，我們先解釋為什麼需要它。"

#: ../../library/unittest.mock.rst:2552
msgid ""
":class:`Mock` is a very powerful and flexible object, but it suffers from a "
"flaw which is general to mocking. If you refactor some of your code, rename "
"members and so on, any tests for code that is still using the *old api* but "
"uses mocks instead of the real objects will still pass. This means your "
"tests can all pass even though your code is broken."
msgstr ""
":class:`Mock` 是一個非常強大且靈活的物件，但它有一個常見的 mock 缺陷。如果你"
"重構某些程式碼或重新命名成員等，則任何仍然使用\\ *舊 api* 但使用 mock 而非真"
"實物件的程式碼測試仍然會通過。這意味著即使你的程式碼壞了，但測試仍可以全部通"
"過。"

#: ../../library/unittest.mock.rst:2560
msgid ""
"Before 3.5, tests with a typo in the word assert would silently pass when "
"they should raise an error. You can still achieve this behavior by passing "
"``unsafe=True`` to Mock."
msgstr ""
"在 3.5 之前，當測試應該引發錯誤時，斷言單字中存在拼字錯誤的測驗會默默地通過。"
"你仍可以透過將 ``unsafe=True`` 傳遞給 Mock 來實作此行為。"

#: ../../library/unittest.mock.rst:2563
msgid ""
"Note that this is another reason why you need integration tests as well as "
"unit tests. Testing everything in isolation is all fine and dandy, but if "
"you don't test how your units are \"wired together\" there is still lots of "
"room for bugs that tests might have caught."
msgstr ""
"謹記這是你需要有整合測試和單元測試的另一個原因。單獨測試所有內容都很好，但如"
"果你不測試你的單元是如何「連接在一起」的，那麼測試還是有機會發現很多錯誤。"

#: ../../library/unittest.mock.rst:2568
msgid ""
":mod:`mock` already provides a feature to help with this, called speccing. "
"If you use a class or instance as the :attr:`spec` for a mock then you can "
"only access attributes on the mock that exist on the real class:"
msgstr ""
":mod:`mock` 已經提供了一個功能來幫助解決這個問題，其稱為 speccing。如果你使用"
"類別或實例作為 mock 的 :attr:`spec`，那麼你在 mock 上只能存取真實類別中存在的"
"屬性："

#: ../../library/unittest.mock.rst:2579
msgid ""
"The spec only applies to the mock itself, so we still have the same issue "
"with any methods on the mock:"
msgstr "該規格僅適用於 mock 本身，因此在 mock 上的任何方法仍然有相同的問題："

#: ../../library/unittest.mock.rst:2582
msgid ""
">>> mock.has_data()\n"
"<mock.Mock object at 0x...>\n"
">>> mock.has_data.assret_called_with()  # Intentional typo!"
msgstr ""
">>> mock.has_data()\n"
"<mock.Mock object at 0x...>\n"
">>> mock.has_data.assret_called_with()  # 故意的錯字！"

#: ../../library/unittest.mock.rst:2588
msgid ""
"Auto-speccing solves this problem. You can either pass ``autospec=True`` to :"
"func:`patch` / :func:`patch.object` or use the :func:`create_autospec` "
"function to create a mock with a spec. If you use the ``autospec=True`` "
"argument to :func:`patch` then the object that is being replaced will be "
"used as the spec object. Because the speccing is done \"lazily\" (the spec "
"is created as attributes on the mock are accessed) you can use it with very "
"complex or deeply nested objects (like modules that import modules that "
"import modules) without a big performance hit."
msgstr ""
"自動規格解決了這個問題。你可以將 ``autospec=True`` 傳遞給 :func:`patch` / :"
"func:`patch.object` 或使用 :func:`create_autospec` 函式建立帶有規格的 mock。"
"如果你對 :func:`patch` 使用 ``autospec=True`` 引數，則被取代的物件將作為規格"
"物件使用。因為規格是「惰性」完成的（規格是在 mock 被存取時作為屬性被建立"
"的），所以你可以將它與非常複雜或深度巢狀使用的物件（例如連續引用的模組）一起"
"使用，而不會過於影響性能。"

#: ../../library/unittest.mock.rst:2597
msgid "Here's an example of it in use::"
msgstr "這是一個正在使用的例子： ::"

#: ../../library/unittest.mock.rst:2599
msgid ""
">>> from urllib import request\n"
">>> patcher = patch('__main__.request', autospec=True)\n"
">>> mock_request = patcher.start()\n"
">>> request is mock_request\n"
"True\n"
">>> mock_request.Request\n"
"<MagicMock name='request.Request' spec='Request' id='...'>"
msgstr ""
">>> from urllib import request\n"
">>> patcher = patch('__main__.request', autospec=True)\n"
">>> mock_request = patcher.start()\n"
">>> request is mock_request\n"
"True\n"
">>> mock_request.Request\n"
"<MagicMock name='request.Request' spec='Request' id='...'>"

#: ../../library/unittest.mock.rst:2607
msgid ""
"You can see that :class:`request.Request` has a spec. :class:`request."
"Request` takes two arguments in the constructor (one of which is *self*). "
"Here's what happens if we try to call it incorrectly::"
msgstr ""
"你可以看到 :class:`request.Request` 有一個規格。:class:`request.Request` 在建"
"構函式中接受兩個引數（其中之一是 *self*\\ ）。如果我們錯誤地呼叫它，會發生以"
"下情況： ::"

#: ../../library/unittest.mock.rst:2611
msgid ""
">>> req = request.Request()\n"
"Traceback (most recent call last):\n"
" ...\n"
"TypeError: <lambda>() takes at least 2 arguments (1 given)"
msgstr ""
">>> req = request.Request()\n"
"Traceback (most recent call last):\n"
" ...\n"
"TypeError: <lambda>() takes at least 2 arguments (1 given)"

#: ../../library/unittest.mock.rst:2616
msgid ""
"The spec also applies to instantiated classes (i.e. the return value of "
"specced mocks)::"
msgstr "此規格也適用於實例化的類別（即有規格的 mock 的回傳值）： ::"

#: ../../library/unittest.mock.rst:2619
msgid ""
">>> req = request.Request('foo')\n"
">>> req\n"
"<NonCallableMagicMock name='request.Request()' spec='Request' id='...'>"
msgstr ""
">>> req = request.Request('foo')\n"
">>> req\n"
"<NonCallableMagicMock name='request.Request()' spec='Request' id='...'>"

#: ../../library/unittest.mock.rst:2623
msgid ""
":class:`Request` objects are not callable, so the return value of "
"instantiating our mocked out :class:`request.Request` is a non-callable "
"mock. With the spec in place any typos in our asserts will raise the correct "
"error::"
msgstr ""
":class:`Request` 物件不是可呼叫物件，因此實例化我們 mock out 的 :class:"
"`request.Request` 的回傳值是不可呼叫的 mock。規格到位後，斷言中的任何拼字錯誤"
"都會引發正確的錯誤： ::"

#: ../../library/unittest.mock.rst:2627
msgid ""
">>> req.add_header('spam', 'eggs')\n"
"<MagicMock name='request.Request().add_header()' id='...'>\n"
">>> req.add_header.assret_called_with  # Intentional typo!\n"
"Traceback (most recent call last):\n"
" ...\n"
"AttributeError: Mock object has no attribute 'assret_called_with'\n"
">>> req.add_header.assert_called_with('spam', 'eggs')"
msgstr ""
">>> req.add_header('spam', 'eggs')\n"
"<MagicMock name='request.Request().add_header()' id='...'>\n"
">>> req.add_header.assret_called_with  # Intentional typo!\n"
"Traceback (most recent call last):\n"
" ...\n"
"AttributeError: Mock object has no attribute 'assret_called_with'\n"
">>> req.add_header.assert_called_with('spam', 'eggs')"

#: ../../library/unittest.mock.rst:2635
msgid ""
"In many cases you will just be able to add ``autospec=True`` to your "
"existing :func:`patch` calls and then be protected against bugs due to typos "
"and api changes."
msgstr ""
"在許多情況下，你只需要將 ``autospec=True`` 新增至現有的 :func:`patch` 呼叫"
"中，然後就可以防止因拼字錯誤和 api 變更而導致的錯誤。"

#: ../../library/unittest.mock.rst:2639
msgid ""
"As well as using *autospec* through :func:`patch` there is a :func:"
"`create_autospec` for creating autospecced mocks directly:"
msgstr ""
"除了透過 :func:`patch` 使用 *autospec* 之外，還有一個 :func:"
"`create_autospec` 用於直接建立有自動規格的 mock："

#: ../../library/unittest.mock.rst:2647
msgid ""
"This isn't without caveats and limitations however, which is why it is not "
"the default behaviour. In order to know what attributes are available on the "
"spec object, autospec has to introspect (access attributes) the spec. As you "
"traverse attributes on the mock a corresponding traversal of the original "
"object is happening under the hood. If any of your specced objects have "
"properties or descriptors that can trigger code execution then you may not "
"be able to use autospec. On the other hand it is much better to design your "
"objects so that introspection is safe [#]_."
msgstr ""
"然而，這並非完全沒有限制，這就是為什麼它不是預設的行為。為了理解規格物件上有"
"哪些可用屬性，autospec 必須內省（存取屬性）規格。當你遍歷 mock 上的屬性時，原"
"始物件的對應遍歷正在默默發生。如果你的規格物件具有可以觸發程式碼執行的屬性或"
"描述器，那麼你可能無法使用 autospec。換句話說，設計你的物件讓內省是安全的 "
"[#]_ 會比較好。"

#: ../../library/unittest.mock.rst:2656
msgid ""
"A more serious problem is that it is common for instance attributes to be "
"created in the :meth:`~object.__init__` method and not to exist on the class "
"at all. *autospec* can't know about any dynamically created attributes and "
"restricts the api to visible attributes. ::"
msgstr ""
"一個更嚴重的問題是，在 :meth:`~object.__init__` 方法中建立實例屬性是常見的，"
"而其根本不存在於類別中。*autospec* 無法知道任何動態建立的屬性，並將 api 限制"
"為可見的屬性。： ::"

#: ../../library/unittest.mock.rst:2661
msgid ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: Mock object has no attribute 'a'"
msgstr ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: Mock object has no attribute 'a'"

#: ../../library/unittest.mock.rst:2673
msgid ""
"There are a few different ways of resolving this problem. The easiest, but "
"not necessarily the least annoying, way is to simply set the required "
"attributes on the mock after creation. Just because *autospec* doesn't allow "
"you to fetch attributes that don't exist on the spec it doesn't prevent you "
"setting them::"
msgstr ""
"有幾種不同的方法可以解決這個問題。最簡單但可能有點煩人的方法是在建立後簡單地"
"在 mock 上設定所需的屬性。因為雖然 *autospec* 不允許你取得規格中不存在的屬"
"性，但是它不會阻止你設定它們： ::"

#: ../../library/unittest.mock.rst:2679
msgid ""
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a = 33\n"
"..."
msgstr ""
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a = 33\n"
"..."

#: ../../library/unittest.mock.rst:2684
msgid ""
"There is a more aggressive version of both *spec* and *autospec* that *does* "
"prevent you setting non-existent attributes. This is useful if you want to "
"ensure your code only *sets* valid attributes too, but obviously it prevents "
"this particular scenario:"
msgstr ""
"*spec* 和 *autospec* 有一個更激進的版本，它會\\ *確實地*\\ 阻止你設定不存在的"
"屬性。如果你想確保你的程式碼僅能\\ *設定*\\ 有效的屬性，那麼這會很有用，但顯"
"然它也順便阻止了這個特殊情況："

#: ../../library/unittest.mock.rst:2697
msgid ""
"Probably the best way of solving the problem is to add class attributes as "
"default values for instance members initialised in :meth:`~object.__init__`. "
"Note that if you are only setting default attributes in :meth:`!__init__` "
"then providing them via class attributes (shared between instances of "
"course) is faster too. e.g."
msgstr ""
"解決問題的最佳方法可能是新增類別屬性作為在 :meth:`~object.__init__` 中初始化"
"的實例成員的預設值。請注意，如果你僅在 :meth:`!__init__` 中設定預設屬性，那麼"
"透過類別屬性（當然在實例之間共用）提供它們也會更快。例如："

#: ../../library/unittest.mock.rst:2703
msgid ""
"class Something:\n"
"    a = 33"
msgstr ""
"class Something:\n"
"    a = 33"

#: ../../library/unittest.mock.rst:2708
msgid ""
"This brings up another issue. It is relatively common to provide a default "
"value of ``None`` for members that will later be an object of a different "
"type. ``None`` would be useless as a spec because it wouldn't let you access "
"*any* attributes or methods on it. As ``None`` is *never* going to be useful "
"as a spec, and probably indicates a member that will normally of some other "
"type, autospec doesn't use a spec for members that are set to ``None``. "
"These will just be ordinary mocks (well - MagicMocks):"
msgstr ""
"這就帶來了另一個問題。為稍後將成為不同型別的物件的成員提供預設值 ``None`` 是"
"相對常見的。``None`` 作為規格是無用的，因為它不允許你存取其上的\\ *任何*\\ 屬"
"性或方法。由於 ``None`` 作為規格\\ *永遠不會*\\ 有用，並且可能表示通常屬於其"
"他型別的成員，因此自動規格不會對設定為 ``None`` 的成員使用規格。這些會只是普"
"通的 mock（通常是 MagicMocks）："

#: ../../library/unittest.mock.rst:2723
msgid ""
"If modifying your production classes to add defaults isn't to your liking "
"then there are more options. One of these is simply to use an instance as "
"the spec rather than the class. The other is to create a subclass of the "
"production class and add the defaults to the subclass without affecting the "
"production class. Both of these require you to use an alternative object as "
"the spec. Thankfully :func:`patch` supports this - you can simply pass the "
"alternative object as the *autospec* argument::"
msgstr ""
"如果修改正式生產 (production) 類別以新增預設值不符合你的喜好，那麼還有更多選"
"擇。其中之一就是簡單地使用實例作為規格而不是使用類別。另一種是建立一個正式生"
"產類別的子類別，並將預設值新增至子類別中，而不影響正式生產類別。這兩個都需要"
"你使用替代物件作為規格。值得慶幸的是 :func:`patch` 支援這一點 - 你可以簡單地"
"將替代物件作為 *autospec* 引數傳遞： ::"

#: ../../library/unittest.mock.rst:2731
msgid ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> class SomethingForTest(Something):\n"
"...   a = 33\n"
"...\n"
">>> p = patch('__main__.Something', autospec=SomethingForTest)\n"
">>> mock = p.start()\n"
">>> mock.a\n"
"<NonCallableMagicMock name='Something.a' spec='int' id='...'>"
msgstr ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> class SomethingForTest(Something):\n"
"...   a = 33\n"
"...\n"
">>> p = patch('__main__.Something', autospec=SomethingForTest)\n"
">>> mock = p.start()\n"
">>> mock.a\n"
"<NonCallableMagicMock name='Something.a' spec='int' id='...'>"

#: ../../library/unittest.mock.rst:2744
msgid ""
"This only applies to classes or already instantiated objects. Calling a "
"mocked class to create a mock instance *does not* create a real instance. It "
"is only attribute lookups - along with calls to :func:`dir` - that are done."
msgstr ""
"這只適用於類別或已經實例化的物件。呼叫一個被 mock 的類別來建立一個 mock 實例"
"\\ *不會*\\ 建立真的實例。它僅查找屬性及對 :func:`dir` 的呼叫。"

#: ../../library/unittest.mock.rst:2749
msgid "Sealing mocks"
msgstr "密封 mock"

#: ../../library/unittest.mock.rst:2758
msgid ""
"Seal will disable the automatic creation of mocks when accessing an "
"attribute of the mock being sealed or any of its attributes that are already "
"mocks recursively."
msgstr ""
"當存取被密封的 mock 的屬性或其任何已經遞迴 mock 的屬性時，seal 將停用 mock 的"
"自動建立。"

#: ../../library/unittest.mock.rst:2761
msgid ""
"If a mock instance with a name or a spec is assigned to an attribute it "
"won't be considered in the sealing chain. This allows one to prevent seal "
"from fixing part of the mock object. ::"
msgstr ""
"如果將具有名稱或規格的 mock 實例指派給屬性，則不會出現在密封鏈中。這表示可藉"
"由固定 mock 物件的一部分來防止密封。： ::"

#: ../../library/unittest.mock.rst:2765
msgid ""
">>> mock = Mock()\n"
">>> mock.submock.attribute1 = 2\n"
">>> mock.not_submock = mock.Mock(name=\"sample_name\")\n"
">>> seal(mock)\n"
">>> mock.new_attribute  # This will raise AttributeError.\n"
">>> mock.submock.attribute2  # This will raise AttributeError.\n"
">>> mock.not_submock.attribute2  # This won't raise."
msgstr ""
">>> mock = Mock()\n"
">>> mock.submock.attribute1 = 2\n"
">>> mock.not_submock = mock.Mock(name=\"sample_name\")\n"
">>> seal(mock)\n"
">>> mock.new_attribute  # This will raise AttributeError.\n"
">>> mock.submock.attribute2  # This will raise AttributeError.\n"
">>> mock.not_submock.attribute2  # This won't raise."

#: ../../library/unittest.mock.rst:2777
msgid ""
"Order of precedence of :attr:`side_effect`, :attr:`return_value` and *wraps*"
msgstr ":attr:`side_effect`、:attr:`return_value` 和 *wraps* 的優先順序"

#: ../../library/unittest.mock.rst:2779
msgid "The order of their precedence is:"
msgstr "它們的優先順序是："

#: ../../library/unittest.mock.rst:2781
msgid ":attr:`~Mock.side_effect`"
msgstr ":attr:`~Mock.side_effect`"

#: ../../library/unittest.mock.rst:2782
msgid ":attr:`~Mock.return_value`"
msgstr ":attr:`~Mock.return_value`"

#: ../../library/unittest.mock.rst:2783
msgid "*wraps*"
msgstr "*wraps*"

#: ../../library/unittest.mock.rst:2785
msgid ""
"If all three are set, mock will return the value from :attr:`~Mock."
"side_effect`, ignoring :attr:`~Mock.return_value` and the wrapped object "
"altogether. If any two are set, the one with the higher precedence will "
"return the value. Regardless of the order of which was set first, the order "
"of precedence remains unchanged."
msgstr ""
"如果這三個都有設定，mock 將會回傳來自 :attr:`~Mock.side_effect` 的值，並忽"
"略 :attr:`~Mock.return_value` 和被包裝物件。如果設定了任兩項，則優先順序較高"
"的一項將回傳該值。無論先設定哪個順序，優先順序都保持不變。"

#: ../../library/unittest.mock.rst:2803
msgid ""
"As ``None`` is the default value of :attr:`~Mock.side_effect`, if you "
"reassign its value back to ``None``, the order of precedence will be checked "
"between :attr:`~Mock.return_value` and the wrapped object, ignoring :attr:"
"`~Mock.side_effect`."
msgstr ""
"由於 ``None`` 是 :attr:`~Mock.side_effect` 的預設值，如果將其值重新賦值回為 "
"``None``，則會檢查 :attr:`~Mock.return_value` 和被包裝物件之間的優先順序，忽"
"略 :attr:`~Mock.side_effect`。"

#: ../../library/unittest.mock.rst:2812
msgid ""
"If the value being returned by :attr:`~Mock.side_effect` is :data:`DEFAULT`, "
"it is ignored and the order of precedence moves to the successor to obtain "
"the value to return."
msgstr ""
"如果 :attr:`~Mock.side_effect` 回傳的值是 :data:`DEFAULT`，它將被忽略，並且優"
"先順序被移動到後面一個以獲得要回傳的值。"

#: ../../library/unittest.mock.rst:2821
msgid ""
"When :class:`Mock` wraps an object, the default value of :attr:`~Mock."
"return_value` will be :data:`DEFAULT`."
msgstr ""
"當 :class:`Mock` 包裝一個物件時，:attr:`~Mock.return_value` 的預設值將為 :"
"data:`DEFAULT`。"

#: ../../library/unittest.mock.rst:2830
msgid ""
"The order of precedence will ignore this value and it will move to the last "
"successor which is the wrapped object."
msgstr "優先順序將忽略該值，並將移動到最後一個，即被包裝物件。"

#: ../../library/unittest.mock.rst:2833
msgid ""
"As the real call is being made to the wrapped object, creating an instance "
"of this mock will return the real instance of the class. The positional "
"arguments, if any, required by the wrapped object must be passed."
msgstr ""
"當對被包裝物件進行真正的呼叫時，建立此 mock 的實例將回傳該類別的真實實例。必"
"須傳遞被包裝物件所需的位置引數（如果存在）。"

#: ../../library/unittest.mock.rst:2851
msgid ""
"But if you assign ``None`` to it, this will not be ignored as it is an "
"explicit assignment. So, the order of precedence will not move to the "
"wrapped object."
msgstr ""
"但如果你為其賦予 ``None`` 則不會被忽略，因為它是明確賦值。因此，優先順序不會"
"移至被包裝物件。"

#: ../../library/unittest.mock.rst:2859
msgid ""
"Even if you set all three at once when initializing the mock, the order of "
"precedence remains the same:"
msgstr "即使你在初始化 mock 時同時設定所有三個，優先順序也保持不變："

#: ../../library/unittest.mock.rst:2876
msgid ""
"If :attr:`~Mock.side_effect` is exhausted, the order of precedence will not "
"cause a value to be obtained from the successors. Instead, ``StopIteration`` "
"exception is raised."
msgstr ""
"如果 :attr:`~Mock.side_effect` 已耗盡，則優先順序將不會使值由後面取得。相反地"
"這會引發 ``StopIteration`` 例外。"
