# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-23 07:52+0800\n"
"PO-Revision-Date: 2018-05-23 16:12+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/threading.rst:2
msgid ":mod:`!threading` --- Thread-based parallelism"
msgstr ":mod:`!threading` --- 基於執行緒的平行性"

#: ../../library/threading.rst:7
msgid "**Source code:** :source:`Lib/threading.py`"
msgstr "**原始碼：**\\ :source:`Lib/threading.py`"

#: ../../library/threading.rst:11
msgid ""
"This module constructs higher-level threading interfaces on top of the lower "
"level :mod:`_thread` module."
msgstr ""

#: ../../library/threading.rst:14
msgid "This module used to be optional, it is now always available."
msgstr ""

#: ../../library/threading.rst:19
msgid ""
":class:`concurrent.futures.ThreadPoolExecutor` offers a higher level "
"interface to push tasks to a background thread without blocking execution of "
"the calling thread, while still being able to retrieve their results when "
"needed."
msgstr ""

#: ../../library/threading.rst:23
msgid ""
":mod:`queue` provides a thread-safe interface for exchanging data between "
"running threads."
msgstr ""

#: ../../library/threading.rst:26
msgid ""
":mod:`asyncio` offers an alternative approach to achieving task level "
"concurrency without requiring the use of multiple operating system threads."
msgstr ""

#: ../../library/threading.rst:31
msgid ""
"In the Python 2.x series, this module contained ``camelCase`` names for some "
"methods and functions. These are deprecated as of Python 3.10, but they are "
"still supported for compatibility with Python 2.5 and lower."
msgstr ""

#: ../../library/threading.rst:38
msgid ""
"In CPython, due to the :term:`Global Interpreter Lock <global interpreter "
"lock>`, only one thread can execute Python code at once (even though certain "
"performance-oriented libraries might overcome this limitation). If you want "
"your application to make better use of the computational resources of multi-"
"core machines, you are advised to use :mod:`multiprocessing` or :class:"
"`concurrent.futures.ProcessPoolExecutor`. However, threading is still an "
"appropriate model if you want to run multiple I/O-bound tasks simultaneously."
msgstr ""

#: ../../includes/wasm-notavail.rst:3
msgid ":ref:`Availability <availability>`: not WASI."
msgstr ":ref:`適用 <availability>`：非 WASI。"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"此模組在 WebAssembly 平台上不起作用或無法使用。更多資訊請參閱 :ref:`wasm-"
"availability`。"

#: ../../library/threading.rst:50
msgid "This module defines the following functions:"
msgstr ""

#: ../../library/threading.rst:55
msgid ""
"Return the number of :class:`Thread` objects currently alive.  The returned "
"count is equal to the length of the list returned by :func:`.enumerate`."
msgstr ""

#: ../../library/threading.rst:58
msgid "The function ``activeCount`` is a deprecated alias for this function."
msgstr ""

#: ../../library/threading.rst:63
msgid ""
"Return the current :class:`Thread` object, corresponding to the caller's "
"thread of control.  If the caller's thread of control was not created "
"through the :mod:`threading` module, a dummy thread object with limited "
"functionality is returned."
msgstr ""

#: ../../library/threading.rst:68
msgid "The function ``currentThread`` is a deprecated alias for this function."
msgstr ""

#: ../../library/threading.rst:73
msgid "Handle uncaught exception raised by :func:`Thread.run`."
msgstr ""

#: ../../library/threading.rst:75
msgid "The *args* argument has the following attributes:"
msgstr ""

#: ../../library/threading.rst:77
msgid "*exc_type*: Exception type."
msgstr ""

#: ../../library/threading.rst:78
msgid "*exc_value*: Exception value, can be ``None``."
msgstr ""

#: ../../library/threading.rst:79
msgid "*exc_traceback*: Exception traceback, can be ``None``."
msgstr ""

#: ../../library/threading.rst:80
msgid "*thread*: Thread which raised the exception, can be ``None``."
msgstr ""

#: ../../library/threading.rst:82
msgid ""
"If *exc_type* is :exc:`SystemExit`, the exception is silently ignored. "
"Otherwise, the exception is printed out on :data:`sys.stderr`."
msgstr ""

#: ../../library/threading.rst:85
msgid ""
"If  this function raises an exception, :func:`sys.excepthook` is called to "
"handle it."
msgstr ""

#: ../../library/threading.rst:88
msgid ""
":func:`threading.excepthook` can be overridden to control how uncaught "
"exceptions raised by :func:`Thread.run` are handled."
msgstr ""

#: ../../library/threading.rst:91
msgid ""
"Storing *exc_value* using a custom hook can create a reference cycle. It "
"should be cleared explicitly to break the reference cycle when the exception "
"is no longer needed."
msgstr ""

#: ../../library/threading.rst:95
msgid ""
"Storing *thread* using a custom hook can resurrect it if it is set to an "
"object which is being finalized. Avoid storing *thread* after the custom "
"hook completes to avoid resurrecting objects."
msgstr ""

#: ../../library/threading.rst:100
msgid ":func:`sys.excepthook` handles uncaught exceptions."
msgstr ""

#: ../../library/threading.rst:106
msgid ""
"Holds the original value of :func:`threading.excepthook`. It is saved so "
"that the original value can be restored in case they happen to get replaced "
"with broken or alternative objects."
msgstr ""

#: ../../library/threading.rst:114
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""

#: ../../library/threading.rst:125
msgid ""
"Return the native integral Thread ID of the current thread assigned by the "
"kernel. This is a non-negative integer. Its value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""

#: ../../library/threading.rst:130
msgid ""
":ref:`Availability <availability>`: Windows, FreeBSD, Linux, macOS, OpenBSD, "
"NetBSD, AIX, DragonFlyBSD, GNU/kFreeBSD."
msgstr ""

#: ../../library/threading.rst:134
msgid "Added support for GNU/kFreeBSD."
msgstr ""

#: ../../library/threading.rst:140
msgid ""
"Return a list of all :class:`Thread` objects currently active.  The list "
"includes daemonic threads and dummy thread objects created by :func:"
"`current_thread`.  It excludes terminated threads and threads that have not "
"yet been started.  However, the main thread is always part of the result, "
"even when terminated."
msgstr ""

#: ../../library/threading.rst:149
msgid ""
"Return the main :class:`Thread` object.  In normal conditions, the main "
"thread is the thread from which the Python interpreter was started."
msgstr ""

#: ../../library/threading.rst:160
msgid ""
"Set a trace function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.settrace` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""

#: ../../library/threading.rst:166
msgid ""
"Set a trace function for all threads started from the :mod:`threading` "
"module and all Python threads that are currently executing."
msgstr ""

#: ../../library/threading.rst:169
msgid ""
"The *func* will be passed to  :func:`sys.settrace` for each thread, before "
"its :meth:`~Thread.run` method is called."
msgstr ""

#: ../../library/threading.rst:180
msgid "Get the trace function as set by :func:`settrace`."
msgstr ""

#: ../../library/threading.rst:189
msgid ""
"Set a profile function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.setprofile` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""

#: ../../library/threading.rst:195
msgid ""
"Set a profile function for all threads started from the :mod:`threading` "
"module and all Python threads that are currently executing."
msgstr ""

#: ../../library/threading.rst:198
msgid ""
"The *func* will be passed to  :func:`sys.setprofile` for each thread, before "
"its :meth:`~Thread.run` method is called."
msgstr ""

#: ../../library/threading.rst:207
msgid "Get the profiler function as set by :func:`setprofile`."
msgstr ""

#: ../../library/threading.rst:214
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`RuntimeError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""

#: ../../library/threading.rst:229
msgid ":ref:`Availability <availability>`: Windows, pthreads."
msgstr ":ref:`適用 <availability>`：Windows, pthreads。"

#: ../../library/threading.rst:231
msgid "Unix platforms with POSIX threads support."
msgstr ""

#: ../../library/threading.rst:234
msgid "This module also defines the following constant:"
msgstr ""

#: ../../library/threading.rst:238
msgid ""
"The maximum value allowed for the *timeout* parameter of blocking functions "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.). "
"Specifying a timeout greater than this value will raise an :exc:"
"`OverflowError`."
msgstr ""

#: ../../library/threading.rst:246
msgid ""
"This module defines a number of classes, which are detailed in the sections "
"below."
msgstr ""

#: ../../library/threading.rst:249
msgid ""
"The design of this module is loosely based on Java's threading model. "
"However, where Java makes locks and condition variables basic behavior of "
"every object, they are separate objects in Python.  Python's :class:`Thread` "
"class supports a subset of the behavior of Java's Thread class; currently, "
"there are no priorities, no thread groups, and threads cannot be destroyed, "
"stopped, suspended, resumed, or interrupted.  The static methods of Java's "
"Thread class, when implemented, are mapped to module-level functions."
msgstr ""

#: ../../library/threading.rst:257
msgid "All of the methods described below are executed atomically."
msgstr ""

#: ../../library/threading.rst:261
msgid "Thread-Local Data"
msgstr ""

#: ../../library/threading.rst:263
msgid ""
"Thread-local data is data whose values are thread specific.  To manage "
"thread-local data, just create an instance of :class:`local` (or a subclass) "
"and store attributes on it::"
msgstr ""

#: ../../library/threading.rst:267
msgid ""
"mydata = threading.local()\n"
"mydata.x = 1"
msgstr ""
"mydata = threading.local()\n"
"mydata.x = 1"

#: ../../library/threading.rst:270
msgid "The instance's values will be different for separate threads."
msgstr ""

#: ../../library/threading.rst:275
msgid "A class that represents thread-local data."
msgstr ""

#: ../../library/threading.rst:277
msgid ""
"For more details and extensive examples, see the documentation string of "
"the :mod:`!_threading_local` module: :source:`Lib/_threading_local.py`."
msgstr ""

#: ../../library/threading.rst:284
msgid "Thread Objects"
msgstr ""

#: ../../library/threading.rst:286
msgid ""
"The :class:`Thread` class represents an activity that is run in a separate "
"thread of control.  There are two ways to specify the activity: by passing a "
"callable object to the constructor, or by overriding the :meth:`~Thread.run` "
"method in a subclass.  No other methods (except for the constructor) should "
"be overridden in a subclass.  In other words, *only*  override the "
"``__init__()`` and :meth:`~Thread.run` methods of this class."
msgstr ""

#: ../../library/threading.rst:293
msgid ""
"Once a thread object is created, its activity must be started by calling the "
"thread's :meth:`~Thread.start` method.  This invokes the :meth:`~Thread.run` "
"method in a separate thread of control."
msgstr ""

#: ../../library/threading.rst:297
msgid ""
"Once the thread's activity is started, the thread is considered 'alive'. It "
"stops being alive when its :meth:`~Thread.run` method terminates -- either "
"normally, or by raising an unhandled exception.  The :meth:`~Thread."
"is_alive` method tests whether the thread is alive."
msgstr ""

#: ../../library/threading.rst:302
msgid ""
"Other threads can call a thread's :meth:`~Thread.join` method.  This blocks "
"the calling thread until the thread whose :meth:`~Thread.join` method is "
"called is terminated."
msgstr ""

#: ../../library/threading.rst:306
msgid ""
"A thread has a name.  The name can be passed to the constructor, and read or "
"changed through the :attr:`~Thread.name` attribute."
msgstr ""

#: ../../library/threading.rst:309
msgid ""
"If the :meth:`~Thread.run` method raises an exception, :func:`threading."
"excepthook` is called to handle it. By default, :func:`threading.excepthook` "
"ignores silently :exc:`SystemExit`."
msgstr ""

#: ../../library/threading.rst:313
msgid ""
"A thread can be flagged as a \"daemon thread\".  The significance of this "
"flag is that the entire Python program exits when only daemon threads are "
"left.  The initial value is inherited from the creating thread.  The flag "
"can be set through the :attr:`~Thread.daemon` property or the *daemon* "
"constructor argument."
msgstr ""

#: ../../library/threading.rst:320
msgid ""
"Daemon threads are abruptly stopped at shutdown.  Their resources (such as "
"open files, database transactions, etc.) may not be released properly. If "
"you want your threads to stop gracefully, make them non-daemonic and use a "
"suitable signalling mechanism such as an :class:`Event`."
msgstr ""

#: ../../library/threading.rst:325
msgid ""
"There is a \"main thread\" object; this corresponds to the initial thread of "
"control in the Python program.  It is not a daemon thread."
msgstr ""

#: ../../library/threading.rst:328
msgid ""
"There is the possibility that \"dummy thread objects\" are created. These "
"are thread objects corresponding to \"alien threads\", which are threads of "
"control started outside the threading module, such as directly from C code.  "
"Dummy thread objects have limited functionality; they are always considered "
"alive and daemonic, and cannot be :ref:`joined <meth-thread-join>`.  They "
"are never deleted, since it is impossible to detect the termination of alien "
"threads."
msgstr ""

#: ../../library/threading.rst:339
msgid ""
"This constructor should always be called with keyword arguments.  Arguments "
"are:"
msgstr ""

#: ../../library/threading.rst:342
msgid ""
"*group* should be ``None``; reserved for future extension when a :class:`!"
"ThreadGroup` class is implemented."
msgstr ""

#: ../../library/threading.rst:345
msgid ""
"*target* is the callable object to be invoked by the :meth:`run` method. "
"Defaults to ``None``, meaning nothing is called."
msgstr ""

#: ../../library/threading.rst:348
msgid ""
"*name* is the thread name. By default, a unique name is constructed of the "
"form \"Thread-*N*\" where *N* is a small decimal number, or \"Thread-*N* "
"(target)\" where \"target\" is ``target.__name__`` if the *target* argument "
"is specified."
msgstr ""

#: ../../library/threading.rst:353
msgid ""
"*args* is a list or tuple of arguments for the target invocation.  Defaults "
"to ``()``."
msgstr ""

#: ../../library/threading.rst:355
msgid ""
"*kwargs* is a dictionary of keyword arguments for the target invocation. "
"Defaults to ``{}``."
msgstr ""

#: ../../library/threading.rst:358
msgid ""
"If not ``None``, *daemon* explicitly sets whether the thread is daemonic. If "
"``None`` (the default), the daemonic property is inherited from the current "
"thread."
msgstr ""

#: ../../library/threading.rst:362
msgid ""
"If the subclass overrides the constructor, it must make sure to invoke the "
"base class constructor (``Thread.__init__()``) before doing anything else to "
"the thread."
msgstr ""

#: ../../library/threading.rst:366
msgid "Added the *daemon* parameter."
msgstr "新增 *daemon* 參數。"

#: ../../library/threading.rst:369
msgid "Use the *target* name if *name* argument is omitted."
msgstr ""

#: ../../library/threading.rst:374
msgid "Start the thread's activity."
msgstr ""

#: ../../library/threading.rst:376
msgid ""
"It must be called at most once per thread object.  It arranges for the "
"object's :meth:`~Thread.run` method to be invoked in a separate thread of "
"control."
msgstr ""

#: ../../library/threading.rst:380
msgid ""
"This method will raise a :exc:`RuntimeError` if called more than once on the "
"same thread object."
msgstr ""

#: ../../library/threading.rst:385
msgid "Method representing the thread's activity."
msgstr ""

#: ../../library/threading.rst:387
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the "
"*target* argument, if any, with positional and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""

#: ../../library/threading.rst:392
msgid ""
"Using list or tuple as the *args* argument which passed to the :class:"
"`Thread` could achieve the same effect."
msgstr ""

#: ../../library/threading.rst:395
msgid "Example::"
msgstr "舉例來說： ::"

#: ../../library/threading.rst:397
msgid ""
">>> from threading import Thread\n"
">>> t = Thread(target=print, args=[1])\n"
">>> t.run()\n"
"1\n"
">>> t = Thread(target=print, args=(1,))\n"
">>> t.run()\n"
"1"
msgstr ""
">>> from threading import Thread\n"
">>> t = Thread(target=print, args=[1])\n"
">>> t.run()\n"
"1\n"
">>> t = Thread(target=print, args=(1,))\n"
">>> t.run()\n"
"1"

#: ../../library/threading.rst:409
msgid ""
"Wait until the thread terminates. This blocks the calling thread until the "
"thread whose :meth:`~Thread.join` method is called terminates -- either "
"normally or through an unhandled exception -- or until the optional timeout "
"occurs."
msgstr ""

#: ../../library/threading.rst:414
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds (or "
"fractions thereof). As :meth:`~Thread.join` always returns ``None``, you "
"must call :meth:`~Thread.is_alive` after :meth:`~Thread.join` to decide "
"whether a timeout happened -- if the thread is still alive, the :meth:"
"`~Thread.join` call timed out."
msgstr ""

#: ../../library/threading.rst:421
msgid ""
"When the *timeout* argument is not present or ``None``, the operation will "
"block until the thread terminates."
msgstr ""

#: ../../library/threading.rst:424
msgid "A thread can be joined many times."
msgstr ""

#: ../../library/threading.rst:426
msgid ""
":meth:`~Thread.join` raises a :exc:`RuntimeError` if an attempt is made to "
"join the current thread as that would cause a deadlock. It is also an error "
"to :meth:`~Thread.join` a thread before it has been started and attempts to "
"do so raise the same exception."
msgstr ""

#: ../../library/threading.rst:433
msgid ""
"A string used for identification purposes only. It has no semantics. "
"Multiple threads may be given the same name.  The initial name is set by the "
"constructor."
msgstr ""

#: ../../library/threading.rst:440
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.name`; use it directly as a "
"property instead."
msgstr ""

#: ../../library/threading.rst:447
msgid ""
"The 'thread identifier' of this thread or ``None`` if the thread has not "
"been started.  This is a nonzero integer.  See the :func:`get_ident` "
"function.  Thread identifiers may be recycled when a thread exits and "
"another thread is created.  The identifier is available even after the "
"thread has exited."
msgstr ""

#: ../../library/threading.rst:455
msgid ""
"The Thread ID (``TID``) of this thread, as assigned by the OS (kernel). This "
"is a non-negative integer, or ``None`` if the thread has not been started. "
"See the :func:`get_native_id` function. This value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""

#: ../../library/threading.rst:464
msgid ""
"Similar to Process IDs, Thread IDs are only valid (guaranteed unique system-"
"wide) from the time the thread is created until the thread has been "
"terminated."
msgstr ""

#: ../../library/threading.rst:468
msgid ""
":ref:`Availability <availability>`: Windows, FreeBSD, Linux, macOS, OpenBSD, "
"NetBSD, AIX, DragonFlyBSD."
msgstr ""

#: ../../library/threading.rst:474
msgid "Return whether the thread is alive."
msgstr ""

#: ../../library/threading.rst:476
msgid ""
"This method returns ``True`` just before the :meth:`~Thread.run` method "
"starts until just after the :meth:`~Thread.run` method terminates.  The "
"module function :func:`.enumerate` returns a list of all alive threads."
msgstr ""

#: ../../library/threading.rst:482
msgid ""
"A boolean value indicating whether this thread is a daemon thread (``True``) "
"or not (``False``).  This must be set before :meth:`~Thread.start` is "
"called, otherwise :exc:`RuntimeError` is raised.  Its initial value is "
"inherited from the creating thread; the main thread is not a daemon thread "
"and therefore all threads created in the main thread default to :attr:"
"`~Thread.daemon` = ``False``."
msgstr ""

#: ../../library/threading.rst:489
msgid ""
"The entire Python program exits when no alive non-daemon threads are left."
msgstr ""

#: ../../library/threading.rst:494
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.daemon`; use it directly as "
"a property instead."
msgstr ""

#: ../../library/threading.rst:503
msgid "Lock Objects"
msgstr "Lock 物件"

#: ../../library/threading.rst:505
msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular thread when locked.  In Python, it is currently the lowest level "
"synchronization primitive available, implemented directly by the :mod:"
"`_thread` extension module."
msgstr ""
"原始鎖 (primitive lock) 是一種同步原語 (synchronization primitive)，在鎖定時"
"不屬於特定執行緒。在 Python 中，它是目前可用的最低階同步原語，直接由 :mod:"
"`_thread` 擴充模組實作。"

#: ../../library/threading.rst:510
msgid ""
"A primitive lock is in one of two states, \"locked\" or \"unlocked\". It is "
"created in the unlocked state.  It has two basic methods, :meth:`~Lock."
"acquire` and :meth:`~Lock.release`.  When the state is unlocked, :meth:"
"`~Lock.acquire` changes the state to locked and returns immediately.  When "
"the state is locked, :meth:`~Lock.acquire` blocks until a call to :meth:"
"`~Lock.release` in another thread changes it to unlocked, then the :meth:"
"`~Lock.acquire` call resets it to locked and returns.  The :meth:`~Lock."
"release` method should only be called in the locked state; it changes the "
"state to unlocked and returns immediately. If an attempt is made to release "
"an unlocked lock, a :exc:`RuntimeError` will be raised."
msgstr ""
"原始鎖會處於兩種狀態之一：「鎖定 (locked)」或「未鎖定 (unclocked)」，建立時會"
"處於未鎖定狀態。它有兩個基本方法 :meth:`~Lock.acquire` 和 :meth:`~Lock."
"release`。當狀態為未鎖定時，:meth:`~Lock.acquire` 會將狀態變更為鎖定並立即回"
"傳。當狀態被鎖定時，:meth:`~Lock.acquire` 會阻塞 (block)，直到另一個執行緒中"
"對 :meth:`~Lock.release` 的呼叫將其更改為未鎖定狀態，然後 :meth:`~Lock."
"acquire` 呼叫會將其重置為鎖定並回傳。:meth:`~Lock.release` 方法只能在鎖定狀態"
"下呼叫；它將狀態更改為未鎖定並立即回傳。如果嘗試釋放未鎖定的鎖，則會引發 :"
"exc:`RuntimeError`。"

#: ../../library/threading.rst:521
msgid "Locks also support the :ref:`context management protocol <with-locks>`."
msgstr "鎖也支援\\ :ref:`情境管理協定 <with-locks>`。"

#: ../../library/threading.rst:523
msgid ""
"When more than one thread is blocked in :meth:`~Lock.acquire` waiting for "
"the state to turn to unlocked, only one thread proceeds when a :meth:`~Lock."
"release` call resets the state to unlocked; which one of the waiting threads "
"proceeds is not defined, and may vary across implementations."
msgstr ""
"當多個執行緒阻塞在 :meth:`~Lock.acquire` 中等待狀態轉變為未鎖定，此時若呼叫 :"
"meth:`~Lock.release` 將狀態重置為未鎖定，則只會有一個執行緒繼續進行；哪一個等"
"待執行緒會繼續進行是未定義的，並且可能因實作而異。"

#: ../../library/threading.rst:528
msgid "All methods are executed atomically."
msgstr "所有方法均以最小不可分割的操作方式 (atomically) 執行。"

#: ../../library/threading.rst:533
msgid ""
"The class implementing primitive lock objects.  Once a thread has acquired a "
"lock, subsequent attempts to acquire it block, until it is released; any "
"thread may release it."
msgstr ""
"實作原始鎖物件的類別。一旦執行緒獲得了鎖，後續再嘗試獲得它就會被阻塞，直到鎖"
"被釋放；任何執行緒都可以去釋放它。"

#: ../../library/threading.rst:537
msgid ""
"``Lock`` is now a class. In earlier Pythons, ``Lock`` was a factory function "
"which returned an instance of the underlying private lock type."
msgstr ""
"``Lock`` 現在是一個類別。在早期的 Python 中，``Lock`` 是一個會回傳底層私有鎖"
"型別實例的工廠函式。"

#: ../../library/threading.rst:545 ../../library/threading.rst:636
msgid "Acquire a lock, blocking or non-blocking."
msgstr "阻塞或非阻塞地取得鎖。"

#: ../../library/threading.rst:547
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default), "
"block until the lock is unlocked, then set it to locked and return ``True``."
msgstr ""
"當以 *blocking* 引數設為 ``True``\\ （預設值）來調用，將會阻塞直到鎖被解鎖，"
"然後將其設為鎖定並回傳 ``True``。"

#: ../../library/threading.rst:550
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block. If "
"a call with *blocking* set to ``True`` would block, return ``False`` "
"immediately; otherwise, set the lock to locked and return ``True``."
msgstr ""
"當以 *blocking* 引數設為 ``False`` 調用則不會阻塞。如果 *blocking* 設定為 "
"``True`` 的呼叫會阻塞，則立即回傳 ``False``；否則將鎖設為鎖定並回傳 "
"``True``。"

#: ../../library/threading.rst:554
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as "
"long as the lock cannot be acquired.  A *timeout* argument of ``-1`` "
"specifies an unbounded wait.  It is forbidden to specify a *timeout* when "
"*blocking* is ``False``."
msgstr ""
"當使用設定為正值的浮點 *timeout* 引數進行調用，只要持續無法取得鎖，最多會阻"
"塞 *timeout* 指定的秒數。``-1`` 的 *timeout* 引數代表指定為不會停止的等待。"
"當 *blocking* 為 ``False`` 時禁止指定 *timeout*。"

#: ../../library/threading.rst:560
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False`` "
"if not (for example if the *timeout* expired)."
msgstr ""
"如果成功取得鎖，則回傳值為 ``True``，否則回傳值為 ``False``\\ （例如像是 "
"*timeout* 已逾期）。"

#: ../../library/threading.rst:563 ../../library/threading.rst:674
#: ../../library/threading.rst:921
msgid "The *timeout* parameter is new."
msgstr "新的 *timeout* 參數。"

#: ../../library/threading.rst:566
msgid ""
"Lock acquisition can now be interrupted by signals on POSIX if the "
"underlying threading implementation supports it."
msgstr "如果底層執行緒實作支援的話，鎖的獲取現在可以被 POSIX 上的訊號中斷。"

#: ../../library/threading.rst:573
msgid ""
"Release a lock.  This can be called from any thread, not only the thread "
"which has acquired the lock."
msgstr "釋放鎖。這可以從任何執行緒呼叫，而不是只有獲得鎖的執行緒。"

#: ../../library/threading.rst:576
msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"threads are blocked waiting for the lock to become unlocked, allow exactly "
"one of them to proceed."
msgstr ""
"當鎖被鎖定時，將其重置為未鎖定然後回傳。如果任何其他執行緒在等待鎖被解鎖時被"
"阻塞，只允許其中一個執行緒繼續進行。"

#: ../../library/threading.rst:580
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr "當在未鎖定的鎖上調用時，會引發 :exc:`RuntimeError`"

#: ../../library/threading.rst:582 ../../library/threading.rst:690
msgid "There is no return value."
msgstr "沒有回傳值。"

#: ../../library/threading.rst:586
msgid "Return ``True`` if the lock is acquired."
msgstr "如果有取得了鎖，則回傳 ``True``。"

#: ../../library/threading.rst:593
msgid "RLock Objects"
msgstr "RLock 物件"

#: ../../library/threading.rst:595
msgid ""
"A reentrant lock is a synchronization primitive that may be acquired "
"multiple times by the same thread.  Internally, it uses the concepts of "
"\"owning thread\" and \"recursion level\" in addition to the locked/unlocked "
"state used by primitive locks.  In the locked state, some thread owns the "
"lock; in the unlocked state, no thread owns it."
msgstr ""
"可重入鎖 (reentrant lock) 是一種同步原語，同一執行緒可以多次取得它。在內部，"
"除了原始鎖使用的鎖定/未鎖定狀態之外，它還使用「所屬執行緒 (owning thread)」和"
"「遞迴等級 (recursion level)」的概念。在鎖定狀態下，某個執行緒會擁有鎖；在未"
"鎖定狀態下則沒有執行緒擁有它。"

#: ../../library/threading.rst:601
msgid ""
"Threads call a lock's :meth:`~RLock.acquire` method to lock it, and its :"
"meth:`~Lock.release` method to unlock it."
msgstr ""
"執行緒呼叫鎖的 :meth:`~RLock.acquire` 方法來鎖定它，並呼叫它的 :meth:`~Lock."
"release` 方法來解鎖它。"

#: ../../library/threading.rst:606
msgid ""
"Reentrant locks support the :ref:`context management protocol <with-locks>`, "
"so it is recommended to use :keyword:`with` instead of manually calling :"
"meth:`~RLock.acquire` and :meth:`~RLock.release` to handle acquiring and "
"releasing the lock for a block of code."
msgstr ""
"可重入鎖支援\\ :ref:`情境管理協定<with-locks>`，因此建議使用 :keyword:`with` "
"而不是手動呼叫 :meth:`~RLock.acquire` 和 :meth:`~RLock.release` 來對程式碼區"
"塊處理鎖的獲得和釋放。"

#: ../../library/threading.rst:611
msgid ""
"RLock's :meth:`~RLock.acquire`/:meth:`~RLock.release` call pairs may be "
"nested, unlike Lock's :meth:`~Lock.acquire`/:meth:`~Lock.release`. Only the "
"final :meth:`~RLock.release` (the :meth:`~Lock.release` of the outermost "
"pair) resets the lock to an unlocked state and allows another thread blocked "
"in :meth:`~RLock.acquire` to proceed."
msgstr ""
"RLock 的 :meth:`~RLock.acquire`/:meth:`~RLock.release` 呼叫成對組合可以嵌套使"
"用，這與 Lock 的 :meth:`~Lock.acquire`/:meth:`~Lock.release` 不同。只有最後一"
"個 :meth:`~RLock.release`\\ （最外面一對的 :meth:`~Lock.release`）會將鎖重置"
"為未鎖定狀態，並允許在 :meth:`~RLock.acquire` 中阻塞的另一個執行緒繼續進行。"

#: ../../library/threading.rst:617
msgid ""
":meth:`~RLock.acquire`/:meth:`~RLock.release` must be used in pairs: each "
"acquire must have a release in the thread that has acquired the lock. "
"Failing to call release as many times the lock has been acquired can lead to "
"deadlock."
msgstr ""
":meth:`~RLock.acquire`/:meth:`~RLock.release` 必須成對使用：每次獲得都必須在"
"已獲得鎖的執行緒中有一個釋放。如果鎖釋放的次數不能和獲取的次數一樣的話，可能"
"會導致死鎖 (deadlock)。"

#: ../../library/threading.rst:624
msgid ""
"This class implements reentrant lock objects.  A reentrant lock must be "
"released by the thread that acquired it.  Once a thread has acquired a "
"reentrant lock, the same thread may acquire it again without blocking; the "
"thread must release it once for each time it has acquired it."
msgstr ""
"此類別實作了可重入鎖物件。可重入鎖必須由獲得它的執行緒釋放。一旦一個執行緒獲"
"得了可重入鎖，同一個執行緒可以再次獲得它而不會阻塞；執行緒每次獲得它也都必須"
"釋放它一次。"

#: ../../library/threading.rst:629
msgid ""
"Note that ``RLock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete RLock class that is supported "
"by the platform."
msgstr ""
"請注意，``RLock`` 實際上是一個工廠函式，它會回傳平台有支援的特定 RLock 類別的"
"最高效率版本的實例。"

#: ../../library/threading.rst:640
msgid ":ref:`Using RLock as a context manager <with-locks>`"
msgstr ":ref:`將 RLock 用作為情境管理器 <with-locks>`"

#: ../../library/threading.rst:641
msgid ""
"Recommended over manual :meth:`!acquire` and :meth:`release` calls whenever "
"practical."
msgstr ""
"若是使用場景合理，和手動呼叫 :meth:`!acquire` 和 :meth:`release` 相比，會是更"
"為推薦的使用方式。"

#: ../../library/threading.rst:645
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default):"
msgstr "當以 *blocking* 引數設為 ``True``\\ （預設值）來調用："

#: ../../library/threading.rst:647 ../../library/threading.rst:659
msgid "If no thread owns the lock, acquire the lock and return immediately."
msgstr "如果沒有執行緒擁有鎖，則獲得鎖並立即回傳。"

#: ../../library/threading.rst:649
msgid ""
"If another thread owns the lock, block until we are able to acquire lock, or "
"*timeout*, if set to a positive float value."
msgstr ""
"如果另一個執行緒擁有鎖，則阻塞直到能夠取得鎖，或者達到 *timeout*\\ （如果設定"
"為正浮點值）。"

#: ../../library/threading.rst:652
msgid ""
"If the same thread owns the lock, acquire the lock again, and return "
"immediately. This is the difference between :class:`Lock` and :class:`!"
"RLock`; :class:`Lock` handles this case the same as the previous, blocking "
"until the lock can be acquired."
msgstr ""
"如果同一個執行緒擁有鎖，則再次取得鎖，並立即回傳。這就是 :class:`Lock` 和 :"
"class:`!RLock` 之間的差別；:class:`Lock` 處理方式與上一種情況相同，會阻塞直到"
"能夠取得鎖。"

#: ../../library/threading.rst:657
msgid "When invoked with the *blocking* argument set to ``False``:"
msgstr "當以 *blocking* 引數設為 ``False`` 來調用："

#: ../../library/threading.rst:661
msgid "If another thread owns the lock, return immediately."
msgstr "如果另一個執行緒擁有該鎖，則立即回傳。"

#: ../../library/threading.rst:663
msgid ""
"If the same thread owns the lock, acquire the lock again and return "
"immediately."
msgstr "如果同一個執行緒擁有鎖，則再次取得鎖並立即回傳。"

#: ../../library/threading.rst:666
msgid ""
"In all cases, if the thread was able to acquire the lock, return ``True``. "
"If the thread was unable to acquire the lock (i.e. if not blocking or the "
"timeout was reached) return ``False``."
msgstr ""
"在所有情況下，如果執行緒能夠取得鎖則回傳 ``True``。如果執行緒無法取得鎖（即沒"
"有阻塞或已達超時限制）則回傳 ``False``。"

#: ../../library/threading.rst:670
msgid ""
"If called multiple times, failing to call :meth:`~RLock.release` as many "
"times may lead to deadlock. Consider using :class:`!RLock` as a context "
"manager rather than calling acquire/release directly."
msgstr ""
"如果多次呼叫，又未能呼叫相同次數的 :meth:`~RLock.release`，則可能會導致死鎖。"
"考慮將 :class:`!RLock` 作為情境管理器使用，而不是直接呼叫 acquire/release。"

#: ../../library/threading.rst:680
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement it "
"is zero, reset the lock to unlocked (not owned by any thread), and if any "
"other threads are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed.  If after the decrement the recursion level "
"is still nonzero, the lock remains locked and owned by the calling thread."
msgstr ""
"釋放鎖並減少遞迴等級。如果被減至零，則將鎖重置為未鎖定（不屬於任何執行緒），"
"並且如果任何其他執行緒被阻塞以等待鎖變成未鎖定狀態，則僅允許其中一個執行緒繼"
"續進行。如果遞減後遞迴等級仍然非零，則鎖會保持鎖定並由呼叫它的執行緒所擁有。"

#: ../../library/threading.rst:686
msgid ""
"Only call this method when the calling thread owns the lock. A :exc:"
"`RuntimeError` is raised if this method is called when the lock is not "
"acquired."
msgstr ""
"僅當呼叫的執行緒擁有鎖時才能呼叫此方法。如果在未取得鎖時呼叫此方法則會引發 :"
"exc:`RuntimeError`。"

#: ../../library/threading.rst:696
msgid "Condition Objects"
msgstr ""

#: ../../library/threading.rst:698
msgid ""
"A condition variable is always associated with some kind of lock; this can "
"be passed in or one will be created by default.  Passing one in is useful "
"when several condition variables must share the same lock.  The lock is part "
"of the condition object: you don't have to track it separately."
msgstr ""

#: ../../library/threading.rst:703
msgid ""
"A condition variable obeys the :ref:`context management protocol <with-"
"locks>`: using the ``with`` statement acquires the associated lock for the "
"duration of the enclosed block.  The :meth:`~Condition.acquire` and :meth:"
"`~Condition.release` methods also call the corresponding methods of the "
"associated lock."
msgstr ""

#: ../../library/threading.rst:709
msgid ""
"Other methods must be called with the associated lock held.  The :meth:"
"`~Condition.wait` method releases the lock, and then blocks until another "
"thread awakens it by calling :meth:`~Condition.notify` or :meth:`~Condition."
"notify_all`.  Once awakened, :meth:`~Condition.wait` re-acquires the lock "
"and returns.  It is also possible to specify a timeout."
msgstr ""

#: ../../library/threading.rst:715
msgid ""
"The :meth:`~Condition.notify` method wakes up one of the threads waiting for "
"the condition variable, if any are waiting.  The :meth:`~Condition."
"notify_all` method wakes up all threads waiting for the condition variable."
msgstr ""

#: ../../library/threading.rst:719
msgid ""
"Note: the :meth:`~Condition.notify` and :meth:`~Condition.notify_all` "
"methods don't release the lock; this means that the thread or threads "
"awakened will not return from their :meth:`~Condition.wait` call "
"immediately, but only when the thread that called :meth:`~Condition.notify` "
"or :meth:`~Condition.notify_all` finally relinquishes ownership of the lock."
msgstr ""

#: ../../library/threading.rst:725
msgid ""
"The typical programming style using condition variables uses the lock to "
"synchronize access to some shared state; threads that are interested in a "
"particular change of state call :meth:`~Condition.wait` repeatedly until "
"they see the desired state, while threads that modify the state call :meth:"
"`~Condition.notify` or :meth:`~Condition.notify_all` when they change the "
"state in such a way that it could possibly be a desired state for one of the "
"waiters.  For example, the following code is a generic producer-consumer "
"situation with unlimited buffer capacity::"
msgstr ""

#: ../../library/threading.rst:734
msgid ""
"# Consume one item\n"
"with cv:\n"
"    while not an_item_is_available():\n"
"        cv.wait()\n"
"    get_an_available_item()\n"
"\n"
"# Produce one item\n"
"with cv:\n"
"    make_an_item_available()\n"
"    cv.notify()"
msgstr ""

#: ../../library/threading.rst:745
msgid ""
"The ``while`` loop checking for the application's condition is necessary "
"because :meth:`~Condition.wait` can return after an arbitrary long time, and "
"the condition which prompted the :meth:`~Condition.notify` call may no "
"longer hold true.  This is inherent to multi-threaded programming.  The :"
"meth:`~Condition.wait_for` method can be used to automate the condition "
"checking, and eases the computation of timeouts::"
msgstr ""

#: ../../library/threading.rst:752
msgid ""
"# Consume an item\n"
"with cv:\n"
"    cv.wait_for(an_item_is_available)\n"
"    get_an_available_item()"
msgstr ""

#: ../../library/threading.rst:757
msgid ""
"To choose between :meth:`~Condition.notify` and :meth:`~Condition."
"notify_all`, consider whether one state change can be interesting for only "
"one or several waiting threads.  E.g. in a typical producer-consumer "
"situation, adding one item to the buffer only needs to wake up one consumer "
"thread."
msgstr ""

#: ../../library/threading.rst:765
msgid ""
"This class implements condition variable objects.  A condition variable "
"allows one or more threads to wait until they are notified by another thread."
msgstr ""

#: ../../library/threading.rst:768
msgid ""
"If the *lock* argument is given and not ``None``, it must be a :class:`Lock` "
"or :class:`RLock` object, and it is used as the underlying lock.  Otherwise, "
"a new :class:`RLock` object is created and used as the underlying lock."
msgstr ""

#: ../../library/threading.rst:772 ../../library/threading.rst:896
#: ../../library/threading.rst:942 ../../library/threading.rst:994
#: ../../library/threading.rst:1062
msgid "changed from a factory function to a class."
msgstr ""

#: ../../library/threading.rst:777
msgid ""
"Acquire the underlying lock. This method calls the corresponding method on "
"the underlying lock; the return value is whatever that method returns."
msgstr ""

#: ../../library/threading.rst:782
msgid ""
"Release the underlying lock. This method calls the corresponding method on "
"the underlying lock; there is no return value."
msgstr ""

#: ../../library/threading.rst:787
msgid ""
"Wait until notified or until a timeout occurs. If the calling thread has not "
"acquired the lock when this method is called, a :exc:`RuntimeError` is "
"raised."
msgstr ""

#: ../../library/threading.rst:791
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call for the same "
"condition variable in another thread, or until the optional timeout occurs.  "
"Once awakened or timed out, it re-acquires the lock and returns."
msgstr ""

#: ../../library/threading.rst:796
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""

#: ../../library/threading.rst:800
msgid ""
"When the underlying lock is an :class:`RLock`, it is not released using its :"
"meth:`release` method, since this may not actually unlock the lock when it "
"was acquired multiple times recursively.  Instead, an internal interface of "
"the :class:`RLock` class is used, which really unlocks it even when it has "
"been recursively acquired several times. Another internal interface is then "
"used to restore the recursion level when the lock is reacquired."
msgstr ""

#: ../../library/threading.rst:808
msgid ""
"The return value is ``True`` unless a given *timeout* expired, in which case "
"it is ``False``."
msgstr ""

#: ../../library/threading.rst:811 ../../library/threading.rst:1027
msgid "Previously, the method always returned ``None``."
msgstr ""

#: ../../library/threading.rst:816
msgid ""
"Wait until a condition evaluates to true.  *predicate* should be a callable "
"which result will be interpreted as a boolean value. A *timeout* may be "
"provided giving the maximum time to wait."
msgstr ""

#: ../../library/threading.rst:820
msgid ""
"This utility method may call :meth:`wait` repeatedly until the predicate is "
"satisfied, or until a timeout occurs. The return value is the last return "
"value of the predicate and will evaluate to ``False`` if the method timed "
"out."
msgstr ""

#: ../../library/threading.rst:825
msgid ""
"Ignoring the timeout feature, calling this method is roughly equivalent to "
"writing::"
msgstr ""

#: ../../library/threading.rst:828
msgid ""
"while not predicate():\n"
"    cv.wait()"
msgstr ""
"while not predicate():\n"
"    cv.wait()"

#: ../../library/threading.rst:831
msgid ""
"Therefore, the same rules apply as with :meth:`wait`: The lock must be held "
"when called and is re-acquired on return.  The predicate is evaluated with "
"the lock held."
msgstr ""

#: ../../library/threading.rst:839
msgid ""
"By default, wake up one thread waiting on this condition, if any.  If the "
"calling thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""

#: ../../library/threading.rst:843
msgid ""
"This method wakes up at most *n* of the threads waiting for the condition "
"variable; it is a no-op if no threads are waiting."
msgstr ""

#: ../../library/threading.rst:846
msgid ""
"The current implementation wakes up exactly *n* threads, if at least *n* "
"threads are waiting.  However, it's not safe to rely on this behavior. A "
"future, optimized implementation may occasionally wake up more than *n* "
"threads."
msgstr ""

#: ../../library/threading.rst:851
msgid ""
"Note: an awakened thread does not actually return from its :meth:`wait` call "
"until it can reacquire the lock.  Since :meth:`notify` does not release the "
"lock, its caller should."
msgstr ""

#: ../../library/threading.rst:857
msgid ""
"Wake up all threads waiting on this condition.  This method acts like :meth:"
"`notify`, but wakes up all waiting threads instead of one. If the calling "
"thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""

#: ../../library/threading.rst:862
msgid "The method ``notifyAll`` is a deprecated alias for this method."
msgstr ""

#: ../../library/threading.rst:868
msgid "Semaphore Objects"
msgstr ""

#: ../../library/threading.rst:870
msgid ""
"This is one of the oldest synchronization primitives in the history of "
"computer science, invented by the early Dutch computer scientist Edsger W. "
"Dijkstra (he used the names ``P()`` and ``V()`` instead of :meth:`~Semaphore."
"acquire` and :meth:`~Semaphore.release`)."
msgstr ""

#: ../../library/threading.rst:875
msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`~Semaphore.acquire` call and incremented by each :meth:`~Semaphore.release` "
"call.  The counter can never go below zero; when :meth:`~Semaphore.acquire` "
"finds that it is zero, it blocks, waiting until some other thread calls :"
"meth:`~Semaphore.release`."
msgstr ""

#: ../../library/threading.rst:881
msgid ""
"Semaphores also support the :ref:`context management protocol <with-locks>`."
msgstr ""

#: ../../library/threading.rst:886
msgid ""
"This class implements semaphore objects.  A semaphore manages an atomic "
"counter representing the number of :meth:`release` calls minus the number "
"of :meth:`acquire` calls, plus an initial value.  The :meth:`acquire` method "
"blocks if necessary until it can return without making the counter negative. "
"If not given, *value* defaults to 1."
msgstr ""

#: ../../library/threading.rst:892
msgid ""
"The optional argument gives the initial *value* for the internal counter; it "
"defaults to ``1``. If the *value* given is less than 0, :exc:`ValueError` is "
"raised."
msgstr ""

#: ../../library/threading.rst:901
msgid "Acquire a semaphore."
msgstr ""

#: ../../library/threading.rst:903
msgid "When invoked without arguments:"
msgstr ""

#: ../../library/threading.rst:905
msgid ""
"If the internal counter is larger than zero on entry, decrement it by one "
"and return ``True`` immediately."
msgstr ""

#: ../../library/threading.rst:907
msgid ""
"If the internal counter is zero on entry, block until awoken by a call to :"
"meth:`~Semaphore.release`.  Once awoken (and the counter is greater than 0), "
"decrement the counter by 1 and return ``True``.  Exactly one thread will be "
"awoken by each call to :meth:`~Semaphore.release`.  The order in which "
"threads are awoken should not be relied on."
msgstr ""

#: ../../library/threading.rst:913
msgid ""
"When invoked with *blocking* set to ``False``, do not block.  If a call "
"without an argument would block, return ``False`` immediately; otherwise, do "
"the same thing as when called without arguments, and return ``True``."
msgstr ""

#: ../../library/threading.rst:917
msgid ""
"When invoked with a *timeout* other than ``None``, it will block for at most "
"*timeout* seconds.  If acquire does not complete successfully in that "
"interval, return ``False``.  Return ``True`` otherwise."
msgstr ""

#: ../../library/threading.rst:926
msgid ""
"Release a semaphore, incrementing the internal counter by *n*.  When it was "
"zero on entry and other threads are waiting for it to become larger than "
"zero again, wake up *n* of those threads."
msgstr ""

#: ../../library/threading.rst:930
msgid "Added the *n* parameter to release multiple waiting threads at once."
msgstr ""

#: ../../library/threading.rst:936
msgid ""
"Class implementing bounded semaphore objects.  A bounded semaphore checks to "
"make sure its current value doesn't exceed its initial value.  If it does, :"
"exc:`ValueError` is raised. In most situations semaphores are used to guard "
"resources with limited capacity.  If the semaphore is released too many "
"times it's a sign of a bug.  If not given, *value* defaults to 1."
msgstr ""

#: ../../library/threading.rst:949
msgid ":class:`Semaphore` Example"
msgstr ":class:`Semaphore` 範例"

#: ../../library/threading.rst:951
msgid ""
"Semaphores are often used to guard resources with limited capacity, for "
"example, a database server.  In any situation where the size of the resource "
"is fixed, you should use a bounded semaphore.  Before spawning any worker "
"threads, your main thread would initialize the semaphore::"
msgstr ""

#: ../../library/threading.rst:956
msgid ""
"maxconnections = 5\n"
"# ...\n"
"pool_sema = BoundedSemaphore(value=maxconnections)"
msgstr ""
"maxconnections = 5\n"
"# ...\n"
"pool_sema = BoundedSemaphore(value=maxconnections)"

#: ../../library/threading.rst:960
msgid ""
"Once spawned, worker threads call the semaphore's acquire and release "
"methods when they need to connect to the server::"
msgstr ""

#: ../../library/threading.rst:963
msgid ""
"with pool_sema:\n"
"    conn = connectdb()\n"
"    try:\n"
"        # ... use connection ...\n"
"    finally:\n"
"        conn.close()"
msgstr ""
"with pool_sema:\n"
"    conn = connectdb()\n"
"    try:\n"
"        # ... 使用該連線 ...\n"
"    finally:\n"
"        conn.close()"

#: ../../library/threading.rst:970
msgid ""
"The use of a bounded semaphore reduces the chance that a programming error "
"which causes the semaphore to be released more than it's acquired will go "
"undetected."
msgstr ""

#: ../../library/threading.rst:977
msgid "Event Objects"
msgstr ""

#: ../../library/threading.rst:979
msgid ""
"This is one of the simplest mechanisms for communication between threads: "
"one thread signals an event and other threads wait for it."
msgstr ""

#: ../../library/threading.rst:982
msgid ""
"An event object manages an internal flag that can be set to true with the :"
"meth:`~Event.set` method and reset to false with the :meth:`~Event.clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is true."
msgstr ""

#: ../../library/threading.rst:989
msgid ""
"Class implementing event objects.  An event manages a flag that can be set "
"to true with the :meth:`~Event.set` method and reset to false with the :meth:"
"`clear` method.  The :meth:`wait` method blocks until the flag is true. The "
"flag is initially false."
msgstr ""

#: ../../library/threading.rst:999
msgid "Return ``True`` if and only if the internal flag is true."
msgstr ""

#: ../../library/threading.rst:1001
msgid "The method ``isSet`` is a deprecated alias for this method."
msgstr ""

#: ../../library/threading.rst:1005
msgid ""
"Set the internal flag to true. All threads waiting for it to become true are "
"awakened. Threads that call :meth:`wait` once the flag is true will not "
"block at all."
msgstr ""

#: ../../library/threading.rst:1011
msgid ""
"Reset the internal flag to false. Subsequently, threads calling :meth:`wait` "
"will block until :meth:`.set` is called to set the internal flag to true "
"again."
msgstr ""

#: ../../library/threading.rst:1017
msgid ""
"Block as long as the internal flag is false and the timeout, if given, has "
"not expired. The return value represents the reason that this blocking "
"method returned; ``True`` if returning because the internal flag is set to "
"true, or ``False`` if a timeout is given and the internal flag did not "
"become true within the given wait time."
msgstr ""

#: ../../library/threading.rst:1023
msgid ""
"When the timeout argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds, or "
"fractions thereof."
msgstr ""

#: ../../library/threading.rst:1034
msgid "Timer Objects"
msgstr ""

#: ../../library/threading.rst:1036
msgid ""
"This class represents an action that should be run only after a certain "
"amount of time has passed --- a timer.  :class:`Timer` is a subclass of :"
"class:`Thread` and as such also functions as an example of creating custom "
"threads."
msgstr ""

#: ../../library/threading.rst:1040
msgid ""
"Timers are started, as with threads, by calling their :meth:`Timer.start "
"<Thread.start>` method.  The timer can be stopped (before its action has "
"begun) by calling the :meth:`~Timer.cancel` method.  The interval the timer "
"will wait before executing its action may not be exactly the same as the "
"interval specified by the user."
msgstr ""

#: ../../library/threading.rst:1046
msgid "For example::"
msgstr "舉例來說： ::"

#: ../../library/threading.rst:1048
msgid ""
"def hello():\n"
"    print(\"hello, world\")\n"
"\n"
"t = Timer(30.0, hello)\n"
"t.start()  # after 30 seconds, \"hello, world\" will be printed"
msgstr ""
"def hello():\n"
"    print(\"hello, world\")\n"
"\n"
"t = Timer(30.0, hello)\n"
"t.start()  # 30 秒後會印出 \"hello, world\""

#: ../../library/threading.rst:1057
msgid ""
"Create a timer that will run *function* with arguments *args* and  keyword "
"arguments *kwargs*, after *interval* seconds have passed. If *args* is "
"``None`` (the default) then an empty list will be used. If *kwargs* is "
"``None`` (the default) then an empty dict will be used."
msgstr ""

#: ../../library/threading.rst:1067
msgid ""
"Stop the timer, and cancel the execution of the timer's action.  This will "
"only work if the timer is still in its waiting stage."
msgstr ""

#: ../../library/threading.rst:1072
msgid "Barrier Objects"
msgstr ""

#: ../../library/threading.rst:1076
msgid ""
"This class provides a simple synchronization primitive for use by a fixed "
"number of threads that need to wait for each other.  Each of the threads "
"tries to pass the barrier by calling the :meth:`~Barrier.wait` method and "
"will block until all of the threads have made their :meth:`~Barrier.wait` "
"calls. At this point, the threads are released simultaneously."
msgstr ""

#: ../../library/threading.rst:1082
msgid ""
"The barrier can be reused any number of times for the same number of threads."
msgstr ""

#: ../../library/threading.rst:1084
msgid ""
"As an example, here is a simple way to synchronize a client and server "
"thread::"
msgstr ""

#: ../../library/threading.rst:1086
msgid ""
"b = Barrier(2, timeout=5)\n"
"\n"
"def server():\n"
"    start_server()\n"
"    b.wait()\n"
"    while True:\n"
"        connection = accept_connection()\n"
"        process_server_connection(connection)\n"
"\n"
"def client():\n"
"    b.wait()\n"
"    while True:\n"
"        connection = make_connection()\n"
"        process_client_connection(connection)"
msgstr ""
"b = Barrier(2, timeout=5)\n"
"\n"
"def server():\n"
"    start_server()\n"
"    b.wait()\n"
"    while True:\n"
"        connection = accept_connection()\n"
"        process_server_connection(connection)\n"
"\n"
"def client():\n"
"    b.wait()\n"
"    while True:\n"
"        connection = make_connection()\n"
"        process_client_connection(connection)"

#: ../../library/threading.rst:1104
msgid ""
"Create a barrier object for *parties* number of threads.  An *action*, when "
"provided, is a callable to be called by one of the threads when they are "
"released.  *timeout* is the default timeout value if none is specified for "
"the :meth:`wait` method."
msgstr ""

#: ../../library/threading.rst:1111
msgid ""
"Pass the barrier.  When all the threads party to the barrier have called "
"this function, they are all released simultaneously.  If a *timeout* is "
"provided, it is used in preference to any that was supplied to the class "
"constructor."
msgstr ""

#: ../../library/threading.rst:1116
msgid ""
"The return value is an integer in the range 0 to *parties* -- 1, different "
"for each thread.  This can be used to select a thread to do some special "
"housekeeping, e.g.::"
msgstr ""

#: ../../library/threading.rst:1120
msgid ""
"i = barrier.wait()\n"
"if i == 0:\n"
"    # Only one thread needs to print this\n"
"    print(\"passed the barrier\")"
msgstr ""
"i = barrier.wait()\n"
"if i == 0:\n"
"    # 只會有一個執行緒會印出這個\n"
"    print(\"passed the barrier\")"

#: ../../library/threading.rst:1125
msgid ""
"If an *action* was provided to the constructor, one of the threads will have "
"called it prior to being released.  Should this call raise an error, the "
"barrier is put into the broken state."
msgstr ""

#: ../../library/threading.rst:1129
msgid "If the call times out, the barrier is put into the broken state."
msgstr ""

#: ../../library/threading.rst:1131
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier "
"is broken or reset while a thread is waiting."
msgstr ""

#: ../../library/threading.rst:1136
msgid ""
"Return the barrier to the default, empty state.  Any threads waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""

#: ../../library/threading.rst:1139
msgid ""
"Note that using this function may require some external synchronization if "
"there are other threads whose state is unknown.  If a barrier is broken it "
"may be better to just leave it and create a new one."
msgstr ""

#: ../../library/threading.rst:1145
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls "
"to :meth:`wait` to fail with the :class:`BrokenBarrierError`.  Use this for "
"example if one of the threads needs to abort, to avoid deadlocking the "
"application."
msgstr ""

#: ../../library/threading.rst:1150
msgid ""
"It may be preferable to simply create the barrier with a sensible *timeout* "
"value to automatically guard against one of the threads going awry."
msgstr ""

#: ../../library/threading.rst:1156
msgid "The number of threads required to pass the barrier."
msgstr ""

#: ../../library/threading.rst:1160
msgid "The number of threads currently waiting in the barrier."
msgstr ""

#: ../../library/threading.rst:1164
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr ""

#: ../../library/threading.rst:1169
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the :class:"
"`Barrier` object is reset or broken."
msgstr ""

#: ../../library/threading.rst:1176
msgid ""
"Using locks, conditions, and semaphores in the :keyword:`!with` statement"
msgstr ""

#: ../../library/threading.rst:1178
msgid ""
"All of the objects provided by this module that have ``acquire`` and "
"``release`` methods can be used as context managers for a :keyword:`with` "
"statement.  The ``acquire`` method will be called when the block is entered, "
"and ``release`` will be called when the block is exited.  Hence, the "
"following snippet::"
msgstr ""

#: ../../library/threading.rst:1184
msgid ""
"with some_lock:\n"
"    # do something..."
msgstr ""
"with some_lock:\n"
"    # 做某些事情..."

#: ../../library/threading.rst:1187
msgid "is equivalent to::"
msgstr ""

#: ../../library/threading.rst:1189
msgid ""
"some_lock.acquire()\n"
"try:\n"
"    # do something...\n"
"finally:\n"
"    some_lock.release()"
msgstr ""
"some_lock.acquire()\n"
"try:\n"
"    # 做某些事情...\n"
"finally:\n"
"    some_lock.release()"

#: ../../library/threading.rst:1195
msgid ""
"Currently, :class:`Lock`, :class:`RLock`, :class:`Condition`, :class:"
"`Semaphore`, and :class:`BoundedSemaphore` objects may be used as :keyword:"
"`with` statement context managers."
msgstr ""

#: ../../library/threading.rst:158 ../../library/threading.rst:176
msgid "trace function"
msgstr ""

#: ../../library/threading.rst:176
msgid "debugger"
msgstr "debugger（除錯器）"

#: ../../library/threading.rst:187 ../../library/threading.rst:205
msgid "profile function"
msgstr ""
