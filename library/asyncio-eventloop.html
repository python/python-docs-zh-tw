<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>事件迴圈 &#8212; Python 3.12.4 說明文件</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=41b4f12d" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=b20cc3f5" />
    
    <script src="../_static/documentation_options.js?v=6bff4b4f"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f1e884e3"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.12.4 說明文件 中搜尋"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="關於這些文件" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="copyright" title="版權" href="../copyright.html" />
    <link rel="next" title="Futures" href="asyncio-future.html" />
    <link rel="prev" title="例外" href="asyncio-exceptions.html" />
    
    <link rel="canonical" href="https://docs.python.org/3/library/asyncio-eventloop.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" />
                <input type="submit" value="前往"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目錄</a></h3>
    <ul>
<li><a class="reference internal" href="#">事件迴圈</a><ul>
<li><a class="reference internal" href="#event-loop-methods">事件迴圈方法</a><ul>
<li><a class="reference internal" href="#running-and-stopping-the-loop">啟動和停止迴圈</a></li>
<li><a class="reference internal" href="#scheduling-callbacks">排程回呼函式</a></li>
<li><a class="reference internal" href="#scheduling-delayed-callbacks">排程延遲的回呼函式</a></li>
<li><a class="reference internal" href="#creating-futures-and-tasks">建立 Futures 和 Tasks</a></li>
<li><a class="reference internal" href="#opening-network-connections">打開網路連線</a></li>
<li><a class="reference internal" href="#creating-network-servers">建立網路伺服器</a></li>
<li><a class="reference internal" href="#transferring-files">傳輸檔案</a></li>
<li><a class="reference internal" href="#tls-upgrade">TLS 升級</a></li>
<li><a class="reference internal" href="#watching-file-descriptors">監視檔案描述器</a></li>
<li><a class="reference internal" href="#working-with-socket-objects-directly">直接使用 socket 物件</a></li>
<li><a class="reference internal" href="#dns">DNS</a></li>
<li><a class="reference internal" href="#working-with-pipes">使用管道</a></li>
<li><a class="reference internal" href="#unix-signals">Unix 訊號</a></li>
<li><a class="reference internal" href="#executing-code-in-thread-or-process-pools">在執行緒池或行程池中執行程式碼</a></li>
<li><a class="reference internal" href="#error-handling-api">錯誤處理 API</a></li>
<li><a class="reference internal" href="#enabling-debug-mode">啟用除錯模式</a></li>
<li><a class="reference internal" href="#running-subprocesses">運行子行程</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callback-handles">回呼處理</a></li>
<li><a class="reference internal" href="#server-objects">Server 物件</a></li>
<li><a class="reference internal" href="#event-loop-implementations">事件迴圈實作</a></li>
<li><a class="reference internal" href="#examples">範例</a><ul>
<li><a class="reference internal" href="#hello-world-with-call-soon">使用 call_soon() 的 Hello World 範例</a></li>
<li><a class="reference internal" href="#display-the-current-date-with-call-later">使用 call_later() 顯示目前日期</a></li>
<li><a class="reference internal" href="#watch-a-file-descriptor-for-read-events">監聽檔案描述器以進行讀取事件</a></li>
<li><a class="reference internal" href="#set-signal-handlers-for-sigint-and-sigterm">設定 SIGINT 和 SIGTERM 的訊號處理程式</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="asyncio-exceptions.html"
                          title="上一章">例外</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="asyncio-future.html"
                          title="下一章">Futures</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/asyncio-eventloop.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="Futures"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="asyncio-exceptions.html" title="例外"
             accesskey="P">上一頁</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準函式庫 (Standard Library)</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >Networking and Interprocess Communication</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> --- 非同步 I/O</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">事件迴圈</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" id="search-box" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="event-loop">
<span id="asyncio-event-loop"></span><h1>事件迴圈<a class="headerlink" href="#event-loop" title="連結到這個標頭">¶</a></h1>
<p><strong>原始碼：</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.12/Lib/asyncio/events.py">Lib/asyncio/events.py</a>、<a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.12/Lib/asyncio/base_events.py">Lib/asyncio/base_events.py</a></p>
<hr class="docutils" />
<p class="rubric">前言</p>
<p>事件迴圈是每個 asyncio 應用程式的核心。事件迴圈執行非同步任務和回呼、執行網路 IO 操作並啟動子行程。</p>
<p>應用程式開發人員通常應使用高階的 asyncio 函式，例如 <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>，並且很少需要參照事件迴圈物件或呼叫其方法。本節主要針對那些需要更細粒度控制事件迴圈行為的低階程式碼、函式庫和框架的作者。</p>
<p class="rubric">取得事件迴圈</p>
<p>以下的低階函式可用於取得、設置或建立事件迴圈：</p>
<dl class="py function">
<dt class="sig sig-object py" id="asyncio.get_running_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">get_running_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_running_loop" title="連結到這個定義">¶</a></dt>
<dd><p>在當前作業系統執行緒中回傳正在運行的事件迴圈。</p>
<p>如果沒有運行的事件迴圈，則引發 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。</p>
<p>此函式只能從協程或回呼函式中呼叫。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.7 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.get_event_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">get_event_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_event_loop" title="連結到這個定義">¶</a></dt>
<dd><p>取得目前的事件迴圈。</p>
<p>當從協程或回呼函式呼叫此函式（例如，使用 call_soon 或類似的 API 於排程呼叫），此函式將永遠回傳正在運行的事件迴圈。</p>
<p>如果沒有設定正在運行的事件迴圈，該函式將回傳 <code class="docutils literal notranslate"><span class="pre">get_event_loop_policy().get_event_loop()</span></code> 呼叫的結果。</p>
<p>由於此函式具有相當複雜的行為（尤其是在使用自訂事件迴圈策略時），在協程和回呼函式中，建議使用 <a class="reference internal" href="#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a> 函式，而不是 <a class="reference internal" href="#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a>。</p>
<p>如上所述，可以考慮使用高階的 <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> 函式，而不是使用這些較低階的函式手動建立和關閉事件迴圈。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.12 版之後被棄用: </span>如果沒有當前事件迴圈，則會發出棄用警告。在未來的某個 Python 發行版中，這將變成錯誤。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.set_event_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">set_event_loop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loop</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.set_event_loop" title="連結到這個定義">¶</a></dt>
<dd><p>將 <em>loop</em> 設置為當前 OS 執行緒的當前事件迴圈。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.new_event_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">new_event_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.new_event_loop" title="連結到這個定義">¶</a></dt>
<dd><p>建立並回傳新的事件迴圈物件。</p>
</dd></dl>

<p>請注意 <a class="reference internal" href="#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a>、<a class="reference internal" href="#asyncio.set_event_loop" title="asyncio.set_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_event_loop()</span></code></a> 和 <a class="reference internal" href="#asyncio.new_event_loop" title="asyncio.new_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">new_event_loop()</span></code></a> 函式的行為可以透過<a class="reference internal" href="asyncio-policy.html#asyncio-policies"><span class="std std-ref">設定自訂事件迴圈策略</span></a>進行調整。</p>
<p class="rubric">目錄</p>
<p>本頁文件包含以下章節：</p>
<ul class="simple">
<li><p><a class="reference internal" href="#event-loop-methods">事件迴圈方法</a>章節是事件迴圈 API 們的參照文件；</p></li>
<li><p><a class="reference internal" href="#callback-handles">回呼處理</a>章節記錄了從排程方法（如 <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> 和 <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a>）回傳的 <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a> 和 <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimerHandle</span></code></a> 實例；</p></li>
<li><p><a class="reference internal" href="#server-objects">Server 物件</a>章節記錄了從事件迴圈方法（如 <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>）回傳的資料型別；</p></li>
<li><p><a class="reference internal" href="#event-loop-implementations">事件迴圈實作</a>章節記錄了 <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 和 <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> 類別；</p></li>
<li><p><a class="reference internal" href="#examples">範例</a>章節展示了如何使用一些事件迴圈 API。</p></li>
</ul>
<section id="event-loop-methods">
<span id="asyncio-event-loop-methods"></span><h2>事件迴圈方法<a class="headerlink" href="#event-loop-methods" title="連結到這個標頭">¶</a></h2>
<p>事件迴圈提供以下<strong>低階</strong> API：</p>
<nav class="contents local" id="id1">
<ul class="simple">
<li><p><a class="reference internal" href="#running-and-stopping-the-loop" id="id2">啟動和停止迴圈</a></p></li>
<li><p><a class="reference internal" href="#scheduling-callbacks" id="id3">排程回呼函式</a></p></li>
<li><p><a class="reference internal" href="#scheduling-delayed-callbacks" id="id4">排程延遲的回呼函式</a></p></li>
<li><p><a class="reference internal" href="#creating-futures-and-tasks" id="id5">建立 Futures 和 Tasks</a></p></li>
<li><p><a class="reference internal" href="#opening-network-connections" id="id6">打開網路連線</a></p></li>
<li><p><a class="reference internal" href="#creating-network-servers" id="id7">建立網路伺服器</a></p></li>
<li><p><a class="reference internal" href="#transferring-files" id="id8">傳輸檔案</a></p></li>
<li><p><a class="reference internal" href="#tls-upgrade" id="id9">TLS 升級</a></p></li>
<li><p><a class="reference internal" href="#watching-file-descriptors" id="id10">監視檔案描述器</a></p></li>
<li><p><a class="reference internal" href="#working-with-socket-objects-directly" id="id11">直接使用 socket 物件</a></p></li>
<li><p><a class="reference internal" href="#dns" id="id12">DNS</a></p></li>
<li><p><a class="reference internal" href="#working-with-pipes" id="id13">使用管道</a></p></li>
<li><p><a class="reference internal" href="#unix-signals" id="id14">Unix 訊號</a></p></li>
<li><p><a class="reference internal" href="#executing-code-in-thread-or-process-pools" id="id15">在執行緒池或行程池中執行程式碼</a></p></li>
<li><p><a class="reference internal" href="#error-handling-api" id="id16">錯誤處理 API</a></p></li>
<li><p><a class="reference internal" href="#enabling-debug-mode" id="id17">啟用除錯模式</a></p></li>
<li><p><a class="reference internal" href="#running-subprocesses" id="id18">運行子行程</a></p></li>
</ul>
</nav>
<section id="running-and-stopping-the-loop">
<h3><a class="toc-backref" href="#id2" role="doc-backlink">啟動和停止迴圈</a><a class="headerlink" href="#running-and-stopping-the-loop" title="連結到這個標頭">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.run_until_complete">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">run_until_complete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">future</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_until_complete" title="連結到這個定義">¶</a></dt>
<dd><p>運行直到 <em>future</em> （一個 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a> 實例）完成。</p>
<p>如果引數是<a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">協程物件</span></a>，則它將被隱式排程為 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a> 運行。</p>
<p>回傳 Future 的結果或引發其例外。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.run_forever">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">run_forever</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_forever" title="連結到這個定義">¶</a></dt>
<dd><p>運行事件迴圈直到 <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> 被呼叫。</p>
<p>如果在呼叫 <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> 之前呼叫 <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a>，則迴圈將使用超時為零的方式輪詢 I/O 選擇器，運行所有回應 I/O 事件（以及已經排程的事件）的回呼函數，然後退出。</p>
<p>如果在 <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> 運行時呼叫 <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a>，則迴圈將運行當前批次的回呼函式，然後退出。請注意，由回呼函式排程的新回呼在此情況下不會運行；而是在下次呼叫 <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> 或 <a class="reference internal" href="#asyncio.loop.run_until_complete" title="asyncio.loop.run_until_complete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_until_complete()</span></code></a> 時運行。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.stop">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.stop" title="連結到這個定義">¶</a></dt>
<dd><p>停止事件迴圈。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.is_running">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">is_running</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.is_running" title="連結到這個定義">¶</a></dt>
<dd><p>如果事件迴圈當前正在運行，則回傳 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.is_closed">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">is_closed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.is_closed" title="連結到這個定義">¶</a></dt>
<dd><p>如果事件迴圈已關閉，則回傳 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.close">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.close" title="連結到這個定義">¶</a></dt>
<dd><p>關閉事件迴圈。</p>
<p>不得於迴圈運行中呼叫此函式。將丟棄任何待處理的回呼。</p>
<p>此方法清除所有佇列並關閉執行器，但不等待執行器完成。</p>
<p>此方法是冪等且不可逆的。在事件迴圈關閉後不應呼叫其他方法。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.shutdown_asyncgens">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">shutdown_asyncgens</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.shutdown_asyncgens" title="連結到這個定義">¶</a></dt>
<dd><p>排程所有當前打開的<a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">非同步產生器</span></a>物件使用 <a class="reference internal" href="../reference/expressions.html#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> 呼叫來關閉。呼叫此方法後，如果疊代新的非同步產生器，事件迴圈將發出警告。應該使用此方法可靠地完成所有已排程的非同步產生器。</p>
<p>請注意，使用 <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> 時不需要呼叫此函式。</p>
<p>範例：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">shutdown_asyncgens</span><span class="p">())</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.6 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.shutdown_default_executor">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">shutdown_default_executor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.shutdown_default_executor" title="連結到這個定義">¶</a></dt>
<dd><p>排程預設執行器的關閉，並等待它加入 <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a> 中的所有執行緒。一旦呼叫了此方法，使用預設執行器與 <a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a> 將引發 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。</p>
<p><em>timeout</em> 參數指定執行器完成加入所需的時間（以 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 秒為單位）。預設情況下為 <code class="docutils literal notranslate"><span class="pre">None</span></code>，不會限制執行器所花費的時間。</p>
<p>如果達到 <em>timeout</em>，將發出 <a class="reference internal" href="exceptions.html#RuntimeWarning" title="RuntimeWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeWarning</span></code></a> 警告，預設執行器將立即終止，不等待其執行緒完成加入。</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>使用 <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> 時請勿呼叫此方法，因為後者會自動處理預設執行器的關閉。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.9 版被加入.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版的變更: </span>加入 <em>timeout</em> 參數。</p>
</div>
</dd></dl>

</section>
<section id="scheduling-callbacks">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">排程回呼函式</a><a class="headerlink" href="#scheduling-callbacks" title="連結到這個標頭">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_soon">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_soon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_soon" title="連結到這個定義">¶</a></dt>
<dd><p>在事件迴圈的下一次疊代中排程以 <em>args</em> 引數呼叫 <em>callback</em> <a class="reference internal" href="../glossary.html#term-callback"><span class="xref std std-term">callback</span></a>。</p>
<p>回傳 <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Handle</span></code></a> 的實例，稍後可以用於取消回呼函式。</p>
<p>回呼函式按照其註冊的順序呼叫。每個回呼函式將被呼叫恰好一次。</p>
<p>選用的僅限關鍵字引數 <em>context</em> 指定了要給 <em>callback</em> 執行的自定義 <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a>。當未提供 <em>context</em> 時，回呼函式使用當前情境。</p>
<p>與 <a class="reference internal" href="#asyncio.loop.call_soon_threadsafe" title="asyncio.loop.call_soon_threadsafe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon_threadsafe()</span></code></a> 不同，此方法不是執行緒安全的。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_soon_threadsafe">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_soon_threadsafe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_soon_threadsafe" title="連結到這個定義">¶</a></dt>
<dd><p>這是 <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon()</span></code></a> 的執行緒安全變體。當從另一個執行緒排程回呼函式時，<em>必須</em>使用此函式，因為 <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon()</span></code></a> 不是執行緒安全的。</p>
<p>如果在已關閉的迴圈上呼叫，則引發 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。在主應用程式關閉時，這可能發生在次要執行緒上。</p>
<p>請參閱文件的<a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">並行和多執行緒</span></a>部分。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span>新增了 <em>context</em> 僅限關鍵字參數。詳細資訊請參閱 <span class="target" id="index-12"></span><a class="pep reference external" href="https://peps.python.org/pep-0567/"><strong>PEP 567</strong></a>。</p>
</div>
</dd></dl>

<div class="admonition note" id="asyncio-pass-keywords">
<p class="admonition-title">備註</p>
<p>大多數 <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> 排程函式不允許傳遞關鍵字引數。要傳遞關鍵字引數，請使用 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># will schedule &quot;print(&quot;Hello&quot;, flush=True)&quot;</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span>
    <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
<p>通常使用 partial 物件比使用 lambda 更方便，因為 asyncio 可以在除錯和錯誤訊息中更好地呈現 partial 物件。</p>
</div>
</section>
<section id="scheduling-delayed-callbacks">
<span id="asyncio-delayed-calls"></span><h3><a class="toc-backref" href="#id4" role="doc-backlink">排程延遲的回呼函式</a><a class="headerlink" href="#scheduling-delayed-callbacks" title="連結到這個標頭">¶</a></h3>
<p>事件迴圈提供為回呼函式排程在將來某個時間點才呼叫的機制。事件迴圈使用了單調時鐘來追蹤時間。</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_later">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_later</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delay</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_later" title="連結到這個定義">¶</a></dt>
<dd><p>排程 <em>callback</em> 在給定的 <em>delay</em> 秒數後呼叫（可以是整數或浮點數）。</p>
<p>回傳 <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TimerHandle</span></code></a> 的實例，可用於取消回呼函式。</p>
<p><em>callback</em> 將只被呼叫恰好一次。如果有兩個回呼函式被排程在完全相同的時間，則其呼叫順序是不定的。</p>
<p>可選的位置引數 <em>args</em> 將在呼叫回呼函式時傳遞。如果要使用關鍵字引數呼叫回呼函數，請使用 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>。</p>
<p>可選的僅限關鍵字 <em>context</em> 引數允許為 <em>callback</em> 指定自定義的 <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> 以提供運行。當未提供 <em>context</em> 時，將使用當前情境。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span>新增了 <em>context</em> 僅限關鍵字參數。詳細資訊請參閱 <span class="target" id="index-13"></span><a class="pep reference external" href="https://peps.python.org/pep-0567/"><strong>PEP 567</strong></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版的變更: </span>在 Python 3.7 及更早版本中，使用預設事件迴圈實作時，<em>delay</em> 不能超過一天。這在 Python 3.8 中已經修復。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_at">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">when</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_at" title="連結到這個定義">¶</a></dt>
<dd><p>排程 <em>callback</em> 在給定的絕對時間戳 <em>when</em> （整數或浮點數）處呼叫，使用與 <a class="reference internal" href="#asyncio.loop.time" title="asyncio.loop.time"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.time()</span></code></a> 相同的時間參照。</p>
<p>此方法的行為與 <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_later()</span></code></a> 相同。</p>
<p>回傳 <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TimerHandle</span></code></a> 的實例，可用於取消回呼函式。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span>新增了 <em>context</em> 僅限關鍵字參數。詳細資訊請參閱 <span class="target" id="index-14"></span><a class="pep reference external" href="https://peps.python.org/pep-0567/"><strong>PEP 567</strong></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版的變更: </span>在 Python 3.7 及更早版本中，使用預設事件迴圈實作時，<em>when</em> 和當前時間之間的差值不能超過一天。這在 Python 3.8 中已經修復。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.time">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">time</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.time" title="連結到這個定義">¶</a></dt>
<dd><p>根據事件迴圈的內部單調時鐘，回傳當前時間，以 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 值表示。</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">備註</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版的變更: </span>在 Python 3.7 及更早版本中，超時（相對 <em>delay</em> 或絕對 <em>when</em>）不應超過一天。這在 Python 3.8 中已經修復。</p>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p>函式 <a class="reference internal" href="asyncio-task.html#asyncio.sleep" title="asyncio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.sleep()</span></code></a>。</p>
</div>
</section>
<section id="creating-futures-and-tasks">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">建立 Futures 和 Tasks</a><a class="headerlink" href="#creating-futures-and-tasks" title="連結到這個標頭">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_future">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_future</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_future" title="連結到這個定義">¶</a></dt>
<dd><p>建立附加到事件迴圈的 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 物件。</p>
<p>這是在 asyncio 中建立 Futures 的首選方式。這允許第三方事件迴圈提供 Future 物件的替代實作（具有更好的性能或儀器計測表現）。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.5.2 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_task">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_task</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coro</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_task" title="連結到這個定義">¶</a></dt>
<dd><p>排程執行<a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">協程</span></a> <em>coro</em>。回傳 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> 物件。</p>
<p>第三方事件迴圈可以使用其自己的 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> 子類別以實現互操作性（interoperability）。在這種情況下，結果類型是 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> 的子類別。</p>
<p>如果提供了 <em>name</em> 引數且不為 <code class="docutils literal notranslate"><span class="pre">None</span></code>，則將其設置為任務的名稱，使用 <a class="reference internal" href="asyncio-task.html#asyncio.Task.set_name" title="asyncio.Task.set_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.set_name()</span></code></a>。</p>
<p>可選的僅限關鍵字 <em>context</em> 引數允許為 <em>coro</em> 指定自定義的 <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> 以提供運行。當未提供 <em>context</em> 時，將建立當前情境的副本。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版的變更: </span>加入 <em>name</em> 參數。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>加入 <em>context</em> 參數。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_task_factory">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_task_factory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factory</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_task_factory" title="連結到這個定義">¶</a></dt>
<dd><p>設置將由 <a class="reference internal" href="#asyncio.loop.create_task" title="asyncio.loop.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_task()</span></code></a> 使用的任務工廠。</p>
<p>如果 <em>factory</em> 為 <code class="docutils literal notranslate"><span class="pre">None</span></code>，將設置預設的任務工廠。否則，<em>factory</em> 必須是一個具有匹配簽名 <code class="docutils literal notranslate"><span class="pre">(loop,</span> <span class="pre">coro,</span> <span class="pre">context=None)</span></code> 的 <em>callable</em>，其中 <em>loop</em> 是有效事件迴圈的參照，<em>coro</em> 是一個協程物件。該可呼叫物件必須回傳一個與 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 相容的物件。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.get_task_factory">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">get_task_factory</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_task_factory" title="連結到這個定義">¶</a></dt>
<dd><p>回傳任務工廠，如果使用預設任務工廠則回傳 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

</section>
<section id="opening-network-connections">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">打開網路連線</a><a class="headerlink" href="#opening-network-connections" title="連結到這個標頭">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_connection">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_connection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_addr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">happy_eyeballs_delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interleave</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_connection" title="連結到這個定義">¶</a></dt>
<dd><p>打開以 <em>host</em> 和 <em>port</em> 指定之給定地址的串流傳輸連線。</p>
<p>根據 <em>host*（或提供的 *family</em> 引數）的情況，socket 家族可以是 <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a> 或 <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>。</p>
<p>Socket 類型將為 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>。</p>
<p><em>protocol_factory</em> 必須是一個回傳 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio protocol</span></a> 實作的可呼叫函式。</p>
<p>此方法將嘗試在背景建立連線。成功時，它將回傳一對 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>。</p>
<p>底層操作的時間軸簡介如下：</p>
<ol class="arabic simple">
<li><p>建立連線並為其建立<a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">傳輸</span></a>。</p></li>
<li><p><em>protocol_factory</em> 在無引數的情況下被呼叫，並且預計回傳一個 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">協定</span></a> 實例。</p></li>
<li><p>通過呼叫其 <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseProtocol.connection_made" title="asyncio.BaseProtocol.connection_made"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connection_made()</span></code></a> 方法，將協議實例與傳輸連線在一起。</p></li>
<li><p>成功時回傳一個 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 元組。</p></li>
</ol>
<p>建立的傳輸是一個依賴實作的雙向串流。</p>
<p>其他引數：</p>
<ul>
<li><p>若有給定 <em>ssl</em> 且非 false，將建立 SSL/TLS 傳輸（預設建立普通 TCP 傳輸）。如果 <em>ssl</em> 為 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 物件，則使用該情境來建立傳輸；如果 <em>ssl</em> 為 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，則使用 <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> 回傳的預設情境。</p>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p><a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">SSL/TLS 安全考量</span></a></p>
</div>
</li>
<li><p><em>server_hostname</em> 設置或覆蓋目標伺服器憑證將匹配的主機名稱。僅在 <em>ssl</em> 不為 <code class="docutils literal notranslate"><span class="pre">None</span></code> 時傳遞。預設情況下，將使用 <em>host</em> 引數的值。如果 <em>host</em> 為空，則沒有預設值，必須傳遞 <em>server_hostname</em> 的值。若 <em>server_hostname</em> 為空字串，將停用主機名稱匹配（這是一個嚴重的安全風險，可能導致中間人攻擊）。</p></li>
<li><p><em>family</em>、<em>proto</em>、<em>flags</em> 是可選的位址家族、協議和旗標，用於傳遞至 getaddrinfo() 進行 <em>host</em> 解析。若有給定這些應該都是相應 <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模組常數的整數。</p></li>
<li><p>若有給定，<em>happy_eyeballs_delay</em> 會啟用此連線的 Happy Eyeballs。它應該是一個浮點數，表示等待連線嘗試完成的秒數，然後在並行啟動下一次嘗試。這是 <span class="target" id="index-15"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8305.html"><strong>RFC 8305</strong></a> 中定義的「連線嘗試延遲」。RFC 建議的合理預設值為 <code class="docutils literal notranslate"><span class="pre">0.25</span></code> 秒（250 毫秒）。</p></li>
<li><p><em>interleave</em> 控制主機名稱解析為多個 IP 位址時的地址重新排序。若為 <code class="docutils literal notranslate"><span class="pre">0</span></code> 或未指定，將不執行重排序，並按 <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> 回傳的順序嘗試位址。如果指定正整數，則按地址家族交錯排列，給定的整數直譯為 <span class="target" id="index-16"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8305.html"><strong>RFC 8305</strong></a> 中定義的「首個地址家族計數」。如果未指定 <em>happy_eyeballs_delay</em>，則預設值為 <code class="docutils literal notranslate"><span class="pre">0</span></code>，如果指定則為 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p></li>
<li><p>若有給定 <em>sock</em> 則其應為已存在且已連線的 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> 物件，可供傳輸使用。如果提供了 <em>sock</em>，則不應指定 <em>host</em>、<em>port</em>、<em>family</em>、<em>proto</em>、<em>flags</em>、<em>happy_eyeballs_delay</em>、<em>interleave</em> 和 <em>local_addr</em> 中的任何一項。</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>引數 <em>sock</em> 將 socket 所有權轉移給所建立的傳輸 socket，請呼叫傳輸的 <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 方法。</p>
</div>
</li>
<li><p>若有給定 <em>local_addr</em> 則其為一個 <code class="docutils literal notranslate"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> 元組，用於在本地綁定 socket。將使用 <code class="docutils literal notranslate"><span class="pre">getaddrinfo()</span></code> 查找 <em>local_host</em> 和 <em>local_port</em>，方式類似於 <em>host</em> 和 <em>port</em>。</p></li>
<li><p><em>ssl_handshake_timeout</em> （對於 TLS 連線）是等待 TLS 交握的時間，以秒為單位，在那之前若未完成則會中斷連線。如果為 <code class="docutils literal notranslate"><span class="pre">None</span></code> （預設值），則會等待 <code class="docutils literal notranslate"><span class="pre">60.0</span></code> 秒。</p></li>
<li><p><em>ssl_shutdown_timeout</em> 是等待 SSL 關閉完成以前中斷連線的時間，以秒為單位。如果為 <code class="docutils literal notranslate"><span class="pre">None</span></code> （預設值），則會等待 <code class="docutils literal notranslate"><span class="pre">30.0</span></code> 秒。</p></li>
<li><p><em>all_errors</em> 決定在無法建立連線時會引發哪些例外。預設情況下，只會引發單一 <code class="docutils literal notranslate"><span class="pre">Exception</span></code>：如果只有一個例外或所有錯誤訊息相同，則引發第一個例外，否則引發包含所有錯誤訊息的單一 <code class="docutils literal notranslate"><span class="pre">OSError</span></code>。當 <code class="docutils literal notranslate"><span class="pre">all_errors</span></code> 為 <code class="docutils literal notranslate"><span class="pre">True</span></code> 時，將引發包含所有例外的 <code class="docutils literal notranslate"><span class="pre">ExceptionGroup</span></code> （即使只有一個例外）。</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版的變更: </span>新增 <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> 中的 SSL/TLS 支援。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版的變更: </span>所有 TCP 連線都預設有 <a class="reference internal" href="socket.html#socket-unix-constants"><span class="std std-ref">socket.TCP_NODELAY</span></a> socket 選項。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span>增加 <em>ssl_handshake_timeout</em> 參數。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版的變更: </span>加入 <em>happy_eyeballs_delay</em> 和 <em>interleave</em> 參數。</p>
<p>Happy Eyeballs 演算法：雙協定堆疊主機 (Dual-Stack Hosts) 的成功。當伺服器的 IPv4 路徑和協議運作正常，但伺服器的 IPv6 路徑和協議不運作時，雙棧用戶端應用程式會比僅具 IPv4 的用戶端體驗到顯著的連線延遲。這是不希望的，因為這會導致雙棧用戶端的使用者體驗變差。本文件具體說明了減少此用戶可見延遲的演算法要求並提供了一種演算法。</p>
<p>更多資訊請見： <a class="reference external" href="https://datatracker.ietf.org/doc/html/rfc6555">https://datatracker.ietf.org/doc/html/rfc6555</a></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>增加 <em>ssl_shutdown_timeout</em> 參數。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版的變更: </span>已新增 <em>all_errors</em>。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p>函式 <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_connection()</span></code></a> 是高階的替代 API。它回傳一對 (<a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>) 可直接在 async/await 程式碼中使用。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_datagram_endpoint">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_datagram_endpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_addr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remote_addr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_broadcast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_datagram_endpoint" title="連結到這個定義">¶</a></dt>
<dd><p>建立一個資料報連線。</p>
<p>Socket 家族可以是 <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a>、<a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> 或 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>，視乎 <em>host</em>（或提供的 <em>family</em> 引數）而定。</p>
<p>Socket 類型將為 <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code></a>。</p>
<p><em>protocol_factory</em> 必須是可呼叫的函式，回傳 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocol</span></a> 實作。</p>
<p>成功時回傳 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 元組。</p>
<p>其他引數：</p>
<ul>
<li><p><em>local_addr</em>，如果提供，是一個 <code class="docutils literal notranslate"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> 元組，用於在本地綁定 socket。<em>local_host</em> 和 <em>local_port</em> 使用 <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> 來查找。</p></li>
<li><p><em>remote_addr</em>，如果提供，是一個 <code class="docutils literal notranslate"><span class="pre">(remote_host,</span> <span class="pre">remote_port)</span></code> 元組，用於將 socket 連線到遠端位址。 <em>remote_host</em> 和 <em>remote_port</em> 使用 <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> 來查找。</p></li>
<li><p><em>family</em>、<em>proto</em> 和 <em>flags</em> 是用於傳遞給 <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> 以解析 <em>host</em> 的可選地址家族、協定和旗標。如果提供，這些應該都是來自相應的 <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模組常數的整數。</p></li>
<li><p><em>reuse_port</em> 告訴核心允許將此端點綁定到與其他現有端點相同的埠，只要它們在建立時都設定了此旗標。此選項不受 Windows 和某些 Unix 系統支援。如果未定義 <code class="xref py py-const docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code> 常數，則不支援此功能。</p></li>
<li><p><em>allow_broadcast</em> 告訴核心允許此端點向廣播位址發送訊息。</p></li>
<li><p><em>sock</em> 可以選擇性地指定，以使用預先存在且已連線的 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> 物件供傳輸使用。如果指定，<em>local_addr</em> 和 <em>remote_addr</em> 應省略（必須是 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>）。</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>引數 <em>sock</em> 將 socket 所有權轉移給所建立的傳輸 socket，請呼叫傳輸的 <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 方法。</p>
</div>
</li>
</ul>
<p>請參閱 <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-client-protocol"><span class="std std-ref">UDP 回應用戶端協議</span></a> 和 <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-server-protocol"><span class="std std-ref">UDP 回應伺服器協議</span></a> 範例。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4.4 版的變更: </span>新增 <em>family</em>、<em>proto</em>、<em>flags</em>、<em>reuse_address</em>、<em>reuse_port</em>、<em>allow_broadcast</em> 和 <em>sock</em> 參數。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版的變更: </span>新增對於 Windows 的支援。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8.1 版的變更: </span>不再支援 <em>reuse_address</em> 參數，因為使用 <code class="xref py py-const docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> 對於 UDP 存有重大的安全疑慮。明確傳遞 <code class="docutils literal notranslate"><span class="pre">reuse_address=True</span></code> 將引發例外。</p>
<p>當具有不同 UID 的多個行程使用 <code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> 將 socket 分配給相同的 UDP socket 地址時，傳入的封包可能會在 socket 之間隨機分佈。</p>
<p>對於有支援的平台，<em>reuse_port</em> 可以用作類似功能的替代方案。使用 <em>reuse_port</em>，將改為使用 <code class="xref py py-const docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code>，該選項明確禁止具有不同 UID 的行程將 socket 分配給相同的 socket 地址。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>自 Python 3.9.0、3.8.1、3.7.6 和 3.6.10 起，已完全移除 <em>reuse_address</em> 參數。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_unix_connection">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_unix_connection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_unix_connection" title="連結到這個定義">¶</a></dt>
<dd><p>建立一個 Unix 連線。</p>
<p>Socket 家族將為 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>；socket 類型將為 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>。</p>
<p>成功時回傳 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 元組。</p>
<p><em>path</em> 是 Unix 域 socket 的名稱，除非指定 <em>sock</em> 參數，否則為必填。支援抽象 Unix sockets、<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>、<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 和 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> 路徑。</p>
<p>有關此方法的引數資訊，請參閱 <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> 方法的文件。</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">適用</span></a>：Unix。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span>新增 <em>ssl_handshake_timeout</em> 參數。<em>path</em> 參數現在可以是 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>增加 <em>ssl_shutdown_timeout</em> 參數。</p>
</div>
</dd></dl>

</section>
<section id="creating-network-servers">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">建立網路伺服器</a><a class="headerlink" href="#creating-network-servers" title="連結到這個標頭">¶</a></h3>
<dl class="py method" id="loop-create-server">
<dt class="sig sig-object py" id="asyncio.loop.create_server">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_server</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">socket.AF_UNSPEC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">socket.AI_PASSIVE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_address</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_serving</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_server" title="連結到這個定義">¶</a></dt>
<dd><p>建立一個 TCP 伺服器（socket 類型 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>），監聽 <em>host</em> 位址的 <em>port</em>。</p>
<p>回傳一個 <a class="reference internal" href="#asyncio.Server" title="asyncio.Server"><code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code></a> 物件。</p>
<p>引數：</p>
<ul>
<li><p><em>protocol_factory</em> 必須是可呼叫的函式，回傳 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocol</span></a> 實作。</p></li>
<li><p>可以將 <em>host</em> 參數設為幾種類型，以確定伺服器將監聽的位置：</p>
<ul class="simple">
<li><p>如果 <em>host</em> 是字串，則 TCP 伺服器綁定到由 <em>host</em> 指定的單個網路介面。</p></li>
<li><p>如果 <em>host</em> 是字串序列，則 TCP 伺服器綁定到序列指定的所有網路介面。</p></li>
<li><p>若 <em>host</em> 是空字串或 <code class="docutils literal notranslate"><span class="pre">None</span></code>，則所有介面都被假定並回傳多個 socket 的清單（可能一個用於 IPv4，另一個用於 IPv6）。</p></li>
</ul>
</li>
<li><p>可以設定 <em>port</em> 參數以指定伺服器應該監聽的埠。如果是 <code class="docutils literal notranslate"><span class="pre">0</span></code> 或 <code class="docutils literal notranslate"><span class="pre">None</span></code>（預設值），將隨機選擇一個未使用的埠（請注意，如果 <em>host</em> 解析為多個網路介面，將為每個介面隨機選擇不同的隨機埠）。</p></li>
<li><p><em>family</em> 可以設定為 <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.AF_INET</span></code></a> 或 <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> 以強制使用 IPv4 或 IPv6。如果未設定，<em>family</em> 將從主機名稱決定（預設為 <a class="reference internal" href="socket.html#socket.AF_UNSPEC" title="socket.AF_UNSPEC"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNSPEC</span></code></a>）。</p></li>
<li><p><em>flags</em> 是 <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> 的位元遮罩。</p></li>
<li><p>可以可選地指定 <em>sock</em> 以使用現有的 socket 物件。如果指定了，<em>host</em> 和 <em>port</em> 不能指定。</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p><em>sock</em> 引數將 socket 的所有權轉移給建立的伺服器。要關閉 socket，請呼叫伺服器的 <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 方法。</p>
</div>
</li>
<li><p><em>backlog</em> 是傳遞給 <a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a> 的最大佇列連線數（預設為 100）。</p></li>
<li><p><em>ssl</em> 可以設定為 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 實例以在接受的連線上啟用 TLS。</p></li>
<li><p><em>reuse_address</em> 告訴內核重用 <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code> 狀態下的本地 socket，而不等待其自然超時過期。如果未指定，在 Unix 上將自動設置為 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p></li>
<li><p><em>reuse_port</em> 告訴內核允許此端點繫結到與其他現有端點繫結的相同埠，只要它們在建立時都設置了此旗標。此選項在旗標 Windows 上不受支援。</p></li>
<li><p>（對於 TLS 伺服器）<em>ssl_handshake_timeout</em> 是在中斷連線之前等待 TLS 握手完成的時間（以秒為單位）。如果為 <code class="docutils literal notranslate"><span class="pre">None</span></code>（預設），則為 <code class="docutils literal notranslate"><span class="pre">60.0</span></code> 秒。</p></li>
<li><p><em>ssl_shutdown_timeout</em> 是等待 SSL 關閉完成以前中斷連線的時間，以秒為單位。如果為 <code class="docutils literal notranslate"><span class="pre">None</span></code> （預設值），則會等待 <code class="docutils literal notranslate"><span class="pre">30.0</span></code> 秒。</p></li>
<li><p>將 <em>start_serving</em> 設置為 <code class="docutils literal notranslate"><span class="pre">True</span></code>（預設）將使建立的伺服器立即開始接受連接。當設置為 <code class="docutils literal notranslate"><span class="pre">False</span></code> 時，用戶應該等待 <a class="reference internal" href="#asyncio.Server.start_serving" title="asyncio.Server.start_serving"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.start_serving()</span></code></a> 或 <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.serve_forever()</span></code></a> 來使伺服器開始接受連線。</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版的變更: </span>新增 <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> 中的 SSL/TLS 支援。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5.1 版的變更: </span><em>host</em> 參數可以是字串序列。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版的變更: </span>新增 <em>ssl_handshake_timeout</em> 與 <em>start_serving</em> 參數。所有 TCP 連線都預設有 <a class="reference internal" href="socket.html#socket-unix-constants"><span class="std std-ref">socket.TCP_NODELAY</span></a> socket 選項。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>增加 <em>ssl_shutdown_timeout</em> 參數。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p><a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a> 函式是一個更高階的替代 API，它回傳一對 <a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> 和 <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>，可以在 async/await 程式碼中使用。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_unix_server">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_unix_server</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_serving</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_unix_server" title="連結到這個定義">¶</a></dt>
<dd><p>類似 <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>，但適用於 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> socket 家族。</p>
<p><em>path</em> 是 Unix 域 socket 的名稱，除非提供了 <em>sock</em> 引數，否則必須給定。支援抽象 Unix sockets、<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>、<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 和 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> 路徑。</p>
<p>有關此方法的引數資訊，請參閱 <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> 方法的文件。</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">適用</span></a>：Unix。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span>新增 <em>ssl_handshake_timeout</em> 與 <em>start_serving</em> 參數。<em>path</em> 參數現在可為一個 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> 物件。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>增加 <em>ssl_shutdown_timeout</em> 參數。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.connect_accepted_socket">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">connect_accepted_socket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_accepted_socket" title="連結到這個定義">¶</a></dt>
<dd><p>將已接受的連線包裝成傳輸層/協議對。</p>
<p>此方法可以由在 asyncio 外接受連線但使用 asyncio 處理連線的伺服器使用。</p>
<p>參數：</p>
<ul>
<li><p><em>protocol_factory</em> 必須是可呼叫的函式，回傳 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocol</span></a> 實作。</p></li>
<li><p><em>sock</em> 是從 <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.accept</span></code></a> 回傳的預先存在的 socket 物件。</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>引數 <em>sock</em> 將 socket 所有權轉移給所建立的傳輸 socket，請呼叫傳輸的 <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 方法。</p>
</div>
</li>
<li><p><em>ssl</em> 可以設置為 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 以在已接受的連線上啟用 SSL。</p></li>
<li><p>（對於 SSL 連線）<em>ssl_handshake_timeout</em> 是在中斷連線之前等待 SSL 握手完成的時間（以秒為單位）。如果為 <code class="docutils literal notranslate"><span class="pre">None</span></code>（預設），則為 <code class="docutils literal notranslate"><span class="pre">60.0</span></code> 秒。</p></li>
<li><p><em>ssl_shutdown_timeout</em> 是等待 SSL 關閉完成以前中斷連線的時間，以秒為單位。如果為 <code class="docutils literal notranslate"><span class="pre">None</span></code> （預設值），則會等待 <code class="docutils literal notranslate"><span class="pre">30.0</span></code> 秒。</p></li>
</ul>
<p>回傳 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 對。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.5.3 版被加入.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span>增加 <em>ssl_handshake_timeout</em> 參數。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>增加 <em>ssl_shutdown_timeout</em> 參數。</p>
</div>
</dd></dl>

</section>
<section id="transferring-files">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">傳輸檔案</a><a class="headerlink" href="#transferring-files" title="連結到這個標頭">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sendfile">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sendfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transport</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fallback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sendfile" title="連結到這個定義">¶</a></dt>
<dd><p>通過 <em>transport</em> 發送 <em>file</em>。回傳發送的總位元組數。</p>
<p>如果可用，該方法使用高性能 <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">os.sendfile()</span></code></a>。</p>
<p><em>file</em> 必須是以二進位模式打開的常規檔案物件。</p>
<p><em>offset</em> 告訴從哪裡開始讀取檔案。如果指定了，<em>count</em> 是要傳輸的總位元組數，而不是發送檔案直到達到 EOF。即使此方法引發錯誤時，檔案位置也始終更新，可以使用 <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> 取得實際發送的位元組數。</p>
<p>將 <em>fallback</em> 設置為 <code class="docutils literal notranslate"><span class="pre">True</span></code> 會使 asyncio 在平台不支援 sendfile 系統呼叫時（例如 Windows 或 Unix 上的 SSL socket）手動讀取和發送檔案。</p>
<p>如果系統不支援 <em>sendfile</em> 系統呼叫且 <em>fallback</em> 為 <code class="docutils literal notranslate"><span class="pre">False</span></code>，則引發 <a class="reference internal" href="asyncio-exceptions.html#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SendfileNotAvailableError</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.7 版被加入.</span></p>
</div>
</dd></dl>

</section>
<section id="tls-upgrade">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">TLS 升級</a><a class="headerlink" href="#tls-upgrade" title="連結到這個標頭">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.start_tls">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">start_tls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transport</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sslcontext</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.start_tls" title="連結到這個定義">¶</a></dt>
<dd><p>將基於傳輸的現有連線升級到 TLS。</p>
<p>建立 TLS 編解碼器實例並在 <em>transport</em> 和 <em>protocol</em> 之間插入它。編解碼器既實作了對於 <em>transport</em> 的協議，也實作了對於 <em>protocol</em> 的傳輸。</p>
<p>回傳建立的雙介面實例。在 <em>await</em> 後，<em>protocol</em> 必須停止使用原始的 <em>transport</em>，僅與回傳的物件通信，因為編碼器快取了 <em>protocol</em> 端的資料，並且與 <em>transport</em> 間歇性地交換額外的 TLS session 封包。</p>
<p>在某些情況下（例如傳入的傳輸已經關閉），此函式可能回傳 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>參數：</p>
<ul class="simple">
<li><p><em>transport</em> 和 <em>protocol</em> 實例，由像 <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a> 和 <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_connection()</span></code></a> 等方法回傳。</p></li>
<li><p><em>sslcontext</em>：配置好的 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 實例。</p></li>
<li><p>當升級伺服器端連線時（像由 <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a> 建立的那樣）傳遞 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p></li>
<li><p><em>server_hostname</em>：設置或覆蓋將用於匹配目標伺服器憑證的主機名。</p></li>
<li><p><em>ssl_handshake_timeout</em> （對於 TLS 連線）是等待 TLS 交握的時間，以秒為單位，在那之前若未完成則會中斷連線。如果為 <code class="docutils literal notranslate"><span class="pre">None</span></code> （預設值），則會等待 <code class="docutils literal notranslate"><span class="pre">60.0</span></code> 秒。</p></li>
<li><p><em>ssl_shutdown_timeout</em> 是等待 SSL 關閉完成以前中斷連線的時間，以秒為單位。如果為 <code class="docutils literal notranslate"><span class="pre">None</span></code> （預設值），則會等待 <code class="docutils literal notranslate"><span class="pre">30.0</span></code> 秒。</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">在 3.7 版被加入.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>增加 <em>ssl_shutdown_timeout</em> 參數。</p>
</div>
</dd></dl>

</section>
<section id="watching-file-descriptors">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">監視檔案描述器</a><a class="headerlink" href="#watching-file-descriptors" title="連結到這個標頭">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.add_reader">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">add_reader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_reader" title="連結到這個定義">¶</a></dt>
<dd><p>開始監視 <em>fd</em> 檔案描述器的讀取可用性，一但 <em>fd</em> 可讀取，使用指定引數呼叫 <em>callback</em>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.remove_reader">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">remove_reader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_reader" title="連結到這個定義">¶</a></dt>
<dd><p>停止監視 <em>fd</em> 檔案描述器的讀取可用性。如果 <em>fd</em> 之前正在監視讀取，則回傳 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.add_writer">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">add_writer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_writer" title="連結到這個定義">¶</a></dt>
<dd><p>開始監視 <em>fd</em> 檔案描述器的寫入可用性，一旦 <em>fd</em> 可寫入，使用指定引數呼叫 <em>callback</em>。</p>
<p>使用 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> 向 <em>callback</em> <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">傳送關鍵字引數</span></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.remove_writer">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">remove_writer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_writer" title="連結到這個定義">¶</a></dt>
<dd><p>停止監視 <em>fd</em> 檔案描述器的寫入可用性。如果 <em>fd</em> 之前正在監視寫入，則回傳 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<p>另請參閱<a class="reference internal" href="asyncio-platforms.html#asyncio-platform-support"><span class="std std-ref">平台支援</span></a>部分以了解這些方法的一些限制。</p>
</section>
<section id="working-with-socket-objects-directly">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">直接使用 socket 物件</a><a class="headerlink" href="#working-with-socket-objects-directly" title="連結到這個標頭">¶</a></h3>
<p>一般情況下，使用基於傳輸的 API（如 <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> 和 <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>）的協議實作比直接使用 socket 的實作更快。然而在某些情況下性能不是關鍵，直接使用 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 物件更方便。</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recv">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbytes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recv" title="連結到這個定義">¶</a></dt>
<dd><p>從 <em>sock</em> 接收最多 <em>nbytes</em>。<a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv()</span></code></a> 的非同步版本。</p>
<p>將接收到的資料作為 bytes 物件回傳。</p>
<p><em>sock</em> 必須是非阻塞 socket。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span>儘管此方法一直記錄為協程方法，但 Python 3.7 之前的版本回傳 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>。自 Python 3.7 起，這是 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 方法。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recv_into">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recv_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recv_into" title="連結到這個定義">¶</a></dt>
<dd><p>從 <em>sock</em> 接收資料到 <em>buf</em> 緩衝區。仿照阻塞 <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv_into()</span></code></a> 方法。</p>
<p>回傳寫入緩衝區位元組的數目。</p>
<p><em>sock</em> 必須是非阻塞 socket。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.7 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recvfrom">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recvfrom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bufsize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recvfrom" title="連結到這個定義">¶</a></dt>
<dd><p>從 <em>sock</em> 接收最多 <em>bufsize</em> 大小的資料單元。<a class="reference internal" href="socket.html#socket.socket.recvfrom" title="socket.socket.recvfrom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recvfrom()</span></code></a> 的非同步版本。</p>
<p>回傳一個元組 (received data, remote address)。</p>
<p><em>sock</em> 必須是非阻塞 socket。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recvfrom_into">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recvfrom_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbytes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recvfrom_into" title="連結到這個定義">¶</a></dt>
<dd><p>從 <em>sock</em> 接收最多 <em>nbytes</em> 大小的資料單元到 <em>buf</em>。<a class="reference internal" href="socket.html#socket.socket.recvfrom_into" title="socket.socket.recvfrom_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recvfrom_into()</span></code></a> 的非同步版本。</p>
<p>回傳一個元組 (number of bytes received, remote address)。</p>
<p><em>sock</em> 必須是非阻塞 socket。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_sendall">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_sendall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendall" title="連結到這個定義">¶</a></dt>
<dd><p>將 <em>data</em> 發送到 <em>sock</em> socket。<a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendall()</span></code></a> 的非同步版本。</p>
<p>此方法將繼續發送到 socket，直到 <em>data</em> 中的所有資料都已發送或發生錯誤。成功時回傳 <code class="docutils literal notranslate"><span class="pre">None</span></code>。錯誤時引發例外。此外，沒有辦法確定接收端成功處理了多少資料（如果有的話）。</p>
<p><em>sock</em> 必須是非阻塞 socket。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span>儘管該方法一直被記錄為協程方法，但在 Python 3.7 之前它回傳 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>。從 Python 3.7 開始，這是一個 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 方法。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_sendto">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_sendto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendto" title="連結到這個定義">¶</a></dt>
<dd><p>從 <em>sock</em> 向 <em>address</em> 發送一個資料單元。<a class="reference internal" href="socket.html#socket.socket.sendto" title="socket.socket.sendto"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendto()</span></code></a> 的非同步版本。</p>
<p>回傳發送的位元組數。</p>
<p><em>sock</em> 必須是非阻塞 socket。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_connect">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_connect" title="連結到這個定義">¶</a></dt>
<dd><p>將 <em>sock</em> 連線到位於 <em>address</em> 的遠端 socket。</p>
<p><a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code></a> 的非同步版本。</p>
<p><em>sock</em> 必須是非阻塞 socket。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5.2 版的變更: </span>不再需要解析 <code class="docutils literal notranslate"><span class="pre">address</span></code>。<code class="docutils literal notranslate"><span class="pre">sock_connect</span></code> 將嘗試透過呼叫 <a class="reference internal" href="socket.html#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.inet_pton()</span></code></a> 檢查 <em>address</em> 是否已解析。如果沒有，將使用 <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.getaddrinfo()</span></code></a> 解析 <em>address</em>。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p><a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> 和 <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_accept">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_accept</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_accept" title="連結到這個定義">¶</a></dt>
<dd><p>接受一個連線。模擬阻塞的 <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.accept()</span></code></a> 方法。</p>
<p>Socket 必須繫結到一個地址並偵聽連線。回傳值是一個 <code class="docutils literal notranslate"><span class="pre">(conn,</span> <span class="pre">address)</span></code> 對，其中 <em>conn</em> 是一個 <em>新</em> socket 物件，可在連線上發送和接收資料，<em>address</em> 是連接另一端對應的 socket 地址。</p>
<p><em>sock</em> 必須是非阻塞 socket。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span>儘管該方法一直被記錄為協程方法，但在 Python 3.7 之前它回傳 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>。從 Python 3.7 開始，這是一個 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 方法。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p><a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> 和 <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_sendfile">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_sendfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fallback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendfile" title="連結到這個定義">¶</a></dt>
<dd><p>如果可行，使用高性能 <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a> 發送檔案。回傳發送的總位元組數。</p>
<p><a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendfile()</span></code></a> 的非同步版本。</p>
<p><em>sock</em> 必須是非阻塞的 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code></a> <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a>。</p>
<p><em>file</em> 必須是以二進位模式打開的常規檔案物件。</p>
<p><em>offset</em> 告訴從哪裡開始讀取檔案。如果指定了，<em>count</em> 是要傳輸的總位元組數，而不是發送檔案直到達到 EOF。即使此方法引發錯誤時，檔案位置也始終更新，可以使用 <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> 取得實際發送的位元組數。</p>
<p>當設置為 <code class="docutils literal notranslate"><span class="pre">True</span></code> 時，<em>fallback</em> 使 asyncio 在平台不支援 sendfile 系統呼叫時（例如 Windows 或 Unix 上的 SSL socket）手動讀取和發送檔案。</p>
<p>如果系統不支援 <em>sendfile</em> 系統呼叫且 <em>fallback</em> 為 <code class="docutils literal notranslate"><span class="pre">False</span></code>，引發 <a class="reference internal" href="asyncio-exceptions.html#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SendfileNotAvailableError</span></code></a>。</p>
<p><em>sock</em> 必須是非阻塞 socket。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.7 版被加入.</span></p>
</div>
</dd></dl>

</section>
<section id="dns">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">DNS</a><a class="headerlink" href="#dns" title="連結到這個標頭">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.getaddrinfo">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">getaddrinfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.getaddrinfo" title="連結到這個定義">¶</a></dt>
<dd><p><a class="reference internal" href="socket.html#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getaddrinfo()</span></code></a> 的非同步版本。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.getnameinfo">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">getnameinfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sockaddr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.getnameinfo" title="連結到這個定義">¶</a></dt>
<dd><p><a class="reference internal" href="socket.html#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getnameinfo()</span></code></a> 的非同步版本。</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">備註</p>
<p>Both <em>getaddrinfo</em> and <em>getnameinfo</em> internally utilize their synchronous
versions through the loop's default thread pool executor.
When this executor is saturated, these methods may experience delays,
which higher-level networking libraries may report as increased timeouts.
To mitigate this, consider using a custom executor for other user tasks,
or setting a default executor with a larger number of workers.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span><em>getaddrinfo</em> 和 <em>getnameinfo</em> 方法一直被記錄為回傳協程，但在 Python 3.7 之前它們實際上回傳 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 物件。從 Python 3.7 開始，兩個方法都是協程。</p>
</div>
</section>
<section id="working-with-pipes">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">使用管道</a><a class="headerlink" href="#working-with-pipes" title="連結到這個標頭">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.connect_read_pipe">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">connect_read_pipe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipe</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_read_pipe" title="連結到這個定義">¶</a></dt>
<dd><p>在事件迴圈中註冊 <em>pipe</em> 的讀取端。</p>
<p><em>protocol_factory</em> 必須是一個回傳 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio protocol</span></a> 實作的可呼叫函式。</p>
<p><em>pipe</em> 是 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">類檔案物件</span></a>。</p>
<p>回傳 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 對，其中 <em>transport</em> 支援 <a class="reference internal" href="asyncio-protocol.html#asyncio.ReadTransport" title="asyncio.ReadTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReadTransport</span></code></a> 介面，<em>protocol</em> 是由 <em>protocol_factory</em> 實例化的物件。</p>
<p>使用 <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 事件迴圈時，<em>pipe</em> 設置為非阻塞模式。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.connect_write_pipe">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">connect_write_pipe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipe</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_write_pipe" title="連結到這個定義">¶</a></dt>
<dd><p>在事件迴圈中註冊 <em>pipe</em> 的寫入端。</p>
<p><em>protocol_factory</em> 必須是一個回傳 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio protocol</span></a> 實作的可呼叫函式。</p>
<p><em>pipe</em> 是 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file-like object</span></a>。</p>
<p>回傳 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 對，其中 <em>transport</em> 支援 <a class="reference internal" href="asyncio-protocol.html#asyncio.WriteTransport" title="asyncio.WriteTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">WriteTransport</span></code></a> 介面，<em>protocol</em> 是由 <em>protocol_factory</em> 實例化的物件。</p>
<p>使用 <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 事件迴圈時，<em>pipe</em> 設置為非阻塞模式。</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">備註</p>
<p><a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 在 Windows 上不支援上述方法。對於 Windows 請使用 <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p><a class="reference internal" href="#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a> 和 <a class="reference internal" href="#asyncio.loop.subprocess_shell" title="asyncio.loop.subprocess_shell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_shell()</span></code></a> 方法。</p>
</div>
</section>
<section id="unix-signals">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Unix 訊號</a><a class="headerlink" href="#unix-signals" title="連結到這個標頭">¶</a></h3>
<dl class="py method" id="loop-add-signal-handler">
<dt class="sig sig-object py" id="asyncio.loop.add_signal_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">add_signal_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_signal_handler" title="連結到這個定義">¶</a></dt>
<dd><p>將 <em>callback</em> 設置為 <em>signum</em> 訊號的處理程式。</p>
<p>該回呼將由 <em>loop</em> 呼叫，與該事件迴圈的其他排隊回呼和可運行的協程一起。與使用 <a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a> 註冊的訊號處理程式不同，使用此函式註冊的回呼允許與事件迴圈進行互動。</p>
<p>如果訊號號無效或不可捕獲，引發 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。如果設定處理程序有問題，拋出 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。</p>
<p>使用 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> 向 <em>callback</em> <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">傳送關鍵字引數</span></a>。</p>
<p>像 <a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a> 一樣，此函式必須在主執行緒中呼叫。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.remove_signal_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">remove_signal_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_signal_handler" title="連結到這個定義">¶</a></dt>
<dd><p>移除 <em>sig</em> 訊號的處理程式。</p>
<p>如果訊號處理程式被移除，回傳 <code class="docutils literal notranslate"><span class="pre">True</span></code>；如果給定訊號沒有設置處理程式，回傳 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">適用</span></a>：Unix。</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p><a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 模組。</p>
</div>
</section>
<section id="executing-code-in-thread-or-process-pools">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">在執行緒池或行程池中執行程式碼</a><a class="headerlink" href="#executing-code-in-thread-or-process-pools" title="連結到這個標頭">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.run_in_executor">
<em class="property"><span class="pre">awaitable</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">run_in_executor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">executor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_in_executor" title="連結到這個定義">¶</a></dt>
<dd><p>安排在指定的執行器中呼叫 <em>func</em>。</p>
<p>The <em>executor</em> argument should be an <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Executor" title="concurrent.futures.Executor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.Executor</span></code></a>
instance. The default executor is used if <em>executor</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.
The default executor can be set by <a class="reference internal" href="#asyncio.loop.set_default_executor" title="asyncio.loop.set_default_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.set_default_executor()</span></code></a>,
otherwise, a <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.ThreadPoolExecutor</span></code></a> will be
lazy-initialized and used by <a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_in_executor()</span></code></a> if needed.</p>
<p>範例：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span>

<span class="k">def</span> <span class="nf">blocking_io</span><span class="p">():</span>
    <span class="c1"># File operations (such as logging) can block the</span>
    <span class="c1"># event loop: run them in a thread pool.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/dev/urandom&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cpu_bound</span><span class="p">():</span>
    <span class="c1"># CPU-bound operations will block the event loop:</span>
    <span class="c1"># in general it is preferable to run them in a</span>
    <span class="c1"># process pool.</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">7</span><span class="p">))</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="c1">## Options:</span>

    <span class="c1"># 1. Run in the default loop&#39;s executor:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span> <span class="n">blocking_io</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;default thread pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 2. Run in a custom thread pool:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">blocking_io</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom thread pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 3. Run in a custom process pool:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">cpu_bound</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom process pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p>請注意，由於 <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a>（由 <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" title="concurrent.futures.ProcessPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessPoolExecutor</span></code></a> 使用）的特殊性，選項 3 需要進入點保護（<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code>）。請參閱<a class="reference internal" href="multiprocessing.html#multiprocessing-safe-main-import"><span class="std std-ref">主模組的安全引入</span></a>。</p>
<p>此方法回傳 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 物件。</p>
<p>使用 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> 將來<a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">關鍵字引數傳遞</span></a>給 <em>func</em>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5.3 版的變更: </span><a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a> 不再配置它建立的執行緒池執行器的 <code class="docutils literal notranslate"><span class="pre">max_workers</span></code>，而是讓執行緒池執行器（<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>）設定預設值。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_default_executor">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_default_executor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">executor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_default_executor" title="連結到這個定義">¶</a></dt>
<dd><p>將 <em>executor</em> 設置為 <a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_in_executor()</span></code></a> 使用的預設執行器。<em>executor</em> 必須是 <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a> 的實例。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span><em>executor</em> 必須是 <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a> 的實例。</p>
</div>
</dd></dl>

</section>
<section id="error-handling-api">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">錯誤處理 API</a><a class="headerlink" href="#error-handling-api" title="連結到這個標頭">¶</a></h3>
<p>允許自定義事件迴圈中的例外處理方式。</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_exception_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handler</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_exception_handler" title="連結到這個定義">¶</a></dt>
<dd><p>將 <em>handler</em> 設定為新的事件迴圈例外處理程式。</p>
<p>如果 <em>handler</em> 是 <code class="docutils literal notranslate"><span class="pre">None</span></code>，則將設置預設例外處理程式。否則，<em>handler</em> 必須是一個可呼叫物件，簽名匹配 <code class="docutils literal notranslate"><span class="pre">(loop,</span> <span class="pre">context)</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">loop</span></code> 是參照活躍事件迴圈的，<code class="docutils literal notranslate"><span class="pre">context</span></code> 是包含例外詳細資訊的 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 物件（有關情境的詳細資訊，請參閱 <a class="reference internal" href="#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_exception_handler()</span></code></a> 文件）。</p>
<p>如果代表 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> 或 <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a> 呼叫處理程式，它將在該任務或回呼處理程式的 <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> 中運行。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版的變更: </span>處理程式可能在引發例外的任務或處理程式的 <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 中被呼叫。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.get_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">get_exception_handler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_exception_handler" title="連結到這個定義">¶</a></dt>
<dd><p>回傳當前的例外處理程式，如果未設置自定義例外處理程式，則回傳 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.5.2 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.default_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">default_exception_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.default_exception_handler" title="連結到這個定義">¶</a></dt>
<dd><p>預設例外處理程式。</p>
<p>當發生例外且未設置例外處理程式時呼叫此函式。自定義例外處理程式可以呼叫此函式以轉由預設處理程式處理。</p>
<p><em>context</em> 參數與 <a class="reference internal" href="#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_exception_handler()</span></code></a> 中的意思相同。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_exception_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_exception_handler" title="連結到這個定義">¶</a></dt>
<dd><p>呼叫當前事件迴圈例外處理程式。</p>
<p><em>context</em> 是一個包含以下鍵的 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 物件（未來的 Python 版本中可能會引入新的鍵）:</p>
<ul class="simple">
<li><p>'message'：錯誤訊息；</p></li>
<li><p>'exception'（可選）：例外物件；</p></li>
<li><p>'future'（可選）： <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 實例；</p></li>
<li><p>'task'（可選）： <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a> 實例；</p></li>
<li><p>'handle'（可選）： <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Handle</span></code></a> 實例；</p></li>
<li><p>'protocol'（可選）： <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">Protocol</span></a> 實例；</p></li>
<li><p>'transport'（可選）： <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">Transport</span></a> 實例；</p></li>
<li><p>'socket'（可選）： <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> 實例；</p></li>
<li><dl class="simple">
<dt>'asyncgen'(可選)： 非同步產生器引發</dt><dd><p>例外。</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>此方法不應在子類別事件迴圈中被覆寫。為了自定義例外處理，請使用 <a class="reference internal" href="#asyncio.loop.set_exception_handler" title="asyncio.loop.set_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_exception_handler()</span></code></a> 方法。</p>
</div>
</dd></dl>

</section>
<section id="enabling-debug-mode">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">啟用除錯模式</a><a class="headerlink" href="#enabling-debug-mode" title="連結到這個標頭">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.get_debug">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">get_debug</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_debug" title="連結到這個定義">¶</a></dt>
<dd><p>取得事件迴圈的除錯模式（<a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>）。</p>
<p>如果環境變數 <span class="target" id="index-17"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONASYNCIODEBUG"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONASYNCIODEBUG</span></code></a> 被設定為非空字串，則預設值為 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否則為 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_debug">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_debug</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enabled</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="functions.html#bool" title="bool"><span class="pre">bool</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_debug" title="連結到這個定義">¶</a></dt>
<dd><p>設定事件迴圈的除錯模式。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span>現在也可以使用新的 <a class="reference internal" href="devmode.html#devmode"><span class="std std-ref">Python 開發模式</span></a> 啟用除錯模式。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="asyncio.loop.slow_callback_duration">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">slow_callback_duration</span></span><a class="headerlink" href="#asyncio.loop.slow_callback_duration" title="連結到這個定義">¶</a></dt>
<dd><p>此屬性可用於設定被視為&quot;慢&quot;的最短執行時間（以秒為單位）。啟用偵錯模式後，&quot;慢&quot;回呼將被記錄。</p>
<p>預設值為 100 毫秒</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p><a class="reference internal" href="asyncio-dev.html#asyncio-debug-mode"><span class="std std-ref">asyncio 的除錯模式</span></a>。</p>
</div>
</section>
<section id="running-subprocesses">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">運行子行程</a><a class="headerlink" href="#running-subprocesses" title="連結到這個標頭">¶</a></h3>
<p>本小節描述的方法是低階的。在常規的 async/await 程式碼中，請考慮使用高階 <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_shell" title="asyncio.create_subprocess_shell"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_shell()</span></code></a> 和 <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_exec" title="asyncio.create_subprocess_exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_exec()</span></code></a> 輔助功能而不是。</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>在 Windows 上，預設事件迴圈 <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> 支援子行程，而 <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 不支援。詳細資訊請參見 <a class="reference internal" href="asyncio-platforms.html#asyncio-windows-subprocess"><span class="std std-ref">Windows 上對於子行程的支援</span></a>。</p>
</div>
<dl class="py method" id="loop-subprocess-exec">
<dt class="sig sig-object py" id="asyncio.loop.subprocess_exec">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">subprocess_exec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stderr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.subprocess_exec" title="連結到這個定義">¶</a></dt>
<dd><p>從 <em>args</em> 指定的一個或多個字串引數建立子行程。</p>
<p><em>args</em> 必須是由以下項表示的字串串列：</p>
<ul class="simple">
<li><p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>；</p></li>
<li><p>或 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>，編碼為 <a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">檔案系統編碼</span></a>。</p></li>
</ul>
<p>第一個字串指定程序可執行檔案，其餘字串指定引數。字串引數一起組成程序的 <code class="docutils literal notranslate"><span class="pre">argv</span></code>。</p>
<p>這與標準函式庫 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 類似，使用 <code class="docutils literal notranslate"><span class="pre">shell=False</span></code> 呼叫並將字串串列作為第一個引數傳遞；然而，<a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">Popen</span></code></a> 接受單個字串串列引數，<em>subprocess_exec</em> 接受多個字串引數。</p>
<p><em>protocol_factory</em> 必須是回傳 <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessProtocol</span></code></a> 子類別的可呼叫物件。</p>
<p>其他參數：</p>
<ul>
<li><p><em>stdin</em> 可以是以下任意一個：</p>
<ul class="simple">
<li><p>類檔案物件</p></li>
<li><p>現有的檔案描述器（正整數），例如用 <a class="reference internal" href="os.html#os.pipe" title="os.pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">os.pipe()</span></code></a> 建立的</p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> 常數（預設），它將建立一個新的管道並連線，</p></li>
<li><p>值 <code class="docutils literal notranslate"><span class="pre">None</span></code> 將使子行程從此行程繼承檔案描述器</p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> 常數，表示將使用特殊的 <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> 檔案</p></li>
</ul>
</li>
<li><p><em>stdout</em> 可以是以下任意一個：</p>
<ul class="simple">
<li><p>類檔案物件</p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> 常數（預設），它將建立一個新的管道並連線，</p></li>
<li><p>值 <code class="docutils literal notranslate"><span class="pre">None</span></code> 將使子行程從此行程繼承檔案描述器</p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> 常數，表示將使用特殊的 <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> 檔案</p></li>
</ul>
</li>
<li><p><em>stderr</em> 可以是以下任意一個：</p>
<ul class="simple">
<li><p>類檔案物件</p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> 常數（預設），它將建立一個新的管道並連線，</p></li>
<li><p>值 <code class="docutils literal notranslate"><span class="pre">None</span></code> 將使子行程從此行程繼承檔案描述器</p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> 常數，表示將使用特殊的 <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> 檔案</p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.STDOUT" title="subprocess.STDOUT"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.STDOUT</span></code></a> 常數，它將標準錯誤串流連線到行程的標準輸出串流</p></li>
</ul>
</li>
<li><p>所有其他關鍵字引數都會傳遞給 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 而不進行直譯，但 <em>bufsize</em>、<em>universal_newlines</em>、<em>shell</em>、<em>text</em>、<em>encoding</em> 和 <em>errors</em> 除外，這些不應該指定。</p>
<p><code class="docutils literal notranslate"><span class="pre">asyncio</span></code> 子行程 API 不支援將串流解碼為文本。可以使用 <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> 將從串流回傳的位元組轉換為文本。</p>
</li>
</ul>
<p>如果傳遞給 <em>stdin</em>、<em>stdout</em> 或 <em>stderr</em> 的類檔案物件表示管道，則該管道的另一端應該使用 <a class="reference internal" href="#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_write_pipe()</span></code></a> 或 <a class="reference internal" href="#asyncio.loop.connect_read_pipe" title="asyncio.loop.connect_read_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_read_pipe()</span></code></a> 註冊到事件迴圈中。</p>
<p>有關其他引數的文件，請參閱 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 類別的建構函式。</p>
<p>回傳 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 對，其中 <em>transport</em> 符合 <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessTransport</span></code></a> 基底類別，<em>protocol</em> 是由 <em>protocol_factory</em> 實例化的物件。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.subprocess_shell">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">subprocess_shell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmd</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stderr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.subprocess_shell" title="連結到這個定義">¶</a></dt>
<dd><p>使用平台的 “shell” 語法從 <em>cmd</em> 建立子行程，<em>cmd</em> 可以是 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或編碼為 <a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">檔案系統編碼</span></a> 的 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 字串。</p>
<p>這類似於標準函式庫中的 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 類別，使用 <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> 呼叫。</p>
<p><em>protocol_factory</em> 必須是回傳 <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessProtocol</span></code></a> 子類別的可呼叫物件。</p>
<p>有關其餘引數的更多詳細資訊，請參閱 <a class="reference internal" href="#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess_exec()</span></code></a>。</p>
<p>回傳一對 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>，其中 <em>transport</em> 符合 <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessTransport</span></code></a> 基底類別，而 <em>protocol</em> 是由 <em>protocol_factory</em> 實例化的物件。</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">備註</p>
<p>由應用程式負責確保適當引用所有空白和特殊字元，以避免 <a class="reference external" href="https://en.wikipedia.org/wiki/Shell_injection#Shell_injection">shell 注入</a>風險。可以使用 <a class="reference internal" href="shlex.html#shlex.quote" title="shlex.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">shlex.quote()</span></code></a> 函式來正確跳脫用於構建 shell 命令的字串中的空白和特殊字元。</p>
</div>
</section>
</section>
<section id="callback-handles">
<h2>回呼處理<a class="headerlink" href="#callback-handles" title="連結到這個標頭">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Handle">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Handle</span></span><a class="headerlink" href="#asyncio.Handle" title="連結到這個定義">¶</a></dt>
<dd><p>由 <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> 和 <a class="reference internal" href="#asyncio.loop.call_soon_threadsafe" title="asyncio.loop.call_soon_threadsafe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon_threadsafe()</span></code></a> 回傳的回呼包裝器。</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Handle.get_context">
<span class="sig-name descname"><span class="pre">get_context</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.get_context" title="連結到這個定義">¶</a></dt>
<dd><p>回傳與處理相關聯的 <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> 物件。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.12 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Handle.cancel">
<span class="sig-name descname"><span class="pre">cancel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancel" title="連結到這個定義">¶</a></dt>
<dd><p>取消回呼。如果回呼已被取消或執行，此方法將不起作用。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Handle.cancelled">
<span class="sig-name descname"><span class="pre">cancelled</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancelled" title="連結到這個定義">¶</a></dt>
<dd><p>如果回呼已被取消，回傳 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.7 版被加入.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncio.TimerHandle">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">TimerHandle</span></span><a class="headerlink" href="#asyncio.TimerHandle" title="連結到這個定義">¶</a></dt>
<dd><p>由 <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a> 和 <a class="reference internal" href="#asyncio.loop.call_at" title="asyncio.loop.call_at"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_at()</span></code></a> 回傳的回呼包裝器。</p>
<p>這個類別是 <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a> 的子類別。</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.TimerHandle.when">
<span class="sig-name descname"><span class="pre">when</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.TimerHandle.when" title="連結到這個定義">¶</a></dt>
<dd><p>回傳預定的回呼時間，以 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 秒為單位。</p>
<p>時間是一個絕對的時間戳，使用與 <a class="reference internal" href="#asyncio.loop.time" title="asyncio.loop.time"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.time()</span></code></a> 相同的時間參照。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.7 版被加入.</span></p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="server-objects">
<h2>Server 物件<a class="headerlink" href="#server-objects" title="連結到這個標頭">¶</a></h2>
<p>Server 物件是由 <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>、<a class="reference internal" href="#asyncio.loop.create_unix_server" title="asyncio.loop.create_unix_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_server()</span></code></a>、<a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a> 和 <a class="reference internal" href="asyncio-stream.html#asyncio.start_unix_server" title="asyncio.start_unix_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_unix_server()</span></code></a> 函式所建立。</p>
<p>請勿直接實例化 <a class="reference internal" href="#asyncio.Server" title="asyncio.Server"><code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code></a> 類別。</p>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Server">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Server</span></span><a class="headerlink" href="#asyncio.Server" title="連結到這個定義">¶</a></dt>
<dd><p><em>Server</em> 物件是非同步情境管理器。當在 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 陳述中使用時，可以保證在完成 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 陳述時，Server 物件將會關閉並停止接受新的連線：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">srv</span><span class="p">:</span>
    <span class="c1"># some code</span>

<span class="c1"># At this point, srv is closed and no longer accepts new connections.</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span>自 Python 3.7 起，Server 物件是非同步情境管理器。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>此類別在 Python 3.9.11、3.10.3 和 3.11 中以 <code class="docutils literal notranslate"><span class="pre">asyncio.Server</span></code> 的形式被公開。</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.close" title="連結到這個定義">¶</a></dt>
<dd><p>停止服務：關閉監聽的 sockets 並將 <a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sockets</span></code></a> 屬性設為 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>代表現有傳入用戶端連線的 sockets 仍然保持開啟。</p>
<p>伺服器以非同步方式關閉；使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_close()</span></code> 協程等待伺服器關閉（不再有活躍連線）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.get_loop">
<span class="sig-name descname"><span class="pre">get_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.get_loop" title="連結到這個定義">¶</a></dt>
<dd><p>回傳與伺服器物件關聯的事件迴圈。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.7 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.start_serving">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">start_serving</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.start_serving" title="連結到這個定義">¶</a></dt>
<dd><p>開始接受連線。</p>
<p>此方法是幂等的，因此可以在伺服器已經運行時呼叫。</p>
<p><em>start_serving</em> 僅限關鍵字參數只能在 <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> 和 <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.start_server()</span></code></a> 中使用，允許建立一個最初不接受連線的 Server 物件。在這種情況下，可以使用 <code class="docutils literal notranslate"><span class="pre">Server.start_serving()</span></code> 或 <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.serve_forever()</span></code></a> 來使 Server 開始接受連線。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.7 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.serve_forever">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">serve_forever</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.serve_forever" title="連結到這個定義">¶</a></dt>
<dd><p>開始接受連線，直到協程被取消。取消 <code class="docutils literal notranslate"><span class="pre">serve_forever</span></code> 任務會導致伺服器關閉。</p>
<p>如果伺服器已經接受連線，則可以呼叫此方法。每個 <em>Server</em> 物件只能存在一個 <code class="docutils literal notranslate"><span class="pre">serve_forever</span></code> 任務。</p>
<p>範例：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">client_connected</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
    <span class="c1"># Communicate with the client with</span>
    <span class="c1"># reader/writer streams.  For example:</span>
    <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">start_server</span><span class="p">(</span>
        <span class="n">client_connected</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">srv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.7 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.is_serving">
<span class="sig-name descname"><span class="pre">is_serving</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.is_serving" title="連結到這個定義">¶</a></dt>
<dd><p>如果伺服器正在接受新連線，則回傳 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.7 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.wait_closed">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">wait_closed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.wait_closed" title="連結到這個定義">¶</a></dt>
<dd><p>等待 <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 方法完成且所有活動連線都已結束。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="asyncio.Server.sockets">
<span class="sig-name descname"><span class="pre">sockets</span></span><a class="headerlink" href="#asyncio.Server.sockets" title="連結到這個定義">¶</a></dt>
<dd><p>伺服器正在監聽的類似 socket 的物件串列，<code class="docutils literal notranslate"><span class="pre">asyncio.trsock.TransportSocket</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span>在 Python 3.7 之前，<code class="docutils literal notranslate"><span class="pre">Server.sockets</span></code> 曾經直接回傳內部伺服器 sockets 的串列。在 3.7 中回傳了該串列的副本。</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="event-loop-implementations">
<span id="asyncio-event-loop-implementations"></span><span id="asyncio-event-loops"></span><h2>事件迴圈實作<a class="headerlink" href="#event-loop-implementations" title="連結到這個標頭">¶</a></h2>
<p>asyncio 內附兩個不同的事件迴圈實作：<a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 和 <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>。</p>
<p>預設情況下，asyncio 配置為在 Unix 上使用 <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a>，在 Windows 上使用 <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>。</p>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.SelectorEventLoop">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">SelectorEventLoop</span></span><a class="headerlink" href="#asyncio.SelectorEventLoop" title="連結到這個定義">¶</a></dt>
<dd><p>基於 <a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a> 模組的事件迴圈。</p>
<p>使用特定平台上最有效的 <em>selector</em>。也可以手動配置要使用的確切 selector 實作：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">selectors</span>

<span class="k">class</span> <span class="nc">MyPolicy</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">DefaultEventLoopPolicy</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">new_event_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">selector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">SelectSelector</span><span class="p">()</span>
      <span class="k">return</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">SelectorEventLoop</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop_policy</span><span class="p">(</span><span class="n">MyPolicy</span><span class="p">())</span>
</pre></div>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">適用</span></a>：Unix、Windows。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncio.ProactorEventLoop">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">ProactorEventLoop</span></span><a class="headerlink" href="#asyncio.ProactorEventLoop" title="連結到這個定義">¶</a></dt>
<dd><p>用於 Windows 的事件迴圈，使用&quot;I/O 完成埠&quot;(IOCP)。</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">適用</span></a>：Windows。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p><a class="reference external" href="https://docs.microsoft.com/zh-tw/windows/desktop/FileIO/i-o-completion-ports">I/O 完成埠（I/O Completion Ports）的 MSDN 文件</a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncio.AbstractEventLoop">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">AbstractEventLoop</span></span><a class="headerlink" href="#asyncio.AbstractEventLoop" title="連結到這個定義">¶</a></dt>
<dd><p>為符合 asyncio 標準的事件迴圈的抽象基礎類別。</p>
<p><a class="reference internal" href="#asyncio-event-loop-methods"><span class="std std-ref">事件迴圈方法</span></a> 部分列出了替代 <code class="docutils literal notranslate"><span class="pre">AbstractEventLoop</span></code> 實作應該定義的所有方法。</p>
</dd></dl>

</section>
<section id="examples">
<h2>範例<a class="headerlink" href="#examples" title="連結到這個標頭">¶</a></h2>
<p>請注意，本節中的所有範例都 <strong>故意</strong> 展示如何使用低階事件迴圈 API，如 <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_forever()</span></code></a> 和 <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a>。現代 asyncio 應用程式很少需要這種方式撰寫；請考慮使用高階的函式，如 <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>。</p>
<section id="hello-world-with-call-soon">
<span id="asyncio-example-lowlevel-helloworld"></span><h3>使用 call_soon() 的 Hello World 範例<a class="headerlink" href="#hello-world-with-call-soon" title="連結到這個標頭">¶</a></h3>
<p>使用 <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> 方法排程回呼的範例。回呼會顯示 <code class="docutils literal notranslate"><span class="pre">&quot;Hello</span> <span class="pre">World&quot;</span></code>，然後停止事件迴圈：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A callback to print &#39;Hello World&#39; and stop the event loop&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

<span class="c1"># Schedule a call to hello_world()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">hello_world</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Blocking call interrupted by loop.stop()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p>使用協程和 <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> 函式建立的類似 <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">Hello World</span></a> 範例。</p>
</div>
</section>
<section id="display-the-current-date-with-call-later">
<span id="asyncio-example-call-later"></span><h3>使用 call_later() 顯示目前日期<a class="headerlink" href="#display-the-current-date-with-call-later" title="連結到這個標頭">¶</a></h3>
<p>一個回呼的範例，每秒顯示目前日期。回呼使用 <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a> 方法在 5 秒後重新排程自己，然後停止事件迴圈：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">def</span> <span class="nf">display_date</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end_time</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

<span class="c1"># Schedule the first call to display_date()</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.0</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Blocking call interrupted by loop.stop()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p>使用協程和 <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> 函式建立的類似 <a class="reference internal" href="asyncio-task.html#asyncio-example-sleep"><span class="std std-ref">current date</span></a> 範例。</p>
</div>
</section>
<section id="watch-a-file-descriptor-for-read-events">
<span id="asyncio-example-watch-fd"></span><h3>監聽檔案描述器以進行讀取事件<a class="headerlink" href="#watch-a-file-descriptor-for-read-events" title="連結到這個標頭">¶</a></h3>
<p>使用 <a class="reference internal" href="#asyncio.loop.add_reader" title="asyncio.loop.add_reader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_reader()</span></code></a> 方法等待檔案描述器接收到某些資料，然後關閉事件迴圈：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socketpair</span>

<span class="c1"># Create a pair of connected file descriptors</span>
<span class="n">rsock</span><span class="p">,</span> <span class="n">wsock</span> <span class="o">=</span> <span class="n">socketpair</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">reader</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">rsock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Received:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>

    <span class="c1"># We are done: unregister the file descriptor</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">remove_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">)</span>

    <span class="c1"># Stop the event loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="c1"># Register the file descriptor for read event</span>
<span class="n">loop</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">,</span> <span class="n">reader</span><span class="p">)</span>

<span class="c1"># Simulate the reception of data from the network</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">wsock</span><span class="o">.</span><span class="n">send</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Run the event loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="c1"># We are done. Close sockets and the event loop.</span>
    <span class="n">rsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">wsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<ul class="simple">
<li><p>使用傳輸、協定和 <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> 方法的類似 <a class="reference internal" href="asyncio-protocol.html#asyncio-example-create-connection"><span class="std std-ref">範例</span></a>。</p></li>
<li><p>另一個使用高階 <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a> 函式和串流的類似 <a class="reference internal" href="asyncio-stream.html#asyncio-example-create-connection-streams"><span class="std std-ref">範例</span></a>。</p></li>
</ul>
</div>
</section>
<section id="set-signal-handlers-for-sigint-and-sigterm">
<span id="asyncio-example-unix-signals"></span><h3>設定 SIGINT 和 SIGTERM 的訊號處理程式<a class="headerlink" href="#set-signal-handlers-for-sigint-and-sigterm" title="連結到這個標頭">¶</a></h3>
<p>（此 <code class="docutils literal notranslate"><span class="pre">signals</span></code> 範例僅在 Unix 上運作。）</p>
<p>使用 <a class="reference internal" href="#asyncio.loop.add_signal_handler" title="asyncio.loop.add_signal_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_signal_handler()</span></code></a> 方法註冊訊號 <code class="xref py py-data docutils literal notranslate"><span class="pre">SIGINT</span></code> 和 <code class="xref py py-data docutils literal notranslate"><span class="pre">SIGTERM</span></code> 的處理程式：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">signal</span>

<span class="k">def</span> <span class="nf">ask_exit</span><span class="p">(</span><span class="n">signame</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;got signal </span><span class="si">%s</span><span class="s2">: exit&quot;</span> <span class="o">%</span> <span class="n">signame</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">signame</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;SIGINT&#39;</span><span class="p">,</span> <span class="s1">&#39;SIGTERM&#39;</span><span class="p">}:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signame</span><span class="p">),</span>
            <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">ask_exit</span><span class="p">,</span> <span class="n">signame</span><span class="p">,</span> <span class="n">loop</span><span class="p">))</span>

    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Event loop running for 1 hour, press Ctrl+C to interrupt.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pid </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span><span class="si">}</span><span class="s2">: send SIGINT or SIGTERM to exit.&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目錄</a></h3>
    <ul>
<li><a class="reference internal" href="#">事件迴圈</a><ul>
<li><a class="reference internal" href="#event-loop-methods">事件迴圈方法</a><ul>
<li><a class="reference internal" href="#running-and-stopping-the-loop">啟動和停止迴圈</a></li>
<li><a class="reference internal" href="#scheduling-callbacks">排程回呼函式</a></li>
<li><a class="reference internal" href="#scheduling-delayed-callbacks">排程延遲的回呼函式</a></li>
<li><a class="reference internal" href="#creating-futures-and-tasks">建立 Futures 和 Tasks</a></li>
<li><a class="reference internal" href="#opening-network-connections">打開網路連線</a></li>
<li><a class="reference internal" href="#creating-network-servers">建立網路伺服器</a></li>
<li><a class="reference internal" href="#transferring-files">傳輸檔案</a></li>
<li><a class="reference internal" href="#tls-upgrade">TLS 升級</a></li>
<li><a class="reference internal" href="#watching-file-descriptors">監視檔案描述器</a></li>
<li><a class="reference internal" href="#working-with-socket-objects-directly">直接使用 socket 物件</a></li>
<li><a class="reference internal" href="#dns">DNS</a></li>
<li><a class="reference internal" href="#working-with-pipes">使用管道</a></li>
<li><a class="reference internal" href="#unix-signals">Unix 訊號</a></li>
<li><a class="reference internal" href="#executing-code-in-thread-or-process-pools">在執行緒池或行程池中執行程式碼</a></li>
<li><a class="reference internal" href="#error-handling-api">錯誤處理 API</a></li>
<li><a class="reference internal" href="#enabling-debug-mode">啟用除錯模式</a></li>
<li><a class="reference internal" href="#running-subprocesses">運行子行程</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callback-handles">回呼處理</a></li>
<li><a class="reference internal" href="#server-objects">Server 物件</a></li>
<li><a class="reference internal" href="#event-loop-implementations">事件迴圈實作</a></li>
<li><a class="reference internal" href="#examples">範例</a><ul>
<li><a class="reference internal" href="#hello-world-with-call-soon">使用 call_soon() 的 Hello World 範例</a></li>
<li><a class="reference internal" href="#display-the-current-date-with-call-later">使用 call_later() 顯示目前日期</a></li>
<li><a class="reference internal" href="#watch-a-file-descriptor-for-read-events">監聽檔案描述器以進行讀取事件</a></li>
<li><a class="reference internal" href="#set-signal-handlers-for-sigint-and-sigterm">設定 SIGINT 和 SIGTERM 的訊號處理程式</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="asyncio-exceptions.html"
                          title="上一章">例外</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="asyncio-future.html"
                          title="下一章">Futures</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/asyncio-eventloop.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="收合側邊欄">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="Futures"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="asyncio-exceptions.html" title="例外"
             >上一頁</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準函式庫 (Standard Library)</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >Networking and Interprocess Communication</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> --- 非同步 I/O</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">事件迴圈</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" id="search-box" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    版權
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最後更新於 Jul 20, 2024 (06:27 UTC)。
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    使用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.6 建立。
    </div>

  </body>
</html>