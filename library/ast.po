# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-18 00:04+0000\n"
"PO-Revision-Date: 2018-05-23 14:38+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/ast.rst:2
msgid ":mod:`!ast` --- Abstract Syntax Trees"
msgstr ":mod:`!ast` --- 抽象語法樹 (Abstract Syntax Trees)"

#: ../../library/ast.rst:14
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**原始碼：**\\ :source:`Lib/ast.py`"

#: ../../library/ast.rst:18
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
":mod:`ast` 模組可以幫助 Python 應用程式處理 Python 抽象語法文法 (abstract "
"syntax grammar) 樹狀資料結構。抽象語法本身可能會隨著每個 Python 版本發布而改"
"變；此模組有助於以程式化的方式來得知當前文法的面貌。"

#: ../../library/ast.rst:23
msgid ""
"An abstract syntax tree can be generated by passing :data:`ast."
"PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using "
"the :func:`parse` helper provided in this module.  The result will be a tree "
"of objects whose classes all inherit from :class:`ast.AST`.  An abstract "
"syntax tree can be compiled into a Python code object using the built-in :"
"func:`compile` function."
msgstr ""
"要生成抽象語法樹，可以透過將 :data:`ast.PyCF_ONLY_AST` 作為旗標傳遞給內建函"
"式 :func:`compile` 或使用此模組所提供的 :func:`parse` 輔助函式。結果將會是一"
"個物件的樹，其類別都繼承自 :class:`ast.AST`。可以使用內建的 :func:`compile` "
"函式將抽象語法樹編譯成 Python 程式碼物件。"

#: ../../library/ast.rst:33
msgid "Abstract Grammar"
msgstr "抽象文法 (Abstract Grammar)"

#: ../../library/ast.rst:35
msgid "The abstract grammar is currently defined as follows:"
msgstr "抽象文法目前定義如下："

#: ../../library/ast.rst:37
msgid ""
"-- ASDL's 4 builtin types are:\n"
"-- identifier, int, string, constant\n"
"\n"
"module Python\n"
"{\n"
"    mod = Module(stmt* body, type_ignore* type_ignores)\n"
"        | Interactive(stmt* body)\n"
"        | Expression(expr body)\n"
"        | FunctionType(expr* argtypes, expr returns)\n"
"\n"
"    stmt = FunctionDef(identifier name, arguments args,\n"
"                       stmt* body, expr* decorator_list, expr? returns,\n"
"                       string? type_comment, type_param* type_params)\n"
"          | AsyncFunctionDef(identifier name, arguments args,\n"
"                             stmt* body, expr* decorator_list, expr? "
"returns,\n"
"                             string? type_comment, type_param* type_params)\n"
"\n"
"          | ClassDef(identifier name,\n"
"             expr* bases,\n"
"             keyword* keywords,\n"
"             stmt* body,\n"
"             expr* decorator_list,\n"
"             type_param* type_params)\n"
"          | Return(expr? value)\n"
"\n"
"          | Delete(expr* targets)\n"
"          | Assign(expr* targets, expr value, string? type_comment)\n"
"          | TypeAlias(expr name, type_param* type_params, expr value)\n"
"          | AugAssign(expr target, operator op, expr value)\n"
"          -- 'simple' indicates that we annotate simple name without parens\n"
"          | AnnAssign(expr target, expr annotation, expr? value, int "
"simple)\n"
"\n"
"          -- use 'orelse' because else is a keyword in target languages\n"
"          | For(expr target, expr iter, stmt* body, stmt* orelse, string? "
"type_comment)\n"
"          | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, "
"string? type_comment)\n"
"          | While(expr test, stmt* body, stmt* orelse)\n"
"          | If(expr test, stmt* body, stmt* orelse)\n"
"          | With(withitem* items, stmt* body, string? type_comment)\n"
"          | AsyncWith(withitem* items, stmt* body, string? type_comment)\n"
"\n"
"          | Match(expr subject, match_case* cases)\n"
"\n"
"          | Raise(expr? exc, expr? cause)\n"
"          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | Assert(expr test, expr? msg)\n"
"\n"
"          | Import(alias* names)\n"
"          | ImportFrom(identifier? module, alias* names, int? level)\n"
"\n"
"          | Global(identifier* names)\n"
"          | Nonlocal(identifier* names)\n"
"          | Expr(expr value)\n"
"          | Pass | Break | Continue\n"
"\n"
"          -- col_offset is the byte offset in the utf8 string the parser "
"uses\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"          -- BoolOp() can use left & right?\n"
"    expr = BoolOp(boolop op, expr* values)\n"
"         | NamedExpr(expr target, expr value)\n"
"         | BinOp(expr left, operator op, expr right)\n"
"         | UnaryOp(unaryop op, expr operand)\n"
"         | Lambda(arguments args, expr body)\n"
"         | IfExp(expr test, expr body, expr orelse)\n"
"         | Dict(expr* keys, expr* values)\n"
"         | Set(expr* elts)\n"
"         | ListComp(expr elt, comprehension* generators)\n"
"         | SetComp(expr elt, comprehension* generators)\n"
"         | DictComp(expr key, expr value, comprehension* generators)\n"
"         | GeneratorExp(expr elt, comprehension* generators)\n"
"         -- the grammar constrains where yield expressions can occur\n"
"         | Await(expr value)\n"
"         | Yield(expr? value)\n"
"         | YieldFrom(expr value)\n"
"         -- need sequences for compare to distinguish between\n"
"         -- x < 4 < 3 and (x < 4) < 3\n"
"         | Compare(expr left, cmpop* ops, expr* comparators)\n"
"         | Call(expr func, expr* args, keyword* keywords)\n"
"         | FormattedValue(expr value, int conversion, expr? format_spec)\n"
"         | JoinedStr(expr* values)\n"
"         | Constant(constant value, string? kind)\n"
"\n"
"         -- the following expression can appear in assignment context\n"
"         | Attribute(expr value, identifier attr, expr_context ctx)\n"
"         | Subscript(expr value, expr slice, expr_context ctx)\n"
"         | Starred(expr value, expr_context ctx)\n"
"         | Name(identifier id, expr_context ctx)\n"
"         | List(expr* elts, expr_context ctx)\n"
"         | Tuple(expr* elts, expr_context ctx)\n"
"\n"
"         -- can appear only in Subscript\n"
"         | Slice(expr? lower, expr? upper, expr? step)\n"
"\n"
"          -- col_offset is the byte offset in the utf8 string the parser "
"uses\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    expr_context = Load | Store | Del\n"
"\n"
"    boolop = And | Or\n"
"\n"
"    operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift\n"
"                 | RShift | BitOr | BitXor | BitAnd | FloorDiv\n"
"\n"
"    unaryop = Invert | Not | UAdd | USub\n"
"\n"
"    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn\n"
"\n"
"    comprehension = (expr target, expr iter, expr* ifs, int is_async)\n"
"\n"
"    excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)\n"
"                    attributes (int lineno, int col_offset, int? end_lineno, "
"int? end_col_offset)\n"
"\n"
"    arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,\n"
"                 expr* kw_defaults, arg? kwarg, expr* defaults)\n"
"\n"
"    arg = (identifier arg, expr? annotation, string? type_comment)\n"
"           attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- keyword arguments supplied to call (NULL identifier for **kwargs)\n"
"    keyword = (identifier? arg, expr value)\n"
"               attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- import name with optional 'as' alias.\n"
"    alias = (identifier name, identifier? asname)\n"
"             attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    withitem = (expr context_expr, expr? optional_vars)\n"
"\n"
"    match_case = (pattern pattern, expr? guard, stmt* body)\n"
"\n"
"    pattern = MatchValue(expr value)\n"
"            | MatchSingleton(constant value)\n"
"            | MatchSequence(pattern* patterns)\n"
"            | MatchMapping(expr* keys, pattern* patterns, identifier? rest)\n"
"            | MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, "
"pattern* kwd_patterns)\n"
"\n"
"            | MatchStar(identifier? name)\n"
"            -- The optional \"rest\" MatchMapping parameter handles "
"capturing extra mapping keys\n"
"\n"
"            | MatchAs(pattern? pattern, identifier? name)\n"
"            | MatchOr(pattern* patterns)\n"
"\n"
"             attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"\n"
"    type_ignore = TypeIgnore(int lineno, string tag)\n"
"\n"
"    type_param = TypeVar(identifier name, expr? bound)\n"
"               | ParamSpec(identifier name)\n"
"               | TypeVarTuple(identifier name)\n"
"               attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"}\n"
msgstr ""

#: ../../library/ast.rst:42
msgid "Node classes"
msgstr "節點 (Node) 類別"

#: ../../library/ast.rst:46
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:"
"`above <abstract-grammar>`.  They are defined in the :mod:`!_ast` C module "
"and re-exported in :mod:`ast`."
msgstr ""
"這是所有 AST 節點類別的基礎。實際的節點類別是衍生自 :file:`Parser/Python."
"asdl` 檔案，該檔案在\\ :ref:`上方 <abstract-grammar>` 重現。它們被定義於 :"
"mod:`!_ast` 的 C 模組中，並於 :mod:`ast` 中重新匯出。"

#: ../../library/ast.rst:51
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, "
"there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production "
"rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"抽象文法中為每個左側符號定義了一個類別（例如 :class:`ast.stmt` 或 :class:"
"`ast.expr`\\ ）。此外，也為每個右側的建構函式 (constructor) 定義了一個類別；"
"這些類別繼承自左側樹的類別。例如，:class:`ast.BinOp` 繼承自 :class:`ast."
"expr`。對於具有替代方案（即為「和 (sums)」）的生產規則，左側類別是抽象的：僅"
"有特定建構函式節點的實例會被建立。"

#: ../../library/ast.rst:64
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the names "
"of all child nodes."
msgstr "每個具體類別都有一個屬性 :attr:`_fields`，它會給出所有子節點的名稱。"

#: ../../library/ast.rst:67
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"具體類別的每個實例對於每個子節點都有一個屬性，其型別如文法中所定義。例如，:"
"class:`ast.BinOp` 實例具有型別為 :class:`ast.expr` 的屬性 :attr:`left`。"

#: ../../library/ast.rst:71
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more "
"values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"如果這些屬性在文法中被標記為可選（使用問號），則該值可能為 ``None``。如果屬性"
"可以有零個或多個值（用星號標記），則這些值將表示為 Python 串列。使用 :func:"
"`compile` 編譯 AST 時，所有可能的屬性都必須存在並且具有有效值。"

#: ../../library/ast.rst:82
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:"
"`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and :attr:`end_col_offset` "
"attributes.  The :attr:`lineno` and :attr:`end_lineno` are the first and "
"last line numbers of source text span (1-indexed so the first line is line "
"1) and the :attr:`col_offset` and :attr:`end_col_offset` are the "
"corresponding UTF-8 byte offsets of the first and last tokens that generated "
"the node. The UTF-8 offset is recorded because the parser uses UTF-8 "
"internally."
msgstr ""
":class:`ast.expr` 和 :class:`ast.stmt` 子類別的實例具有 :attr:`lineno`、:"
"attr:`col_offset`、:attr:`end_lineno` 和 :attr:`end_col_offset` 屬性。:attr:"
"`lineno` 和 :attr:`end_lineno` 是原始文本跨度 (source text span) 的第一個和最"
"後一個列號（1-indexed，因此第一列號是 1）以及 :attr:`col_offset` 和 :attr:"
"`end_col_offset` 是生成節點的第一個和最後一個標記對應的 UTF-8 位元組偏移量。"
"會記錄 UTF-8 偏移量是因為剖析器 (parser) 內部使用 UTF-8。"

#: ../../library/ast.rst:91
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for example "
"one can get the source segment of a one-line expression node using "
"``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"請注意，編譯器並不需要結束位置，因此其為可選的。結束偏移量在最後一個符號\\ *"
"之後*，例如可以使用 ``source_line[node.col_offset : node.end_col_offset]`` 來"
"獲取單列運算式節點 (expression node) 的原始片段。"

#: ../../library/ast.rst:96
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ":class:`ast.T` 類別的建構函式按以下方式剖析其引數："

#: ../../library/ast.rst:98
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""
"如果有位置引數，則必須與 :attr:`T._fields` 中的項目一樣多；它們將被賦値為這些"
"名稱的屬性。"

#: ../../library/ast.rst:100
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr "如果有關鍵字引數，它們會將相同名稱的屬性設定為給定值。"

#: ../../library/ast.rst:103
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr ""
"例如，要建立並填充 (populate) :class:`ast.UnaryOp` 節點，你可以使用： ::"

#: ../../library/ast.rst:106
msgid ""
"node = ast.UnaryOp()\n"
"node.op = ast.USub()\n"
"node.operand = ast.Constant()\n"
"node.operand.value = 5\n"
"node.operand.lineno = 0\n"
"node.operand.col_offset = 0\n"
"node.lineno = 0\n"
"node.col_offset = 0"
msgstr ""
"node = ast.UnaryOp()\n"
"node.op = ast.USub()\n"
"node.operand = ast.Constant()\n"
"node.operand.value = 5\n"
"node.operand.lineno = 0\n"
"node.operand.col_offset = 0\n"
"node.lineno = 0\n"
"node.col_offset = 0"

#: ../../library/ast.rst:115
msgid "or the more compact ::"
msgstr "或更簡潔的： ::"

#: ../../library/ast.rst:117
msgid ""
"node = ast.UnaryOp(ast.USub(), ast.Constant(5, lineno=0, col_offset=0),\n"
"                   lineno=0, col_offset=0)"
msgstr ""
"node = ast.UnaryOp(ast.USub(), ast.Constant(5, lineno=0, col_offset=0),\n"
"                   lineno=0, col_offset=0)"

#: ../../library/ast.rst:122
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr ":class:`ast.Constant` 類別現在用於所有常數。"

#: ../../library/ast.rst:126
msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr "以它們的值表示簡單索引，擴充切片 (slice) 則以元組 (tuple) 表示。"

#: ../../library/ast.rst:131
msgid ""
"Old classes :class:`!ast.Num`, :class:`!ast.Str`, :class:`!ast.Bytes`, :"
"class:`!ast.NameConstant` and :class:`!ast.Ellipsis` are still available, "
"but they will be removed in future Python releases.  In the meantime, "
"instantiating them will return an instance of a different class."
msgstr ""
"舊的類別 :class:`!ast.Num`、:class:`!ast.Str`、:class:`!ast.Bytes`、:class:`!"
"ast.NameConstant` 和 :class:`!ast.Ellipsis` 仍然可用，但它們將在未來的 "
"Python 釋出版本中移除。與此同時，實例化它們將回傳不同類別的實例。"

#: ../../library/ast.rst:138
msgid ""
"Old classes :class:`!ast.Index` and :class:`!ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different class."
msgstr ""
"舊的類別 :class:`!ast.Index` 和 :class:`!ast.ExtSlice` 仍然可用，但它們將在未"
"來的 Python 版本中刪除。同時，實例化它們會回傳不同類別的實例。"

#: ../../library/ast.rst:144
msgid ""
"The descriptions of the specific node classes displayed here were initially "
"adapted from the fantastic `Green Tree Snakes <https://greentreesnakes."
"readthedocs.io/en/latest/>`__ project and all its contributors."
msgstr ""
"這裡顯示的特定節點類別的描述最初是從出色的 `Green Tree Snakes <https://"
"greentreesnakes.readthedocs.io/en/latest/>`__ 專案和所有貢獻者那裡改編而來"
"的。"

#: ../../library/ast.rst:153
msgid "Root nodes"
msgstr "根節點"

#: ../../library/ast.rst:157
msgid ""
"A Python module, as with :ref:`file input <file-input>`. Node type generated "
"by :func:`ast.parse` in the default ``\"exec\"`` *mode*."
msgstr ""
"一個 Python 模組，與\\ :ref:`檔案輸入 <file-input>` 一樣。由 :func:`ast."
"parse` 在預設的 ``\"exec\"`` *mode* 下生成的節點型別。"

#: ../../library/ast.rst:160
msgid "*body* is a :class:`list` of the module's :ref:`ast-statements`."
msgstr "*body* 是模組的\\ :ref:`ast-statements` 的一個 :class:`list`。"

#: ../../library/ast.rst:162
msgid ""
"*type_ignores* is a :class:`list` of the module's type ignore comments; see :"
"func:`ast.parse` for more details."
msgstr ""
"*type_ignores* 是模組的忽略型別註解的 :class:`list`；有關更多詳細資訊，請參"
"閱 :func:`ast.parse`。"

#: ../../library/ast.rst:165
msgid ""
">>> print(ast.dump(ast.parse('x = 1'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1))],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('x = 1'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1))],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:179
msgid ""
"A single Python :ref:`expression input <expression-input>`. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"eval\"``."
msgstr ""
"單個 Python :ref:`運算式輸入 <expression-input>`。當 *mode* 是 ``\"eval\"`` "
"時節點型別由 :func:`ast.parse` 生成。"

#: ../../library/ast.rst:182
msgid ""
"*body* is a single node, one of the :ref:`expression types <ast-"
"expressions>`."
msgstr ""
"*body* 是單個節點，是\\ :ref:`運算式型別 <ast-expressions>`\\ 的其中之一。"

#: ../../library/ast.rst:185 ../../library/ast.rst:255
msgid ""
">>> print(ast.dump(ast.parse('123', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Constant(value=123))"
msgstr ""
">>> print(ast.dump(ast.parse('123', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Constant(value=123))"

#: ../../library/ast.rst:194
msgid ""
"A single :ref:`interactive input <interactive>`, like in :ref:`tut-interac`. "
"Node type generated by :func:`ast.parse` when *mode* is ``\"single\"``."
msgstr ""
"單個\\ :ref:`互動式輸入 <interactive>`，和\\ :ref:`tut-interac`\\ 中所述的相"
"似。當 *mode* 是 ``\"single\"`` 時節點型別由 :func:`ast.parse` 生成。"

#: ../../library/ast.rst:197
msgid "*body* is a :class:`list` of :ref:`statement nodes <ast-statements>`."
msgstr ""
"*body* 是\\ :ref:`陳述式節點 (statement nodes) <ast-statements>` 的 :class:"
"`list`。"

#: ../../library/ast.rst:199
msgid ""
">>> print(ast.dump(ast.parse('x = 1; y = 2', mode='single'), indent=4))\n"
"Interactive(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1)),\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='y', ctx=Store())],\n"
"            value=Constant(value=2))])"
msgstr ""
">>> print(ast.dump(ast.parse('x = 1; y = 2', mode='single'), indent=4))\n"
"Interactive(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1)),\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='y', ctx=Store())],\n"
"            value=Constant(value=2))])"

#: ../../library/ast.rst:216
msgid ""
"A representation of an old-style type comments for functions, as Python "
"versions prior to 3.5 didn't support :pep:`484` annotations. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"func_type\"``."
msgstr ""
"函式的舊式型別註解的表示法，因為 3.5 之前的 Python 版本不支援 :pep:`484` 註"
"釋。當 *mode* 是 ``\"func_type\"`` 時節點型別由 :func:`ast.parse` 生成。"

#: ../../library/ast.rst:220
msgid "Such type comments would look like this::"
msgstr "這種型別的註解看起來像這樣： ::"

#: ../../library/ast.rst:222
msgid ""
"def sum_two_number(a, b):\n"
"    # type: (int, int) -> int\n"
"    return a + b"
msgstr ""
"def sum_two_number(a, b):\n"
"    # type: (int, int) -> int\n"
"    return a + b"

#: ../../library/ast.rst:226
msgid ""
"*argtypes* is a :class:`list` of :ref:`expression nodes <ast-expressions>`."
msgstr ""
"*argtypes* 是\\ :ref:`運算式節點 <ast-expressions>`\\ 的 :class:`list`。"

#: ../../library/ast.rst:228
msgid "*returns* is a single :ref:`expression node <ast-expressions>`."
msgstr "*returns* 是單個\\ :ref:`運算式節點 <ast-expressions>`。"

#: ../../library/ast.rst:230
msgid ""
">>> print(ast.dump(ast.parse('(int, str) -> List[int]', mode='func_type'), "
"indent=4))\n"
"FunctionType(\n"
"    argtypes=[\n"
"        Name(id='int', ctx=Load()),\n"
"        Name(id='str', ctx=Load())],\n"
"    returns=Subscript(\n"
"        value=Name(id='List', ctx=Load()),\n"
"        slice=Name(id='int', ctx=Load()),\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('(int, str) -> List[int]', mode='func_type'), "
"indent=4))\n"
"FunctionType(\n"
"    argtypes=[\n"
"        Name(id='int', ctx=Load()),\n"
"        Name(id='str', ctx=Load())],\n"
"    returns=Subscript(\n"
"        value=Name(id='List', ctx=Load()),\n"
"        slice=Name(id='int', ctx=Load()),\n"
"        ctx=Load()))"

#: ../../library/ast.rst:246
msgid "Literals"
msgstr "文本 (Literals)"

#: ../../library/ast.rst:250
msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"simple types such as a number, string or ``None``, but also immutable "
"container types (tuples and frozensets) if all of their elements are "
"constant."
msgstr ""
"一個常數值。``Constant`` 文本的 ``value`` 屬性包含它所代表的 Python 物件。表"
"示的值可以是簡單型別，例如數字、字串或 ``None``，但如果它們的所有元素都是常"
"數，也可以是不可變的 (immutable) 容器型別（元組和凍結集合 (frozensets)）。"

#: ../../library/ast.rst:264
msgid ""
"Node representing a single formatting field in an f-string. If the string "
"contains a single formatting field and nothing else the node can be isolated "
"otherwise it appears in :class:`JoinedStr`."
msgstr ""
"表示 f 字串 (f-string) 中的單個格式化欄位的節點。如果字串包含單個格式欄位並且"
"沒有其他內容，則可以隔離 (isolate) 該節點，否則它將出現在 :class:`JoinedStr` "
"中。"

#: ../../library/ast.rst:268
msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr "``value`` 為任何運算式節點（例如文字、變數或函式呼叫）。"

#: ../../library/ast.rst:270
msgid "``conversion`` is an integer:"
msgstr "``conversion`` 是一個整數："

#: ../../library/ast.rst:272
msgid "-1: no formatting"
msgstr "-1: 無格式化"

#: ../../library/ast.rst:273
msgid "115: ``!s`` string formatting"
msgstr "115: ``!s`` 字串格式化"

#: ../../library/ast.rst:274
msgid "114: ``!r`` repr formatting"
msgstr "114:``!r`` 重複格式化化"

#: ../../library/ast.rst:275
msgid "97: ``!a`` ascii formatting"
msgstr "97: ``！a`` ascii 格式化"

#: ../../library/ast.rst:277
msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting of "
"the value, or ``None`` if no format was specified. Both ``conversion`` and "
"``format_spec`` can be set at the same time."
msgstr ""
"``format_spec`` 是一個 :class:`JoinedStr` 節點，表示值的格式，若未指定格式則"
"為 ``None``。``conversion`` 和 ``format_spec`` 可以同時設定。"

#: ../../library/ast.rst:284
msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and :class:"
"`Constant` nodes."
msgstr ""
"一個 f 字串，包含一系列 :class:`FormattedValue` 和 :class:`Constant` 節點。"

#: ../../library/ast.rst:287
msgid ""
">>> print(ast.dump(ast.parse('f\"sin({a}) is {sin(a):.3}\"', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=JoinedStr(\n"
"        values=[\n"
"            Constant(value='sin('),\n"
"            FormattedValue(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                conversion=-1),\n"
"            Constant(value=') is '),\n"
"            FormattedValue(\n"
"                value=Call(\n"
"                    func=Name(id='sin', ctx=Load()),\n"
"                    args=[\n"
"                        Name(id='a', ctx=Load())],\n"
"                    keywords=[]),\n"
"                conversion=-1,\n"
"                format_spec=JoinedStr(\n"
"                    values=[\n"
"                        Constant(value='.3')]))]))"
msgstr ""
">>> print(ast.dump(ast.parse('f\"sin({a}) is {sin(a):.3}\"', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=JoinedStr(\n"
"        values=[\n"
"            Constant(value='sin('),\n"
"            FormattedValue(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                conversion=-1),\n"
"            Constant(value=') is '),\n"
"            FormattedValue(\n"
"                value=Call(\n"
"                    func=Name(id='sin', ctx=Load()),\n"
"                    args=[\n"
"                        Name(id='a', ctx=Load())],\n"
"                    keywords=[]),\n"
"                conversion=-1,\n"
"                format_spec=JoinedStr(\n"
"                    values=[\n"
"                        Constant(value='.3')]))]))"

#: ../../library/ast.rst:313
msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the elements. "
"``ctx`` is :class:`Store` if the container is an assignment target (i.e. "
"``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""
"串列或元組。``elts`` 保存表示元素的節點串列。如果容器是賦值目標（即 ``(x,"
"y)=something`` ），則 ``ctx`` 是 :class:`Store`，否則是 :class:`Load`。"

#: ../../library/ast.rst:317
msgid ""
">>> print(ast.dump(ast.parse('[1, 2, 3]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=List(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)],\n"
"        ctx=Load()))\n"
">>> print(ast.dump(ast.parse('(1, 2, 3)', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Tuple(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)],\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('[1, 2, 3]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=List(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)],\n"
"        ctx=Load()))\n"
">>> print(ast.dump(ast.parse('(1, 2, 3)', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Tuple(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)],\n"
"        ctx=Load()))"

#: ../../library/ast.rst:339
msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr "一個集合。``elts`` 保存表示集合之元素的節點串列。"

#: ../../library/ast.rst:341
msgid ""
">>> print(ast.dump(ast.parse('{1, 2, 3}', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Set(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)]))"
msgstr ""
">>> print(ast.dump(ast.parse('{1, 2, 3}', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Set(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)]))"

#: ../../library/ast.rst:354
msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing the "
"keys and the values respectively, in matching order (what would be returned "
"when calling :code:`dictionary.keys()` and :code:`dictionary.values()`)."
msgstr ""
"一個字典 (dictionary)。``keys`` 和 ``values`` 分別按匹配順序保存表示鍵和值的"
"節點串列（為呼叫 :code:`dictionary.keys()` 和 :code:`dictionary.values()` 時"
"將回傳的內容）。"

#: ../../library/ast.rst:358
msgid ""
"When doing dictionary unpacking using dictionary literals the expression to "
"be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr ""
"當使用字典文本進行字典解包 (unpack) 時，要擴充的運算式位於 ``values`` 串列"
"中，在 ``keys`` 中的相應位置有一個 ``None``。"

#: ../../library/ast.rst:362
msgid ""
">>> print(ast.dump(ast.parse('{\"a\":1, **d}', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Dict(\n"
"        keys=[\n"
"            Constant(value='a'),\n"
"            None],\n"
"        values=[\n"
"            Constant(value=1),\n"
"            Name(id='d', ctx=Load())]))"
msgstr ""
">>> print(ast.dump(ast.parse('{\"a\":1, **d}', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Dict(\n"
"        keys=[\n"
"            Constant(value='a'),\n"
"            None],\n"
"        values=[\n"
"            Constant(value=1),\n"
"            Name(id='d', ctx=Load())]))"

#: ../../library/ast.rst:376
msgid "Variables"
msgstr "變數"

#: ../../library/ast.rst:380
msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of "
"the following types."
msgstr "一個變數名稱。``id`` 將名稱以字串形式保存，且 ``ctx`` 是以下型別之一。"

#: ../../library/ast.rst:388
msgid ""
"Variable references can be used to load the value of a variable, to assign a "
"new value to it, or to delete it. Variable references are given a context to "
"distinguish these cases."
msgstr ""
"變數參照可用於載入變數的值、為其分配新值或刪除它。變數參照被賦予情境 "
"(context) 來區分這些情況。"

#: ../../library/ast.rst:392
msgid ""
">>> print(ast.dump(ast.parse('a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Name(id='a', ctx=Load()))],\n"
"    type_ignores=[])\n"
"\n"
">>> print(ast.dump(ast.parse('a = 1'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='a', ctx=Store())],\n"
"            value=Constant(value=1))],\n"
"    type_ignores=[])\n"
"\n"
">>> print(ast.dump(ast.parse('del a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Delete(\n"
"            targets=[\n"
"                Name(id='a', ctx=Del())])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Name(id='a', ctx=Load()))],\n"
"    type_ignores=[])\n"
"\n"
">>> print(ast.dump(ast.parse('a = 1'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='a', ctx=Store())],\n"
"            value=Constant(value=1))],\n"
"    type_ignores=[])\n"
"\n"
">>> print(ast.dump(ast.parse('del a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Delete(\n"
"            targets=[\n"
"                Name(id='a', ctx=Del())])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:421
msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a :"
"class:`Name` node. This type must be used when building a :class:`Call` node "
"with ``*args``."
msgstr ""
"一個 ``*var`` 變數參照。``value`` 保存變數，通常是一個 :class:`Name` 節點。在"
"使用 ``*args`` 建置 :class:`Call` 節點時必須使用此型別。"

#: ../../library/ast.rst:425
msgid ""
">>> print(ast.dump(ast.parse('a, *b = it'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Name(id='a', ctx=Store()),\n"
"                        Starred(\n"
"                            value=Name(id='b', ctx=Store()),\n"
"                            ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='it', ctx=Load()))],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('a, *b = it'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Name(id='a', ctx=Store()),\n"
"                        Starred(\n"
"                            value=Name(id='b', ctx=Store()),\n"
"                            ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='it', ctx=Load()))],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:446
msgid "Expressions"
msgstr "運算式"

#: ../../library/ast.rst:450
msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a :class:"
"`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` or :class:"
"`YieldFrom` node."
msgstr ""
"當運算式（例如函式呼叫）本身作為陳述式出現且未使用或儲存其回傳值時，它將被包"
"裝在此容器中。``value`` 保存此區段 (section) 中的一個其他節點：:class:"
"`Constant`、:class:`Name`、:class:`Lambda`、:class:`Yield` 或 :class:"
"`YieldFrom`"

#: ../../library/ast.rst:455
msgid ""
">>> print(ast.dump(ast.parse('-a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=UnaryOp(\n"
"                op=USub(),\n"
"                operand=Name(id='a', ctx=Load())))],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('-a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=UnaryOp(\n"
"                op=USub(),\n"
"                operand=Name(id='a', ctx=Load())))],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:469
msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression "
"node."
msgstr ""
"一元運算 (unary operation)。``op`` 是運算子，``operand`` 是任何運算式節點。"

#: ../../library/ast.rst:478
msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, :class:`Invert` "
"is the ``~`` operator."
msgstr ""
"一元運算子標記。 :class:`Not` 是 ``not`` 關鍵字、:class:`Invert` 是 ``~`` 運"
"算子。"

#: ../../library/ast.rst:481
msgid ""
">>> print(ast.dump(ast.parse('not x', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=UnaryOp(\n"
"        op=Not(),\n"
"        operand=Name(id='x', ctx=Load())))"
msgstr ""
">>> print(ast.dump(ast.parse('not x', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=UnaryOp(\n"
"        op=Not(),\n"
"        operand=Name(id='x', ctx=Load())))"

#: ../../library/ast.rst:492
msgid ""
"A binary operation (like addition or division). ``op`` is the operator, and "
"``left`` and ``right`` are any expression nodes."
msgstr ""
"二元運算 (binary operation)（如加法或除法）。 ``op`` 是運算子、``left`` 和 "
"``right`` 是任意運算式節點。"

#: ../../library/ast.rst:495
msgid ""
">>> print(ast.dump(ast.parse('x + y', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=BinOp(\n"
"        left=Name(id='x', ctx=Load()),\n"
"        op=Add(),\n"
"        right=Name(id='y', ctx=Load())))"
msgstr ""
">>> print(ast.dump(ast.parse('x + y', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=BinOp(\n"
"        left=Name(id='x', ctx=Load()),\n"
"        op=Add(),\n"
"        right=Name(id='y', ctx=Load())))"

#: ../../library/ast.rst:519
msgid "Binary operator tokens."
msgstr "二元運算子 token。"

#: ../../library/ast.rst:524
msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or :class:`And`. "
"``values`` are the values involved. Consecutive operations with the same "
"operator, such as ``a or b or c``, are collapsed into one node with several "
"values."
msgstr ""
"布林運算 'or' 或 'and'。``op`` 是 :class:`Or` 或 :class:`And`。``values`` 是"
"有所涉及的值。使用同一運算子的連續操作（例如 ``a or b or c``\\ ）會被折疊為具"
"有多個值的一個節點。"

#: ../../library/ast.rst:529
msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr "這不包括 ``not``，它是一個 :class:`UnaryOp`。"

#: ../../library/ast.rst:531
msgid ""
">>> print(ast.dump(ast.parse('x or y', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=BoolOp(\n"
"        op=Or(),\n"
"        values=[\n"
"            Name(id='x', ctx=Load()),\n"
"            Name(id='y', ctx=Load())]))"
msgstr ""
">>> print(ast.dump(ast.parse('x or y', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=BoolOp(\n"
"        op=Or(),\n"
"        values=[\n"
"            Name(id='x', ctx=Load()),\n"
"            Name(id='y', ctx=Load())]))"

#: ../../library/ast.rst:545
msgid "Boolean operator tokens."
msgstr "布林運算子 token。"

#: ../../library/ast.rst:550
msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list of "
"values after the first element in the comparison."
msgstr ""
"兩個或多個值的比較。``left`` 是比較中的第一個值、``ops`` 是運算子串列、"
"``comparators`` 是要比較的第一個元素之後值的串列。"

#: ../../library/ast.rst:554
msgid ""
">>> print(ast.dump(ast.parse('1 <= a < 10', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Compare(\n"
"        left=Constant(value=1),\n"
"        ops=[\n"
"            LtE(),\n"
"            Lt()],\n"
"        comparators=[\n"
"            Name(id='a', ctx=Load()),\n"
"            Constant(value=10)]))"
msgstr ""
">>> print(ast.dump(ast.parse('1 <= a < 10', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Compare(\n"
"        left=Constant(value=1),\n"
"        ops=[\n"
"            LtE(),\n"
"            Lt()],\n"
"        comparators=[\n"
"            Name(id='a', ctx=Load()),\n"
"            Constant(value=10)]))"

#: ../../library/ast.rst:579
msgid "Comparison operator tokens."
msgstr "比較運算子 token。"

#: ../../library/ast.rst:584
msgid ""
"A function call. ``func`` is the function, which will often be a :class:"
"`Name` or :class:`Attribute` object. Of the arguments:"
msgstr ""
"一個函式呼叫。``func`` 是該函式，通常是一個 :class:`Name` 或 :class:"
"`Attribute` 物件。而在引數中："

#: ../../library/ast.rst:587
msgid "``args`` holds a list of the arguments passed by position."
msgstr "``args`` 保存按位置傳遞的引數串列。"

#: ../../library/ast.rst:588
msgid ""
"``keywords`` holds a list of :class:`.keyword` objects representing "
"arguments passed by keyword."
msgstr ""
"``keywords`` 保存一個 :class:`.keyword` 物件串列，表示透過關鍵字傳遞的引數。"

#: ../../library/ast.rst:591
msgid ""
"When creating a ``Call`` node, ``args`` and ``keywords`` are required, but "
"they can be empty lists."
msgstr ""
"建立 ``Call`` 節點時會需要 ``args`` 和 ``keywords``，但它們可以是空串列。"

#: ../../library/ast.rst:594
msgid ""
">>> print(ast.dump(ast.parse('func(a, b=c, *d, **e)', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=Call(\n"
"        func=Name(id='func', ctx=Load()),\n"
"        args=[\n"
"            Name(id='a', ctx=Load()),\n"
"            Starred(\n"
"                value=Name(id='d', ctx=Load()),\n"
"                ctx=Load())],\n"
"        keywords=[\n"
"            keyword(\n"
"                arg='b',\n"
"                value=Name(id='c', ctx=Load())),\n"
"            keyword(\n"
"                value=Name(id='e', ctx=Load()))]))"
msgstr ""
">>> print(ast.dump(ast.parse('func(a, b=c, *d, **e)', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=Call(\n"
"        func=Name(id='func', ctx=Load()),\n"
"        args=[\n"
"            Name(id='a', ctx=Load()),\n"
"            Starred(\n"
"                value=Name(id='d', ctx=Load()),\n"
"                ctx=Load())],\n"
"        keywords=[\n"
"            keyword(\n"
"                arg='b',\n"
"                value=Name(id='c', ctx=Load())),\n"
"            keyword(\n"
"                value=Name(id='e', ctx=Load()))]))"

#: ../../library/ast.rst:615
msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a raw "
"string of the parameter name, ``value`` is a node to pass in."
msgstr ""
"函式呼叫或類別定義的關鍵字引數。``arg`` 是參數名稱的原始字串，``value`` 是要"
"傳入的節點。"

#: ../../library/ast.rst:621
msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, so "
"in the following example, all three are :class:`Name` nodes."
msgstr ""
"像是 ``a if b else c`` 之類的運算式。每個欄位都保存一個節點，因此在以下範例"
"中，所有三個都是 :class:`Name` 節點。"

#: ../../library/ast.rst:624
msgid ""
">>> print(ast.dump(ast.parse('a if b else c', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=IfExp(\n"
"        test=Name(id='b', ctx=Load()),\n"
"        body=Name(id='a', ctx=Load()),\n"
"        orelse=Name(id='c', ctx=Load())))"
msgstr ""
">>> print(ast.dump(ast.parse('a if b else c', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=IfExp(\n"
"        test=Name(id='b', ctx=Load()),\n"
"        body=Name(id='a', ctx=Load()),\n"
"        orelse=Name(id='c', ctx=Load())))"

#: ../../library/ast.rst:636
msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a :class:"
"`Name`. ``attr`` is a bare string giving the name of the attribute, and "
"``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` according to how "
"the attribute is acted on."
msgstr ""
"屬性的存取，例如 ``d.keys``。``value`` 是一個節點，通常是一個 :class:`Name`。"
"``attr`` 是一個屬性名稱的字串，``ctx`` 根據屬性的作用方式可能是 :class:"
"`Load`、:class:`Store` 或 :class:`Del`。"

#: ../../library/ast.rst:641
msgid ""
">>> print(ast.dump(ast.parse('snake.colour', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Attribute(\n"
"        value=Name(id='snake', ctx=Load()),\n"
"        attr='colour',\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('snake.colour', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Attribute(\n"
"        value=Name(id='snake', ctx=Load()),\n"
"        attr='colour',\n"
"        ctx=Load()))"

#: ../../library/ast.rst:653
msgid ""
"A named expression. This AST node is produced by the assignment expressions "
"operator (also known as the walrus operator). As opposed to the :class:"
"`Assign` node in which the first argument can be multiple nodes, in this "
"case both ``target`` and ``value`` must be single nodes."
msgstr ""
"一個附名運算式 (named expression)。該 AST 節點由賦值運算式運算子（也稱為海象"
"運算子）產生。相對於 :class:`Assign` 節點之第一個引數可為多個節點，在這種情況"
"下 ``target`` 和 ``value`` 都必須是單個節點。"

#: ../../library/ast.rst:658
msgid ""
">>> print(ast.dump(ast.parse('(x := 4)', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=NamedExpr(\n"
"        target=Name(id='x', ctx=Store()),\n"
"        value=Constant(value=4)))"
msgstr ""
">>> print(ast.dump(ast.parse('(x := 4)', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=NamedExpr(\n"
"        target=Name(id='x', ctx=Store()),\n"
"        value=Constant(value=4)))"

#: ../../library/ast.rst:669
msgid "Subscripting"
msgstr "下標 (Subscripting)"

#: ../../library/ast.rst:673
msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object (usually "
"sequence or mapping). ``slice`` is an index, slice or key. It can be a :"
"class:`Tuple` and contain a :class:`Slice`. ``ctx`` is :class:`Load`, :class:"
"`Store` or :class:`Del` according to the action performed with the subscript."
msgstr ""
"一個下標，例如 ``l[1]``。``value`` 是下標物件（通常是序列或對映）。``slice`` "
"是索引、切片或鍵。它可以是一個 :class:`Tuple` 並包含一個 :class:`Slice`。根據"
"下標執行的操作不同，``ctx`` 可以是 :class:`Load`、:class:`Store` 或 :class:"
"`Del`。"

#: ../../library/ast.rst:679
msgid ""
">>> print(ast.dump(ast.parse('l[1:2, 3]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Subscript(\n"
"        value=Name(id='l', ctx=Load()),\n"
"        slice=Tuple(\n"
"            elts=[\n"
"                Slice(\n"
"                    lower=Constant(value=1),\n"
"                    upper=Constant(value=2)),\n"
"                Constant(value=3)],\n"
"            ctx=Load()),\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('l[1:2, 3]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Subscript(\n"
"        value=Name(id='l', ctx=Load()),\n"
"        slice=Tuple(\n"
"            elts=[\n"
"                Slice(\n"
"                    lower=Constant(value=1),\n"
"                    upper=Constant(value=2)),\n"
"                Constant(value=3)],\n"
"            ctx=Load()),\n"
"        ctx=Load()))"

#: ../../library/ast.rst:697
msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). Can "
"occur only inside the *slice* field of :class:`Subscript`, either directly "
"or as an element of :class:`Tuple`."
msgstr ""
"常規切片（形式為 ``lower:upper`` 或 ``lower:upper:step``\\ ）。只能直接或者或"
"者作為 :class:`Tuple` 的元素出現在 :class:`Subscript` 的 *slice* 欄位內。"

#: ../../library/ast.rst:701
msgid ""
">>> print(ast.dump(ast.parse('l[1:2]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Subscript(\n"
"        value=Name(id='l', ctx=Load()),\n"
"        slice=Slice(\n"
"            lower=Constant(value=1),\n"
"            upper=Constant(value=2)),\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('l[1:2]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Subscript(\n"
"        value=Name(id='l', ctx=Load()),\n"
"        slice=Slice(\n"
"            lower=Constant(value=1),\n"
"            upper=Constant(value=2)),\n"
"        ctx=Load()))"

#: ../../library/ast.rst:714
msgid "Comprehensions"
msgstr "綜合運算式 (comprehensions)"

#: ../../library/ast.rst:721
msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr ""
"串列和集合綜合運算、生成器運算式和字典綜合運算。``elt``\\ （或 ``key`` 和 "
"``value``\\ ）是單個節點，表示各個項目會被求值 (evaluate) 的部分。"

#: ../../library/ast.rst:725
msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr "``generators`` 是一個 :class:`comprehension` 節點的串列。"

#: ../../library/ast.rst:727
msgid ""
">>> print(ast.dump(ast.parse('[x for x in numbers]', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Name(id='x', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                ifs=[],\n"
"                is_async=0)]))\n"
">>> print(ast.dump(ast.parse('{x: x**2 for x in numbers}', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=DictComp(\n"
"        key=Name(id='x', ctx=Load()),\n"
"        value=BinOp(\n"
"            left=Name(id='x', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Constant(value=2)),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                ifs=[],\n"
"                is_async=0)]))\n"
">>> print(ast.dump(ast.parse('{x for x in numbers}', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=SetComp(\n"
"        elt=Name(id='x', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                ifs=[],\n"
"                is_async=0)]))"
msgstr ""
">>> print(ast.dump(ast.parse('[x for x in numbers]', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Name(id='x', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                ifs=[],\n"
"                is_async=0)]))\n"
">>> print(ast.dump(ast.parse('{x: x**2 for x in numbers}', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=DictComp(\n"
"        key=Name(id='x', ctx=Load()),\n"
"        value=BinOp(\n"
"            left=Name(id='x', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Constant(value=2)),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                ifs=[],\n"
"                is_async=0)]))\n"
">>> print(ast.dump(ast.parse('{x for x in numbers}', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=SetComp(\n"
"        elt=Name(id='x', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                ifs=[],\n"
"                is_async=0)]))"

#: ../../library/ast.rst:767
msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use "
"for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""
"綜合運算中的一個 ``for`` 子句。``target`` 是用於每個元素的參照 - 通常是 :"
"class:`Name` 或 :class:`Tuple` 節點。``iter`` 是要疊代的物件。``ifs`` 是測試"
"運算式的串列：每個 ``for`` 子句可以有多個 ``ifs``。"

#: ../../library/ast.rst:772
msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr ""
"``is_async`` 表示綜合運算式是非同步的（使用 ``async for`` 而不是 ``for`` ）。"
"該值為整數（0 或 1）。"

#: ../../library/ast.rst:775
msgid ""
">>> print(ast.dump(ast.parse('[ord(c) for line in file for c in line]', "
"mode='eval'),\n"
"...                indent=4)) # Multiple comprehensions in one.\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Call(\n"
"            func=Name(id='ord', ctx=Load()),\n"
"            args=[\n"
"                Name(id='c', ctx=Load())],\n"
"            keywords=[]),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='line', ctx=Store()),\n"
"                iter=Name(id='file', ctx=Load()),\n"
"                ifs=[],\n"
"                is_async=0),\n"
"            comprehension(\n"
"                target=Name(id='c', ctx=Store()),\n"
"                iter=Name(id='line', ctx=Load()),\n"
"                ifs=[],\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('(n**2 for n in it if n>5 if n<10)', "
"mode='eval'),\n"
"...                indent=4)) # generator comprehension\n"
"Expression(\n"
"    body=GeneratorExp(\n"
"        elt=BinOp(\n"
"            left=Name(id='n', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Constant(value=2)),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='n', ctx=Store()),\n"
"                iter=Name(id='it', ctx=Load()),\n"
"                ifs=[\n"
"                    Compare(\n"
"                        left=Name(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=5)]),\n"
"                    Compare(\n"
"                        left=Name(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Lt()],\n"
"                        comparators=[\n"
"                            Constant(value=10)])],\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('[i async for i in soc]', mode='eval'),\n"
"...                indent=4)) # Async comprehension\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Name(id='i', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='i', ctx=Store()),\n"
"                iter=Name(id='soc', ctx=Load()),\n"
"                ifs=[],\n"
"                is_async=1)]))"
msgstr ""

#: ../../library/ast.rst:841
msgid "Statements"
msgstr "陳述式"

#: ../../library/ast.rst:845
msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr "一個賦值。``targets`` 是節點串列，``value`` 是單個節點。"

#: ../../library/ast.rst:847
msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to each. "
"Unpacking is represented by putting a :class:`Tuple` or :class:`List` within "
"``targets``."
msgstr ""
"``targets`` 中的多個節點表示為每個節點分配相同的值。解包是透過在 ``targets`` "
"中放置一個 :class:`Tuple` 或 :class:`List` 來表示的。"

#: ../../library/ast.rst:853 ../../library/ast.rst:1165
#: ../../library/ast.rst:1370 ../../library/ast.rst:1895
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment."
msgstr "``type_comment`` 是一個可選字串，其中的註解為型別註釋。"

#: ../../library/ast.rst:855
msgid ""
">>> print(ast.dump(ast.parse('a = b = 1'), indent=4)) # Multiple assignment\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='a', ctx=Store()),\n"
"                Name(id='b', ctx=Store())],\n"
"            value=Constant(value=1))],\n"
"    type_ignores=[])\n"
"\n"
">>> print(ast.dump(ast.parse('a,b = c'), indent=4)) # Unpacking\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Name(id='a', ctx=Store()),\n"
"                        Name(id='b', ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='c', ctx=Load()))],\n"
"    type_ignores=[])"
msgstr ""

#: ../../library/ast.rst:883
msgid ""
"An assignment with a type annotation. ``target`` is a single node and can be "
"a :class:`Name`, an :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or :class:"
"`Name` node. ``value`` is a single optional node."
msgstr ""
"帶有型別註釋的賦值。``target`` 是單個節點，可以是 :class:`Name`、:class:"
"`Attribute` 或 :class:`Subscript`。``annotation`` 是註釋，例如 :class:"
"`Constant` 或 :class:`Name` 節點。``value`` 是單個可選節點。"

#: ../../library/ast.rst:888
msgid ""
"``simple`` is always either 0 (indicating a \"complex\" target) or 1 "
"(indicating a \"simple\" target). A \"simple\" target consists solely of a :"
"class:`Name` node that does not appear between parentheses; all other "
"targets are considered complex. Only simple targets appear in the :attr:"
"`__annotations__` dictionary of modules and classes."
msgstr ""
"``simple`` 總會是 0（表示一個「複雜」目標）或 1（表示一個「簡單」目標）。一個"
"「簡單」目標僅包含一個 :class:`Name` 節點，且不出現在括號之間；所有其他目標都"
"被視為是複雜的。只有簡單目標會出現在模組和類別的 :attr:`__annotations__` 字典"
"中。"

#: ../../library/ast.rst:894
msgid ""
">>> print(ast.dump(ast.parse('c: int'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Name(id='c', ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=1)],\n"
"    type_ignores=[])\n"
"\n"
">>> print(ast.dump(ast.parse('(a): int = 1'), indent=4)) # Annotation with "
"parenthesis\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Name(id='a', ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            value=Constant(value=1),\n"
"            simple=0)],\n"
"    type_ignores=[])\n"
"\n"
">>> print(ast.dump(ast.parse('a.b: int'), indent=4)) # Attribute annotation\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Attribute(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                attr='b',\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)],\n"
"    type_ignores=[])\n"
"\n"
">>> print(ast.dump(ast.parse('a[1]: int'), indent=4)) # Subscript "
"annotation\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Subscript(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                slice=Constant(value=1),\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)],\n"
"    type_ignores=[])"
msgstr ""

#: ../../library/ast.rst:942
msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` with "
"value for 1."
msgstr ""
"增加賦值 (augmented assignment)，例如 ``a += 1``。在下面的範例中，``target`` "
"是 ``x`` 的 :class:`Name` 節點（帶有 :class:`Store` 情境），``op`` 是 :class:"
"`Add`，``value`` 是一個值為 1 的 :class:`Constant`。"

#: ../../library/ast.rst:947
msgid ""
"The ``target`` attribute cannot be of class :class:`Tuple` or :class:`List`, "
"unlike the targets of :class:`Assign`."
msgstr ""
"與 :class:`Assign` 的目標不同，``target`` 屬性不能屬於 :class:`Tuple` 或 :"
"class:`List` 類別。"

#: ../../library/ast.rst:950
msgid ""
">>> print(ast.dump(ast.parse('x += 2'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AugAssign(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            op=Add(),\n"
"            value=Constant(value=2))],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('x += 2'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AugAssign(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            op=Add(),\n"
"            value=Constant(value=2))],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:964
msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from y``."
msgstr ""
"一個 ``raise`` 陳述式。``exc`` 是要引發的例外物件，通常是 :class:`Call` 或 :"
"class:`Name`，若是獨立的 ``raise`` 則為 ``None``。``cause`` 是 ``raise x "
"from y`` 中的可選部分 ``y``。"

#: ../../library/ast.rst:968
msgid ""
">>> print(ast.dump(ast.parse('raise x from y'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Raise(\n"
"            exc=Name(id='x', ctx=Load()),\n"
"            cause=Name(id='y', ctx=Load()))],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('raise x from y'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Raise(\n"
"            exc=Name(id='x', ctx=Load()),\n"
"            cause=Name(id='y', ctx=Load()))],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:981
msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` node. "
"``msg`` holds the failure message."
msgstr ""
"一個斷言 (assertion)。``test`` 保存條件，例如 :class:`Compare` 節點。``msg`` "
"保存失敗訊息。"

#: ../../library/ast.rst:984
msgid ""
">>> print(ast.dump(ast.parse('assert x,y'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assert(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            msg=Name(id='y', ctx=Load()))],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('assert x,y'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assert(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            msg=Name(id='y', ctx=Load()))],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:997
msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as :"
"class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""
"代表一個 ``del`` 陳述式。``targets`` 是節點串列，例如 :class:`Name`、:class:"
"`Attribute` 或 :class:`Subscript` 節點。"

#: ../../library/ast.rst:1000
msgid ""
">>> print(ast.dump(ast.parse('del x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Delete(\n"
"            targets=[\n"
"                Name(id='x', ctx=Del()),\n"
"                Name(id='y', ctx=Del()),\n"
"                Name(id='z', ctx=Del())])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('del x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Delete(\n"
"            targets=[\n"
"                Name(id='x', ctx=Del()),\n"
"                Name(id='y', ctx=Del()),\n"
"                Name(id='z', ctx=Del())])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1015
msgid "A ``pass`` statement."
msgstr "一個 ``pass`` 陳述式。"

#: ../../library/ast.rst:1017
msgid ""
">>> print(ast.dump(ast.parse('pass'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Pass()],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('pass'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Pass()],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1028
msgid ""
"A :ref:`type alias <type-aliases>` created through the :keyword:`type` "
"statement. ``name`` is the name of the alias, ``type_params`` is a list of :"
"ref:`type parameters <ast-type-params>`, and ``value`` is the value of the "
"type alias."
msgstr ""
"透過 :keyword:`type` 陳述式建立的\\ :ref:`型別別名 (type alias) <type-"
"aliases>`。``name`` 是別名的名稱、``type_params`` 是\\ :ref:`型別參數 (type "
"parameter) <ast-type-params>` 的串列、``value`` 是型別別名的值。"

#: ../../library/ast.rst:1033
msgid ""
">>> print(ast.dump(ast.parse('type Alias = int'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[],\n"
"            value=Name(id='int', ctx=Load()))],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('type Alias = int'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[],\n"
"            value=Name(id='int', ctx=Load()))],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1046
msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr "其他僅適用於函式或迴圈內部的陳述式將在其他部分中描述。"

#: ../../library/ast.rst:1050
msgid "Imports"
msgstr "引入 (imports)"

#: ../../library/ast.rst:1054
msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr "一個 import 陳述式。``names`` 是 :class:`alias` 節點的串列。"

#: ../../library/ast.rst:1056
msgid ""
">>> print(ast.dump(ast.parse('import x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Import(\n"
"            names=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('import x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Import(\n"
"            names=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1071
msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from . "
"import foo``. ``level`` is an integer holding the level of the relative "
"import (0 means absolute import)."
msgstr ""
"代表 ``from x import y``。``module`` 是 'from' 名稱的原始字串，前面沒有任何的"
"點 (dot)，或者對於諸如 ``from . import foo`` 之類的陳述式則為 ``None``。"
"``level`` 是一個整數，保存相對引入的級別（0 表示絕對引入）。"

#: ../../library/ast.rst:1076
msgid ""
">>> print(ast.dump(ast.parse('from y import x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ImportFrom(\n"
"            module='y',\n"
"            names=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')],\n"
"            level=0)],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('from y import x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ImportFrom(\n"
"            module='y',\n"
"            names=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')],\n"
"            level=0)],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1093
msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` if "
"the regular name is to be used."
msgstr ""
"這兩個參數都是名稱的原始字串。如果要使用常規名稱，``asname`` 可以為 "
"``None``。"

#: ../../library/ast.rst:1096
msgid ""
">>> print(ast.dump(ast.parse('from ..foo.bar import a as b, c'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ImportFrom(\n"
"            module='foo.bar',\n"
"            names=[\n"
"                alias(name='a', asname='b'),\n"
"                alias(name='c')],\n"
"            level=2)],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('from ..foo.bar import a as b, c'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ImportFrom(\n"
"            module='foo.bar',\n"
"            names=[\n"
"                alias(name='a', asname='b'),\n"
"                alias(name='c')],\n"
"            level=2)],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1110
msgid "Control flow"
msgstr "流程控制"

#: ../../library/ast.rst:1113
msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're not "
"present."
msgstr "諸如 ``else`` 之類的可選子句如果不存在，則將被儲存為空串列。"

#: ../../library/ast.rst:1118
msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a :class:"
"`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""
"一個 ``if`` 陳述式。``test`` 保存單個節點，例如 :class:`Compare` 節點。"
"``body`` 和 ``orelse`` 各自保存一個節點串列。"

#: ../../library/ast.rst:1121
msgid ""
"``elif`` clauses don't have a special representation in the AST, but rather "
"appear as extra :class:`If` nodes within the ``orelse`` section of the "
"previous one."
msgstr ""
"``elif`` 子句在 AST 中沒有特殊表示，而是在前一個子句的 ``orelse`` 部分中作為"
"額外的 :class:`If` 節點出現。"

#: ../../library/ast.rst:1125
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... if x:\n"
"...    ...\n"
"... elif y:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        If(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                If(\n"
"                    test=Name(id='y', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))],\n"
"                    orelse=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... if x:\n"
"...    ...\n"
"... elif y:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        If(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                If(\n"
"                    test=Name(id='y', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))],\n"
"                    orelse=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1156
msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as a "
"single :class:`Name`, :class:`Tuple`, :class:`List`, :class:`Attribute` or :"
"class:`Subscript` node. ``iter`` holds the item to be looped over, again as "
"a single node. ``body`` and ``orelse`` contain lists of nodes to execute. "
"Those in ``orelse`` are executed if the loop finishes normally, rather than "
"via a ``break`` statement."
msgstr ""
"一個 ``for`` 迴圈。 ``target`` 保存迴圈賦予的變數，為單個 :class:`Name`、:"
"class:`Tuple`、:class:`List`、:class:`Attribute` 或 :class:`Subscript` 節點。"
"``iter`` 保存要迴圈跑過的項目，也為單個節點。``body`` 和 ``orelse`` 包含要執"
"行的節點串列。如果迴圈正常完成，則執行 ``orelse`` 中的內容，而不是透過 "
"``break`` 陳述式執行。"

#: ../../library/ast.rst:1167
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... for x in y:\n"
"...     ...\n"
"... else:\n"
"...     ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        For(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            iter=Name(id='y', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... for x in y:\n"
"...     ...\n"
"... else:\n"
"...     ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        For(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            iter=Name(id='y', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1191
msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a :class:`Compare` "
"node."
msgstr "一個 ``while`` 迴圈。``test`` 保存條件，例如 :class:`Compare` 節點。"

#: ../../library/ast.rst:1194
msgid ""
">> print(ast.dump(ast.parse(\"\"\"\n"
"... while x:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        While(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])],\n"
"    type_ignores=[])"
msgstr ""
">> print(ast.dump(ast.parse(\"\"\"\n"
"... while x:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        While(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1218
msgid "The ``break`` and ``continue`` statements."
msgstr "``break`` 和 ``continue`` 陳述式。"

#: ../../library/ast.rst:1220
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... for a in b:\n"
"...     if a > 5:\n"
"...         break\n"
"...     else:\n"
"...         continue\n"
"...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        For(\n"
"            target=Name(id='a', ctx=Store()),\n"
"            iter=Name(id='b', ctx=Load()),\n"
"            body=[\n"
"                If(\n"
"                    test=Compare(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=5)]),\n"
"                    body=[\n"
"                        Break()],\n"
"                    orelse=[\n"
"                        Continue()])],\n"
"            orelse=[])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... for a in b:\n"
"...     if a > 5:\n"
"...         break\n"
"...     else:\n"
"...         continue\n"
"...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        For(\n"
"            target=Name(id='a', ctx=Store()),\n"
"            iter=Name(id='b', ctx=Load()),\n"
"            body=[\n"
"                If(\n"
"                    test=Compare(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=5)]),\n"
"                    body=[\n"
"                        Break()],\n"
"                    orelse=[\n"
"                        Continue()])],\n"
"            orelse=[])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1253
msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr ""
"``try`` 區塊。除 ``handlers`` 是 :class:`ExceptHandler` 節點的串列外，其他所"
"有屬性都是要執行之節點的串列。"

#: ../../library/ast.rst:1256
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... try:\n"
"...    ...\n"
"... except Exception:\n"
"...    ...\n"
"... except OtherException as e:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... finally:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Try(\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                ExceptHandler(\n"
"                    type=Name(id='OtherException', ctx=Load()),\n"
"                    name='e',\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            finalbody=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... try:\n"
"...    ...\n"
"... except Exception:\n"
"...    ...\n"
"... except OtherException as e:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... finally:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Try(\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                ExceptHandler(\n"
"                    type=Name(id='OtherException', ctx=Load()),\n"
"                    name='e',\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            finalbody=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1299
msgid ""
"``try`` blocks which are followed by ``except*`` clauses. The attributes are "
"the same as for :class:`Try` but the :class:`ExceptHandler` nodes in "
"``handlers`` are interpreted as ``except*`` blocks rather then ``except``."
msgstr ""
"``try`` 區塊，後面跟著 ``except*`` 子句。這些屬性與 :class:`Try` 相同，但是 "
"``handlers`` 中的 :class:`ExceptHandler` 節點被直譯 (interpret) 為 "
"``except*`` 區塊而不是 ``except``。"

#: ../../library/ast.rst:1303
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... try:\n"
"...    ...\n"
"... except* Exception:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TryStar(\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])],\n"
"            orelse=[],\n"
"            finalbody=[])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... try:\n"
"...    ...\n"
"... except* Exception:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TryStar(\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])],\n"
"            orelse=[],\n"
"            finalbody=[])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1331
msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match, "
"typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of nodes."
msgstr ""
"單個 ``except`` 子句。``type`` 是會被匹配的例外型別，通常是一個 :class:"
"`Name` 節點（或者 ``None`` 表示會捕捉到所有例外的 ``except:`` 子句）。"
"``name`` 是用於保存例外的名稱之原始字串，如果子句沒有 ``as foo`` ，則為 "
"``None``。``body`` 是節點串列。"

#: ../../library/ast.rst:1336
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... try:\n"
"...     a + 1\n"
"... except TypeError:\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Try(\n"
"            body=[\n"
"                Expr(\n"
"                    value=BinOp(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        op=Add(),\n"
"                        right=Constant(value=1)))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='TypeError', ctx=Load()),\n"
"                    body=[\n"
"                        Pass()])],\n"
"            orelse=[],\n"
"            finalbody=[])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... try:\n"
"...     a + 1\n"
"... except TypeError:\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Try(\n"
"            body=[\n"
"                Expr(\n"
"                    value=BinOp(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        op=Add(),\n"
"                        right=Constant(value=1)))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='TypeError', ctx=Load()),\n"
"                    body=[\n"
"                        Pass()])],\n"
"            orelse=[],\n"
"            finalbody=[])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1365
msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block inside "
"the context."
msgstr ""
"一個 ``with`` 區塊。``items`` 是表示情境管理器的 :class:`withitem` 節點串列，"
"``body`` 是情境內的縮進區塊。"

#: ../../library/ast.rst:1375
msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a :class:"
"`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, or ``None`` "
"if that isn't used."
msgstr ""
"``with`` 區塊中的單個情境管理器。``context_expr`` 是情境管理器，通常是一個 :"
"class:`Call` 節點。``Optional_vars`` 是 ``as foo`` 部分的 :class:`Name`、:"
"class:`Tuple` 或 :class:`List`，或者如果不使用則為 ``None`` 。"

#: ../../library/ast.rst:1380
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... with a as b, c as d:\n"
"...    something(b, d)\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        With(\n"
"            items=[\n"
"                withitem(\n"
"                    context_expr=Name(id='a', ctx=Load()),\n"
"                    optional_vars=Name(id='b', ctx=Store())),\n"
"                withitem(\n"
"                    context_expr=Name(id='c', ctx=Load()),\n"
"                    optional_vars=Name(id='d', ctx=Store()))],\n"
"            body=[\n"
"                Expr(\n"
"                    value=Call(\n"
"                        func=Name(id='something', ctx=Load()),\n"
"                        args=[\n"
"                            Name(id='b', ctx=Load()),\n"
"                            Name(id='d', ctx=Load())],\n"
"                        keywords=[]))])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... with a as b, c as d:\n"
"...    something(b, d)\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        With(\n"
"            items=[\n"
"                withitem(\n"
"                    context_expr=Name(id='a', ctx=Load()),\n"
"                    optional_vars=Name(id='b', ctx=Store())),\n"
"                withitem(\n"
"                    context_expr=Name(id='c', ctx=Load()),\n"
"                    optional_vars=Name(id='d', ctx=Store()))],\n"
"            body=[\n"
"                Expr(\n"
"                    value=Call(\n"
"                        func=Name(id='something', ctx=Load()),\n"
"                        args=[\n"
"                            Name(id='b', ctx=Load()),\n"
"                            Name(id='d', ctx=Load())],\n"
"                        keywords=[]))])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1408
msgid "Pattern matching"
msgstr "模式匹配 (pattern matching)"

#: ../../library/ast.rst:1413
msgid ""
"A ``match`` statement. ``subject`` holds the subject of the match (the "
"object that is being matched against the cases) and ``cases`` contains an "
"iterable of :class:`match_case` nodes with the different cases."
msgstr ""
"一個 ``match`` 陳述式。``subject`` 保存匹配的主題（與案例匹配的物件），"
"``cases`` 包含具有不同案例的 :class:`match_case` 節點的可疊代物件。"

#: ../../library/ast.rst:1421
msgid ""
"A single case pattern in a ``match`` statement. ``pattern`` contains the "
"match pattern that the subject will be matched against. Note that the :class:"
"`AST` nodes produced for patterns differ from those produced for "
"expressions, even when they share the same syntax."
msgstr ""
"``match`` 陳述式中的單個案例模式。``pattern`` 包含主題將與之匹配的匹配模式。"
"請注意，為模式生成的 :class:`AST` 節點與為運算式生成的節點不同，即使它們共享"
"相同的語法。"

#: ../../library/ast.rst:1426
msgid ""
"The ``guard`` attribute contains an expression that will be evaluated if the "
"pattern matches the subject."
msgstr "``guard`` 屬性包含一個運算式，如果模式與主題匹配，則將對該運算式求值。"

#: ../../library/ast.rst:1429
msgid ""
"``body`` contains a list of nodes to execute if the pattern matches and the "
"result of evaluating the guard expression is true."
msgstr ""
"``body`` 包含一個節點串列，如果模式匹配並且為防護運算式 (guard expression) 的"
"求值 (evaluate) 結果為真，則會執行該節點串列。"

#: ../../library/ast.rst:1432
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] if x>0:\n"
"...         ...\n"
"...     case tuple():\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchAs(name='x')]),\n"
"                    guard=Compare(\n"
"                        left=Name(id='x', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=0)]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='tuple', ctx=Load()),\n"
"                        patterns=[],\n"
"                        kwd_attrs=[],\n"
"                        kwd_patterns=[]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] if x>0:\n"
"...         ...\n"
"...     case tuple():\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchAs(name='x')]),\n"
"                    guard=Compare(\n"
"                        left=Name(id='x', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=0)]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='tuple', ctx=Load()),\n"
"                        patterns=[],\n"
"                        kwd_attrs=[],\n"
"                        kwd_patterns=[]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1474
msgid ""
"A match literal or value pattern that compares by equality. ``value`` is an "
"expression node. Permitted value nodes are restricted as described in the "
"match statement documentation. This pattern succeeds if the match subject is "
"equal to the evaluated value."
msgstr ""
"以相等性進行比較的匹配文本或值的模式。``value`` 是一個運算式節點。允許值節點"
"受到匹配陳述式文件中所述的限制。如果匹配主題等於求出值，則此模式成功。"

#: ../../library/ast.rst:1479
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case \"Relevant\":\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchValue(\n"
"                        value=Constant(value='Relevant')),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case \"Relevant\":\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchValue(\n"
"                        value=Constant(value='Relevant')),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1503
msgid ""
"A match literal pattern that compares by identity. ``value`` is the "
"singleton to be compared against: ``None``, ``True``, or ``False``. This "
"pattern succeeds if the match subject is the given constant."
msgstr ""
"按識別性 (identity) 進行比較的匹配文本模式。``value`` 是要與 ``None``、"
"``True`` 或 ``False`` 進行比較的單例 (singleton)。如果匹配主題是給定的常數，"
"則此模式成功。"

#: ../../library/ast.rst:1507
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case None:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSingleton(value=None),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case None:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSingleton(value=None),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1530
msgid ""
"A match sequence pattern. ``patterns`` contains the patterns to be matched "
"against the subject elements if the subject is a sequence. Matches a "
"variable length sequence if one of the subpatterns is a ``MatchStar`` node, "
"otherwise matches a fixed length sequence."
msgstr ""
"匹配序列模式。如果主題是一個序列，``patterns`` 包含與主題元素匹配的模式。如果"
"子模式之一是 ``MatchStar`` 節點，則匹配可變長度序列，否則匹配固定長度序列。"

#: ../../library/ast.rst:1535
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [1, 2]:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=1)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=2))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [1, 2]:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=1)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=2))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1563
msgid ""
"Matches the rest of the sequence in a variable length match sequence "
"pattern. If ``name`` is not ``None``, a list containing the remaining "
"sequence elements is bound to that name if the overall sequence pattern is "
"successful."
msgstr ""
"以可變長度匹配序列模式匹配序列的其餘部分。如果 ``name`` 不是 ``None``，則如果"
"整體序列模式成功，則包含其餘序列元素的串列將綁定到該名稱。"

#: ../../library/ast.rst:1567
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [1, 2, *rest]:\n"
"...         ...\n"
"...     case [*_]:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=1)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=2)),\n"
"                            MatchStar(name='rest')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchStar()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [1, 2, *rest]:\n"
"...         ...\n"
"...     case [*_]:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=1)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=2)),\n"
"                            MatchStar(name='rest')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchStar()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1605
msgid ""
"A match mapping pattern. ``keys`` is a sequence of expression nodes. "
"``patterns`` is a corresponding sequence of pattern nodes. ``rest`` is an "
"optional name that can be specified to capture the remaining mapping "
"elements. Permitted key expressions are restricted as described in the match "
"statement documentation."
msgstr ""
"匹配對映模式。``keys`` 是運算式節點的序列。``patterns`` 是相應的模式節點序"
"列。``rest`` 是一個可選名稱，可以指定它來捕獲剩餘的對映元素。允許的鍵運算式受"
"到匹配陳述式文件中所述的限制。"

#: ../../library/ast.rst:1611
msgid ""
"This pattern succeeds if the subject is a mapping, all evaluated key "
"expressions are present in the mapping, and the value corresponding to each "
"key matches the corresponding subpattern. If ``rest`` is not ``None``, a "
"dict containing the remaining mapping elements is bound to that name if the "
"overall mapping pattern is successful."
msgstr ""
"如果主題是對映，所有求值出的鍵運算式都存在於對映中，並且與每個鍵對應的值與相"
"應的子模式匹配，則此模式成功。如果 ``rest`` 不是 ``None``，則如果整體對映模式"
"成功，則包含其餘對映元素的字典將綁定到該名稱。"

#: ../../library/ast.rst:1617
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case {1: _, 2: _}:\n"
"...         ...\n"
"...     case {**rest}:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchMapping(\n"
"                        keys=[\n"
"                            Constant(value=1),\n"
"                            Constant(value=2)],\n"
"                        patterns=[\n"
"                            MatchAs(),\n"
"                            MatchAs()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchMapping(keys=[], patterns=[], "
"rest='rest'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case {1: _, 2: _}:\n"
"...         ...\n"
"...     case {**rest}:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchMapping(\n"
"                        keys=[\n"
"                            Constant(value=1),\n"
"                            Constant(value=2)],\n"
"                        patterns=[\n"
"                            MatchAs(),\n"
"                            MatchAs()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchMapping(keys=[], patterns=[], "
"rest='rest'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1653
msgid ""
"A match class pattern. ``cls`` is an expression giving the nominal class to "
"be matched. ``patterns`` is a sequence of pattern nodes to be matched "
"against the class defined sequence of pattern matching attributes. "
"``kwd_attrs`` is a sequence of additional attributes to be matched "
"(specified as keyword arguments in the class pattern), ``kwd_patterns`` are "
"the corresponding patterns (specified as keyword values in the class "
"pattern)."
msgstr ""
"匹配類別模式。``cls`` 是一個給定要匹配的名義類別 (nominal class) 的運算式。"
"``patterns`` 是要與類別定義的模式匹配屬性序列進行匹配的模式節點序列。"
"``kwd_attrs`` 是要匹配的附加屬性序列（在類別模式中指定為關鍵字引數），"
"``kwd_patterns`` 是相應的模式（在類別模式中指定為關鍵字的值）。"

#: ../../library/ast.rst:1660
msgid ""
"This pattern succeeds if the subject is an instance of the nominated class, "
"all positional patterns match the corresponding class-defined attributes, "
"and any specified keyword attributes match their corresponding pattern."
msgstr ""
"如果主題是指定類別的實例，所有位置模式都與相應的類別定義屬性匹配，並且任何指"
"定的關鍵字屬性與其相應模式匹配，則此模式成功。"

#: ../../library/ast.rst:1664
msgid ""
"Note: classes may define a property that returns self in order to match a "
"pattern node against the instance being matched. Several builtin types are "
"also matched that way, as described in the match statement documentation."
msgstr ""
"注意：類別可以定義一個回傳 self 的特性 (property)，以便將模式節點與正在匹配的"
"實例進行匹配。一些內建型別也以這種方式匹配，如同匹配陳述式文件中所述。"

#: ../../library/ast.rst:1668
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case Point2D(0, 0):\n"
"...         ...\n"
"...     case Point3D(x=0, y=0, z=0):\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='Point2D', ctx=Load()),\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0))],\n"
"                        kwd_attrs=[],\n"
"                        kwd_patterns=[]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='Point3D', ctx=Load()),\n"
"                        patterns=[],\n"
"                        kwd_attrs=[\n"
"                            'x',\n"
"                            'y',\n"
"                            'z'],\n"
"                        kwd_patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case Point2D(0, 0):\n"
"...         ...\n"
"...     case Point3D(x=0, y=0, z=0):\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='Point2D', ctx=Load()),\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0))],\n"
"                        kwd_attrs=[],\n"
"                        kwd_patterns=[]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='Point3D', ctx=Load()),\n"
"                        patterns=[],\n"
"                        kwd_attrs=[\n"
"                            'x',\n"
"                            'y',\n"
"                            'z'],\n"
"                        kwd_patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1719
msgid ""
"A match \"as-pattern\", capture pattern or wildcard pattern. ``pattern`` "
"contains the match pattern that the subject will be matched against. If the "
"pattern is ``None``, the node represents a capture pattern (i.e a bare name) "
"and will always succeed."
msgstr ""
"匹配的 「as 模式 (as-pattern)」，為捕獲模式 (capture pattern) 或通配模式 "
"(wildcard pattern)。``pattern`` 包含主題將與之匹配的匹配模式。如果模式為 "
"``None``，則該節點代表捕獲模式（即裸名 (bare name)）並且始終會成功。"

#: ../../library/ast.rst:1724
msgid ""
"The ``name`` attribute contains the name that will be bound if the pattern "
"is successful. If ``name`` is ``None``, ``pattern`` must also be ``None`` "
"and the node represents the wildcard pattern."
msgstr ""
"``name`` 屬性包含模式成功時將綁定的名稱。如果 ``name`` 為 ``None``，則 "
"``pattern`` 也必須為 ``None``，並且節點代表通配模式。"

#: ../../library/ast.rst:1728
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] as y:\n"
"...         ...\n"
"...     case _:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchAs(\n"
"                        pattern=MatchSequence(\n"
"                            patterns=[\n"
"                                MatchAs(name='x')]),\n"
"                        name='y'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchAs(),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] as y:\n"
"...         ...\n"
"...     case _:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchAs(\n"
"                        pattern=MatchSequence(\n"
"                            patterns=[\n"
"                                MatchAs(name='x')]),\n"
"                        name='y'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchAs(),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1762
msgid ""
"A match \"or-pattern\". An or-pattern matches each of its subpatterns in "
"turn to the subject, until one succeeds. The or-pattern is then deemed to "
"succeed. If none of the subpatterns succeed the or-pattern fails. The "
"``patterns`` attribute contains a list of match pattern nodes that will be "
"matched against the subject."
msgstr ""
"匹配的 「or 模式 (or-pattern)」。 or 模式依次將其每個子模式與主題進行匹配，直"
"到成功為止，然後 or 模式就會被認為是成功的。如果沒有一個子模式成功，則 or 模"
"式將失敗。 ``patterns`` 屬性包含將與主題進行匹配的匹配模式節點串列。"

#: ../../library/ast.rst:1768
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] | (y):\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchOr(\n"
"                        patterns=[\n"
"                            MatchSequence(\n"
"                                patterns=[\n"
"                                    MatchAs(name='x')]),\n"
"                            MatchAs(name='y')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] | (y):\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchOr(\n"
"                        patterns=[\n"
"                            MatchSequence(\n"
"                                patterns=[\n"
"                                    MatchAs(name='x')]),\n"
"                            MatchAs(name='y')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1797
msgid "Type parameters"
msgstr "型別參數 (type parameters)"

#: ../../library/ast.rst:1799
msgid ""
":ref:`Type parameters <type-params>` can exist on classes, functions, and "
"type aliases."
msgstr ":ref:`型別參數 <type-params>`\\ 可以存在於類別、函式和型別別名上。"

#: ../../library/ast.rst:1804
msgid ""
"A :class:`typing.TypeVar`. ``name`` is the name of the type variable. "
"``bound`` is the bound or constraints, if any. If ``bound`` is a :class:"
"`Tuple`, it represents constraints; otherwise it represents the bound."
msgstr ""
"一個 :class:`typing.TypeVar`。``name`` 是型別變數的名稱。``bound`` 是（如果有"
"存在的）界限 (bound) 或約束 (constraint)。如果 ``bound`` 是一個 :class:"
"`Tuple`，它代表約束；否則它代表界限。"

#: ../../library/ast.rst:1808
msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[T: int] = list[T]\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVar(\n"
"                    name='T',\n"
"                    bound=Name(id='int', ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='list', ctx=Load()),\n"
"                slice=Name(id='T', ctx=Load()),\n"
"                ctx=Load()))],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"type Alias[T: int] = list[T]\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVar(\n"
"                    name='T',\n"
"                    bound=Name(id='int', ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='list', ctx=Load()),\n"
"                slice=Name(id='T', ctx=Load()),\n"
"                ctx=Load()))],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1829
msgid ""
"A :class:`typing.ParamSpec`. ``name`` is the name of the parameter "
"specification."
msgstr "A :class:`typing.ParamSpec`。``name`` 是參數規範的名稱。"

#: ../../library/ast.rst:1831
msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[**P] = Callable[P, int]\"), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                ParamSpec(name='P')],\n"
"            value=Subscript(\n"
"                value=Name(id='Callable', ctx=Load()),\n"
"                slice=Tuple(\n"
"                    elts=[\n"
"                        Name(id='P', ctx=Load()),\n"
"                        Name(id='int', ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"type Alias[**P] = Callable[P, int]\"), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                ParamSpec(name='P')],\n"
"            value=Subscript(\n"
"                value=Name(id='Callable', ctx=Load()),\n"
"                slice=Tuple(\n"
"                    elts=[\n"
"                        Name(id='P', ctx=Load()),\n"
"                        Name(id='int', ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1854
msgid ""
"A :class:`typing.TypeVarTuple`. ``name`` is the name of the type variable "
"tuple."
msgstr "一個 :class:`typing.TypeVarTuple`。``name`` 是型別變數元組的名稱。"

#: ../../library/ast.rst:1856
msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[*Ts] = tuple[*Ts]\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVarTuple(name='Ts')],\n"
"            value=Subscript(\n"
"                value=Name(id='tuple', ctx=Load()),\n"
"                slice=Tuple(\n"
"                    elts=[\n"
"                        Starred(\n"
"                            value=Name(id='Ts', ctx=Load()),\n"
"                            ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"type Alias[*Ts] = tuple[*Ts]\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVarTuple(name='Ts')],\n"
"            value=Subscript(\n"
"                value=Name(id='tuple', ctx=Load()),\n"
"                slice=Tuple(\n"
"                    elts=[\n"
"                        Starred(\n"
"                            value=Name(id='Ts', ctx=Load()),\n"
"                            ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1879
msgid "Function and class definitions"
msgstr "函式和類別定義"

#: ../../library/ast.rst:1883
msgid "A function definition."
msgstr "一個函式定義。"

#: ../../library/ast.rst:1885
msgid "``name`` is a raw string of the function name."
msgstr "``name`` 是函式名稱的原始字串。"

#: ../../library/ast.rst:1886
msgid "``args`` is an :class:`arguments` node."
msgstr "``args`` 是一個 :class:`arguments` 節點。"

#: ../../library/ast.rst:1887
msgid "``body`` is the list of nodes inside the function."
msgstr "``body`` 是函式內節點的串列。"

#: ../../library/ast.rst:1888
msgid ""
"``decorator_list`` is the list of decorators to be applied, stored outermost "
"first (i.e. the first in the list will be applied last)."
msgstr ""
"``decorator_list`` 是要應用的裝飾器串列，在最外層者會被儲存在首位（即串列中首"
"位將會是最後一個被應用的那個）。"

#: ../../library/ast.rst:1890
msgid "``returns`` is the return annotation."
msgstr "``returns`` 是回傳註釋。"

#: ../../library/ast.rst:1891 ../../library/ast.rst:2067
msgid "``type_params`` is a list of :ref:`type parameters <ast-type-params>`."
msgstr "``type_params`` 是\\ :ref:`型別參數 <ast-type-params>`\\ 的串列。"

#: ../../library/ast.rst:1897 ../../library/ast.rst:2096
#: ../../library/ast.rst:2107
msgid "Added ``type_params``."
msgstr "新增了 ``type_params``。"

#: ../../library/ast.rst:1903
msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr ""
"``lambda`` 是可以在運算式內使用的最小函式定義。與 :class:`FunctionDef` 不同，"
"``body`` 保存單個節點。"

#: ../../library/ast.rst:1906
msgid ""
">>> print(ast.dump(ast.parse('lambda x,y: ...'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Lambda(\n"
"                args=arguments(\n"
"                    posonlyargs=[],\n"
"                    args=[\n"
"                        arg(arg='x'),\n"
"                        arg(arg='y')],\n"
"                    kwonlyargs=[],\n"
"                    kw_defaults=[],\n"
"                    defaults=[]),\n"
"                body=Constant(value=Ellipsis)))],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('lambda x,y: ...'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Lambda(\n"
"                args=arguments(\n"
"                    posonlyargs=[],\n"
"                    args=[\n"
"                        arg(arg='x'),\n"
"                        arg(arg='y')],\n"
"                    kwonlyargs=[],\n"
"                    kw_defaults=[],\n"
"                    defaults=[]),\n"
"                body=Constant(value=Ellipsis)))],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1927
msgid "The arguments for a function."
msgstr "函式的引數。"

#: ../../library/ast.rst:1929
msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` nodes."
msgstr ""
"``posonlyargs``、``args`` 和 ``kwonlyargs`` 是 :class:`arg` 節點的串列。"

#: ../../library/ast.rst:1930
msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr ""
"``vararg`` 和 ``kwarg`` 是單個 :class:`arg` 節點，指的是 ``*args, **kwargs`` "
"參數。"

#: ../../library/ast.rst:1932
msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. If "
"one is ``None``, the corresponding argument is required."
msgstr ""
"``kw_defaults`` 是僅限關鍵字引數的預設值串列。如果其中某個為 ``None``，則相應"
"參數就會是必要的。"

#: ../../library/ast.rst:1934
msgid ""
"``defaults`` is a list of default values for arguments that can be passed "
"positionally. If there are fewer defaults, they correspond to the last n "
"arguments."
msgstr ""
"``defaults`` 是可以按位置傳遞的引數的預設值串列。如果預設值較少，則它們對應於"
"最後 n 個引數。"

#: ../../library/ast.rst:1941
msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument name; "
"``annotation`` is its annotation, such as a :class:`Name` node."
msgstr ""
"串列中的單個引數。``arg`` 是引數名稱的原始字串，``annotation`` 是它的註釋，例"
"如 :class:`Name` 節點。"

#: ../../library/ast.rst:1946
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment"
msgstr "``type_comment`` 是一個可選字串，其註解為型別註釋"

#: ../../library/ast.rst:1948
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... @decorator1\n"
"... @decorator2\n"
"... def f(a: 'annotation', b=1, c=2, *d, e, f=3, **g) -> 'return "
"annotation':\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        FunctionDef(\n"
"            name='f',\n"
"            args=arguments(\n"
"                posonlyargs=[],\n"
"                args=[\n"
"                    arg(\n"
"                        arg='a',\n"
"                        annotation=Constant(value='annotation')),\n"
"                    arg(arg='b'),\n"
"                    arg(arg='c')],\n"
"                vararg=arg(arg='d'),\n"
"                kwonlyargs=[\n"
"                    arg(arg='e'),\n"
"                    arg(arg='f')],\n"
"                kw_defaults=[\n"
"                    None,\n"
"                    Constant(value=3)],\n"
"                kwarg=arg(arg='g'),\n"
"                defaults=[\n"
"                    Constant(value=1),\n"
"                    Constant(value=2)]),\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())],\n"
"            returns=Constant(value='return annotation'),\n"
"            type_params=[])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... @decorator1\n"
"... @decorator2\n"
"... def f(a: 'annotation', b=1, c=2, *d, e, f=3, **g) -> 'return "
"annotation':\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        FunctionDef(\n"
"            name='f',\n"
"            args=arguments(\n"
"                posonlyargs=[],\n"
"                args=[\n"
"                    arg(\n"
"                        arg='a',\n"
"                        annotation=Constant(value='annotation')),\n"
"                    arg(arg='b'),\n"
"                    arg(arg='c')],\n"
"                vararg=arg(arg='d'),\n"
"                kwonlyargs=[\n"
"                    arg(arg='e'),\n"
"                    arg(arg='f')],\n"
"                kw_defaults=[\n"
"                    None,\n"
"                    Constant(value=3)],\n"
"                kwarg=arg(arg='g'),\n"
"                defaults=[\n"
"                    Constant(value=1),\n"
"                    Constant(value=2)]),\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())],\n"
"            returns=Constant(value='return annotation'),\n"
"            type_params=[])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:1991
msgid "A ``return`` statement."
msgstr "一個 ``return`` 陳述式。"

#: ../../library/ast.rst:1993
msgid ""
">>> print(ast.dump(ast.parse('return 4'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Return(\n"
"            value=Constant(value=4))],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('return 4'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Return(\n"
"            value=Constant(value=4))],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:2006
msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in an :class:`Expr` node if the value sent back is not "
"used."
msgstr ""
"一個 ``yield`` 或 ``yield from`` 運算式。因為這些是運算式，所以如果不使用發送"
"回來的值，則必須將它們包裝在 :class:`Expr` 節點中。"

#: ../../library/ast.rst:2009
msgid ""
">>> print(ast.dump(ast.parse('yield x'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Yield(\n"
"                value=Name(id='x', ctx=Load())))],\n"
"    type_ignores=[])\n"
"\n"
">>> print(ast.dump(ast.parse('yield from x'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=YieldFrom(\n"
"                value=Name(id='x', ctx=Load())))],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('yield x'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Yield(\n"
"                value=Name(id='x', ctx=Load())))],\n"
"    type_ignores=[])\n"
"\n"
">>> print(ast.dump(ast.parse('yield from x'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=YieldFrom(\n"
"                value=Name(id='x', ctx=Load())))],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:2031
msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw strings."
msgstr "``global`` 和 ``nonlocal`` 陳述式。``names`` 是原始字串的串列。"

#: ../../library/ast.rst:2033
msgid ""
">>> print(ast.dump(ast.parse('global x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Global(\n"
"            names=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])],\n"
"    type_ignores=[])\n"
"\n"
">>> print(ast.dump(ast.parse('nonlocal x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Nonlocal(\n"
"            names=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse('global x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Global(\n"
"            names=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])],\n"
"    type_ignores=[])\n"
"\n"
">>> print(ast.dump(ast.parse('nonlocal x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Nonlocal(\n"
"            names=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:2058
msgid "A class definition."
msgstr "一個類別定義。"

#: ../../library/ast.rst:2060
msgid "``name`` is a raw string for the class name"
msgstr "``name`` 是類別名的原始字串"

#: ../../library/ast.rst:2061
msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr "``bases`` 是被顯式指定的基底類別節點串列。"

#: ../../library/ast.rst:2062
msgid ""
"``keywords`` is a list of :class:`.keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per :pep:"
"`3115`."
msgstr ""
"``keywords`` 是一個 :class:`.keyword` 節點的串列，主要用於 'metaclass'（元類"
"別）。如 :pep:`3115` 所述，其他關鍵字將被傳遞到 metaclass。"

#: ../../library/ast.rst:2064
msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr "``body`` 是表示類別定義中程式碼的節點串列。"

#: ../../library/ast.rst:2066
msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr "``decorator_list`` 是一個節點串列，如 :class:`FunctionDef` 中所示。"

#: ../../library/ast.rst:2069
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... @decorator1\n"
"... @decorator2\n"
"... class Foo(base1, base2, metaclass=meta):\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ClassDef(\n"
"            name='Foo',\n"
"            bases=[\n"
"                Name(id='base1', ctx=Load()),\n"
"                Name(id='base2', ctx=Load())],\n"
"            keywords=[\n"
"                keyword(\n"
"                    arg='metaclass',\n"
"                    value=Name(id='meta', ctx=Load()))],\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())],\n"
"            type_params=[])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... @decorator1\n"
"... @decorator2\n"
"... class Foo(base1, base2, metaclass=meta):\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ClassDef(\n"
"            name='Foo',\n"
"            bases=[\n"
"                Name(id='base1', ctx=Load()),\n"
"                Name(id='base2', ctx=Load())],\n"
"            keywords=[\n"
"                keyword(\n"
"                    arg='metaclass',\n"
"                    value=Name(id='meta', ctx=Load()))],\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())],\n"
"            type_params=[])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:2100
msgid "Async and await"
msgstr "async 和 await"

#: ../../library/ast.rst:2104
msgid ""
"An ``async def`` function definition. Has the same fields as :class:"
"`FunctionDef`."
msgstr "一個 ``async def`` 函式定義。與 :class:`FunctionDef` 具有相同的欄位。"

#: ../../library/ast.rst:2113
msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"一個 ``await`` 運算式。``value`` 是它等待的東西。僅在 :class:"
"`AsyncFunctionDef` 主體 (body) 中有效。"

#: ../../library/ast.rst:2116
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... async def f():\n"
"...     await other_func()\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=arguments(\n"
"                posonlyargs=[],\n"
"                args=[],\n"
"                kwonlyargs=[],\n"
"                kw_defaults=[],\n"
"                defaults=[]),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Await(\n"
"                        value=Call(\n"
"                            func=Name(id='other_func', ctx=Load()),\n"
"                            args=[],\n"
"                            keywords=[])))],\n"
"            decorator_list=[],\n"
"            type_params=[])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... async def f():\n"
"...     await other_func()\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=arguments(\n"
"                posonlyargs=[],\n"
"                args=[],\n"
"                kwonlyargs=[],\n"
"                kw_defaults=[],\n"
"                defaults=[]),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Await(\n"
"                        value=Call(\n"
"                            func=Name(id='other_func', ctx=Load()),\n"
"                            args=[],\n"
"                            keywords=[])))],\n"
"            decorator_list=[],\n"
"            type_params=[])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:2147
msgid ""
"``async for`` loops and ``async with`` context managers. They have the same "
"fields as :class:`For` and :class:`With`, respectively. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"``async for`` 迴圈和 ``async with`` 情境管理器。它們分別具有與 :class:`For` "
"和 :class:`With` 相同的欄位。僅在 :class:`AsyncFunctionDef` 主體中有效。"

#: ../../library/ast.rst:2152
msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses of :"
"class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, :class:`ast."
"boolop` and :class:`ast.expr_context`) on the returned tree will be "
"singletons. Changes to one will be reflected in all other occurrences of the "
"same value (e.g. :class:`ast.Add`)."
msgstr ""
"當字串被 :func:`ast.parse` 剖析時，回傳樹的運算子節點（\\ :class:`ast."
"operator`、:class:`ast.unaryop`、:class:`ast.cmpop`、:class: :class:`ast."
"boolop` 和 :class:`ast.expr_context`\\ ）將是單例。對其中之一的更改將反映在所"
"有其他出現的相同值中（例如 :class:`ast.Add`\\ ）。"

#: ../../library/ast.rst:2160
msgid ":mod:`ast` Helpers"
msgstr ":mod:`ast` 輔助程式"

#: ../../library/ast.rst:2162
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""
"除了節點類別之外，:mod:`ast` 模組還定義了這些用於遍歷 (traverse) 抽象語法樹的"
"實用函式和類別："

#: ../../library/ast.rst:2167
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr ""
"將原始碼剖析為 AST 節點。相當於 ``compile(source, filename, mode, ast."
"PyCF_ONLY_AST)``。"

#: ../../library/ast.rst:2170
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed to :"
"func:`compile`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In "
"addition, the locations of ``# type: ignore`` comments will be returned as "
"the ``type_ignores`` attribute of :class:`Module` (otherwise it is always an "
"empty list)."
msgstr ""
"如果給定 ``type_comments=True``，剖析器將被修改為檢查並回傳 :pep:`484` 和 :"
"pep:`526` 指定的型別註釋。這相當於將 :data:`ast.PyCF_TYPE_COMMENTS` 新增到傳"
"遞給 :func:`compile` 的旗標中。這將報告錯誤型別註釋的語法錯誤。如果沒有此旗"
"標，型別註釋將被忽略，並且所選 AST 節點上的 ``type_comment`` 欄位將始終為 "
"``None``。此外，``# type: ignore`` 註釋的位置將作為 :class:`Module` 的 "
"``type_ignores`` 屬性回傳（否則它始終是一個空串列）。"

#: ../../library/ast.rst:2180
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified to "
"correspond to :pep:`484` \"signature type comments\", e.g. ``(str, int) -> "
"List[str]``."
msgstr ""
"此外，如果 ``mode`` 是 ``'func_type'``，則輸入語法將會依據 :pep:`484`\\ 「簽"
"名型別註解 (signature type comments)」而被修改，例如 ``(str, int) -> "
"List[str]``。"

#: ../../library/ast.rst:2184
msgid ""
"Setting ``feature_version`` to a tuple ``(major, minor)`` will result in a "
"\"best-effort\" attempt to parse using that Python version's grammar. For "
"example, setting ``feature_version=(3, 9)`` will attempt to disallow parsing "
"of :keyword:`match` statements. Currently ``major`` must equal to ``3``. The "
"lowest supported version is ``(3, 4)`` (and this may increase in future "
"Python versions); the highest is ``sys.version_info[0:2]``. \"Best-effort\" "
"attempt means there is no guarantee that the parse (or success of the parse) "
"is the same as when run on the Python version corresponding to "
"``feature_version``."
msgstr ""
"將 ``feature_version`` 設定為元組 ``(major, minor)`` 將「盡可能」嘗試使用該 "
"Python 版本的文法進行剖析。當前 ``major`` 必須等於 ``3``。例如，設定 "
"``feature_version=(3, 4)`` 將嘗試禁止剖析 :keyword:`match` 陳述式。目前 "
"``major`` 必須為 ``3``、支援的最低版本為 ``(3, 4)``\\ （這在未來的 Python 版"
"本中可能會增加）；最高的是 ``sys.version_info[0:2]``。「盡可能」嘗試意味著不"
"能保證剖析（或剖析的成功）與在與 ``feature_version`` 對應的 Python 版本上運行"
"時相同。"

#: ../../library/ast.rst:2194
msgid ""
"If source contains a null character (``\\0``), :exc:`ValueError` is raised."
msgstr "如果來源包含 null 字元 (``\\0``)，則會引發 :exc:`ValueError`。"

#: ../../library/ast.rst:2197
msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to be "
"inside a function node)."
msgstr ""
"請注意，成功將原始碼剖析為 AST 物件並不能保證提供的原始碼是可以執行的有效 "
"Python 程式碼，因為編譯步驟可能會引發進一步的 :exc:`SyntaxError` 例外。例如，"
"原始的 ``return 42`` 為 return 陳述式生成一個有效的 AST 節點，但它不能單獨編"
"譯（它需要位於函式節點內）。"

#: ../../library/ast.rst:2204
msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr ""
"特別是 :func:`ast.parse` 不會執行任何範圍檢查，而編譯步驟才會執行此操作。"

#: ../../library/ast.rst:2208
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string due to stack depth limitations in Python's AST compiler."
msgstr ""
"由於 Python AST 編譯器中的堆疊 (stack) 深度限制，太大或太複雜的字串可能會導"
"致 Python 直譯器崩潰。"

#: ../../library/ast.rst:2212
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr "新增 ``type_comments``、``mode='func_type'`` 與 ``feature_version``。"

#: ../../library/ast.rst:2218
msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with :"
"func:`ast.parse`."
msgstr ""
"反剖析 :class:`ast.AST` 物件並生成一個帶有程式碼的字串，如果使用 :func:`ast."
"parse` 剖析回來，該程式碼將生成等效的 :class:`ast.AST` 物件。"

#: ../../library/ast.rst:2223
msgid ""
"The produced code string will not necessarily be equal to the original code "
"that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr ""
"生成的程式碼字串不一定等於生成 :class:`ast.AST` 物件的原始程式碼（沒有任何編"
"譯器最佳化，例如常數元組/凍結集合）。"

#: ../../library/ast.rst:2228
msgid ""
"Trying to unparse a highly complex expression would result with :exc:"
"`RecursionError`."
msgstr "嘗試剖析高度複雜的運算式會導致 :exc:`RecursionError`。"

#: ../../library/ast.rst:2236
msgid ""
"Evaluate an expression node or a string containing only a Python literal or "
"container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists, "
"dicts, sets, booleans, ``None`` and ``Ellipsis``."
msgstr ""
"為僅包含 Python 文本或容器之顯示的運算式節點或字串來求值。提供的字串或節點只"
"能包含以下 Python 文本結構：字串、位元組、數字、元組、串列、字典、集合、布林"
"值、``None`` 和 ``Ellipsis``。"

#: ../../library/ast.rst:2241
msgid ""
"This can be used for evaluating strings containing Python values without the "
"need to parse the values oneself.  It is not capable of evaluating "
"arbitrarily complex expressions, for example involving operators or indexing."
msgstr ""
"這可用於為包含 Python 值的字串求值，而無需自己剖析這些值。它無法計算任意複雜"
"的運算式，例如涉及運算子或索引。"

#: ../../library/ast.rst:2246
msgid ""
"This function had been documented as \"safe\" in the past without defining "
"what that meant. That was misleading. This is specifically designed not to "
"execute Python code, unlike the more general :func:`eval`. There is no "
"namespace, no name lookups, or ability to call out. But it is not free from "
"attack: A relatively small input can lead to memory exhaustion or to C stack "
"exhaustion, crashing the process. There is also the possibility for "
"excessive CPU consumption denial of service on some inputs. Calling it on "
"untrusted data is thus not recommended."
msgstr ""
"該函式過去被記錄為「安全」，但沒有定義其含義，這有點誤導讀者，它是特別設計為"
"不去執行 Python 程式碼，與更通用的 :func:`eval` 不同。沒有命名空間、沒有名稱"
"查找、也沒有呼叫的能力。但它也不能免受攻擊：相對較小的輸入可能會導致記憶體耗"
"盡或 C 堆疊耗盡，從而導致行程崩潰。某些輸入也可能會出現 CPU 消耗過多而導致拒"
"絕服務的情況。因此不建議在不受信任的資料上呼叫它。"

#: ../../library/ast.rst:2256
msgid ""
"It is possible to crash the Python interpreter due to stack depth "
"limitations in Python's AST compiler."
msgstr "由於 Python AST 編譯器的堆疊深度限制，Python 直譯器可能會崩潰。"

#: ../../library/ast.rst:2259
msgid ""
"It can raise :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, :exc:"
"`MemoryError` and :exc:`RecursionError` depending on the malformed input."
msgstr ""
"它可能會引發 :exc:`ValueError`、:exc:`TypeError`、:exc:`SyntaxError`、:exc:"
"`MemoryError` 和 :exc:`RecursionError`，具體取決於格式錯誤的輸入。"

#: ../../library/ast.rst:2263
msgid "Now allows bytes and set literals."
msgstr "現在允許位元組和集合文本 (set literal)。"

#: ../../library/ast.rst:2266
msgid "Now supports creating empty sets with ``'set()'``."
msgstr "現在支援使用 ``'set()'`` 建立空集合。"

#: ../../library/ast.rst:2269
msgid "For string inputs, leading spaces and tabs are now stripped."
msgstr "對於字串輸入，前導空格和定位字元 (tab) 現在已被去除。"

#: ../../library/ast.rst:2275
msgid ""
"Return the docstring of the given *node* (which must be a :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or :class:"
"`Module` node), or ``None`` if it has no docstring. If *clean* is true, "
"clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"回傳給定 *node* 的文件字串 (docstring)（必須是 :class:`FunctionDef`、:class:"
"`AsyncFunctionDef`、:class:`ClassDef` 或 :class:`Module` 節點）或如果它沒有文"
"件字串則為 ``None``。如果 *clean* 為 true，則使用 :func:`inspect.cleandoc` 清"
"理文件字串的縮排。"

#: ../../library/ast.rst:2281
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr "目前已支援 :class:`AsyncFunctionDef`。"

#: ../../library/ast.rst:2287
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`~ast.AST.lineno`, :attr:`~ast.AST.end_lineno`, :"
"attr:`~ast.AST.col_offset`, or :attr:`~ast.AST.end_col_offset`) is missing, "
"return ``None``."
msgstr ""
"獲取生成 *node* 的 *source* 的原始碼片段。如果某些位置資訊（:attr:`~ast.AST."
"lineno`、:attr:`~ast.AST.end_lineno`、:attr:`~ast.AST.col_offset` 或 :attr:"
"`~ast.AST.end_col_offset`\\ ）遺漏，則回傳 ``None``。"

#: ../../library/ast.rst:2291
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be "
"padded with spaces to match its original position."
msgstr ""
"如果 *padded* 為 ``True``，則多列陳述式的第一列將用空格填充 (padded) 以匹配其"
"原始位置。"

#: ../../library/ast.rst:2299
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects :"
"attr:`~ast.AST.lineno` and :attr:`~ast.AST.col_offset` attributes for every "
"node that supports them.  This is rather tedious to fill in for generated "
"nodes, so this helper adds these attributes recursively where not already "
"set, by setting them to the values of the parent node.  It works recursively "
"starting at *node*."
msgstr ""
"當你使用 :func:`compile` 編譯節點樹時，對於每個有支援 :attr:`~ast.AST."
"lineno` 和 :attr:`~ast.AST.col_offset` 屬性之節點，編譯器預期他們的這些屬性都"
"要存在。填入生成的節點相當繁瑣，因此該輔助工具透過將這些屬性設定為父節點的"
"值，在尚未設定的地方遞迴地新增這些屬性。它從 *node* 開始遞迴地作用。"

#: ../../library/ast.rst:2308
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different "
"location in a file."
msgstr ""
"將樹中從 *node* 開始的每個節點的列號和結束列號增加 *n*。這對於「移動程式碼」"
"到檔案中的不同位置很有用。"

#: ../../library/ast.rst:2315
msgid ""
"Copy source location (:attr:`~ast.AST.lineno`, :attr:`~ast.AST.col_offset`, :"
"attr:`~ast.AST.end_lineno`, and :attr:`~ast.AST.end_col_offset`) from "
"*old_node* to *new_node* if possible, and return *new_node*."
msgstr ""
"如果可行，將原始位置（:attr:`~ast.AST.lineno`、:attr:`~ast.AST.col_offset`、:"
"attr:`~ast.AST.end_lineno` 和 :attr:`~ast.AST.end_col_offset` ）從 "
"*old_node* 複製到 *new_node*，並回傳 *new_node* 。"

#: ../../library/ast.rst:2322
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""
"為 *node* 上存在的 ``node._fields`` 中的每個欄位生成一個 ``(fieldname, "
"value)`` 元組。"

#: ../../library/ast.rst:2328
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""
"生成 *node* 的所有直接子節點，即作為節點的所有欄位以及作為節點串列欄位的所有"
"項目。"

#: ../../library/ast.rst:2334
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"遞迴地生成樹中從 *node* 開始的所有後代節點（包括 *node* 本身），不按指定順"
"序。如果你只想就地修改節點而不關心情境，這非常有用。"

#: ../../library/ast.rst:2341
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""
"節點訪問者基底類別，它遍歷抽象語法樹並為找到的每個節點呼叫訪問者函式。該函式"
"可能會回傳一個由 :meth:`visit` 方法轉發的值。"

#: ../../library/ast.rst:2345
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr "這個類別應該被子類別化，子類別新增訪問者方法。"

#: ../../library/ast.rst:2350
msgid ""
"Visit a node.  The default implementation calls the method called :samp:"
"`self.visit_{classname}` where *classname* is the name of the node class, "
"or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"訪問一個節點。預設實作呼叫名為 :samp:`self.visit_{classname}` 的方法，其中 "
"*classname* 是節點類別的名稱，或者在該方法不存在時呼叫 :meth:"
"`generic_visit`。"

#: ../../library/ast.rst:2356
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "該訪問者對該節點的所有子節點呼叫 :meth:`visit`。"

#: ../../library/ast.rst:2358
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them itself."
msgstr ""
"請注意，除非訪問者呼叫 :meth:`generic_visit` 或訪問它們本身，否則不會訪問具有"
"自定義訪問者方法的節點之子節點。"

#: ../../library/ast.rst:2364
msgid "Handles all constant nodes."
msgstr "處理所有常數節點。"

#: ../../library/ast.rst:2366
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists (:class:"
"`NodeTransformer`) that allows modifications."
msgstr ""
"如果你想在遍歷期間將變更應用 (apply) 於節點，請不要使用 :class:"
"`NodeVisitor`。為此，有個允許修改的特殊遍歷訪問者工具 :class:"
"`NodeTransformer`。"

#: ../../library/ast.rst:2372
msgid ""
"Methods :meth:`!visit_Num`, :meth:`!visit_Str`, :meth:`!visit_Bytes`, :meth:"
"`!visit_NameConstant` and :meth:`!visit_Ellipsis` are deprecated now and "
"will not be called in future Python versions.  Add the :meth:"
"`visit_Constant` method to handle all constant nodes."
msgstr ""
":meth:`!visit_Num`、:meth:`!visit_Str`、:meth:`!visit_Bytes`、:meth:`!"
"visit_NameConstant` 和 :meth:`!visit_Ellipsis` 方法現已棄用，並且不會在未來的"
"Python 版本中被呼叫。新增 :meth:`visit_Constant` 方法來處理所有常數節點。"

#: ../../library/ast.rst:2380
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr "一個 :class:`NodeVisitor` 子類別，它會遍歷抽象語法樹並允許修改節點。"

#: ../../library/ast.rst:2383
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
":class:`NodeTransformer` 將遍歷 AST 並使用訪問者方法的回傳值來替換或刪除舊節"
"點。如果訪問者方法的回傳值為 ``None``，則該節點將從其位置中刪除，否則將被替換"
"為回傳值。回傳值可能是原始節點，在這種情況下不會發生替換。"

#: ../../library/ast.rst:2389
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups "
"(``foo``) to ``data['foo']``::"
msgstr ""
"下面是一個示範用的 transformer，它將查找所有出現名稱 (``foo``) 並改寫為 "
"``data['foo']``： ::"

#: ../../library/ast.rst:2392
msgid ""
"class RewriteName(NodeTransformer):\n"
"\n"
"    def visit_Name(self, node):\n"
"        return Subscript(\n"
"            value=Name(id='data', ctx=Load()),\n"
"            slice=Constant(value=node.id),\n"
"            ctx=node.ctx\n"
"        )"
msgstr ""
"class RewriteName(NodeTransformer):\n"
"\n"
"    def visit_Name(self, node):\n"
"        return Subscript(\n"
"            value=Name(id='data', ctx=Load()),\n"
"            slice=Constant(value=node.id),\n"
"            ctx=node.ctx\n"
"        )"

#: ../../library/ast.rst:2401
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`~ast."
"NodeVisitor.generic_visit` method for the node first."
msgstr ""
"請記住，如果你正在操作的節點有子節點，你必須自己轉換子節點或先呼叫該節點的 :"
"meth:`~ast.NodeVisitor.generic_visit` 方法。"

#: ../../library/ast.rst:2405
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""
"對於屬於陳述式總集 (collection) 一部分的節點（適用於所有陳述式節點），訪問者"
"還可以回傳節點串列，而不僅僅是單個節點。"

#: ../../library/ast.rst:2409
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as :attr:`~ast."
"AST.lineno`), :func:`fix_missing_locations` should be called with the new "
"sub-tree to recalculate the location information::"
msgstr ""
"如果 :class:`NodeTransformer` 引進了新節點（不屬於原始樹的一部分），但沒有給"
"它們提供位置資訊（例如 :attr:`~ast.AST.lineno`\\ ），則應使用新的子樹呼叫 :"
"func:`fix_missing_locations` 以重新計算位置資訊： ::"

#: ../../library/ast.rst:2414
msgid ""
"tree = ast.parse('foo', mode='eval')\n"
"new_tree = fix_missing_locations(RewriteName().visit(tree))"
msgstr ""
"tree = ast.parse('foo', mode='eval')\n"
"new_tree = fix_missing_locations(RewriteName().visit(tree))"

#: ../../library/ast.rst:2417
msgid "Usually you use the transformer like this::"
msgstr "你通常會像這樣使用 transformer： ::"

#: ../../library/ast.rst:2419
msgid "node = YourTransformer().visit(node)"
msgstr "node = YourTransformer().visit(node)"

#: ../../library/ast.rst:2424
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  If *annotate_fields* is true (by default), the returned "
"string will show the names and the values for fields. If *annotate_fields* "
"is false, the result string will be more compact by omitting unambiguous "
"field names.  Attributes such as line numbers and column offsets are not "
"dumped by default.  If this is wanted, *include_attributes* can be set to "
"true."
msgstr ""
"回傳 *node* 中樹的格式化傾印 (formatted dump)，這主要用於除錯。如果 "
"*annotate_fields* 為 true（為預設值），則回傳的字串將顯示欄位的名稱和值。如"
"果 *annotate_fields* 為 false，則透過省略明確的欄位名稱，結果字串將更加縮減簡"
"潔。預設情況下，不會傾印列號和行偏移量等屬性。如果需要，可以設定 "
"*include_attributes* 為 true。"

#: ../../library/ast.rst:2432
msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, or "
"``\"\"`` will only insert newlines.  ``None`` (the default) selects the "
"single line representation. Using a positive integer indent indents that "
"many spaces per level.  If *indent* is a string (such as ``\"\\t\"``), that "
"string is used to indent each level."
msgstr ""
"如果 *indent* 是非負整數或字串，那麼樹將使用該縮排級別來做漂亮印出 (pretty-"
"print)。縮排級別 0、負數或 ``\"\"`` 只會插入換列符號 (newlines)。``None``\\ "
"（預設值）代表選擇單列表示。使用正整數縮排可以在每個級別縮排相同數量的空格。"
"如果 *indent* 是一個字串（例如 ``\"\\t\"``\\ ），則該字串用於縮排每個級別。"

#: ../../library/ast.rst:2439
msgid "Added the *indent* option."
msgstr "新增 *indent* 選項。"

#: ../../library/ast.rst:2446
msgid "Compiler Flags"
msgstr "編譯器旗標"

#: ../../library/ast.rst:2448
msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr "可以將以下旗標傳遞給 :func:`compile` 以變更對程式的編譯效果："

#: ../../library/ast.rst:2453
msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` and "
"async comprehensions."
msgstr ""
"啟用對最高階 ``await``、``async for``、``async with`` 和非同步綜合運算的支"
"援。"

#: ../../library/ast.rst:2460
msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr "生成並回傳抽象語法樹，而不是回傳已編譯的程式碼物件。"

#: ../../library/ast.rst:2465
msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# type: "
"<type>``, ``# type: ignore <stuff>``)."
msgstr ""
"啟用對 :pep:`484` 和 :pep:`526` 樣式型別註釋的支援 (``# type: <type>``, ``# "
"type: ignore <stuff>``)。"

#: ../../library/ast.rst:2474
msgid "Command-Line Usage"
msgstr "命令列用法"

#: ../../library/ast.rst:2478
msgid ""
"The :mod:`ast` module can be executed as a script from the command line. It "
"is as simple as:"
msgstr ":mod:`ast` 模組可以作為腳本從命令列執行，可以像這樣簡單地做到："

#: ../../library/ast.rst:2481
msgid "python -m ast [-m <mode>] [-a] [infile]"
msgstr "python -m ast [-m <mode>] [-a] [infile]"

#: ../../library/ast.rst:2485
msgid "The following options are accepted:"
msgstr "以下選項可被接受："

#: ../../library/ast.rst:2491
msgid "Show the help message and exit."
msgstr "顯示幫助訊息並退出。"

#: ../../library/ast.rst:2496
msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in :"
"func:`parse`."
msgstr "指定必須編譯哪種類型的程式碼，像是 :func:`parse` 中的 *mode* 引數。"

#: ../../library/ast.rst:2501
msgid "Don't parse type comments."
msgstr "不要剖析型別註解。"

#: ../../library/ast.rst:2505
msgid "Include attributes such as line numbers and column offsets."
msgstr "包括列號和行偏移量等屬性。"

#: ../../library/ast.rst:2510
msgid "Indentation of nodes in AST (number of spaces)."
msgstr "AST 中節點的縮進（空格數）。"

#: ../../library/ast.rst:2512
msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped to "
"stdout.  Otherwise, the content is read from stdin."
msgstr ""
"如果指定了 :file:`infile`，則其內容將被剖析為 AST 並傾印 (dump) 到 stdout。否"
"則會從 stdin 讀取內容。"

#: ../../library/ast.rst:2518
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an external "
"documentation resource, has good details on working with Python ASTs."
msgstr ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_ 是一個外部文件"
"資源，提供了有關使用 Python AST 的詳細資訊。"

#: ../../library/ast.rst:2521
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annotates Python ASTs with the positions of tokens and text in the source "
"code that generated them. This is helpful for tools that make source code "
"transformations."
msgstr ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ 使"
"用生成它們的原始碼中的標記和文本的位置來註釋 Python AST。這對於進行原始碼轉換"
"的工具很有幫助。"

#: ../../library/ast.rst:2526
msgid ""
"`leoAst.py <https://leo-editor.github.io/leo-editor/appendices.html#leoast-"
"py>`_ unifies the token-based and parse-tree-based views of python programs "
"by inserting two-way links between tokens and ast nodes."
msgstr ""
"`leoAst.py <https://leo-editor.github.io/leo-editor/appendices.html#leoast-"
"py>`_ 透過在 token 和 ast 節點之間插入雙向鏈結，統一了 python 程式的基於 "
"token 和基於剖析樹的視圖。"

#: ../../library/ast.rst:2531
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete Syntax "
"Tree that looks like an ast tree and keeps all formatting details. It's "
"useful for building automated refactoring (codemod) applications and linters."
msgstr ""
"`LibCST <https://libcst.readthedocs.io/>`_ 將程式碼剖析為具體語法樹 "
"(Concrete Syntax Tree)，看起來像 ast 樹並保留所有格式詳細資訊。它對於建置自動"
"重構 (codemod) 應用程式和 linter 非常有用。"

#: ../../library/ast.rst:2536
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax errors "
"in your Python file."
msgstr ""
"`Parso <https://parso.readthedocs.io>`_ 是一個 Python 剖析器，支援不同 "
"Python 版本的錯誤復原和往返剖析。Parso 還能夠列出 Python 檔案中的多個語法錯"
"誤。"

#: ../../library/ast.rst:59
msgid "? (question mark)"
msgstr "? （問號）"

#: ../../library/ast.rst:59 ../../library/ast.rst:60
msgid "in AST grammar"
msgstr "於 AST 文法中"

#: ../../library/ast.rst:60
msgid "* (asterisk)"
msgstr "* （星號）"
