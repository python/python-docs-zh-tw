# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Translators:
# Adrian Liaw <adrianliaw2000@gmail.com>, 2018
# nienzu <ibqqz0602@gmail.com>, 2018
# Matt Wang <mattwang44@gmail.com>, 2021
# Phil Lin <linooohon@gmail.com>, 2022
# Steven Hsu <hsuhaochun@gmail.com>, 2023
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-07 03:11+0800\n"
"PO-Revision-Date: 2024-05-06 17:06+0800\n"
"Last-Translator: KNChiu <y9760210@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: ../../library/functions.rst:5 ../../library/functions.rst:11
msgid "Built-in Functions"
msgstr "內建函式"

#: ../../library/functions.rst:7
msgid ""
"The Python interpreter has a number of functions and types built into it "
"that are always available.  They are listed here in alphabetical order."
msgstr ""
"Python 直譯器有內建多個可隨時使用的函式和型別。以下按照英文字母排序列出。"

#: ../../library/functions.rst:0
msgid "**A**"
msgstr "**A**"

#: ../../library/functions.rst:0
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/functions.rst:0
msgid ":func:`aiter`"
msgstr ":func:`aiter`"

#: ../../library/functions.rst:0
msgid ":func:`all`"
msgstr ":func:`all`"

#: ../../library/functions.rst:0
msgid ":func:`anext`"
msgstr ":func:`anext`"

#: ../../library/functions.rst:0
msgid ":func:`any`"
msgstr ":func:`any`"

#: ../../library/functions.rst:0
msgid ":func:`ascii`"
msgstr ":func:`ascii`"

#: ../../library/functions.rst:0
msgid "**B**"
msgstr "**B**"

#: ../../library/functions.rst:0
msgid ":func:`bin`"
msgstr ":func:`bin`"

#: ../../library/functions.rst:0
msgid ":func:`bool`"
msgstr ":func:`bool`"

#: ../../library/functions.rst:0
msgid ":func:`breakpoint`"
msgstr ":func:`breakpoint`"

#: ../../library/functions.rst:0
msgid "|func-bytearray|_"
msgstr "|func-bytearray|_"

#: ../../library/functions.rst:0
msgid "|func-bytes|_"
msgstr "|func-bytes|_"

#: ../../library/functions.rst:0
msgid "**C**"
msgstr "**C**"

#: ../../library/functions.rst:0
msgid ":func:`callable`"
msgstr ":func:`callable`"

#: ../../library/functions.rst:0
msgid ":func:`chr`"
msgstr ":func:`chr`"

#: ../../library/functions.rst:0
msgid ":func:`classmethod`"
msgstr ":func:`classmethod`"

#: ../../library/functions.rst:0
msgid ":func:`compile`"
msgstr ":func:`compile`"

#: ../../library/functions.rst:0
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../../library/functions.rst:0
msgid "**D**"
msgstr "**D**"

#: ../../library/functions.rst:0
msgid ":func:`delattr`"
msgstr ":func:`delattr`"

#: ../../library/functions.rst:0
msgid "|func-dict|_"
msgstr "|func-dict|_"

#: ../../library/functions.rst:0
msgid ":func:`dir`"
msgstr ":func:`dir`"

#: ../../library/functions.rst:0
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/functions.rst:0
msgid "**E**"
msgstr "**E**"

#: ../../library/functions.rst:0
msgid ":func:`enumerate`"
msgstr ":func:`enumerate`"

#: ../../library/functions.rst:0
msgid ":func:`eval`"
msgstr ":func:`eval`"

#: ../../library/functions.rst:0
msgid ":func:`exec`"
msgstr ":func:`exec`"

#: ../../library/functions.rst:0
msgid "**F**"
msgstr "**F**"

#: ../../library/functions.rst:0
msgid ":func:`filter`"
msgstr ":func:`filter`"

#: ../../library/functions.rst:0
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../../library/functions.rst:0
msgid ":func:`format`"
msgstr ":func:`format`"

#: ../../library/functions.rst:0
msgid "|func-frozenset|_"
msgstr "|func-frozenset|_"

#: ../../library/functions.rst:0
msgid "**G**"
msgstr "**G**"

#: ../../library/functions.rst:0
msgid ":func:`getattr`"
msgstr ":func:`getattr`"

#: ../../library/functions.rst:0
msgid ":func:`globals`"
msgstr ":func:`globals`"

#: ../../library/functions.rst:0
msgid "**H**"
msgstr "**H**"

#: ../../library/functions.rst:0
msgid ":func:`hasattr`"
msgstr ":func:`hasattr`"

#: ../../library/functions.rst:0
msgid ":func:`hash`"
msgstr ":func:`hash`"

#: ../../library/functions.rst:0
msgid ":func:`help`"
msgstr ":func:`help`"

#: ../../library/functions.rst:0
msgid ":func:`hex`"
msgstr ":func:`hex`"

#: ../../library/functions.rst:0
msgid "**I**"
msgstr "**I**"

#: ../../library/functions.rst:0
msgid ":func:`id`"
msgstr ":func:`id`"

#: ../../library/functions.rst:0
msgid ":func:`input`"
msgstr ":func:`input`"

#: ../../library/functions.rst:0
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/functions.rst:0
msgid ":func:`isinstance`"
msgstr ":func:`isinstance`"

#: ../../library/functions.rst:0
msgid ":func:`issubclass`"
msgstr ":func:`issubclass`"

#: ../../library/functions.rst:0
msgid ":func:`iter`"
msgstr ":func:`iter`"

#: ../../library/functions.rst:0
msgid "**L**"
msgstr "**L**"

#: ../../library/functions.rst:0
msgid ":func:`len`"
msgstr ":func:`len`"

#: ../../library/functions.rst:0
msgid "|func-list|_"
msgstr "|func-list|_"

#: ../../library/functions.rst:0
msgid ":func:`locals`"
msgstr ":func:`locals`"

#: ../../library/functions.rst:0
msgid "**M**"
msgstr "**M**"

#: ../../library/functions.rst:0
msgid ":func:`map`"
msgstr ":func:`map`"

#: ../../library/functions.rst:0
msgid ":func:`max`"
msgstr ":func:`max`"

#: ../../library/functions.rst:0
msgid "|func-memoryview|_"
msgstr "|func-memoryview|_"

#: ../../library/functions.rst:0
msgid ":func:`min`"
msgstr ":func:`min`"

#: ../../library/functions.rst:0
msgid "**N**"
msgstr "**N**"

#: ../../library/functions.rst:0
msgid ":func:`next`"
msgstr ":func:`next`"

#: ../../library/functions.rst:0
msgid "**O**"
msgstr "**O**"

#: ../../library/functions.rst:0
msgid ":func:`object`"
msgstr ":func:`object`"

#: ../../library/functions.rst:0
msgid ":func:`oct`"
msgstr ":func:`oct`"

#: ../../library/functions.rst:0
msgid ":func:`open`"
msgstr ":func:`open`"

#: ../../library/functions.rst:0
msgid ":func:`ord`"
msgstr ":func:`ord`"

#: ../../library/functions.rst:0
msgid "**P**"
msgstr "**P**"

#: ../../library/functions.rst:0
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/functions.rst:0
msgid ":func:`print`"
msgstr ":func:`print`"

#: ../../library/functions.rst:0
msgid ":func:`property`"
msgstr ":func:`property`"

#: ../../library/functions.rst:0
msgid "**R**"
msgstr "**R**"

#: ../../library/functions.rst:0
msgid "|func-range|_"
msgstr "|func-range|_"

#: ../../library/functions.rst:0
msgid ":func:`repr`"
msgstr ":func:`repr`"

#: ../../library/functions.rst:0
msgid ":func:`reversed`"
msgstr ":func:`reversed`"

#: ../../library/functions.rst:0
msgid ":func:`round`"
msgstr ":func:`round`"

#: ../../library/functions.rst:0
msgid "**S**"
msgstr "**S**"

#: ../../library/functions.rst:0
msgid "|func-set|_"
msgstr "|func-set|_"

#: ../../library/functions.rst:0
msgid ":func:`setattr`"
msgstr ":func:`setattr`"

#: ../../library/functions.rst:0
msgid ":func:`slice`"
msgstr ":func:`slice`"

#: ../../library/functions.rst:0
msgid ":func:`sorted`"
msgstr ":func:`sorted`"

#: ../../library/functions.rst:0
msgid ":func:`staticmethod`"
msgstr ":func:`staticmethod`"

#: ../../library/functions.rst:0
msgid "|func-str|_"
msgstr "|func-str|_"

#: ../../library/functions.rst:0
msgid ":func:`sum`"
msgstr ":func:`sum`"

#: ../../library/functions.rst:0
msgid ":func:`super`"
msgstr ":func:`super`"

#: ../../library/functions.rst:0
msgid "**T**"
msgstr "**T**"

#: ../../library/functions.rst:0
msgid "|func-tuple|_"
msgstr "|func-tuple|_"

#: ../../library/functions.rst:0
msgid ":func:`type`"
msgstr ":func:`type`"

#: ../../library/functions.rst:0
msgid "**V**"
msgstr "**V**"

#: ../../library/functions.rst:0
msgid ":func:`vars`"
msgstr ":func:`vars`"

#: ../../library/functions.rst:0
msgid "**Z**"
msgstr "**Z**"

#: ../../library/functions.rst:0
msgid ":func:`zip`"
msgstr ":func:`zip`"

#: ../../library/functions.rst:0
msgid "**_**"
msgstr "**_**"

#: ../../library/functions.rst:0
msgid ":func:`__import__`"
msgstr ":func:`__import__`"

#: ../../library/functions.rst:59
msgid ""
"Return the absolute value of a number.  The argument may be an integer, a "
"floating-point number, or an object implementing :meth:`~object.__abs__`. If "
"the argument is a complex number, its magnitude is returned."
msgstr ""
"回傳一個數的絕對值，引數可以是整數、浮點數或有實現 :meth:`~object.__abs__` 的"
"物件。如果引數是一個複數，回傳它的純量（大小）。"

#: ../../library/functions.rst:67
msgid ""
"Return an :term:`asynchronous iterator` for an :term:`asynchronous "
"iterable`. Equivalent to calling ``x.__aiter__()``."
msgstr ""
"回傳 :term:`非同步疊代器 <asynchronous iterator>` 做為 :term:`非同步可疊代物"
"件 <asynchronous iterable>`。相當於呼叫 x.__aiter__()。"

#: ../../library/functions.rst:70
msgid "Note: Unlike :func:`iter`, :func:`aiter` has no 2-argument variant."
msgstr "注意：與 :func:`iter` 不同，:func:`aiter` 沒有兩個引數的變體。"

#: ../../library/functions.rst:76
msgid ""
"Return ``True`` if all elements of the *iterable* are true (or if the "
"iterable is empty).  Equivalent to::"
msgstr ""
"如果 *iterable* 的所有元素皆為真（或 iterable 為空）則回傳 ``True``。等價"
"於： ::"

#: ../../library/functions.rst:79
msgid ""
"def all(iterable):\n"
"    for element in iterable:\n"
"        if not element:\n"
"            return False\n"
"    return True"
msgstr ""
"def all(iterable):\n"
"    for element in iterable:\n"
"        if not element:\n"
"            return False\n"
"    return True"

#: ../../library/functions.rst:89
msgid ""
"When awaited, return the next item from the given :term:`asynchronous "
"iterator`, or *default* if given and the iterator is exhausted."
msgstr ""
"當進入 await 時，從給定的 :term:`asynchronous iterator` 中回傳下一個項目"
"（item），疊代完畢則回傳 *default* 。"

#: ../../library/functions.rst:92
msgid ""
"This is the async variant of the :func:`next` builtin, and behaves similarly."
msgstr "這是內建函式 :func:`next` 的非同步版本，其行為類似於："

#: ../../library/functions.rst:95
msgid ""
"This calls the :meth:`~object.__anext__` method of *async_iterator*, "
"returning an :term:`awaitable`. Awaiting this returns the next value of the "
"iterator. If *default* is given, it is returned if the iterator is "
"exhausted, otherwise :exc:`StopAsyncIteration` is raised."
msgstr ""
"呼叫 *async_iterator* 的 :meth:`~object.__anext__` 方法，回傳 :term:"
"`awaitable`。等待返回疊代器的下一個值。如果指定 *default*，當疊代器結束時會返"
"回該值，否則會引發 :exc:`StopAsyncIteration` 。"

#: ../../library/functions.rst:104
msgid ""
"Return ``True`` if any element of the *iterable* is true.  If the iterable "
"is empty, return ``False``.  Equivalent to::"
msgstr ""
"如果 *iterable* 的任一元素為真，回傳 ``True``。如果 iterable 是空的，則回傳 "
"``False``。等價於： ::"

#: ../../library/functions.rst:107
msgid ""
"def any(iterable):\n"
"    for element in iterable:\n"
"        if element:\n"
"            return True\n"
"    return False"
msgstr ""
"def any(iterable):\n"
"    for element in iterable:\n"
"        if element:\n"
"            return True\n"
"    return False"

#: ../../library/functions.rst:116
msgid ""
"As :func:`repr`, return a string containing a printable representation of an "
"object, but escape the non-ASCII characters in the string returned by :func:"
"`repr` using ``\\x``, ``\\u``, or ``\\U`` escapes.  This generates a string "
"similar to that returned by :func:`repr` in Python 2."
msgstr ""
"就像函式 :func:`repr`，回傳一個表示物件的字串，但是 :func:`repr` 回傳的字串中"
"非 ASCII 編碼的字元會被跳脫 (escape)，像是 ``\\x``、``\\u`` 和 ``\\U``。這個"
"函式生成的字串和 Python 2 的 :func:`repr` 回傳的結果相似。"

#: ../../library/functions.rst:124
msgid ""
"Convert an integer number to a binary string prefixed with \"0b\". The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`~object.__index__` method that returns an "
"integer. Some examples:"
msgstr ""
"將一個整數轉變為一個前綴為 \"0b\" 的二進位制字串。結果是一個有效的 Python 運"
"算式。如果 *x* 不是 Python 的 :class:`int` 物件，那它需要定義 :meth:`~object."
"__index__` method 回傳一個整數。舉例來說："

#: ../../library/functions.rst:134
msgid ""
"If the prefix \"0b\" is desired or not, you can use either of the following "
"ways."
msgstr "如果不一定需要 \"0b\" 前綴，還可以使用如下的方法。"

#: ../../library/functions.rst:141 ../../library/functions.rst:909
#: ../../library/functions.rst:1246
msgid "See also :func:`format` for more information."
msgstr "可參考 :func:`format` 獲取更多資訊。"

#: ../../library/functions.rst:146
#, fuzzy
msgid ""
"Return a Boolean value, i.e. one of ``True`` or ``False``.  The argument is "
"converted using the standard :ref:`truth testing procedure <truth>`. If the "
"argument is false or omitted, this returns ``False``; otherwise, it returns "
"``True``.  The :class:`bool` class is a subclass of :class:`int` (see :ref:"
"`typesnumeric`). It cannot be subclassed further.  Its only instances are "
"``False`` and ``True`` (see :ref:`typebool`)."
msgstr ""
"回傳一個布林值，即 ``True`` 或者 ``False``。*x* 使用標準的\\ :ref:`真值測試程"
"序 <truth>`\\ 來轉換。如果 *x* 為假或者被省略，則回傳 ``False``；其他情況回"
"傳 ``True``。:class:`bool` class（類別）是 :class:`int` 的 subclass（子類別）"
"（參見 :ref:`typesnumeric`），其他 class 不能繼承自它。它只有 ``False`` 和 "
"``True`` 兩個實例（參見 :ref:`typebool`）。"

#: ../../library/functions.rst:156 ../../library/functions.rst:774
msgid "The parameter is now positional-only."
msgstr "現在為僅限位置參數。"

#: ../../library/functions.rst:161
msgid ""
"This function drops you into the debugger at the call site.  Specifically, "
"it calls :func:`sys.breakpointhook`, passing ``args`` and ``kws`` straight "
"through.  By default, ``sys.breakpointhook()`` calls :func:`pdb.set_trace` "
"expecting no arguments.  In this case, it is purely a convenience function "
"so you don't have to explicitly import :mod:`pdb` or type as much code to "
"enter the debugger.  However, :func:`sys.breakpointhook` can be set to some "
"other function and :func:`breakpoint` will automatically call that, allowing "
"you to drop into the debugger of choice. If :func:`sys.breakpointhook` is "
"not accessible, this function will raise :exc:`RuntimeError`."
msgstr ""
"這個函式將呼叫 :func:`sys.breakpointhook` 函式，並將 ``args`` 和 ``kws`` 傳遞"
"給它。這將有效地讓你在特定的呼叫點進入除錯器。預設情況下，``sys."
"breakpointhook()`` 呼叫 :func:`pdb.set_trace` 不須帶任何引數。這樣的設計是為"
"了方便使用者，讓他們不需要額外地導入 :mod:`pdb` 模組或輸入太多程式就可以進入"
"除錯器。然而，可以將 :func:`sys.breakpointhook` 設置為其他函式，並且 :func:"
"`breakpoint` 將自動呼叫該函式，讓你進入所選擇的除錯器。如果無法存取 :func:"
"`sys.breakpointhook` 這個函式，則此函式將引發 :exc:`RuntimeError`。"

#: ../../library/functions.rst:173
msgid ""
"By default, the behavior of :func:`breakpoint` can be changed with the :"
"envvar:`PYTHONBREAKPOINT` environment variable. See :func:`sys."
"breakpointhook` for usage details."
msgstr ""
"預設情況下，:func:`breakpoint` 的行為可以透過 :envvar:`PYTHONBREAKPOINT` 環境"
"變數來更改。有關使用詳情，請參考 :func:`sys.breakpointhook`。"

#: ../../library/functions.rst:177
msgid ""
"Note that this is not guaranteed if :func:`sys.breakpointhook` has been "
"replaced."
msgstr "請注意，如果 :func:`sys.breakpointhook` 被替換了，則無法保證此功能。"

#: ../../library/functions.rst:180
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.breakpoint`` with "
"argument ``breakpointhook``."
msgstr ""
"引發一個附帶引數 ``breakpointhook`` 的\\ :ref:`稽核事件 <auditing>` "
"``builtins.breakpoint``。"

#: ../../library/functions.rst:190
msgid ""
"Return a new array of bytes.  The :class:`bytearray` class is a mutable "
"sequence of integers in the range 0 <= x < 256.  It has most of the usual "
"methods of mutable sequences, described in :ref:`typesseq-mutable`, as well "
"as most methods that the :class:`bytes` type has, see :ref:`bytes-methods`."
msgstr ""
"回傳一個新的 bytes 陣列。:class:`bytearray` class 是一個可變的整數序列，包含"
"範圍為 0 <= x < 256 的整數。它有可變序列大部分常見的 method（如在 :ref:"
"`typesseq-mutable` 中所述），同時也有 :class:`bytes` 型別大部分的 method，參"
"見 :ref:`bytes-methods`。"

#: ../../library/functions.rst:195
msgid ""
"The optional *source* parameter can be used to initialize the array in a few "
"different ways:"
msgstr "選擇性參數 *source* 可以被用來以不同的方式初始化陣列："

#: ../../library/functions.rst:198
msgid ""
"If it is a *string*, you must also give the *encoding* (and optionally, "
"*errors*) parameters; :func:`bytearray` then converts the string to bytes "
"using :meth:`str.encode`."
msgstr ""
"如果是一個 *string*，你必須提供 *encoding* 參數（以及選擇性地提供 "
"*errors* ）；:func:`bytearray` 會使用 :meth:`str.encode` method 來將 string "
"轉變成 bytes。"

#: ../../library/functions.rst:202
msgid ""
"If it is an *integer*, the array will have that size and will be initialized "
"with null bytes."
msgstr ""
"如果是一個 *integer*，陣列則會有該數值的長度，並以 null bytes 來當作初始值。"

#: ../../library/functions.rst:205
msgid ""
"If it is an object conforming to the :ref:`buffer interface "
"<bufferobjects>`, a read-only buffer of the object will be used to "
"initialize the bytes array."
msgstr ""
"如果是一個符合 :ref:`buffer 介面 <bufferobjects>`\\ 的物件，該物件的唯讀 "
"buffer 會被用來初始化 bytes 陣列。"

#: ../../library/functions.rst:208
msgid ""
"If it is an *iterable*, it must be an iterable of integers in the range ``0 "
"<= x < 256``, which are used as the initial contents of the array."
msgstr ""
"如果是一個 *iterable*，它的元素必須是範圍為 ``0 <= x < 256`` 的整數，並且會被"
"用作陣列的初始值。"

#: ../../library/functions.rst:211
msgid "Without an argument, an array of size 0 is created."
msgstr "如果沒有引數，則建立長度為 0 的陣列。"

#: ../../library/functions.rst:213
msgid "See also :ref:`binaryseq` and :ref:`typebytearray`."
msgstr "可參考 :ref:`binaryseq` 和 :ref:`typebytearray`。"

#: ../../library/functions.rst:222
msgid ""
"Return a new \"bytes\" object which is an immutable sequence of integers in "
"the range ``0 <= x < 256``.  :class:`bytes` is an immutable version of :"
"class:`bytearray` -- it has the same non-mutating methods and the same "
"indexing and slicing behavior."
msgstr ""
"回傳一個新的 \"bytes\" 物件，會是一個元素是範圍為 ``0 <= x < 256`` 整數的不可"
"變序列。:class:`bytes` 是 :class:`bytearray` 的不可變版本 — 它的同樣具備不改"
"變物件的 method，也有相同的索引和切片操作。"

#: ../../library/functions.rst:227
msgid ""
"Accordingly, constructor arguments are interpreted as for :func:`bytearray`."
msgstr "因此，建構函式的引數和 :func:`bytearray` 相同。"

#: ../../library/functions.rst:229
msgid "Bytes objects can also be created with literals, see :ref:`strings`."
msgstr "Bytes 物件還可以用文字建立，參見 :ref:`strings`。"

#: ../../library/functions.rst:231
msgid "See also :ref:`binaryseq`, :ref:`typebytes`, and :ref:`bytes-methods`."
msgstr "可參考 :ref:`binaryseq`、:ref:`typebytes` 和 :ref:`bytes-methods`。"

#: ../../library/functions.rst:236
msgid ""
"Return :const:`True` if the *object* argument appears callable, :const:"
"`False` if not.  If this returns ``True``, it is still possible that a call "
"fails, but if it is ``False``, calling *object* will never succeed. Note "
"that classes are callable (calling a class returns a new instance); "
"instances are callable if their class has a :meth:`~object.__call__` method."
msgstr ""
"如果引數 *object* 是可呼叫的，回傳 :const:`True`，否則回傳 :const:`False`。如"
"果回傳 ``True``，呼叫仍可能會失敗；但如果回傳 ``False``，則呼叫 *object* 肯定"
"會失敗。注意 class 是可呼叫的（呼叫 class 會回傳一個新的實例）；如果實例的 "
"class 有定義 :meth:`~object.__call__` method，則它是可呼叫的。"

#: ../../library/functions.rst:242
msgid ""
"This function was first removed in Python 3.0 and then brought back in "
"Python 3.2."
msgstr "這個函式一開始在 Python 3.0 被移除，但在 Python 3.2 又被重新加入。"

#: ../../library/functions.rst:249
msgid ""
"Return the string representing a character whose Unicode code point is the "
"integer *i*.  For example, ``chr(97)`` returns the string ``'a'``, while "
"``chr(8364)`` returns the string ``'€'``. This is the inverse of :func:`ord`."
msgstr ""
"回傳代表字元之 Unicode 編碼位置為整數 *i* 的字串。例如，``chr(97)`` 回傳字串 "
"``'a'``，而 ``chr(8364)`` 回傳字串 ``'€'``。這是 :func:`ord` 的逆函式。"

#: ../../library/functions.rst:253
msgid ""
"The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in "
"base 16).  :exc:`ValueError` will be raised if *i* is outside that range."
msgstr ""
"引數的有效範圍是 0 到 1,114,111（16 進制表示為 0x10FFFF）。如果 *i* 超過這個"
"範圍，會引發 :exc:`ValueError`。"

#: ../../library/functions.rst:259
msgid "Transform a method into a class method."
msgstr "把一個 method 封裝成 class method（類別方法）。"

#: ../../library/functions.rst:261
msgid ""
"A class method receives the class as an implicit first argument, just like "
"an instance method receives the instance. To declare a class method, use "
"this idiom::"
msgstr ""
"一個 class method 把自己的 class 作為第一個引數，就像一個實例 method 把實例自"
"己作為第一個引數。請用以下慣例來宣告 class method： ::"

#: ../../library/functions.rst:265
msgid ""
"class C:\n"
"    @classmethod\n"
"    def f(cls, arg1, arg2): ..."
msgstr ""
"class C:\n"
"    @classmethod\n"
"    def f(cls, arg1, arg2): ..."

#: ../../library/functions.rst:269
msgid ""
"The ``@classmethod`` form is a function :term:`decorator` -- see :ref:"
"`function` for details."
msgstr ""
"``@classmethod`` 語法是一個函式 :term:`decorator` — 參見 :ref:`function` 中關"
"於函式定義的詳細介紹。"

#: ../../library/functions.rst:272
msgid ""
"A class method can be called either on the class (such as ``C.f()``) or on "
"an instance (such as ``C().f()``).  The instance is ignored except for its "
"class. If a class method is called for a derived class, the derived class "
"object is passed as the implied first argument."
msgstr ""
"一個 class method 可以在 class（如 ``C.f()``）或實例（如 ``C().f()``）上呼"
"叫。實例除了它的 class 資訊，其他都會被忽略。如果一個 class method 在 "
"subclass 上呼叫，subclass 會作為第一個引數傳入。"

#: ../../library/functions.rst:277
msgid ""
"Class methods are different than C++ or Java static methods. If you want "
"those, see :func:`staticmethod` in this section. For more information on "
"class methods, see :ref:`types`."
msgstr ""
"Class method 和 C++ 與 Java 的 static method 是有區別的。如果你想瞭解 static "
"method，請看本節的 :func:`staticmethod`。關於 class method 的更多資訊，請參考"
"\\ :ref:`types`。"

#: ../../library/functions.rst:281
msgid ""
"Class methods can now wrap other :term:`descriptors <descriptor>` such as :"
"func:`property`."
msgstr ""
"Class methods 現在可以包裝其他\\ :term:`描述器 <descriptor>`，例如 :func:"
"`property`"

#: ../../library/functions.rst:285
msgid ""
"Class methods now inherit the method attributes (``__module__``, "
"``__name__``, ``__qualname__``, ``__doc__`` and ``__annotations__``) and "
"have a new ``__wrapped__`` attribute."
msgstr ""
"Class method 現在繼承了 method 屬性（``__module__``、``__name__``、"
"``__qualname__``、``__doc__`` 和 ``__annotations__``），並擁有一個新的 "
"``__wrapped__`` 屬性。"

#: ../../library/functions.rst:290
msgid ""
"Class methods can no longer wrap other :term:`descriptors <descriptor>` such "
"as :func:`property`."
msgstr ""
"Class methods 不能再包裝其他的\\ :term:`描述器 <descriptor>`，例如 :func:"
"`property`。"

#: ../../library/functions.rst:297
msgid ""
"Compile the *source* into a code or AST object.  Code objects can be "
"executed by :func:`exec` or :func:`eval`.  *source* can either be a normal "
"string, a byte string, or an AST object.  Refer to the :mod:`ast` module "
"documentation for information on how to work with AST objects."
msgstr ""
"將 *source* 編譯成程式碼或 AST 物件。程式碼物件可以被 :func:`exec` 或 :func:"
"`eval` 執行。*source* 可以是一般的字串、bytes 字串、或者 AST 物件。參見 :mod:"
"`ast` module（模組）的說明文件瞭解如何使用 AST 物件。"

#: ../../library/functions.rst:302
msgid ""
"The *filename* argument should give the file from which the code was read; "
"pass some recognizable value if it wasn't read from a file (``'<string>'`` "
"is commonly used)."
msgstr ""
"*filename* 引數必須是程式碼的檔名；如果程式碼不是從檔案中讀取，可以傳入一些可"
"辨識的值（經常會使用 ``'<string>'`` 來替代）。"

#: ../../library/functions.rst:306
msgid ""
"The *mode* argument specifies what kind of code must be compiled; it can be "
"``'exec'`` if *source* consists of a sequence of statements, ``'eval'`` if "
"it consists of a single expression, or ``'single'`` if it consists of a "
"single interactive statement (in the latter case, expression statements that "
"evaluate to something other than ``None`` will be printed)."
msgstr ""
"*mode* 引數指定了編譯程式碼時必須用的模式。如果 *source* 是一系列的陳述式，可"
"以是 ``'exec'``；如果是單一運算式，可以是 ``'eval'``；如果是單個互動式陳述"
"式，可以是 ``'single'``\\ （在最後一種情況下，如果運算式執行結果不是 "
"``None`` 則會被印出來）。"

#: ../../library/functions.rst:312
msgid ""
"The optional arguments *flags* and *dont_inherit* control which :ref:"
"`compiler options <ast-compiler-flags>` should be activated and which :ref:"
"`future features <future>` should be allowed. If neither is present (or both "
"are zero) the code is compiled with the same flags that affect the code that "
"is calling :func:`compile`. If the *flags* argument is given and "
"*dont_inherit* is not (or is zero) then the compiler options and the future "
"statements specified by the *flags* argument are used in addition to those "
"that would be used anyway. If *dont_inherit* is a non-zero integer then the "
"*flags* argument is it -- the flags (future features and compiler options) "
"in the surrounding code are ignored."
msgstr ""
"可選引數 *flags* 和 *dont_inherit* 控制啟用哪個\\ :ref:`編譯器選項 <ast-"
"compiler-flags>`\\ 以及允許哪個\\ :ref:`未來功能 <future>`。如果兩者都不存在"
"（或兩者都為零），則會呼叫與 :func:`compile` 相同旗標的程式碼來編譯。如果給"
"定 *flags* 引數而未給定 *dont_inherit*（或為零）則無論如何都會使用由 *flags* "
"引數所指定的編譯器選項和未來陳述式。如果 *dont_inherit* 是一個非零整數，則使"
"用 *flags* 引數 －－ 周圍程式碼中的旗標（未來功能和編譯器選項）將被忽略。"

#: ../../library/functions.rst:323
msgid ""
"Compiler options and future statements are specified by bits which can be "
"bitwise ORed together to specify multiple options. The bitfield required to "
"specify a given future feature can be found as the :attr:`~__future__."
"_Feature.compiler_flag` attribute on the :class:`~__future__._Feature` "
"instance in the :mod:`__future__` module. :ref:`Compiler flags <ast-compiler-"
"flags>` can be found in :mod:`ast` module, with ``PyCF_`` prefix."
msgstr ""
"編譯器選項和 future 陳述式使用 bits 來表示，可以一起被位元操作 OR 來表示複數"
"個選項。需要被具體定義特徵的位元域可以透過 :mod:`__future__` module 中 :"
"class:`~__future__._Feature` 實例中的 :attr:`~__future__._Feature."
"compiler_flag` 屬性來獲得。:ref:`編譯器旗標 <ast-compiler-flags>`\\ 可以在 :"
"mod:`ast` module 中搜尋有 ``PyCF_`` 前綴的名稱。"

#: ../../library/functions.rst:331
msgid ""
"The argument *optimize* specifies the optimization level of the compiler; "
"the default value of ``-1`` selects the optimization level of the "
"interpreter as given by :option:`-O` options.  Explicit levels are ``0`` (no "
"optimization; ``__debug__`` is true), ``1`` (asserts are removed, "
"``__debug__`` is false) or ``2`` (docstrings are removed too)."
msgstr ""
"引數 *optimize* 用來指定編譯器的最佳化級別；預設值 ``-1`` 選擇與直譯器的 :"
"option:`-O` 選項相同的最佳化級別。其他級別為 ``0``\\ （沒有最佳化；\\ "
"``__debug__`` 為真值）、``1``\\ （assert 被刪除，``__debug__`` 為假值）或 "
"``2``\\ （說明字串 (docstring) 也被刪除）。"

#: ../../library/functions.rst:337
msgid ""
"This function raises :exc:`SyntaxError` if the compiled source is invalid, "
"and :exc:`ValueError` if the source contains null bytes."
msgstr ""
"如果編譯的原始碼無效，此函式會引發 :exc:`SyntaxError`，如果原始碼包含 null "
"bytes，則會引發 :exc:`ValueError`。"

#: ../../library/functions.rst:340
msgid ""
"If you want to parse Python code into its AST representation, see :func:`ast."
"parse`."
msgstr "如果你想解析 Python 程式碼為 AST 運算式，請參閱 :func:`ast.parse`。"

#: ../../library/functions.rst:343 ../../library/functions.rst:345
msgid ""
"Raises an :ref:`auditing event <auditing>` ``compile`` with arguments "
"``source`` and ``filename``. This event may also be raised by implicit "
"compilation."
msgstr ""
"引發一個附帶引數 ``source``、``filename`` 的\\ :ref:`稽核事件 <auditing>` "
"``compile``。此事件也可能由隱式編譯 (implicit compilation) 所引發。"

#: ../../library/functions.rst:351
msgid ""
"When compiling a string with multi-line code in ``'single'`` or ``'eval'`` "
"mode, input must be terminated by at least one newline character.  This is "
"to facilitate detection of incomplete and complete statements in the :mod:"
"`code` module."
msgstr ""
"在 ``'single'`` 或 ``'eval'`` 模式編譯多行程式碼時，輸入必須以至少一個換行符"
"結尾。這使 :mod:`code` module 更容易檢測陳述式的完整性。"

#: ../../library/functions.rst:358
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string when compiling to an AST object due to stack depth "
"limitations in Python's AST compiler."
msgstr ""
"如果編譯足夠大或者足夠複雜的字串成 AST 物件時，Python 直譯器會因為 Python "
"AST 編譯器的 stack 深度限制而崩潰。"

#: ../../library/functions.rst:362
msgid ""
"Allowed use of Windows and Mac newlines.  Also, input in ``'exec'`` mode "
"does not have to end in a newline anymore.  Added the *optimize* parameter."
msgstr ""
"允許使用 Windows 和 Mac 的換行符號。此外，在 ``'exec'`` 模式不需要以換行符號"
"結尾。增加了 *optimize* 參數。"

#: ../../library/functions.rst:366
msgid ""
"Previously, :exc:`TypeError` was raised when null bytes were encountered in "
"*source*."
msgstr "在之前的版本，*source* 中包含 null bytes 會引發 :exc:`TypeError`。"

#: ../../library/functions.rst:370
msgid ""
"``ast.PyCF_ALLOW_TOP_LEVEL_AWAIT`` can now be passed in flags to enable "
"support for top-level ``await``, ``async for``, and ``async with``."
msgstr ""
"``ast.PyCF_ALLOW_TOP_LEVEL_AWAIT`` 現在可以傳遞旗標以啟用對頂層 ``await``、"
"``async for`` 和 ``async with`` 的支援。"

#: ../../library/functions.rst:379
msgid ""
"Convert a single string or number to a complex number, or create a complex "
"number from real and imaginary parts."
msgstr ""

#: ../../library/functions.rst:382 ../../library/functions.rst:719
#: ../../library/functions.rst:965
msgid "Examples:"
msgstr "例如： ::"

#: ../../library/functions.rst:384
msgid ""
">>> complex('+1.23')\n"
"(1.23+0j)\n"
">>> complex('-4.5j')\n"
"-4.5j\n"
">>> complex('-1.23+4.5j')\n"
"(-1.23+4.5j)\n"
">>> complex('\\t( -1.23+4.5J )\\n')\n"
"(-1.23+4.5j)\n"
">>> complex('-Infinity+NaNj')\n"
"(-inf+nanj)\n"
">>> complex(1.23)\n"
"(1.23+0j)\n"
">>> complex(imag=-4.5)\n"
"-4.5j\n"
">>> complex(-1.23, 4.5)\n"
"(-1.23+4.5j)"
msgstr ""
">>> complex('+1.23')\n"
"(1.23+0j)\n"
">>> complex('-4.5j')\n"
"-4.5j\n"
">>> complex('-1.23+4.5j')\n"
"(-1.23+4.5j)\n"
">>> complex('\\t( -1.23+4.5J )\\n')\n"
"(-1.23+4.5j)\n"
">>> complex('-Infinity+NaNj')\n"
"(-inf+nanj)\n"
">>> complex(1.23)\n"
"(1.23+0j)\n"
">>> complex(imag=-4.5)\n"
"-4.5j\n"
">>> complex(-1.23, 4.5)\n"
"(-1.23+4.5j)"

#: ../../library/functions.rst:403
msgid ""
"If the argument is a string, it must contain either a real part (in the same "
"format as for :func:`float`) or an imaginary part (in the same format but "
"with a ``'j'`` or ``'J'`` suffix), or both real and imaginary parts (the "
"sign of the imaginary part is mandatory in this case). The string can "
"optionally be surrounded by whitespaces and the round parentheses ``'('`` "
"and ``')'``, which are ignored. The string must not contain whitespace "
"between ``'+'``, ``'-'``, the ``'j'`` or ``'J'`` suffix, and the decimal "
"number. For example, ``complex('1+2j')`` is fine, but ``complex('1 + 2j')`` "
"raises :exc:`ValueError`. More precisely, the input must conform to the :"
"token:`~float:complexvalue` production rule in the following grammar, after "
"parentheses and leading and trailing whitespace characters are removed:"
msgstr ""

#: ../../library/functions.rst:422
#, fuzzy
msgid ""
"If the argument is a number, the constructor serves as a numeric conversion "
"like :class:`int` and :class:`float`. For a general Python object ``x``, "
"``complex(x)`` delegates to ``x.__complex__()``. If :meth:`~object."
"__complex__` is not defined then it falls back to :meth:`~object.__float__`. "
"If :meth:`!__float__` is not defined then it falls back to :meth:`~object."
"__index__`."
msgstr ""
"對於一個普通的 Python 物件 ``x``，``complex(x)`` 會委派給 ``x."
"__complex__()``。如果 :meth:`~object.__complex__` 未定義，則會回退 (fall "
"back) 到 :meth:`~object.__float__`。如果 :meth:`!__float__` 未定義，則會再回"
"退到 :meth:`~object.__index__`。"

#: ../../library/functions.rst:431
msgid ""
"If two arguments are provided or keyword arguments are used, each argument "
"may be any numeric type (including complex). If both arguments are real "
"numbers, return a complex number with the real component *real* and the "
"imaginary component *imag*. If both arguments are complex numbers, return a "
"complex number with the real component ``real.real-imag.imag`` and the "
"imaginary component ``real.imag+imag.real``. If one of arguments is a real "
"number, only its real component is used in the above expressions."
msgstr ""

#: ../../library/functions.rst:441
msgid "If all arguments are omitted, returns ``0j``."
msgstr ""

#: ../../library/functions.rst:443
msgid "The complex type is described in :ref:`typesnumeric`."
msgstr "複數型別在 :ref:`typesnumeric` 中有相關描述。"

#: ../../library/functions.rst:445 ../../library/functions.rst:771
#: ../../library/functions.rst:1014
msgid "Grouping digits with underscores as in code literals is allowed."
msgstr "可以使用底線將程式碼文字中的數字進行分組。"

#: ../../library/functions.rst:448
msgid ""
"Falls back to :meth:`~object.__index__` if :meth:`~object.__complex__` and :"
"meth:`~object.__float__` are not defined."
msgstr ""
"如果 :meth:`~object.__complex__` 和 :meth:`~object.__float__` 未定義，則會回"
"退到 :meth:`~object.__index__`。"

#: ../../library/functions.rst:455
msgid ""
"This is a relative of :func:`setattr`.  The arguments are an object and a "
"string.  The string must be the name of one of the object's attributes.  The "
"function deletes the named attribute, provided the object allows it.  For "
"example, ``delattr(x, 'foobar')`` is equivalent to ``del x.foobar``. *name* "
"need not be a Python identifier (see :func:`setattr`)."
msgstr ""
"這是 :func:`setattr` 相關的函式。引數是一個物件和一個字串，該字串必須是物件中"
"某個屬性名稱。如果物件允許，該函式將刪除指定的屬性。例如 ``delattr(x, "
"'foobar')`` 等價於 ``del x.foobar``。*name* 不必是個 Python 識別符 "
"(identifier)（請見 :func:`setattr`）。"

#: ../../library/functions.rst:468
msgid ""
"Create a new dictionary.  The :class:`dict` object is the dictionary class. "
"See :class:`dict` and :ref:`typesmapping` for documentation about this class."
msgstr ""
"建立一個新的 dictionary（字典）。:class:`dict` 物件是一個 dictionary class。"
"參見 :class:`dict` 和 :ref:`typesmapping` 來瞭解這個 class。"

#: ../../library/functions.rst:471
msgid ""
"For other containers see the built-in :class:`list`, :class:`set`, and :"
"class:`tuple` classes, as well as the :mod:`collections` module."
msgstr ""
"其他容器型別，請參見內建的 :class:`list`、:class:`set` 和 :class:`tuple` "
"class，以及 :mod:`collections` module。"

#: ../../library/functions.rst:478
msgid ""
"Without arguments, return the list of names in the current local scope.  "
"With an argument, attempt to return a list of valid attributes for that "
"object."
msgstr ""
"如果沒有引數，則回傳當前區域作用域 (local scope) 中的名稱列表。如果有引數，它"
"會嘗試回傳該物件的有效屬性列表。"

#: ../../library/functions.rst:481
msgid ""
"If the object has a method named :meth:`~object.__dir__`, this method will "
"be called and must return the list of attributes. This allows objects that "
"implement a custom :func:`~object.__getattr__` or :func:`~object."
"__getattribute__` function to customize the way :func:`dir` reports their "
"attributes."
msgstr ""
"如果物件有一個名為 :meth:`~object.__dir__` 的 method，那麼該 method 將被呼"
"叫，並且必須回傳一個屬性列表。這允許實現自定義 :func:`~object.__getattr__` "
"或 :func:`~object.__getattribute__` 函式的物件能夠自定義 :func:`dir` 來報告它"
"們的屬性。"

#: ../../library/functions.rst:488
msgid ""
"If the object does not provide :meth:`~object.__dir__`, the function tries "
"its best to gather information from the object's :attr:`~object.__dict__` "
"attribute, if defined, and from its type object.  The resulting list is not "
"necessarily complete and may be inaccurate when the object has a custom :"
"func:`~object.__getattr__`."
msgstr ""
"如果物件不提供 :meth:`~object.__dir__`，這個函式會嘗試從物件已定義的 :attr:"
"`~object.__dict__` 屬性和型別物件收集資訊。結果列表並不總是完整的，如果物件有"
"自定義 :func:`~object.__getattr__`，那結果可能不準確。"

#: ../../library/functions.rst:494
msgid ""
"The default :func:`dir` mechanism behaves differently with different types "
"of objects, as it attempts to produce the most relevant, rather than "
"complete, information:"
msgstr ""
"預設的 :func:`dir` 機制對不同型別的物件有不同行為，它會試圖回傳最相關而非最完"
"整的資訊："

#: ../../library/functions.rst:498
msgid ""
"If the object is a module object, the list contains the names of the "
"module's attributes."
msgstr "如果物件是 module 物件，則列表包含 module 的屬性名稱。"

#: ../../library/functions.rst:501
msgid ""
"If the object is a type or class object, the list contains the names of its "
"attributes, and recursively of the attributes of its bases."
msgstr ""
"如果物件是型別或 class 物件，則列表包含它們的屬性名稱，並且遞迴查詢其基礎的所"
"有屬性。"

#: ../../library/functions.rst:504
msgid ""
"Otherwise, the list contains the object's attributes' names, the names of "
"its class's attributes, and recursively of the attributes of its class's "
"base classes."
msgstr ""
"否則，包含物件的屬性名稱列表、它的 class 屬性名稱，並且遞迴查詢它的 class 的"
"所有基礎 class 的屬性。"

#: ../../library/functions.rst:508
msgid "The resulting list is sorted alphabetically.  For example:"
msgstr "回傳的列表按字母表排序，例如："

#: ../../library/functions.rst:528
msgid ""
"Because :func:`dir` is supplied primarily as a convenience for use at an "
"interactive prompt, it tries to supply an interesting set of names more than "
"it tries to supply a rigorously or consistently defined set of names, and "
"its detailed behavior may change across releases.  For example, metaclass "
"attributes are not in the result list when the argument is a class."
msgstr ""
"因為 :func:`dir` 主要是為了便於在互動式提示字元時使用，所以它會試圖回傳人們感"
"興趣的名稱集合，而不是試圖保證結果的嚴格性或一致性，它具體的行為也可能在不同"
"版本之間改變。例如，當引數是一個 class 時，metaclass 的屬性不包含在結果列表"
"中。"

#: ../../library/functions.rst:538
msgid ""
"Take two (non-complex) numbers as arguments and return a pair of numbers "
"consisting of their quotient and remainder when using integer division.  "
"With mixed operand types, the rules for binary arithmetic operators apply.  "
"For integers, the result is the same as ``(a // b, a % b)``. For floating-"
"point numbers the result is ``(q, a % b)``, where *q* is usually ``math."
"floor(a / b)`` but may be 1 less than that.  In any case ``q * b + a % b`` "
"is very close to *a*, if ``a % b`` is non-zero it has the same sign as *b*, "
"and ``0 <= abs(a % b) < abs(b)``."
msgstr ""
"它將兩個（非複數）數字作為引數，並在執行整數除法時回傳一對商和餘數。對於混合"
"運算元型別，適用二進位算術運算子的規則。對於整數，運算結果和 ``(a // b, a % "
"b)`` 一致。對於浮點數，運算結果是 ``(q, a % b)``，*q* 通常是 ``math."
"floor(a / b)`` 但可能會比 1 小。在任何情況下，``q * b + a % b`` 和 *a* 基本相"
"等，如果 ``a % b`` 非零，則它的符號和 *b* 一樣，且 ``0 <= abs(a % b) < "
"abs(b)``。"

#: ../../library/functions.rst:550
msgid ""
"Return an enumerate object. *iterable* must be a sequence, an :term:"
"`iterator`, or some other object which supports iteration. The :meth:"
"`~iterator.__next__` method of the iterator returned by :func:`enumerate` "
"returns a tuple containing a count (from *start* which defaults to 0) and "
"the values obtained from iterating over *iterable*."
msgstr ""
"回傳一個列舉 (enumerate) 物件。*iterable* 必須是一個序列、:term:`iterator` 或"
"其他支援疊代的物件。:func:`enumerate` 回傳之 iterator 的 :meth:`~iterator."
"__next__` method 回傳一個 tuple（元組），裡面包含一個計數值（從 *start* 開"
"始，預設為 0）和透過疊代 *iterable* 獲得的值。"

#: ../../library/functions.rst:562
msgid "Equivalent to::"
msgstr "等價於： ::"

#: ../../library/functions.rst:564
msgid ""
"def enumerate(iterable, start=0):\n"
"    n = start\n"
"    for elem in iterable:\n"
"        yield n, elem\n"
"        n += 1"
msgstr ""
"def enumerate(iterable, start=0):\n"
"    n = start\n"
"    for elem in iterable:\n"
"        yield n, elem\n"
"        n += 1"

#: ../../library/functions.rst:0
msgid "Parameters"
msgstr ""

#: ../../library/functions.rst:574
msgid "A Python expression."
msgstr ""

#: ../../library/functions.rst:578
msgid "The global namespace (default: ``None``)."
msgstr ""

#: ../../library/functions.rst:582
msgid "The local namespace (default: ``None``)."
msgstr ""

#: ../../library/functions.rst:0
msgid "Returns"
msgstr ""

#: ../../library/functions.rst:586
msgid "The result of the evaluated expression."
msgstr ""

#: ../../library/functions.rst:0
msgid "raises"
msgstr "引發"

#: ../../library/functions.rst:587
msgid "Syntax errors are reported as exceptions."
msgstr ""

#: ../../library/functions.rst:589
msgid ""
"The *expression* argument is parsed and evaluated as a Python expression "
"(technically speaking, a condition list) using the *globals* and *locals* "
"dictionaries as global and local namespace.  If the *globals* dictionary is "
"present and does not contain a value for the key ``__builtins__``, a "
"reference to the dictionary of the built-in module :mod:`builtins` is "
"inserted under that key before *expression* is parsed.  That way you can "
"control what builtins are available to the executed code by inserting your "
"own ``__builtins__`` dictionary into *globals* before passing it to :func:"
"`eval`.  If the *locals* dictionary is omitted it defaults to the *globals* "
"dictionary.  If both dictionaries are omitted, the expression is executed "
"with the *globals* and *locals* in the environment where :func:`eval` is "
"called.  Note, *eval()* does not have access to the :term:`nested scopes "
"<nested scope>` (non-locals) in the enclosing environment."
msgstr ""
"*expression* 引數會被視為一條 Python 運算式（技術上而言，是條件列表）來剖析及"
"求值，而 *globals* 和 *locals* dictionaries 分別用作全域和區域命名空間。如果 "
"*globals* dictionary 存在但缺少 ``__builtins__`` 的鍵值，那 *expression* 被剖"
"析之前，將為該鍵插入對內建 :mod:`builtins` module dictionary 的引用。這麼一"
"來，在將 ``__builtins__`` dictionary 傳入 :func:`eval` 之前，你可以透過將它插"
"入 *globals* 來控制你需要哪些內建函式來執行程式碼。如果 *locals* 被省略，那它"
"的預設值是 *globals* dictionary。如果兩個 dictionary 引數都被省略，則在 :"
"func:`eval` 被呼叫的環境中執行運算式。請注意，*eval()* 在封閉 (enclosing) 環"
"境中無法存取\\ :term:`巢狀作用域 <nested scope>` (non-locals)。"

#: ../../library/functions.rst:604
msgid "Example:"
msgstr "範例："

#: ../../library/functions.rst:610
msgid ""
"This function can also be used to execute arbitrary code objects (such as "
"those created by :func:`compile`).  In this case, pass a code object instead "
"of a string.  If the code object has been compiled with ``'exec'`` as the "
"*mode* argument, :func:`eval`\\'s return value will be ``None``."
msgstr ""
"這個函式也可以用來執行任意程式碼物件（如被 :func:`compile` 建立的那些）。這種"
"情況下，傳入的引數是程式碼物件而不是字串。如果編譯該物件時的 *mode* 引數是 "
"``'exec'``，那麼 :func:`eval` 回傳值為 ``None``。"

#: ../../library/functions.rst:615
msgid ""
"Hints: dynamic execution of statements is supported by the :func:`exec` "
"function.  The :func:`globals` and :func:`locals` functions return the "
"current global and local dictionary, respectively, which may be useful to "
"pass around for use by :func:`eval` or :func:`exec`."
msgstr ""
"提示：:func:`exec` 函式支援動態執行陳述式。:func:`globals` 和 :func:`locals` "
"函式分別回傳當前的全域性和局部性 dictionary，它們對於將引數傳遞給 :func:"
"`eval` 或 :func:`exec` 可能會方便許多。"

#: ../../library/functions.rst:620
msgid ""
"If the given source is a string, then leading and trailing spaces and tabs "
"are stripped."
msgstr "如果給定來源是一個字串，那麼其前後的空格和定位字元會被移除。"

#: ../../library/functions.rst:623
msgid ""
"See :func:`ast.literal_eval` for a function that can safely evaluate strings "
"with expressions containing only literals."
msgstr ""
"另外可以參閱 :func:`ast.literal_eval`，該函式可以安全執行僅包含文字的運算式字"
"串。"

#: ../../library/functions.rst:626 ../../library/functions.rst:628
#: ../../library/functions.rst:671 ../../library/functions.rst:673
msgid ""
"Raises an :ref:`auditing event <auditing>` ``exec`` with the code object as "
"the argument. Code compilation events may also be raised."
msgstr ""
"引發一個附帶程式碼物件為引數的\\ :ref:`稽核事件 <auditing>` ``exec``。也可能"
"會引發程式碼編譯事件。"

#: ../../library/functions.rst:635
msgid ""
"This function supports dynamic execution of Python code. *object* must be "
"either a string or a code object.  If it is a string, the string is parsed "
"as a suite of Python statements which is then executed (unless a syntax "
"error occurs). [#]_ If it is a code object, it is simply executed.  In all "
"cases, the code that's executed is expected to be valid as file input (see "
"the section :ref:`file-input` in the Reference Manual). Be aware that the :"
"keyword:`nonlocal`, :keyword:`yield`,  and :keyword:`return` statements may "
"not be used outside of function definitions even within the context of code "
"passed to the :func:`exec` function. The return value is ``None``."
msgstr ""
"這個函式支援動態執行 Python 程式碼。*object* 必須是字串或者程式碼物件。如果是"
"字串，那麼該字串將被剖析為一系列 Python 陳述式並執行（除非發生語法錯誤）。"
"[#]_ 如果是程式碼物件，它將被直接執行。無論哪種情況，被執行的程式碼都需要和檔"
"案輸入一樣是有效的（可參閱語言參考手冊中關於\\ :ref:`file-input`\\ 的章節）。"
"請注意，即使在傳遞給 :func:`exec` 函式的程式碼的上下文中，:keyword:"
"`nonlocal`、:keyword:`yield` 和 :keyword:`return` 陳述式也不能在函式之外使"
"用。該函式回傳值是 ``None``。"

#: ../../library/functions.rst:646
#, fuzzy
msgid ""
"In all cases, if the optional parts are omitted, the code is executed in the "
"current scope.  If only *globals* is provided, it must be a dictionary (and "
"not a subclass of dictionary), which will be used for both the global and "
"the local variables.  If *globals* and *locals* are given, they are used for "
"the global and local variables, respectively.  If provided, *locals* can be "
"any mapping object.  Remember that at the module level, globals and locals "
"are the same dictionary."
msgstr ""
"無論哪種情況，如果省略了選擇性引數，程式碼將在當前作用域內執行。如果只提供了 "
"*globals* 引數，就必須是 dictionary 型別，而且會被用作全域性和本地變數。如果"
"同時提供了 *globals* 和 *locals* 引數，它們分別被用作全域性和本地變數。如果提"
"供了 *locals* 引數，則它可以是任何映射物件。請記住在 module 層級中全域性和本"
"地變數是相同的 dictionary。"

#: ../../library/functions.rst:656
msgid ""
"Most users should just pass a *globals* argument and never *locals*. If exec "
"gets two separate objects as *globals* and *locals*, the code will be "
"executed as if it were embedded in a class definition."
msgstr ""
"大部分使用者只需要傳入 *globals* 引數，而不用傳遞  *locals*。如果 exec 有兩個"
"不同的 *globals* 和 *locals* 物件，程式碼就像嵌入在 class 定義中一樣執行。"

#: ../../library/functions.rst:660
msgid ""
"If the *globals* dictionary does not contain a value for the key "
"``__builtins__``, a reference to the dictionary of the built-in module :mod:"
"`builtins` is inserted under that key.  That way you can control what "
"builtins are available to the executed code by inserting your own "
"``__builtins__`` dictionary into *globals* before passing it to :func:`exec`."
msgstr ""
"如果 *globals* dictionary 不包含 ``__builtins__`` 鍵值，則將為該鍵插入對內"
"建 :mod:`builtins` module dictionary 的引用。這麼一來，在將 ``__builtins__`` "
"dictionary 傳入 :func:`exec` 之前，你可以透過將它插入 *globals* 來控制你需要"
"哪些內建函式來執行程式碼。"

#: ../../library/functions.rst:666
msgid ""
"The *closure* argument specifies a closure--a tuple of cellvars. It's only "
"valid when the *object* is a code object containing free variables. The "
"length of the tuple must exactly match the number of free variables "
"referenced by the code object."
msgstr ""
"*closure* 引數會指定一個閉包 (closure) — 它是一個 cellvar（格變數）的 tuple。"
"只有在 *object* 是一個含有自由變數 (free variable) 的程式碼物件時，它才有效。"
"Tuple 的長度必須與程式碼物件所引用的自由變數數量完全匹配。"

#: ../../library/functions.rst:678
msgid ""
"The built-in functions :func:`globals` and :func:`locals` return the current "
"global and local dictionary, respectively, which may be useful to pass "
"around for use as the second and third argument to :func:`exec`."
msgstr ""
"內建 :func:`globals` 和 :func:`locals` 函式各自回傳當前的全域性和本地 "
"dictionary，因此可以將它們傳遞給 :func:`exec` 的第二個和第三個引數。"

#: ../../library/functions.rst:684
msgid ""
"The default *locals* act as described for function :func:`locals` below: "
"modifications to the default *locals* dictionary should not be attempted. "
"Pass an explicit *locals* dictionary if you need to see effects of the code "
"on *locals* after function :func:`exec` returns."
msgstr ""
"預設情況下，*locals* 的行為如下面 :func:`locals` 函式描述的一樣：不要試圖改變"
"預設的 *locals* dictionary。如果你想在 :func:`exec` 函式回傳時知道程式碼對 "
"*locals* 的變動，請明確地傳遞 *locals* dictionary 。"

#: ../../library/functions.rst:689
msgid "Added the *closure* parameter."
msgstr "增加了 *closure* 參數。"

#: ../../library/functions.rst:695
msgid ""
"Construct an iterator from those elements of *iterable* for which *function* "
"is true.  *iterable* may be either a sequence, a container which supports "
"iteration, or an iterator.  If *function* is ``None``, the identity function "
"is assumed, that is, all elements of *iterable* that are false are removed."
msgstr ""
"用 *iterable* 中函式 *function* 為 True 的那些元素，構建一個新的 iterator。"
"*iterable* 可以是一個序列、一個支援疊代的容器、或一個 iterator。如果 "
"*function* 是 ``None``，則會假設它是一個識別性函式，即 *iterable* 中所有假值"
"元素會被移除。"

#: ../../library/functions.rst:701
msgid ""
"Note that ``filter(function, iterable)`` is equivalent to the generator "
"expression ``(item for item in iterable if function(item))`` if function is "
"not ``None`` and ``(item for item in iterable if item)`` if function is "
"``None``."
msgstr ""
"請注意，``filter(function, iterable)`` 相當於一個生成器運算式，當 function 不"
"是 ``None`` 的時候為 ``(item for item in iterable if function(item))``；"
"function 是 ``None`` 的時候為 ``(item for item in iterable if item)``。"

#: ../../library/functions.rst:706
msgid ""
"See :func:`itertools.filterfalse` for the complementary function that "
"returns elements of *iterable* for which *function* is false."
msgstr ""
"請參閱 :func:`itertools.filterfalse`，只有 *function* 為 false 時才選取 "
"*iterable* 中元素的互補函式。"

#: ../../library/functions.rst:717
msgid "Return a floating-point number constructed from a number or a string."
msgstr "回傳從數字或字串生成的浮點數。"

#: ../../library/functions.rst:721
msgid ""
">>> float('+1.23')\n"
"1.23\n"
">>> float('   -12345\\n')\n"
"-12345.0\n"
">>> float('1e-003')\n"
"0.001\n"
">>> float('+1E6')\n"
"1000000.0\n"
">>> float('-Infinity')\n"
"-inf"
msgstr ""
">>> float('+1.23')\n"
"1.23\n"
">>> float('   -12345\\n')\n"
"-12345.0\n"
">>> float('1e-003')\n"
"0.001\n"
">>> float('+1E6')\n"
"1000000.0\n"
">>> float('-Infinity')\n"
"-inf"

#: ../../library/functions.rst:734
msgid ""
"If the argument is a string, it should contain a decimal number, optionally "
"preceded by a sign, and optionally embedded in whitespace.  The optional "
"sign may be ``'+'`` or ``'-'``; a ``'+'`` sign has no effect on the value "
"produced.  The argument may also be a string representing a NaN (not-a-"
"number), or positive or negative infinity. More precisely, the input must "
"conform to the :token:`~float:floatvalue` production rule in the following "
"grammar, after leading and trailing whitespace characters are removed:"
msgstr ""
"如果引數是字串，則它必須是包含十進位制數字的字串，字串前面可以有符號，之前也"
"可以有空格。選擇性的符號有 ``'+'`` 和 ``'-'``；``'+'`` 對建立的值沒有影響。引"
"數也可以是 NaN（非數字）或正負無窮大的字串。確切地說，除去首尾的空格後，輸入"
"必須遵循以下語法中 :token:`~float:floatvalue` 的生成規則："

#: ../../library/functions.rst:755
msgid ""
"Case is not significant, so, for example, \"inf\", \"Inf\", \"INFINITY\", "
"and \"iNfINity\" are all acceptable spellings for positive infinity."
msgstr ""
"字母大小寫不影響，例如，\"inf\"、\"Inf\"、\"INFINITY\"、\"iNfINity\" 都可以表"
"示正無窮大。"

#: ../../library/functions.rst:758
msgid ""
"Otherwise, if the argument is an integer or a floating-point number, a "
"floating-point number with the same value (within Python's floating-point "
"precision) is returned.  If the argument is outside the range of a Python "
"float, an :exc:`OverflowError` will be raised."
msgstr ""
"否則，如果引數是整數或浮點數，則回傳具有相同值（在 Python 浮點精度範圍內）的"
"浮點數。如果引數在 Python 浮點精度範圍外，則會引發 :exc:`OverflowError`。"

#: ../../library/functions.rst:763
msgid ""
"For a general Python object ``x``, ``float(x)`` delegates to ``x."
"__float__()``.  If :meth:`~object.__float__` is not defined then it falls "
"back to :meth:`~object.__index__`."
msgstr ""
"對於一般的 Python 物件 ``x``，``float(x)`` 會委派給 ``x.__float__()``。如果未"
"定義 :meth:`~object.__float__` 則會回退到 :meth:`~object.__index__`。"

#: ../../library/functions.rst:767
msgid "If no argument is given, ``0.0`` is returned."
msgstr "如果沒有引數，則回傳 ``0.0``。"

#: ../../library/functions.rst:769
msgid "The float type is described in :ref:`typesnumeric`."
msgstr ":ref:`typesnumeric` 描述了浮點數型別。"

#: ../../library/functions.rst:777
msgid ""
"Falls back to :meth:`~object.__index__` if :meth:`~object.__float__` is not "
"defined."
msgstr ""
"如果 :meth:`~object.__float__` 未定義，則會回退到 :meth:`~object.__index__`。"

#: ../../library/functions.rst:787
msgid ""
"Convert a *value* to a \"formatted\" representation, as controlled by "
"*format_spec*.  The interpretation of *format_spec* will depend on the type "
"of the *value* argument; however, there is a standard formatting syntax that "
"is used by most built-in types: :ref:`formatspec`."
msgstr ""
"將 *value* 轉換為 *format_spec* 控制的 \"格式化\" 表示。*format_spec* 的解釋"
"取決於 *value* 引數的型別，但是大多數內建型別使用標準格式化語法：:ref:"
"`formatspec`。"

#: ../../library/functions.rst:792
msgid ""
"The default *format_spec* is an empty string which usually gives the same "
"effect as calling :func:`str(value) <str>`."
msgstr ""
"預設的 *format_spec* 是一個空字串，它通常和呼叫 :func:`str(value) <str>` 的效"
"果相同。"

#: ../../library/functions.rst:795
msgid ""
"A call to ``format(value, format_spec)`` is translated to ``type(value)."
"__format__(value, format_spec)`` which bypasses the instance dictionary when "
"searching for the value's :meth:`~object.__format__` method. A :exc:"
"`TypeError` exception is raised if the method search reaches :mod:`object` "
"and the *format_spec* is non-empty, or if either the *format_spec* or the "
"return value are not strings."
msgstr ""
"呼叫 ``format(value, format_spec)`` 會轉換成 ``type(value).__format__(value, "
"format_spec)``，當搜尋 value 的 :meth:`~object.__format__` method 時，會忽略"
"實例中的字典。如果搜尋到 :mod:`object` 這個 method 但 *format_spec* 不為空，"
"或是 *format_spec* 或回傳值不是字串，則會引發 :exc:`TypeError`。"

#: ../../library/functions.rst:802
msgid ""
"``object().__format__(format_spec)`` raises :exc:`TypeError` if "
"*format_spec* is not an empty string."
msgstr ""
"當 *format_spec* 不是空字串時，``object().__format__(format_spec)`` 會引發 :"
"exc:`TypeError`。"

#: ../../library/functions.rst:811
msgid ""
"Return a new :class:`frozenset` object, optionally with elements taken from "
"*iterable*.  ``frozenset`` is a built-in class.  See :class:`frozenset` and :"
"ref:`types-set` for documentation about this class."
msgstr ""
"回傳一個新的 :class:`frozenset` 物件，它包含選擇性引數 *iterable* 中的元素。"
"``frozenset`` 是一個內建的 class。有關此 class 的文件，請參閱 :class:"
"`frozenset` 和 :ref:`types-set`。"

#: ../../library/functions.rst:815
msgid ""
"For other containers see the built-in :class:`set`, :class:`list`, :class:"
"`tuple`, and :class:`dict` classes, as well as the :mod:`collections` module."
msgstr ""
"請參閱內建的 :class:`set`、:class:`list`、:class:`tuple` 和 :class:`dict` "
"class，以及 :mod:`collections` module 來了解其它的容器。"

#: ../../library/functions.rst:823
msgid ""
"Return the value of the named attribute of *object*.  *name* must be a "
"string. If the string is the name of one of the object's attributes, the "
"result is the value of that attribute.  For example, ``getattr(x, "
"'foobar')`` is equivalent to ``x.foobar``.  If the named attribute does not "
"exist, *default* is returned if provided, otherwise :exc:`AttributeError` is "
"raised. *name* need not be a Python identifier (see :func:`setattr`)."
msgstr ""
"回傳 *object* 之具名屬性的值。*name* 必須是字串。如果該字串是物件屬性之一的名"
"稱，則回傳該屬性的值。例如，``getattr(x, 'foobar')`` 等同於 ``x.foobar``。如"
"果指定的屬性不存在，且提供了 *default* 值，則回傳其值，否則引發 :exc:"
"`AttributeError`。*name* 不必是個 Python 識別符 (identifier)（請見 :func:"
"`setattr`）。"

#: ../../library/functions.rst:832
msgid ""
"Since :ref:`private name mangling <private-name-mangling>` happens at "
"compilation time, one must manually mangle a private attribute's (attributes "
"with two leading underscores) name in order to retrieve it with :func:"
"`getattr`."
msgstr ""
"由於\\ :ref:`私有名稱改編 (private name mangling) <private-name-mangling>` 是"
"發生在編譯期，因此你必須手動改編私有屬性（有兩個前導底線的屬性）的名稱，才能"
"使用 :func:`getattr` 來取得它。"

#: ../../library/functions.rst:840
msgid ""
"Return the dictionary implementing the current module namespace. For code "
"within functions, this is set when the function is defined and remains the "
"same regardless of where the function is called."
msgstr ""
"回傳代表當前 module 命名空間的 dictionary。對於在函式中的程式碼來說，這在定義"
"函式時設定且不論該函式是在何處呼叫都會保持相同。"

#: ../../library/functions.rst:847
msgid ""
"The arguments are an object and a string.  The result is ``True`` if the "
"string is the name of one of the object's attributes, ``False`` if not. "
"(This is implemented by calling ``getattr(object, name)`` and seeing whether "
"it raises an :exc:`AttributeError` or not.)"
msgstr ""
"該引數是一個物件和一個字串。如果字串是物件屬性之一的名稱，則回傳 ``True``，否"
"則回傳 ``False``。（此功能是透過呼叫 ``getattr(object, name)`` 並檢查是否引"
"發 :exc:`AttributeError` 來實作的。）"

#: ../../library/functions.rst:855
msgid ""
"Return the hash value of the object (if it has one).  Hash values are "
"integers.  They are used to quickly compare dictionary keys during a "
"dictionary lookup.  Numeric values that compare equal have the same hash "
"value (even if they are of different types, as is the case for 1 and 1.0)."
msgstr ""
"回傳該物件的雜湊值（如果它有的話）。雜湊值是整數。它們在 dictionary 查詢元素"
"時用來快速比較 dictionary 的鍵。相同大小的數字數值有相同的雜湊值（即使它們型"
"別不同，如 1 和 1.0）。"

#: ../../library/functions.rst:862
msgid ""
"For objects with custom :meth:`~object.__hash__` methods, note that :func:"
"`hash` truncates the return value based on the bit width of the host machine."
msgstr ""
"請注意，如果物件帶有自訂的 :meth:`~object.__hash__` 方法，:func:`hash` 將根據"
"運行機器的位元長度來截斷回傳值。"

#: ../../library/functions.rst:869
msgid ""
"Invoke the built-in help system.  (This function is intended for interactive "
"use.)  If no argument is given, the interactive help system starts on the "
"interpreter console.  If the argument is a string, then the string is looked "
"up as the name of a module, function, class, method, keyword, or "
"documentation topic, and a help page is printed on the console.  If the "
"argument is any other kind of object, a help page on the object is generated."
msgstr ""
"啟動內建的幫助系統（此函式主要以互動式使用）。如果沒有引數，直譯器控制台裡會"
"啟動互動式幫助系統。如果引數是一個字串，則會在 module、函式、class、method、"
"關鍵字或說明文件主題中搜索該字串，並在控制台上列印幫助資訊。如果引數是其他任"
"意物件，則會生成該物件的幫助頁。"

#: ../../library/functions.rst:876
msgid ""
"Note that if a slash(/) appears in the parameter list of a function when "
"invoking :func:`help`, it means that the parameters prior to the slash are "
"positional-only. For more info, see :ref:`the FAQ entry on positional-only "
"parameters <faq-positional-only-arguments>`."
msgstr ""
"請注意，呼叫 :func:`help` 時，如果斜線 (/) 出現在函式的參數列表中，這表示斜線"
"前面的參數是僅限位置 (positional-only) 參數。有關更多資訊，請參閱\\ :ref:`常"
"見問答集中的僅限位置參數條目 <faq-positional-only-arguments>`。"

#: ../../library/functions.rst:881
msgid ""
"This function is added to the built-in namespace by the :mod:`site` module."
msgstr "此函式會被 :mod:`site` module 加入到內建命名空間。"

#: ../../library/functions.rst:883
msgid ""
"Changes to :mod:`pydoc` and :mod:`inspect` mean that the reported signatures "
"for callables are now more comprehensive and consistent."
msgstr ""
"對於 :mod:`pydoc` 和 :mod:`inspect` 的變更，使得可呼叫物件回報的的簽名 "
"(signature) 更加全面和一致。"

#: ../../library/functions.rst:890
msgid ""
"Convert an integer number to a lowercase hexadecimal string prefixed with "
"\"0x\". If *x* is not a Python :class:`int` object, it has to define an :"
"meth:`~object.__index__` method that returns an integer. Some examples:"
msgstr ""
"將整數轉換為以 \"0x\" 為前綴的小寫十六進位制字串。如果 *x* 不是 Python :"
"class:`int` 物件，則必須定義一個 :meth:`~object.__index__` method 並且回傳一"
"個整數。舉例來說："

#: ../../library/functions.rst:899
msgid ""
"If you want to convert an integer number to an uppercase or lower "
"hexadecimal string with prefix or not, you can use either of the following "
"ways:"
msgstr ""
"如果要將整數轉換為大寫或小寫的十六進位制字串，並可選擇有無 \"0x\" 前綴，則可"
"以使用如下方法："

#: ../../library/functions.rst:911
msgid ""
"See also :func:`int` for converting a hexadecimal string to an integer using "
"a base of 16."
msgstr "另請參閱 :func:`int` 將十六進位制字串轉換為以 16 為基數的整數。"

#: ../../library/functions.rst:916
msgid ""
"To obtain a hexadecimal string representation for a float, use the :meth:"
"`float.hex` method."
msgstr ""
"如果要獲取浮點數的十六進位制字串形式，請使用 :meth:`float.hex` method。"

#: ../../library/functions.rst:922
msgid ""
"Return the \"identity\" of an object.  This is an integer which is "
"guaranteed to be unique and constant for this object during its lifetime. "
"Two objects with non-overlapping lifetimes may have the same :func:`id` "
"value."
msgstr ""
"回傳物件的 \"識別性\" 。該值是一個整數，在此物件的生命週期中保證是唯一且恆定"
"的。兩個生命期不重疊的物件可能具有相同的 :func:`id` 值。"

#: ../../library/functions.rst:927
msgid "This is the address of the object in memory."
msgstr "這是該物件在記憶體中的位址。"

#: ../../library/functions.rst:929
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.id`` with argument "
"``id``."
msgstr ""
"引發一個附帶引數 ``id`` 的\\ :ref:`稽核事件 <auditing>` ``builtins.id``。"

#: ../../library/functions.rst:935
msgid ""
"If the *prompt* argument is present, it is written to standard output "
"without a trailing newline.  The function then reads a line from input, "
"converts it to a string (stripping a trailing newline), and returns that.  "
"When EOF is read, :exc:`EOFError` is raised.  Example::"
msgstr ""
"如果有提供 *prompt* 引數，則將其寫入標準輸出，末尾不帶換行符。接下來，該函式"
"從輸入中讀取一行，將其轉換為字串（去除末尾的換行符）並回傳。當讀取到 EOF 時，"
"則引發 :exc:`EOFError`。例如： ::"

#: ../../library/functions.rst:940
msgid ""
">>> s = input('--> ')  \n"
"--> Monty Python's Flying Circus\n"
">>> s  \n"
"\"Monty Python's Flying Circus\""
msgstr ""
">>> s = input('--> ')  \n"
"--> Monty Python's Flying Circus\n"
">>> s  \n"
"\"Monty Python's Flying Circus\""

#: ../../library/functions.rst:945
msgid ""
"If the :mod:`readline` module was loaded, then :func:`input` will use it to "
"provide elaborate line editing and history features."
msgstr ""
"如果載入了 :mod:`readline` module，:func:`input` 將使用它來提供複雜的行編輯和"
"歷史記錄功能。"

#: ../../library/functions.rst:948 ../../library/functions.rst:950
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.input`` with argument "
"``prompt`` before reading input"
msgstr ""
"引發一個附帶讀取輸入前的引數 ``prompt`` 的\\ :ref:`稽核事件 <auditing>` "
"``builtins.input``。"

#: ../../library/functions.rst:953 ../../library/functions.rst:955
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.input/result`` with "
"the result after successfully reading input."
msgstr ""
"引發一個附帶成功讀取結果的\\ :ref:`稽核事件 <auditing>` ``builtins.input/"
"result``。"

#: ../../library/functions.rst:962
msgid ""
"Return an integer object constructed from a number or a string, or return "
"``0`` if no arguments are given."
msgstr ""

#: ../../library/functions.rst:967
msgid ""
">>> int(123.45)\n"
"123\n"
">>> int('123')\n"
"123\n"
">>> int('   -12_345\\n')\n"
"-12345\n"
">>> int('FACE', 16)\n"
"64206\n"
">>> int('0xface', 0)\n"
"64206\n"
">>> int('01110011', base=2)\n"
"115"
msgstr ""
">>> int(123.45)\n"
"123\n"
">>> int('123')\n"
"123\n"
">>> int('   -12_345\\n')\n"
"-12345\n"
">>> int('FACE', 16)\n"
"64206\n"
">>> int('0xface', 0)\n"
"64206\n"
">>> int('01110011', base=2)\n"
"115"

#: ../../library/functions.rst:982
msgid ""
"If the argument defines :meth:`~object.__int__`, ``int(x)`` returns ``x."
"__int__()``.  If the argument defines :meth:`~object.__index__`, it returns "
"``x.__index__()``.  If the argument defines :meth:`~object.__trunc__`, it "
"returns ``x.__trunc__()``. For floating-point numbers, this truncates "
"towards zero."
msgstr ""
"如果引數定義了 :meth:`~object.__int__`，則 ``int(x)`` 回傳 ``x.__int__()``。"
"如果引數定義了 :meth:`~object.__index__` 則回傳 ``x.__index__()``。如果引數定"
"義了 :meth:`~object.__trunc__` 則回傳 ``x.__trunc__()``。對於浮點數，則會向零"
"的方向無條件捨去。"

#: ../../library/functions.rst:988
msgid ""
"If the argument is not a number or if *base* is given, then it must be a "
"string, :class:`bytes`, or :class:`bytearray` instance representing an "
"integer in radix *base*.  Optionally, the string can be preceded by ``+`` or "
"``-`` (with no space in between), have leading zeros, be surrounded by "
"whitespace, and have single underscores interspersed between digits."
msgstr ""
"如果引數不是數字或如果有給定 *base*，則它必須是個字串、:class:`bytes` 或 :"
"class:`bytearray` 實例，表示基數 (radix) *base* 中的整數。可選地，字串之前可"
"以有 ``+`` 或 ``-``\\ （中間沒有空格）、可有個前導的零、也可被空格包圍、或在"
"數字間有單一底線。"

#: ../../library/functions.rst:994
msgid ""
"A base-n integer string contains digits, each representing a value from 0 to "
"n-1. The values 0--9 can be represented by any Unicode decimal digit. The "
"values 10--35 can be represented by ``a`` to ``z`` (or ``A`` to ``Z``). The "
"default *base* is 10. The allowed bases are 0 and 2--36. Base-2, -8, and -16 "
"strings can be optionally prefixed with ``0b``/``0B``, ``0o``/``0O``, or "
"``0x``/``0X``, as with integer literals in code.  For base 0, the string is "
"interpreted in a similar way to an :ref:`integer literal in code "
"<integers>`, in that the actual base is 2, 8, 10, or 16 as determined by the "
"prefix. Base 0 also disallows leading zeros: ``int('010', 0)`` is not legal, "
"while ``int('010')`` and ``int('010', 8)`` are."
msgstr ""
"一個 n 進制的整數字串，包含各個代表 0 到 n-1 的數字，0–9 可以用任何 Unicode "
"十進制數字表示，10–35 可以用 ``a`` 到 ``z``\\ （或 ``A`` 到 ``Z``\\ ）表示。"
"預設的 *base* 是 10。允許的進位制有 0、2–36。2、8、16 進位制的字串可以在程式"
"碼中用 ``0b``/``0B``、``0o``/``0O``、``0x``/``0X`` 前綴來表示，如同程式碼中的"
"整數文字。進位制為 0 的字串將以和\\ :ref:`程式碼整數字面值 (integer literal "
"in code) <integers>` 類似的方式來直譯，最後由前綴決定的結果會是 2、8、10、16 "
"進制中的一個，所以 ``int('010', 0)`` 是非法的，但 ``int('010')`` 和 "
"``int('010', 8)`` 是有效的。"

#: ../../library/functions.rst:1005
msgid "The integer type is described in :ref:`typesnumeric`."
msgstr "整數型別定義請參閱\\ :ref:`typesnumeric`。"

#: ../../library/functions.rst:1007
msgid ""
"If *base* is not an instance of :class:`int` and the *base* object has a :"
"meth:`base.__index__ <object.__index__>` method, that method is called to "
"obtain an integer for the base.  Previous versions used :meth:`base.__int__ "
"<object.__int__>` instead of :meth:`base.__index__ <object.__index__>`."
msgstr ""
"如果 *base* 不是 :class:`int` 的實例，但 *base* 物件有 :meth:`base.__index__ "
"<object.__index__>` method，則會呼叫該 method 來獲取此進位制所需的整數。以前"
"的版本使用 :meth:`base.__int__ <object.__int__>` 而不是 :meth:`base."
"__index__ <object.__index__>`。"

#: ../../library/functions.rst:1017
msgid "The first parameter is now positional-only."
msgstr "第一個參數為僅限位置參數。"

#: ../../library/functions.rst:1020
msgid ""
"Falls back to :meth:`~object.__index__` if :meth:`~object.__int__` is not "
"defined."
msgstr ""
"如果未定義 :meth:`~object.__int__` 則會回退到 :meth:`~object.__index__`。"

#: ../../library/functions.rst:1023
msgid "The delegation to :meth:`~object.__trunc__` is deprecated."
msgstr "對 :meth:`~object.__trunc__` 的委派已棄用。"

#: ../../library/functions.rst:1026
msgid ""
":class:`int` string inputs and string representations can be limited to help "
"avoid denial of service attacks. A :exc:`ValueError` is raised when the "
"limit is exceeded while converting a string to an :class:`int` or when "
"converting an :class:`int` into a string would exceed the limit. See the :"
"ref:`integer string conversion length limitation <int_max_str_digits>` "
"documentation."
msgstr ""
":class:`int` 的字串輸入和字串表示法可以被限制，以避免阻斷服務攻擊 (denial of "
"service attack)。在字串 *x* 轉換為 :class:`int` 時已超出限制，或是在 :class:"
"`int` 轉換為字串時將會超出限制時，會引發 :exc:`ValueError`。請參閱\\ :ref:`整"
"數字串轉換的長度限制 <int_max_str_digits>`\\ 說明文件。"

#: ../../library/functions.rst:1036
msgid ""
"Return ``True`` if the *object* argument is an instance of the *classinfo* "
"argument, or of a (direct, indirect, or :term:`virtual <abstract base "
"class>`) subclass thereof.  If *object* is not an object of the given type, "
"the function always returns ``False``. If *classinfo* is a tuple of type "
"objects (or recursively, other such tuples) or a :ref:`types-union` of "
"multiple types, return ``True`` if *object* is an instance of any of the "
"types. If *classinfo* is not a type or tuple of types and such tuples, a :"
"exc:`TypeError` exception is raised. :exc:`TypeError` may not be raised for "
"an invalid type if an earlier check succeeds."
msgstr ""
"如果 *object* 引數是 *classinfo* 引數的實例，或者是（直接、間接或 :term:"
"`virtual <abstract base class>`）subclass 的實例，則回傳 ``True``。如果 "
"*object* 不是給定型別的物件，函式始終回傳 ``False``。如果 *classinfo* 是包含"
"物件型別的 tuple（或多個遞迴 tuple）或一個包含多種型別的 :ref:`types-union`，"
"若 *object* 是其中的任何一個物件的實例則回傳 ``True``。如果 *classinfo* 既不"
"是型別，也不是型別 tuple 或型別的遞迴 tuple，那麼會引發 :exc:`TypeError` 異"
"常。若是先前檢查已經成功，:exc:`TypeError` 可能不會再因為不合格的型別而被引"
"發。"

#: ../../library/functions.rst:1047 ../../library/functions.rst:1061
msgid "*classinfo* can be a :ref:`types-union`."
msgstr "*classinfo* 可以是一個 :ref:`types-union`。"

#: ../../library/functions.rst:1053
msgid ""
"Return ``True`` if *class* is a subclass (direct, indirect, or :term:"
"`virtual <abstract base class>`) of *classinfo*.  A class is considered a "
"subclass of itself. *classinfo* may be a tuple of class objects (or "
"recursively, other such tuples) or a :ref:`types-union`, in which case "
"return ``True`` if *class* is a subclass of any entry in *classinfo*.  In "
"any other case, a :exc:`TypeError` exception is raised."
msgstr ""
"如果 *class* 是 *classinfo* 的 subclass（直接、間接或 :term:`virtual "
"<abstract base class>`），則回傳 ``True``。*classinfo* 可以是 class 物件的 "
"tuple（或遞迴地其他類似 tuple）或是一個 :ref:`types-union`，此時若 *class* "
"是 *classinfo* 中任一元素的 subclass 時則回傳 ``True``。其他情況，會引發 :"
"exc:`TypeError`。"

#: ../../library/functions.rst:1068
msgid ""
"Return an :term:`iterator` object.  The first argument is interpreted very "
"differently depending on the presence of the second argument. Without a "
"second argument, *object* must be a collection object which supports the :"
"term:`iterable` protocol (the :meth:`~object.__iter__` method), or it must "
"support the sequence protocol (the :meth:`~object.__getitem__` method with "
"integer arguments starting at ``0``).  If it does not support either of "
"those protocols, :exc:`TypeError` is raised. If the second argument, "
"*sentinel*, is given, then *object* must be a callable object.  The iterator "
"created in this case will call *object* with no arguments for each call to "
"its :meth:`~iterator.__next__` method; if the value returned is equal to "
"*sentinel*, :exc:`StopIteration` will be raised, otherwise the value will be "
"returned."
msgstr ""
"回傳一個 :term:`iterator` 物件。根據是否存在第二個引數，第一個引數的意義是非"
"常不同的。如果沒有第二個引數，*object* 必須是支援 :term:`iterable` 協定（有 :"
"meth:`~object.__iter__` method）的集合物件，或必須支援序列協定（有 :meth:"
"`~object.__getitem__` 方法，且數字引數從 ``0`` 開始）。如果它不支援這些協定，"
"會引發 :exc:`TypeError`。如果有第二個引數 *sentinel*，那麼 *object* 必須是可"
"呼叫的物件，這種情況下生成的 iterator，每次疊代呼叫 :meth:`~iterator."
"__next__` 時會不帶引數地呼叫 *object*；如果回傳的結果是 *sentinel* 則引發 :"
"exc:`StopIteration`，否則回傳呼叫結果。"

#: ../../library/functions.rst:1082
msgid "See also :ref:`typeiter`."
msgstr "另請參閱 :ref:`typeiter`。"

#: ../../library/functions.rst:1084
msgid ""
"One useful application of the second form of :func:`iter` is to build a "
"block-reader. For example, reading fixed-width blocks from a binary database "
"file until the end of file is reached::"
msgstr ""
":func:`iter` 的第二種形式有一個好用的應用，是能夠建立一個區塊閱讀器 (block-"
"reader)。例如，從二進位資料庫檔案中讀取固定寬度的區塊，直到檔案的結尾： ::"

#: ../../library/functions.rst:1088
msgid ""
"from functools import partial\n"
"with open('mydata.db', 'rb') as f:\n"
"    for block in iter(partial(f.read, 64), b''):\n"
"        process_block(block)"
msgstr ""
"from functools import partial\n"
"with open('mydata.db', 'rb') as f:\n"
"    for block in iter(partial(f.read, 64), b''):\n"
"        process_block(block)"

#: ../../library/functions.rst:1096
msgid ""
"Return the length (the number of items) of an object.  The argument may be a "
"sequence (such as a string, bytes, tuple, list, or range) or a collection "
"(such as a dictionary, set, or frozen set)."
msgstr ""
"回傳物件的長度（元素個數）。引數可以是序列（如 string、bytes、tuple、list 或 "
"range）或集合（如 dictionary、set 或 frozen set）。"

#: ../../library/functions.rst:1102
msgid ""
"``len`` raises :exc:`OverflowError` on lengths larger than :data:`sys."
"maxsize`, such as :class:`range(2 ** 100) <range>`."
msgstr ""
"如果物件長度大於 :data:`sys.maxsize`，像是 :class:`range(2 ** 100) <range>`，"
"則 ``len`` 會引發 :exc:`OverflowError`。"

#: ../../library/functions.rst:1111
msgid ""
"Rather than being a function, :class:`list` is actually a mutable sequence "
"type, as documented in :ref:`typesseq-list` and :ref:`typesseq`."
msgstr ""
"除了是函式，:class:`list` 也是可變序列型別，詳情請參閱 :ref:`typesseq-list` "
"和 :ref:`typesseq`。"

#: ../../library/functions.rst:1117
msgid ""
"Update and return a dictionary representing the current local symbol table. "
"Free variables are returned by :func:`locals` when it is called in function "
"blocks, but not in class blocks. Note that at the module level, :func:"
"`locals` and :func:`globals` are the same dictionary."
msgstr ""
"更新並回傳表示當前本地符號表的 dictionary。在函式區塊而不是 class 區塊中呼"
"叫 :func:`locals` 時會回傳自由變數。請注意，在 module 階層中，:func:`locals` "
"和 :func:`globals` 是相同的 dictionary。"

#: ../../library/functions.rst:1123
msgid ""
"The contents of this dictionary should not be modified; changes may not "
"affect the values of local and free variables used by the interpreter."
msgstr ""
"此 dictionary 的內容不應該被更動；更改可能不會影響直譯器使用的本地變數或自由"
"變數的值。"

#: ../../library/functions.rst:1128
msgid ""
"Return an iterator that applies *function* to every item of *iterable*, "
"yielding the results.  If additional *iterables* arguments are passed, "
"*function* must take that many arguments and is applied to the items from "
"all iterables in parallel.  With multiple iterables, the iterator stops when "
"the shortest iterable is exhausted.  For cases where the function inputs are "
"already arranged into argument tuples, see :func:`itertools.starmap`\\."
msgstr ""
"產生一個將 *function* 應用於 *iterable* 中所有元素，並收集回傳結果的 "
"iterator。如果傳遞了額外的 *iterables* 引數，則 *function* 必須接受相同個數的"
"引數，並使用所有從 iterables 中同時獲取的元素。當有多個 iterables 時，最短的 "
"iteratable 耗盡時 iterator 也會結束。如果函式的輸入已經被編排為引數的 tuple，"
"請參閱 :func:`itertools.starmap`。"

#: ../../library/functions.rst:1140
msgid ""
"Return the largest item in an iterable or the largest of two or more "
"arguments."
msgstr "回傳 iterable 中最大的元素，或者回傳兩個以上的引數中最大的。"

#: ../../library/functions.rst:1143
msgid ""
"If one positional argument is provided, it should be an :term:`iterable`. "
"The largest item in the iterable is returned.  If two or more positional "
"arguments are provided, the largest of the positional arguments is returned."
msgstr ""
"如果只提供了一個位置引數，它必須是個 :term:`iterable`，iterable 中最大的元素"
"會被回傳。如果提供了兩個或以上的位置引數，則回傳最大的位置引數。"

#: ../../library/functions.rst:1148 ../../library/functions.rst:1186
msgid ""
"There are two optional keyword-only arguments. The *key* argument specifies "
"a one-argument ordering function like that used for :meth:`list.sort`. The "
"*default* argument specifies an object to return if the provided iterable is "
"empty. If the iterable is empty and *default* is not provided, a :exc:"
"`ValueError` is raised."
msgstr ""
"這個函式有兩個選擇性的僅限關鍵字引數。*key* 引數能指定單一引數所使用的排序函"
"式，如同 :meth:`list.sort` 的使用方式。*default* 引數是當 iterable 為空時回傳"
"的物件。如果 iterable 為空，並且沒有提供 *default*，則會引發 :exc:"
"`ValueError`。"

#: ../../library/functions.rst:1154
msgid ""
"If multiple items are maximal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving tools "
"such as ``sorted(iterable, key=keyfunc, reverse=True)[0]`` and ``heapq."
"nlargest(1, iterable, key=keyfunc)``."
msgstr ""
"如果有多個最大元素，則此函式將回傳第一個找到的。這和其他穩定排序工具如 "
"``sorted(iterable, key=keyfunc, reverse=True)[0]`` 和 ``heapq.nlargest(1, "
"iterable, key=keyfunc)`` 一致。"

#: ../../library/functions.rst:1159 ../../library/functions.rst:1197
msgid "Added the *default* keyword-only parameter."
msgstr "新增 *default* 僅限關鍵字參數。"

#: ../../library/functions.rst:1162 ../../library/functions.rst:1200
msgid "The *key* can be ``None``."
msgstr "*key* 可以為 ``None``。"

#: ../../library/functions.rst:1170
msgid ""
"Return a \"memory view\" object created from the given argument.  See :ref:"
"`typememoryview` for more information."
msgstr ""
"回傳由給定的引數所建立之「memory view（記憶體檢視）」物件。有關詳細資訊，請參"
"閱\\ :ref:`typememoryview`。"

#: ../../library/functions.rst:1178
msgid ""
"Return the smallest item in an iterable or the smallest of two or more "
"arguments."
msgstr "回傳 iterable 中最小的元素，或者回傳兩個以上的引數中最小的。"

#: ../../library/functions.rst:1181
msgid ""
"If one positional argument is provided, it should be an :term:`iterable`. "
"The smallest item in the iterable is returned.  If two or more positional "
"arguments are provided, the smallest of the positional arguments is returned."
msgstr ""
"如果只提供了一個位置引數，它必須是 :term:`iterable`，iterable 中最小的元素會"
"被回傳。如果提供了兩個以上的位置引數，則回傳最小的位置引數。"

#: ../../library/functions.rst:1192
msgid ""
"If multiple items are minimal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving tools "
"such as ``sorted(iterable, key=keyfunc)[0]`` and ``heapq.nsmallest(1, "
"iterable, key=keyfunc)``."
msgstr ""
"如果有多個最小元素，則此函式將回傳第一個找到的。這和其他穩定排序工具如 "
"``sorted(iterable, key=keyfunc)[0]`` 和 ``heapq.nsmallest(1, iterable, "
"key=keyfunc)`` 一致。"

#: ../../library/functions.rst:1207
msgid ""
"Retrieve the next item from the :term:`iterator` by calling its :meth:"
"`~iterator.__next__` method.  If *default* is given, it is returned if the "
"iterator is exhausted, otherwise :exc:`StopIteration` is raised."
msgstr ""
"透過呼叫 :term:`iterator` 的 :meth:`~iterator.__next__` method 獲取下一個元"
"素。如果 iterator 耗盡，則回傳給定的預設值 *default*，如果沒有預設值則引發 :"
"exc:`StopIteration`。"

#: ../../library/functions.rst:1214
msgid ""
"Return a new featureless object.  :class:`object` is a base for all classes. "
"It has methods that are common to all instances of Python classes.  This "
"function does not accept any arguments."
msgstr ""
"回傳一個沒有特徵的新物件。:class:`object` 是所有 class 的基礎，它具有所有 "
"Python class 實例的通用 method。這個函式不接受任何引數。"

#: ../../library/functions.rst:1220
msgid ""
":class:`object` does *not* have a :attr:`~object.__dict__`, so you can't "
"assign arbitrary attributes to an instance of the :class:`object` class."
msgstr ""
"由於 :class:`object` *沒有* :attr:`~object.__dict__`，因此無法將任意屬性賦"
"給 :class:`object` class 的實例。"

#: ../../library/functions.rst:1226
msgid ""
"Convert an integer number to an octal string prefixed with \"0o\".  The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`~object.__index__` method that returns an "
"integer. For example:"
msgstr ""
"將一個整數轉變為一個前綴為 \"0o\" 的八進位制字串。回傳結果是一個有效的 "
"Python 運算式。如果 *x* 不是 Python 的 :class:`int` 物件，那它需要定義 :meth:"
"`~object.__index__` method 回傳一個整數。舉例來說："

#: ../../library/functions.rst:1236
msgid ""
"If you want to convert an integer number to an octal string either with the "
"prefix \"0o\" or not, you can use either of the following ways."
msgstr ""
"如果要將整數轉換為八進位制字串，不論是否具備 \"0o\" 前綴，都可以使用下面的方"
"法。"

#: ../../library/functions.rst:1253
msgid ""
"Open *file* and return a corresponding :term:`file object`.  If the file "
"cannot be opened, an :exc:`OSError` is raised. See :ref:`tut-files` for more "
"examples of how to use this function."
msgstr ""
"開啟 *file* 並回傳對應的\\ :term:`檔案物件 <file object>`。如果該檔案不能開"
"啟，則引發 :exc:`OSError`。關於使用此函式的更多方法，請參閱\\ :ref:`tut-"
"files`。"

#: ../../library/functions.rst:1257
msgid ""
"*file* is a :term:`path-like object` giving the pathname (absolute or "
"relative to the current working directory) of the file to be opened or an "
"integer file descriptor of the file to be wrapped.  (If a file descriptor is "
"given, it is closed when the returned I/O object is closed unless *closefd* "
"is set to ``False``.)"
msgstr ""
"*file* 是一個\\ :term:`類路徑物件 <path-like object>`，是將被開啟之檔案的路徑"
"（絕對路徑或當前工作目錄的相對路徑），或是要被包裝 (wrap) 檔案的整數檔案描述"
"器 (file descriptor)。（如果有給定檔案描述器，它會隨著回傳的 I/O 物件關閉而關"
"閉，除非 *closefd* 被設為 ``False``。）"

#: ../../library/functions.rst:1263
msgid ""
"*mode* is an optional string that specifies the mode in which the file is "
"opened.  It defaults to ``'r'`` which means open for reading in text mode. "
"Other common values are ``'w'`` for writing (truncating the file if it "
"already exists), ``'x'`` for exclusive creation, and ``'a'`` for appending "
"(which on *some* Unix systems, means that *all* writes append to the end of "
"the file regardless of the current seek position).  In text mode, if "
"*encoding* is not specified the encoding used is platform-dependent: :func:"
"`locale.getencoding` is called to get the current locale encoding. (For "
"reading and writing raw bytes use binary mode and leave *encoding* "
"unspecified.)  The available modes are:"
msgstr ""
"*mode* 是一個選擇性字串，用於指定開啟檔案的模式。預設值是 ``'r'``，這意味著它"
"以文字模式開啟並讀取。其他常見模式有：寫入 ``'w'``\\ （會捨去已經存在的檔"
"案）、唯一性建立 ``'x'``、追加寫入 ``'a'``\\ （在\\ *一些* Unix 系統上，無論"
"當前的檔案指標在什麼位置，*所有* 寫入都會追加到檔案末尾）。在文字模式，如果沒"
"有指定 *encoding*，則根據電腦平臺來決定使用的編碼：呼叫 :func:`locale."
"getencoding` 來獲取當前的本地編碼。（要讀取和寫入原始 bytes，請使用二進位制模"
"式且不要指定 *encoding*。）可用的模式有："

#: ../../library/functions.rst:1280
msgid "Character"
msgstr "字元"

#: ../../library/functions.rst:1280
msgid "Meaning"
msgstr "意義"

#: ../../library/functions.rst:1282
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/functions.rst:1282
msgid "open for reading (default)"
msgstr "讀取（預設）"

#: ../../library/functions.rst:1283
msgid "``'w'``"
msgstr "``'w'``"

#: ../../library/functions.rst:1283
msgid "open for writing, truncating the file first"
msgstr "寫入，會先清除檔案內容"

#: ../../library/functions.rst:1284
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/functions.rst:1284
msgid "open for exclusive creation, failing if the file already exists"
msgstr "唯一性建立，如果文件已存在則會失敗"

#: ../../library/functions.rst:1285
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/functions.rst:1285
msgid "open for writing, appending to the end of file if it exists"
msgstr "寫入，如果檔案存在則在其末端附加內容"

#: ../../library/functions.rst:1286
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/functions.rst:1286 ../../library/functions.rst:1430
msgid "binary mode"
msgstr "二進制模式"

#: ../../library/functions.rst:1287
msgid "``'t'``"
msgstr "``'t'``"

#: ../../library/functions.rst:1287
msgid "text mode (default)"
msgstr "文字模式（預設）"

#: ../../library/functions.rst:1288
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/functions.rst:1288
msgid "open for updating (reading and writing)"
msgstr "更新（讀取並寫入）"

#: ../../library/functions.rst:1291
msgid ""
"The default mode is ``'r'`` (open for reading text, a synonym of ``'rt'``). "
"Modes ``'w+'`` and ``'w+b'`` open and truncate the file.  Modes ``'r+'`` and "
"``'r+b'`` open the file with no truncation."
msgstr ""
"預設的模式是 ``'r'``\\ （開啟並讀取文字，同 ``'rt'``）。``'w+'`` 和 "
"``'w+b'`` 模式會開啟並清除檔案。``'r+'`` 和 ``'r+b'`` 模式會開啟且保留檔案內"
"容。"

#: ../../library/functions.rst:1295
msgid ""
"As mentioned in the :ref:`io-overview`, Python distinguishes between binary "
"and text I/O.  Files opened in binary mode (including ``'b'`` in the *mode* "
"argument) return contents as :class:`bytes` objects without any decoding.  "
"In text mode (the default, or when ``'t'`` is included in the *mode* "
"argument), the contents of the file are returned as :class:`str`, the bytes "
"having been first decoded using a platform-dependent encoding or using the "
"specified *encoding* if given."
msgstr ""
"如\\ :ref:`io-overview`\\ 中所述，Python 能區分二進制和文字的 I/O。在二進制模"
"式下開啟的檔案（*mode* 引數中含有 ``'b'``）會將其內容以 :class:`bytes` 物件回"
"傳，而不進行任何解碼。在文字模式（預設情況，或當 *mode* 引數中含有 "
"``'t'``），檔案的內容會以 :class:`str` 回傳，其位元組已經先被解碼，使用的是取"
"決於平台的編碼系統或是給定的 *encoding*。"

#: ../../library/functions.rst:1305
msgid ""
"Python doesn't depend on the underlying operating system's notion of text "
"files; all the processing is done by Python itself, and is therefore "
"platform-independent."
msgstr ""
"Python 不會使用底層作業系統對於文字檔案的操作概念；所有的處理都是由 Python 獨"
"自完成的，因此能獨立於不同平台。"

#: ../../library/functions.rst:1309
msgid ""
"*buffering* is an optional integer used to set the buffering policy.  Pass 0 "
"to switch buffering off (only allowed in binary mode), 1 to select line "
"buffering (only usable when writing in text mode), and an integer > 1 to "
"indicate the size in bytes of a fixed-size chunk buffer. Note that "
"specifying a buffer size this way applies for binary buffered I/O, but "
"``TextIOWrapper`` (i.e., files opened with ``mode='r+'``) would have another "
"buffering. To disable buffering in ``TextIOWrapper``, consider using the "
"``write_through`` flag for :func:`io.TextIOWrapper.reconfigure`. When no "
"*buffering* argument is given, the default buffering policy works as follows:"
msgstr ""
"*buffering* 是一個選擇性的整數，用於設定緩衝策略。傳入 0 表示關閉緩衝（僅在二"
"進制模式下被允許），1 表示行緩衝（line buffering，僅在文字模式下可用），而 "
">1 的整數是指示一個大小固定的區塊緩衝區 (chunk buffer)，其位元組的數量。請注"
"意，此類指定緩衝區大小的方式適用於二進制緩衝 I/O，但是 ``TextIOWrapper``\\ "
"（以 ``mode='r+'`` 開啟的檔案）會有另一種緩衝方式。若要在 ``TextIOWrapper`` "
"中停用緩衝，可考慮使用 :func:`io.TextIOWrapper.reconfigure` 的 "
"``write_through`` 旗標。若未給定 *buffering* 引數，則預設的緩衝策略會運作如"
"下："

#: ../../library/functions.rst:1319
msgid ""
"Binary files are buffered in fixed-size chunks; the size of the buffer is "
"chosen using a heuristic trying to determine the underlying device's \"block "
"size\" and falling back on :const:`io.DEFAULT_BUFFER_SIZE`.  On many "
"systems, the buffer will typically be 4096 or 8192 bytes long."
msgstr ""
"二進制檔案會以固定大小的區塊進行緩衝；緩衝區的大小是使用啟發式嘗試 "
"(heuristic trying) 來決定底層設備的「區塊大小」，並會回退到 :attr:`io."
"DEFAULT_BUFFER_SIZE`。在許多系統上，緩衝區的長度通常為 4096 或 8192 個位元"
"組。"

#: ../../library/functions.rst:1324
msgid ""
"\"Interactive\" text files (files for which :meth:`~io.IOBase.isatty` "
"returns ``True``) use line buffering.  Other text files use the policy "
"described above for binary files."
msgstr ""
"「互動式」文字檔（:meth:`~io.IOBase.isatty` 回傳 ``True`` 的檔案）會使用列緩"
"衝。其他文字檔則使用上述的二進制檔案緩衝策略。"

#: ../../library/functions.rst:1328
msgid ""
"*encoding* is the name of the encoding used to decode or encode the file. "
"This should only be used in text mode.  The default encoding is platform "
"dependent (whatever :func:`locale.getencoding` returns), but any :term:`text "
"encoding` supported by Python can be used. See the :mod:`codecs` module for "
"the list of supported encodings."
msgstr ""
"*encoding* 是用於解碼或編碼檔案的編碼系統之名稱。它只應該在文字模式下使用。預"
"設的編碼系統會取決於平台（根據 :func:`locale.getencoding` 回傳的內容），但 "
"Python 支援的任何 :term:`text encoding`\\ （文字編碼）都是可以使用的。關於支"
"援的編碼系統清單，請參閱 :mod:`codecs` module。"

#: ../../library/functions.rst:1334
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled—this cannot be used in binary mode. A variety of "
"standard error handlers are available (listed under :ref:`error-handlers`), "
"though any error handling name that has been registered with :func:`codecs."
"register_error` is also valid.  The standard names include:"
msgstr ""
"*errors* 是一個選擇性的字串，用於指定要如何處理編碼和解碼的錯誤——它不能在二進"
"制模式下使用。有許多不同的標準錯誤處理程式（error handler，在\\ :ref:`error-"
"handlers`\\ 有列出清單），不過任何已註冊到 :func:`codecs.register_error` 的錯"
"誤處理程式名稱也都是有效的。標準的名稱包括："

#: ../../library/functions.rst:1342
msgid ""
"``'strict'`` to raise a :exc:`ValueError` exception if there is an encoding "
"error.  The default value of ``None`` has the same effect."
msgstr ""
"``'strict'`` 如果發生編碼錯誤，則引發 :exc:`ValueError` 例外。預設值 "
"``None`` 也有相同的效果。"

#: ../../library/functions.rst:1346
msgid ""
"``'ignore'`` ignores errors.  Note that ignoring encoding errors can lead to "
"data loss."
msgstr "``'ignore'`` 忽略錯誤。請注意，忽略編碼錯誤可能導致資料遺失。"

#: ../../library/functions.rst:1349
msgid ""
"``'replace'`` causes a replacement marker (such as ``'?'``) to be inserted "
"where there is malformed data."
msgstr ""
"``'replace'`` 會在格式不正確的資料位置插入一個替換標誌（像是 ``'?'``）。"

#: ../../library/functions.rst:1352
msgid ""
"``'surrogateescape'`` will represent any incorrect bytes as low surrogate "
"code units ranging from U+DC80 to U+DCFF. These surrogate code units will "
"then be turned back into the same bytes when the ``surrogateescape`` error "
"handler is used when writing data.  This is useful for processing files in "
"an unknown encoding."
msgstr ""
"``'surrogateescape'`` 會將任何不正確的位元組表示為低位代理碼元 (low "
"surrogate code unit)，範圍從 U+DC80 到 U+DCFF。在寫入資料時，這些代理碼元將會"
"被還原回 ``surrogateescape`` 錯誤處理程式當時所處理的那些相同位元組。這對於處"
"理未知編碼方式的檔案會很好用。"

#: ../../library/functions.rst:1359
msgid ""
"``'xmlcharrefreplace'`` is only supported when writing to a file. Characters "
"not supported by the encoding are replaced with the appropriate XML "
"character reference :samp:`&#{nnn};`."
msgstr ""
"``'xmlcharrefreplace'`` 僅在寫入檔案時可支援。編碼系統不支援的字元會被替換為"
"適當的 XML 字元參考 (character reference) ``&#nnn;``。"

#: ../../library/functions.rst:1363
msgid ""
"``'backslashreplace'`` replaces malformed data by Python's backslashed "
"escape sequences."
msgstr ""
"``'backslashreplace'`` 會用 Python 的反斜線跳脫序列 (backslashed escape "
"sequence) 替換格式不正確的資料。"

#: ../../library/functions.rst:1366
msgid ""
"``'namereplace'`` (also only supported when writing) replaces unsupported "
"characters with ``\\N{...}`` escape sequences."
msgstr ""
"``'namereplace'``\\ （也僅在寫入時支援）會將不支援的字元替換為 ``\\N{...}`` "
"跳脫序列。"

#: ../../library/functions.rst:1374
msgid ""
"*newline* determines how to parse newline characters from the stream. It can "
"be ``None``, ``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as "
"follows:"
msgstr ""
"*newline* 會決定如何剖析資料串流 (stream) 中的換行字元。它可以是 ``None``、"
"``''``、``'\\n'``、``'\\r'`` 或 ``'\\r\\n'``。它的運作規則如下："

#: ../../library/functions.rst:1378
msgid ""
"When reading input from the stream, if *newline* is ``None``, universal "
"newlines mode is enabled.  Lines in the input can end in ``'\\n'``, "
"``'\\r'``, or ``'\\r\\n'``, and these are translated into ``'\\n'`` before "
"being returned to the caller.  If it is ``''``, universal newlines mode is "
"enabled, but line endings are returned to the caller untranslated.  If it "
"has any of the other legal values, input lines are only terminated by the "
"given string, and the line ending is returned to the caller untranslated."
msgstr ""
"從資料串流讀取輸入時，如果 *newline* 是 ``None``，則會啟用通用換行模式。輸入"
"資料中的行結尾可以是 ``'\\n'``、``'\\r'`` 或 ``'\\r\\n'``，這些符號會被轉換"
"為 ``'\\n'`` 之後再回傳給呼叫方。如果是 ``''``，也會啟用通用換行模式，但在回"
"傳給呼叫方時，行尾符號不會被轉換。如果它是任何其他有效的值，則輸入資料的行只"
"會由給定的字串做結尾，且在回傳給呼叫方時，行尾符號不會被轉換。"

#: ../../library/functions.rst:1386
msgid ""
"When writing output to the stream, if *newline* is ``None``, any ``'\\n'`` "
"characters written are translated to the system default line separator, :"
"data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no translation "
"takes place.  If *newline* is any of the other legal values, any ``'\\n'`` "
"characters written are translated to the given string."
msgstr ""
"將輸出寫入資料串流時，如果 *newline* 是 ``None``，則被寫入的任何 ``'\\n'`` 字"
"元都會轉換為系統預設的行分隔符號 :data:`os.linesep`。如果 *newline* 是 "
"``''`` 或 ``'\\n'``，則不做任何轉換。如果 *newline* 是任何其他有效的值，則寫"
"入的任何 ``'\\n'`` 字元都將轉換為給定的字串。"

#: ../../library/functions.rst:1392
msgid ""
"If *closefd* is ``False`` and a file descriptor rather than a filename was "
"given, the underlying file descriptor will be kept open when the file is "
"closed.  If a filename is given *closefd* must be ``True`` (the default); "
"otherwise, an error will be raised."
msgstr ""
"如果 *closefd* 是 ``False``，且給定的 *file* 引數是一個檔案描述器而不是檔名，"
"則當檔案關閉時，底層的檔案描述器會保持開啟狀態。如果有給定一個檔名，則 "
"*closefd* 必須是 ``True``\\ （預設值）；否則將引發錯誤。"

#: ../../library/functions.rst:1397
msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by calling "
"*opener* with (*file*, *flags*). *opener* must return an open file "
"descriptor (passing :mod:`os.open` as *opener* results in functionality "
"similar to passing ``None``)."
msgstr ""
"透過以 *opener* 傳遞一個可呼叫物件，就可以自訂開啟函式。然後透過以引數 "
"(*file*, *flags*) 呼叫 *opener*，就能取得檔案物件的底層檔案描述器。*opener* "
"必須回傳一個開啟的檔案描述器（將 :mod:`os.open` 作為 *opener* 傳入，在功能上"
"的結果會相當於傳入 ``None``）。"

#: ../../library/functions.rst:1403
msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr "新建立的檔案是\\ :ref:`不可繼承的 <fd_inheritance>`。"

#: ../../library/functions.rst:1405
msgid ""
"The following example uses the :ref:`dir_fd <dir_fd>` parameter of the :func:"
"`os.open` function to open a file relative to a given directory::"
msgstr ""
"下面的範例使用 :func:`os.open` 函式回傳值當作 :ref:`dir_fd <dir_fd>` 的參數，"
"從給定的目錄中用相對路徑開啟檔案： ::"

#: ../../library/functions.rst:1408
msgid ""
">>> import os\n"
">>> dir_fd = os.open('somedir', os.O_RDONLY)\n"
">>> def opener(path, flags):\n"
"...     return os.open(path, flags, dir_fd=dir_fd)\n"
"...\n"
">>> with open('spamspam.txt', 'w', opener=opener) as f:\n"
"...     print('This will be written to somedir/spamspam.txt', file=f)\n"
"...\n"
">>> os.close(dir_fd)  # don't leak a file descriptor"
msgstr ""

#: ../../library/functions.rst:1418
msgid ""
"The type of :term:`file object` returned by the :func:`open` function "
"depends on the mode.  When :func:`open` is used to open a file in a text "
"mode (``'w'``, ``'r'``, ``'wt'``, ``'rt'``, etc.), it returns a subclass of :"
"class:`io.TextIOBase` (specifically :class:`io.TextIOWrapper`).  When used "
"to open a file in a binary mode with buffering, the returned class is a "
"subclass of :class:`io.BufferedIOBase`.  The exact class varies: in read "
"binary mode, it returns an :class:`io.BufferedReader`; in write binary and "
"append binary modes, it returns an :class:`io.BufferedWriter`, and in read/"
"write mode, it returns an :class:`io.BufferedRandom`.  When buffering is "
"disabled, the raw stream, a subclass of :class:`io.RawIOBase`, :class:`io."
"FileIO`, is returned."
msgstr ""
":func:`open` 函式回傳的 :term:`file object` 型別取決於模式。當 :func:`open` "
"是在文字模式中開啟檔案時（``'w'``、``'r'``、``'wt'``、``'rt'`` 等），它會回"
"傳 :class:`io.TextIOBase` 的一個 subclass（具體來說，就是 :class:`io."
"TextIOWrapper`）。使用有緩衝的二進制模式開啟檔案時，回傳的 class 則會是 :"
"class:`io.BufferedIOBase` 的 subclass。確切的 class 各不相同：在讀取的二進制"
"模式，它會回傳 :class:`io.BufferedReader`；在寫入和附加的二進制模式，它會回"
"傳 :class:`io.BufferedWriter`，而在讀／寫模式，它會回傳 :class:`io."
"BufferedRandom`。當緩衝被停用時，會回傳原始資料串流 :class:`io.FileIO`，它"
"是 :class:`io.RawIOBase` 的一個 subclass。"

#: ../../library/functions.rst:1439
msgid ""
"See also the file handling modules, such as :mod:`fileinput`, :mod:`io` "
"(where :func:`open` is declared), :mod:`os`, :mod:`os.path`, :mod:"
"`tempfile`, and :mod:`shutil`."
msgstr ""
"另請參閱檔案操作模組，例如 :mod:`fileinput`、:mod:`io`\\ （定義了 :func:"
"`open` 的 module ）、:mod:`os`、:mod:`os.path`、:mod:`tempfile` 以及 :mod:"
"`shutil`。"

#: ../../library/functions.rst:1443
msgid ""
"Raises an :ref:`auditing event <auditing>` ``open`` with arguments ``path``, "
"``mode``, ``flags``."
msgstr ""
"引發一個附帶引數 ``path``、``mode``、``flags`` 的\\ :ref:`稽核事件 "
"<auditing>` ``open``。"

#: ../../library/functions.rst:1445
msgid ""
"The ``mode`` and ``flags`` arguments may have been modified or inferred from "
"the original call."
msgstr "``mode`` 和 ``flags`` 引數可能會被原始的呼叫所修改或推論 (infer)。"

#: ../../library/functions.rst:1450
msgid "The *opener* parameter was added."
msgstr "增加了 *opener* 參數。"

#: ../../library/functions.rst:1451
msgid "The ``'x'`` mode was added."
msgstr "增加了 ``'x'`` 模式。"

#: ../../library/functions.rst:1452
msgid ":exc:`IOError` used to be raised, it is now an alias of :exc:`OSError`."
msgstr "過去引發的 :exc:`IOError`，現在是 :exc:`OSError` 的別名。"

#: ../../library/functions.rst:1453
msgid ""
":exc:`FileExistsError` is now raised if the file opened in exclusive "
"creation mode (``'x'``) already exists."
msgstr ""
"如果檔案已存在但使用了唯一性建立模式 (``'x'``)，現在會引發 :exc:"
"`FileExistsError`。"

#: ../../library/functions.rst:1458
msgid "The file is now non-inheritable."
msgstr "檔案在此版本開始是不可繼承的。"

#: ../../library/functions.rst:1462
msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the function now retries the system call instead of raising an :"
"exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"如果系統呼叫被中斷，但訊號處理程式沒有引發例外，此函式現在會重試系統呼叫，而"
"不是引發 :exc:`InterruptedError` 例外（原因詳見 :pep:`475`）。"

#: ../../library/functions.rst:1465
msgid "The ``'namereplace'`` error handler was added."
msgstr "增加了 ``'namereplace'`` 錯誤處理程式。"

#: ../../library/functions.rst:1469
msgid "Support added to accept objects implementing :class:`os.PathLike`."
msgstr "增加對於實作 :class:`os.PathLike` 物件的支援。"

#: ../../library/functions.rst:1470
msgid ""
"On Windows, opening a console buffer may return a subclass of :class:`io."
"RawIOBase` other than :class:`io.FileIO`."
msgstr ""
"在 Windows 上，開啟一個控制臺緩衝區可能會回傳 :class:`io.RawIOBase` 的 "
"subclass，而不是 :class:`io.FileIO`。"

#: ../../library/functions.rst:1473
msgid "The ``'U'`` mode has been removed."
msgstr "``'U'`` 模式被移除。"

#: ../../library/functions.rst:1478
msgid ""
"Given a string representing one Unicode character, return an integer "
"representing the Unicode code point of that character.  For example, "
"``ord('a')`` returns the integer ``97`` and ``ord('€')`` (Euro sign) returns "
"``8364``.  This is the inverse of :func:`chr`."
msgstr ""
"對於代表單個 Unicode 字元的字串，回傳代表它 Unicode 編碼位置的整數。例如 "
"``ord('a')`` 回傳整數 ``97``、``ord('€')``\\ （歐元符號）回傳 ``8364``。這"
"是 :func:`chr` 的逆函式。"

#: ../../library/functions.rst:1486
msgid ""
"Return *base* to the power *exp*; if *mod* is present, return *base* to the "
"power *exp*, modulo *mod* (computed more efficiently than ``pow(base, exp) % "
"mod``). The two-argument form ``pow(base, exp)`` is equivalent to using the "
"power operator: ``base**exp``."
msgstr ""
"回傳 *base* 的 *exp* 次方；如果 *mod* 存在，則回傳 *base* 的 *exp* 次方對 "
"*mod* 取餘數（比直接呼叫 ``pow(base, exp) % mod`` 計算更高效）。兩個引數形式"
"的 ``pow(exp, exp)`` 等價於次方運算子：``base**exp``。"

#: ../../library/functions.rst:1491
#, fuzzy
msgid ""
"The arguments must have numeric types.  With mixed operand types, the "
"coercion rules for binary arithmetic operators apply.  For :class:`int` "
"operands, the result has the same type as the operands (after coercion) "
"unless the second argument is negative; in that case, all arguments are "
"converted to float and a float result is delivered.  For example, ``pow(10, "
"2)`` returns ``100``, but ``pow(10, -2)`` returns ``0.01``.  For a negative "
"base of type :class:`int` or :class:`float` and a non-integral exponent, a "
"complex result is delivered.  For example, ``pow(-9, 0.5)`` returns a value "
"close to ``3j``. Whereas, for a negative base of type :class:`int` or :class:"
"`float` with an integral exponent, a float result is delivered. For example, "
"``pow(-9, 2.0)`` returns ``81.0``."
msgstr ""
"引數必須是數值型別。對於不同型別的運算元，會套用二元算術運算子的強制轉型 "
"(coercion) 規則。對於 :class:`int` 運算元，運算結果會（在強制轉型後）與運算元"
"的型別相同，除非第二個引數是負數；在這種情況下，所有的引數都會被轉換為浮點數"
"並得到浮點數的結果。例如，``pow(10, 2)`` 會回傳 ``100``，但 ``pow(10, -2)`` "
"會回傳 ``0.01``。如果底數 (base) 是型別為 :class:`int` 或 :class:`float` 的負"
"數，且指數 (exponent) 不是整數，則會得到一個複數的結果。例如，``pow(-9, "
"0.5)`` 會回傳一個接近 ``3j`` 的值。"

#: ../../library/functions.rst:1503
msgid ""
"For :class:`int` operands *base* and *exp*, if *mod* is present, *mod* must "
"also be of integer type and *mod* must be nonzero. If *mod* is present and "
"*exp* is negative, *base* must be relatively prime to *mod*. In that case, "
"``pow(inv_base, -exp, mod)`` is returned, where *inv_base* is an inverse to "
"*base* modulo *mod*."
msgstr ""
"對於 :class:`int` 運算元 *base* 和 *exp*，如果有給定 *mod*，則 *mod* 也必須是"
"整數型別，且 *mod* 必須不為零。如果有給定 *mod* 且 *exp* 為負，則 *base* 必須"
"與 *mod* 互質。在這種情況下，會回傳 ``pow(inv_base, -exp, mod)``，其中 "
"*inv_base* 是 *base* 對 *mod* 的模倒數 (inverse modulo)。"

#: ../../library/functions.rst:1509
msgid "Here's an example of computing an inverse for ``38`` modulo ``97``::"
msgstr "以下是一個計算 ``38`` 對 ``97`` 取模倒數的範例： ::"

#: ../../library/functions.rst:1511
msgid ""
">>> pow(38, -1, mod=97)\n"
"23\n"
">>> 23 * 38 % 97 == 1\n"
"True"
msgstr ""
">>> pow(38, -1, mod=97)\n"
"23\n"
">>> 23 * 38 % 97 == 1\n"
"True"

#: ../../library/functions.rst:1516
msgid ""
"For :class:`int` operands, the three-argument form of ``pow`` now allows the "
"second argument to be negative, permitting computation of modular inverses."
msgstr ""
"對於 :class:`int` 運算元，現在 ``pow`` 的三引數形式允許第二個引數為負數，也容"
"許模倒數的計算。"

#: ../../library/functions.rst:1521
msgid ""
"Allow keyword arguments.  Formerly, only positional arguments were supported."
msgstr "允許關鍵字引數。在此之前只支援位置引數。"

#: ../../library/functions.rst:1528
msgid ""
"Print *objects* to the text stream *file*, separated by *sep* and followed "
"by *end*.  *sep*, *end*, *file*, and *flush*, if present, must be given as "
"keyword arguments."
msgstr ""
"將 *objects* 列印到文字資料串流 *file*，用 *sep* 分隔並以 *end* 結尾。如果有"
"給定 *sep*、*end*、*file* 和 *flush*，那麼它們必須是關鍵字引數的形式。"

#: ../../library/functions.rst:1532
msgid ""
"All non-keyword arguments are converted to strings like :func:`str` does and "
"written to the stream, separated by *sep* and followed by *end*.  Both *sep* "
"and *end* must be strings; they can also be ``None``, which means to use the "
"default values.  If no *objects* are given, :func:`print` will just write "
"*end*."
msgstr ""
"所有的非關鍵字引數都會像是 :func:`str` 操作一樣地被轉換為字串，並寫入資料串"
"流，彼此以 *sep* 分隔，並以 *end* 結尾。*sep* 和 *end* 都必須是字串；它們也可"
"以是 ``None``，這表示使用預設值。如果沒有給定 *objects*，:func:`print` 就只會"
"寫入 *end*。"

#: ../../library/functions.rst:1538
msgid ""
"The *file* argument must be an object with a ``write(string)`` method; if it "
"is not present or ``None``, :data:`sys.stdout` will be used.  Since printed "
"arguments are converted to text strings, :func:`print` cannot be used with "
"binary mode file objects.  For these, use ``file.write(...)`` instead."
msgstr ""
"*file* 引數必須是一個有 ``write(string)`` method 的物件；如果沒有給定或被設"
"為 ``None``，則將使用 :data:`sys.stdout`。因為要列印的引數會被轉換為文字字"
"串，所以 :func:`print` 不能用於二進位模式的檔案物件。對於此類物件，請改用 "
"``file.write(...)``。"

#: ../../library/functions.rst:1543
msgid ""
"Output buffering is usually determined by *file*. However, if *flush* is "
"true, the stream is forcibly flushed."
msgstr ""
"輸出緩衝通常會由 *file* 決定。但是如果 *flush* 為 true，則資料串流會被強制清"
"除。"

#: ../../library/functions.rst:1547
msgid "Added the *flush* keyword argument."
msgstr "增加了 *flush* 關鍵字引數。"

#: ../../library/functions.rst:1553
msgid "Return a property attribute."
msgstr "回傳 property 屬性。"

#: ../../library/functions.rst:1555
msgid ""
"*fget* is a function for getting an attribute value.  *fset* is a function "
"for setting an attribute value. *fdel* is a function for deleting an "
"attribute value.  And *doc* creates a docstring for the attribute."
msgstr ""
"*fget* 是一個用於取得屬性值的函式，*fset* 是一個用於設定屬性值的函式，*fdel* "
"是一個用於刪除屬性值的函式，而 *doc* 會為該屬性建立一個說明字串。"

#: ../../library/functions.rst:1559
msgid "A typical use is to define a managed attribute ``x``::"
msgstr "一個典型的用途是定義一個受管理的屬性 ``x``： ::"

#: ../../library/functions.rst:1561
msgid ""
"class C:\n"
"    def __init__(self):\n"
"        self._x = None\n"
"\n"
"    def getx(self):\n"
"        return self._x\n"
"\n"
"    def setx(self, value):\n"
"        self._x = value\n"
"\n"
"    def delx(self):\n"
"        del self._x\n"
"\n"
"    x = property(getx, setx, delx, \"I'm the 'x' property.\")"
msgstr ""
"class C:\n"
"    def __init__(self):\n"
"        self._x = None\n"
"\n"
"    def getx(self):\n"
"        return self._x\n"
"\n"
"    def setx(self, value):\n"
"        self._x = value\n"
"\n"
"    def delx(self):\n"
"        del self._x\n"
"\n"
"    x = property(getx, setx, delx, \"I'm the 'x' property.\")"

#: ../../library/functions.rst:1576
msgid ""
"If *c* is an instance of *C*, ``c.x`` will invoke the getter, ``c.x = "
"value`` will invoke the setter, and ``del c.x`` the deleter."
msgstr ""
"如果 *c* 是 *C* 的一個實例，則 ``c.x`` 將會呼叫取得器 (getter)，``c.x = "
"value`` 會呼叫設定器 (setter)，而 ``del c.x`` 會呼叫刪除器 (deleter)。"

#: ../../library/functions.rst:1579
msgid ""
"If given, *doc* will be the docstring of the property attribute. Otherwise, "
"the property will copy *fget*'s docstring (if it exists).  This makes it "
"possible to create read-only properties easily using :func:`property` as a :"
"term:`decorator`::"
msgstr ""
"如果有給定 *doc*，它將會是 property 屬性的說明字串。否則，property 會複製 "
"*fget* 的說明字串（如果它存在的話）。這樣一來，就能夠輕鬆地使用 :func:"
"`property` 作為\\ :term:`裝飾器 <decorator>`\\ 來建立唯讀屬性： ::"

#: ../../library/functions.rst:1583
msgid ""
"class Parrot:\n"
"    def __init__(self):\n"
"        self._voltage = 100000\n"
"\n"
"    @property\n"
"    def voltage(self):\n"
"        \"\"\"Get the current voltage.\"\"\"\n"
"        return self._voltage"
msgstr ""

#: ../../library/functions.rst:1592
msgid ""
"The ``@property`` decorator turns the :meth:`!voltage` method into a "
"\"getter\" for a read-only attribute with the same name, and it sets the "
"docstring for *voltage* to \"Get the current voltage.\""
msgstr ""

#: ../../library/functions.rst:1600
msgid ""
"A property object has ``getter``, ``setter``, and ``deleter`` methods usable "
"as decorators that create a copy of the property with the corresponding "
"accessor function set to the decorated function.  This is best explained "
"with an example:"
msgstr ""

#: ../../library/functions.rst:1605
msgid ""
"class C:\n"
"    def __init__(self):\n"
"        self._x = None\n"
"\n"
"    @property\n"
"    def x(self):\n"
"        \"\"\"I'm the 'x' property.\"\"\"\n"
"        return self._x\n"
"\n"
"    @x.setter\n"
"    def x(self, value):\n"
"        self._x = value\n"
"\n"
"    @x.deleter\n"
"    def x(self):\n"
"        del self._x"
msgstr ""
"class C:\n"
"    def __init__(self):\n"
"        self._x = None\n"
"\n"
"    @property\n"
"    def x(self):\n"
"        \"\"\"I'm the 'x' property.\"\"\"\n"
"        return self._x\n"
"\n"
"    @x.setter\n"
"    def x(self, value):\n"
"        self._x = value\n"
"\n"
"    @x.deleter\n"
"    def x(self):\n"
"        del self._x"

#: ../../library/functions.rst:1624
msgid ""
"This code is exactly equivalent to the first example.  Be sure to give the "
"additional functions the same name as the original property (``x`` in this "
"case.)"
msgstr ""

#: ../../library/functions.rst:1628
msgid ""
"The returned property object also has the attributes ``fget``, ``fset``, and "
"``fdel`` corresponding to the constructor arguments."
msgstr ""

#: ../../library/functions.rst:1631
msgid "The docstrings of property objects are now writeable."
msgstr ""

#: ../../library/functions.rst:1640
msgid ""
"Rather than being a function, :class:`range` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-range` and :ref:`typesseq`."
msgstr ""

#: ../../library/functions.rst:1646
msgid ""
"Return a string containing a printable representation of an object.  For "
"many types, this function makes an attempt to return a string that would "
"yield an object with the same value when passed to :func:`eval`; otherwise, "
"the representation is a string enclosed in angle brackets that contains the "
"name of the type of the object together with additional information often "
"including the name and address of the object.  A class can control what this "
"function returns for its instances by defining a :meth:`~object.__repr__` "
"method. If :func:`sys.displayhook` is not accessible, this function will "
"raise :exc:`RuntimeError`."
msgstr ""

#: ../../library/functions.rst:1657
msgid "This class has a custom representation that can be evaluated::"
msgstr ""

#: ../../library/functions.rst:1659
msgid ""
"class Person:\n"
"   def __init__(self, name, age):\n"
"      self.name = name\n"
"      self.age = age\n"
"\n"
"   def __repr__(self):\n"
"      return f\"Person('{self.name}', {self.age})\""
msgstr ""
"class Person:\n"
"   def __init__(self, name, age):\n"
"      self.name = name\n"
"      self.age = age\n"
"\n"
"   def __repr__(self):\n"
"      return f\"Person('{self.name}', {self.age})\""

#: ../../library/functions.rst:1670
msgid ""
"Return a reverse :term:`iterator`.  *seq* must be an object which has a :"
"meth:`~object.__reversed__` method or supports the sequence protocol (the :"
"meth:`~object.__len__` method and the :meth:`~object.__getitem__` method "
"with integer arguments starting at ``0``)."
msgstr ""

#: ../../library/functions.rst:1678
msgid ""
"Return *number* rounded to *ndigits* precision after the decimal point.  If "
"*ndigits* is omitted or is ``None``, it returns the nearest integer to its "
"input."
msgstr ""

#: ../../library/functions.rst:1682
msgid ""
"For the built-in types supporting :func:`round`, values are rounded to the "
"closest multiple of 10 to the power minus *ndigits*; if two multiples are "
"equally close, rounding is done toward the even choice (so, for example, "
"both ``round(0.5)`` and ``round(-0.5)`` are ``0``, and ``round(1.5)`` is "
"``2``).  Any integer value is valid for *ndigits* (positive, zero, or "
"negative).  The return value is an integer if *ndigits* is omitted or "
"``None``. Otherwise, the return value has the same type as *number*."
msgstr ""

#: ../../library/functions.rst:1691
msgid ""
"For a general Python object ``number``, ``round`` delegates to ``number."
"__round__``."
msgstr ""

#: ../../library/functions.rst:1696
msgid ""
"The behavior of :func:`round` for floats can be surprising: for example, "
"``round(2.675, 2)`` gives ``2.67`` instead of the expected ``2.68``. This is "
"not a bug: it's a result of the fact that most decimal fractions can't be "
"represented exactly as a float.  See :ref:`tut-fp-issues` for more "
"information."
msgstr ""

#: ../../library/functions.rst:1708
msgid ""
"Return a new :class:`set` object, optionally with elements taken from "
"*iterable*.  ``set`` is a built-in class.  See :class:`set` and :ref:`types-"
"set` for documentation about this class."
msgstr ""

#: ../../library/functions.rst:1712
msgid ""
"For other containers see the built-in :class:`frozenset`, :class:`list`, :"
"class:`tuple`, and :class:`dict` classes, as well as the :mod:`collections` "
"module."
msgstr ""

#: ../../library/functions.rst:1719
msgid ""
"This is the counterpart of :func:`getattr`.  The arguments are an object, a "
"string, and an arbitrary value.  The string may name an existing attribute "
"or a new attribute.  The function assigns the value to the attribute, "
"provided the object allows it.  For example, ``setattr(x, 'foobar', 123)`` "
"is equivalent to ``x.foobar = 123``."
msgstr ""

#: ../../library/functions.rst:1725
msgid ""
"*name* need not be a Python identifier as defined in :ref:`identifiers` "
"unless the object chooses to enforce that, for example in a custom :meth:"
"`~object.__getattribute__` or via :attr:`~object.__slots__`. An attribute "
"whose name is not an identifier will not be accessible using the dot "
"notation, but is accessible through :func:`getattr` etc.."
msgstr ""

#: ../../library/functions.rst:1733
msgid ""
"Since :ref:`private name mangling <private-name-mangling>` happens at "
"compilation time, one must manually mangle a private attribute's (attributes "
"with two leading underscores) name in order to set it with :func:`setattr`."
msgstr ""

#: ../../library/functions.rst:1742
msgid ""
"Return a :term:`slice` object representing the set of indices specified by "
"``range(start, stop, step)``.  The *start* and *step* arguments default to "
"``None``."
msgstr ""

#: ../../library/functions.rst:1750
msgid ""
"Slice objects have read-only data attributes :attr:`!start`, :attr:`!stop`, "
"and :attr:`!step` which merely return the argument values (or their "
"default).  They have no other explicit functionality; however, they are used "
"by NumPy and other third-party packages."
msgstr ""

#: ../../library/functions.rst:1755
msgid ""
"Slice objects are also generated when extended indexing syntax is used.  For "
"example: ``a[start:stop:step]`` or ``a[start:stop, i]``.  See :func:"
"`itertools.islice` for an alternate version that returns an :term:`iterator`."
msgstr ""

#: ../../library/functions.rst:1760
msgid ""
"Slice objects are now :term:`hashable` (provided :attr:`~slice.start`, :attr:"
"`~slice.stop`, and :attr:`~slice.step` are hashable)."
msgstr ""

#: ../../library/functions.rst:1766
msgid "Return a new sorted list from the items in *iterable*."
msgstr ""

#: ../../library/functions.rst:1768
msgid ""
"Has two optional arguments which must be specified as keyword arguments."
msgstr "有兩個選擇性引數，只能使用關鍵字引數來指定。"

#: ../../library/functions.rst:1770
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each element in *iterable* (for example, ``key=str."
"lower``).  The default value is ``None`` (compare the elements directly)."
msgstr ""

#: ../../library/functions.rst:1774
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""

#: ../../library/functions.rst:1777
msgid ""
"Use :func:`functools.cmp_to_key` to convert an old-style *cmp* function to a "
"*key* function."
msgstr ""

#: ../../library/functions.rst:1780
msgid ""
"The built-in :func:`sorted` function is guaranteed to be stable. A sort is "
"stable if it guarantees not to change the relative order of elements that "
"compare equal --- this is helpful for sorting in multiple passes (for "
"example, sort by department, then by salary grade)."
msgstr ""

#: ../../library/functions.rst:1785
msgid ""
"The sort algorithm uses only ``<`` comparisons between items.  While "
"defining an :meth:`~object.__lt__` method will suffice for sorting, :PEP:`8` "
"recommends that all six :ref:`rich comparisons <comparisons>` be "
"implemented.  This will help avoid bugs when using the same data with other "
"ordering tools such as :func:`max` that rely on a different underlying "
"method.  Implementing all six comparisons also helps avoid confusion for "
"mixed type comparisons which can call reflected the :meth:`~object.__gt__` "
"method."
msgstr ""

#: ../../library/functions.rst:1794
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""

#: ../../library/functions.rst:1798
msgid "Transform a method into a static method."
msgstr ""

#: ../../library/functions.rst:1800
msgid ""
"A static method does not receive an implicit first argument. To declare a "
"static method, use this idiom::"
msgstr ""

#: ../../library/functions.rst:1803
msgid ""
"class C:\n"
"    @staticmethod\n"
"    def f(arg1, arg2, argN): ..."
msgstr ""
"class C:\n"
"    @staticmethod\n"
"    def f(arg1, arg2, argN): ..."

#: ../../library/functions.rst:1807
msgid ""
"The ``@staticmethod`` form is a function :term:`decorator` -- see :ref:"
"`function` for details."
msgstr ""
"``@staticmethod`` 語法是一個函式 :term:`decorator` - 參見 :ref:`function` 中"
"的詳細介紹。"

#: ../../library/functions.rst:1810
msgid ""
"A static method can be called either on the class (such as ``C.f()``) or on "
"an instance (such as ``C().f()``). Moreover, the static method :term:"
"`descriptor` is also callable, so it can be used in the class definition "
"(such as ``f()``)."
msgstr ""

#: ../../library/functions.rst:1815
msgid ""
"Static methods in Python are similar to those found in Java or C++. Also, "
"see :func:`classmethod` for a variant that is useful for creating alternate "
"class constructors."
msgstr ""

#: ../../library/functions.rst:1819
msgid ""
"Like all decorators, it is also possible to call ``staticmethod`` as a "
"regular function and do something with its result.  This is needed in some "
"cases where you need a reference to a function from a class body and you "
"want to avoid the automatic transformation to instance method.  For these "
"cases, use this idiom::"
msgstr ""

#: ../../library/functions.rst:1825
msgid ""
"def regular_function():\n"
"    ...\n"
"\n"
"class C:\n"
"    method = staticmethod(regular_function)"
msgstr ""
"def regular_function():\n"
"    ...\n"
"\n"
"class C:\n"
"    method = staticmethod(regular_function)"

#: ../../library/functions.rst:1831
msgid "For more information on static methods, see :ref:`types`."
msgstr "關於 static method 的更多資訊，請參考 :ref:`types`。"

#: ../../library/functions.rst:1833
msgid ""
"Static methods now inherit the method attributes (``__module__``, "
"``__name__``, ``__qualname__``, ``__doc__`` and ``__annotations__``), have a "
"new ``__wrapped__`` attribute, and are now callable as regular functions."
msgstr ""

#: ../../library/functions.rst:1848
msgid ""
"Return a :class:`str` version of *object*.  See :func:`str` for details."
msgstr ""

#: ../../library/functions.rst:1850
msgid ""
"``str`` is the built-in string :term:`class`.  For general information about "
"strings, see :ref:`textseq`."
msgstr ""

#: ../../library/functions.rst:1856
msgid ""
"Sums *start* and the items of an *iterable* from left to right and returns "
"the total.  The *iterable*'s items are normally numbers, and the start value "
"is not allowed to be a string."
msgstr ""

#: ../../library/functions.rst:1860
msgid ""
"For some use cases, there are good alternatives to :func:`sum`. The "
"preferred, fast way to concatenate a sequence of strings is by calling ``''."
"join(sequence)``.  To add floating-point values with extended precision, "
"see :func:`math.fsum`\\.  To concatenate a series of iterables, consider "
"using :func:`itertools.chain`."
msgstr ""

#: ../../library/functions.rst:1866
msgid "The *start* parameter can be specified as a keyword argument."
msgstr "*start* 參數可被指定為關鍵字引數。"

#: ../../library/functions.rst:1869
msgid ""
"Summation of floats switched to an algorithm that gives higher accuracy on "
"most builds."
msgstr ""

#: ../../library/functions.rst:1876
msgid ""
"Return a proxy object that delegates method calls to a parent or sibling "
"class of *type*.  This is useful for accessing inherited methods that have "
"been overridden in a class."
msgstr ""

#: ../../library/functions.rst:1880
msgid ""
"The *object_or_type* determines the :term:`method resolution order` to be "
"searched.  The search starts from the class right after the *type*."
msgstr ""

#: ../../library/functions.rst:1884
msgid ""
"For example, if :attr:`~class.__mro__` of *object_or_type* is ``D -> B -> C -"
"> A -> object`` and the value of *type* is ``B``, then :func:`super` "
"searches ``C -> A -> object``."
msgstr ""

#: ../../library/functions.rst:1888
msgid ""
"The :attr:`~class.__mro__` attribute of the class corresponding to "
"*object_or_type* lists the method resolution search order used by both :func:"
"`getattr` and :func:`super`.  The attribute is dynamic and can change "
"whenever the inheritance hierarchy is updated."
msgstr ""

#: ../../library/functions.rst:1893
msgid ""
"If the second argument is omitted, the super object returned is unbound.  If "
"the second argument is an object, ``isinstance(obj, type)`` must be true.  "
"If the second argument is a type, ``issubclass(type2, type)`` must be true "
"(this is useful for classmethods)."
msgstr ""

#: ../../library/functions.rst:1898
msgid ""
"There are two typical use cases for *super*.  In a class hierarchy with "
"single inheritance, *super* can be used to refer to parent classes without "
"naming them explicitly, thus making the code more maintainable.  This use "
"closely parallels the use of *super* in other programming languages."
msgstr ""

#: ../../library/functions.rst:1903
msgid ""
"The second use case is to support cooperative multiple inheritance in a "
"dynamic execution environment.  This use case is unique to Python and is not "
"found in statically compiled languages or languages that only support single "
"inheritance.  This makes it possible to implement \"diamond diagrams\" where "
"multiple base classes implement the same method.  Good design dictates that "
"such implementations have the same calling signature in every case (because "
"the order of calls is determined at runtime, because that order adapts to "
"changes in the class hierarchy, and because that order can include sibling "
"classes that are unknown prior to runtime)."
msgstr ""

#: ../../library/functions.rst:1913
msgid "For both use cases, a typical superclass call looks like this::"
msgstr ""

#: ../../library/functions.rst:1915
msgid ""
"class C(B):\n"
"    def method(self, arg):\n"
"        super().method(arg)    # This does the same thing as:\n"
"                               # super(C, self).method(arg)"
msgstr ""

#: ../../library/functions.rst:1920
msgid ""
"In addition to method lookups, :func:`super` also works for attribute "
"lookups.  One possible use case for this is calling :term:`descriptors "
"<descriptor>` in a parent or sibling class."
msgstr ""

#: ../../library/functions.rst:1924
msgid ""
"Note that :func:`super` is implemented as part of the binding process for "
"explicit dotted attribute lookups such as ``super().__getitem__(name)``. It "
"does so by implementing its own :meth:`~object.__getattribute__` method for "
"searching classes in a predictable order that supports cooperative multiple "
"inheritance. Accordingly, :func:`super` is undefined for implicit lookups "
"using statements or operators such as ``super()[name]``."
msgstr ""

#: ../../library/functions.rst:1932
msgid ""
"Also note that, aside from the zero argument form, :func:`super` is not "
"limited to use inside methods.  The two argument form specifies the "
"arguments exactly and makes the appropriate references.  The zero argument "
"form only works inside a class definition, as the compiler fills in the "
"necessary details to correctly retrieve the class being defined, as well as "
"accessing the current instance for ordinary methods."
msgstr ""

#: ../../library/functions.rst:1939
msgid ""
"For practical suggestions on how to design cooperative classes using :func:"
"`super`, see `guide to using super() <https://rhettinger.wordpress."
"com/2011/05/26/super-considered-super/>`_."
msgstr ""

#: ../../library/functions.rst:1949
msgid ""
"Rather than being a function, :class:`tuple` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-tuple` and :ref:`typesseq`."
msgstr ""

#: ../../library/functions.rst:1958
msgid ""
"With one argument, return the type of an *object*.  The return value is a "
"type object and generally the same object as returned by :attr:`object."
"__class__ <instance.__class__>`."
msgstr ""

#: ../../library/functions.rst:1962
msgid ""
"The :func:`isinstance` built-in function is recommended for testing the type "
"of an object, because it takes subclasses into account."
msgstr ""

#: ../../library/functions.rst:1966
msgid ""
"With three arguments, return a new type object.  This is essentially a "
"dynamic form of the :keyword:`class` statement. The *name* string is the "
"class name and becomes the :attr:`~definition.__name__` attribute. The "
"*bases* tuple contains the base classes and becomes the :attr:`~class."
"__bases__` attribute; if empty, :class:`object`, the ultimate base of all "
"classes, is added.  The *dict* dictionary contains attribute and method "
"definitions for the class body; it may be copied or wrapped before becoming "
"the :attr:`~object.__dict__` attribute. The following two statements create "
"identical :class:`type` objects:"
msgstr ""

#: ../../library/functions.rst:1981
msgid "See also :ref:`bltin-type-objects`."
msgstr "另請參閱 :ref:`bltin-type-objects`。"

#: ../../library/functions.rst:1983
msgid ""
"Keyword arguments provided to the three argument form are passed to the "
"appropriate metaclass machinery (usually :meth:`~object.__init_subclass__`) "
"in the same way that keywords in a class definition (besides *metaclass*) "
"would."
msgstr ""

#: ../../library/functions.rst:1988
msgid "See also :ref:`class-customization`."
msgstr "另請參閱 :ref:`class-customization`。"

#: ../../library/functions.rst:1990
msgid ""
"Subclasses of :class:`type` which don't override ``type.__new__`` may no "
"longer use the one-argument form to get the type of an object."
msgstr ""

#: ../../library/functions.rst:1997
msgid ""
"Return the :attr:`~object.__dict__` attribute for a module, class, instance, "
"or any other object with a :attr:`~object.__dict__` attribute."
msgstr ""

#: ../../library/functions.rst:2000
msgid ""
"Objects such as modules and instances have an updateable :attr:`~object."
"__dict__` attribute; however, other objects may have write restrictions on "
"their :attr:`~object.__dict__` attributes (for example, classes use a :class:"
"`types.MappingProxyType` to prevent direct dictionary updates)."
msgstr ""

#: ../../library/functions.rst:2005
msgid ""
"Without an argument, :func:`vars` acts like :func:`locals`.  Note, the "
"locals dictionary is only useful for reads since updates to the locals "
"dictionary are ignored."
msgstr ""

#: ../../library/functions.rst:2009
msgid ""
"A :exc:`TypeError` exception is raised if an object is specified but it "
"doesn't have a :attr:`~object.__dict__` attribute (for example, if its class "
"defines the :attr:`~object.__slots__` attribute)."
msgstr ""

#: ../../library/functions.rst:2015
msgid ""
"Iterate over several iterables in parallel, producing tuples with an item "
"from each one."
msgstr ""

#: ../../library/functions.rst:2018
msgid "Example::"
msgstr "例如： ::"

#: ../../library/functions.rst:2020
msgid ""
">>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):\n"
"...     print(item)\n"
"...\n"
"(1, 'sugar')\n"
"(2, 'spice')\n"
"(3, 'everything nice')"
msgstr ""
">>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):\n"
"...     print(item)\n"
"...\n"
"(1, 'sugar')\n"
"(2, 'spice')\n"
"(3, 'everything nice')"

#: ../../library/functions.rst:2027
msgid ""
"More formally: :func:`zip` returns an iterator of tuples, where the *i*-th "
"tuple contains the *i*-th element from each of the argument iterables."
msgstr ""

#: ../../library/functions.rst:2030
msgid ""
"Another way to think of :func:`zip` is that it turns rows into columns, and "
"columns into rows.  This is similar to `transposing a matrix <https://en."
"wikipedia.org/wiki/Transpose>`_."
msgstr ""

#: ../../library/functions.rst:2034
msgid ""
":func:`zip` is lazy: The elements won't be processed until the iterable is "
"iterated on, e.g. by a :keyword:`!for` loop or by wrapping in a :class:"
"`list`."
msgstr ""

#: ../../library/functions.rst:2038
msgid ""
"One thing to consider is that the iterables passed to :func:`zip` could have "
"different lengths; sometimes by design, and sometimes because of a bug in "
"the code that prepared these iterables.  Python offers three different "
"approaches to dealing with this issue:"
msgstr ""

#: ../../library/functions.rst:2043
msgid ""
"By default, :func:`zip` stops when the shortest iterable is exhausted. It "
"will ignore the remaining items in the longer iterables, cutting off the "
"result to the length of the shortest iterable::"
msgstr ""

#: ../../library/functions.rst:2047
msgid ""
">>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))\n"
"[(0, 'fee'), (1, 'fi'), (2, 'fo')]"
msgstr ""
">>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))\n"
"[(0, 'fee'), (1, 'fi'), (2, 'fo')]"

#: ../../library/functions.rst:2050
msgid ""
":func:`zip` is often used in cases where the iterables are assumed to be of "
"equal length.  In such cases, it's recommended to use the ``strict=True`` "
"option. Its output is the same as regular :func:`zip`::"
msgstr ""

#: ../../library/functions.rst:2054
msgid ""
">>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))\n"
"[('a', 1), ('b', 2), ('c', 3)]"
msgstr ""
">>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))\n"
"[('a', 1), ('b', 2), ('c', 3)]"

#: ../../library/functions.rst:2057
msgid ""
"Unlike the default behavior, it raises a :exc:`ValueError` if one iterable "
"is exhausted before the others:"
msgstr ""

#: ../../library/functions.rst:2075
msgid ""
"Without the ``strict=True`` argument, any bug that results in iterables of "
"different lengths will be silenced, possibly manifesting as a hard-to-find "
"bug in another part of the program."
msgstr ""

#: ../../library/functions.rst:2079
msgid ""
"Shorter iterables can be padded with a constant value to make all the "
"iterables have the same length.  This is done by :func:`itertools."
"zip_longest`."
msgstr ""

#: ../../library/functions.rst:2083
msgid ""
"Edge cases: With a single iterable argument, :func:`zip` returns an iterator "
"of 1-tuples.  With no arguments, it returns an empty iterator."
msgstr ""

#: ../../library/functions.rst:2086
msgid "Tips and tricks:"
msgstr ""

#: ../../library/functions.rst:2088
msgid ""
"The left-to-right evaluation order of the iterables is guaranteed. This "
"makes possible an idiom for clustering a data series into n-length groups "
"using ``zip(*[iter(s)]*n, strict=True)``.  This repeats the *same* iterator "
"``n`` times so that each output tuple has the result of ``n`` calls to the "
"iterator. This has the effect of dividing the input into n-length chunks."
msgstr ""

#: ../../library/functions.rst:2094
msgid ""
":func:`zip` in conjunction with the ``*`` operator can be used to unzip a "
"list::"
msgstr ""

#: ../../library/functions.rst:2097
msgid ""
">>> x = [1, 2, 3]\n"
">>> y = [4, 5, 6]\n"
">>> list(zip(x, y))\n"
"[(1, 4), (2, 5), (3, 6)]\n"
">>> x2, y2 = zip(*zip(x, y))\n"
">>> x == list(x2) and y == list(y2)\n"
"True"
msgstr ""
">>> x = [1, 2, 3]\n"
">>> y = [4, 5, 6]\n"
">>> list(zip(x, y))\n"
"[(1, 4), (2, 5), (3, 6)]\n"
">>> x2, y2 = zip(*zip(x, y))\n"
">>> x == list(x2) and y == list(y2)\n"
"True"

#: ../../library/functions.rst:2105
msgid "Added the ``strict`` argument."
msgstr "增加了 ``strict`` 引數。"

#: ../../library/functions.rst:2117
msgid ""
"This is an advanced function that is not needed in everyday Python "
"programming, unlike :func:`importlib.import_module`."
msgstr ""

#: ../../library/functions.rst:2120
msgid ""
"This function is invoked by the :keyword:`import` statement.  It can be "
"replaced (by importing the :mod:`builtins` module and assigning to "
"``builtins.__import__``) in order to change semantics of the :keyword:`!"
"import` statement, but doing so is **strongly** discouraged as it is usually "
"simpler to use import hooks (see :pep:`302`) to attain the same goals and "
"does not cause issues with code which assumes the default import "
"implementation is in use.  Direct use of :func:`__import__` is also "
"discouraged in favor of :func:`importlib.import_module`."
msgstr ""

#: ../../library/functions.rst:2129
msgid ""
"The function imports the module *name*, potentially using the given "
"*globals* and *locals* to determine how to interpret the name in a package "
"context. The *fromlist* gives the names of objects or submodules that should "
"be imported from the module given by *name*.  The standard implementation "
"does not use its *locals* argument at all and uses its *globals* only to "
"determine the package context of the :keyword:`import` statement."
msgstr ""

#: ../../library/functions.rst:2136
msgid ""
"*level* specifies whether to use absolute or relative imports. ``0`` (the "
"default) means only perform absolute imports.  Positive values for *level* "
"indicate the number of parent directories to search relative to the "
"directory of the module calling :func:`__import__` (see :pep:`328` for the "
"details)."
msgstr ""

#: ../../library/functions.rst:2142
msgid ""
"When the *name* variable is of the form ``package.module``, normally, the "
"top-level package (the name up till the first dot) is returned, *not* the "
"module named by *name*.  However, when a non-empty *fromlist* argument is "
"given, the module named by *name* is returned."
msgstr ""

#: ../../library/functions.rst:2147
msgid ""
"For example, the statement ``import spam`` results in bytecode resembling "
"the following code::"
msgstr ""

#: ../../library/functions.rst:2150
msgid "spam = __import__('spam', globals(), locals(), [], 0)"
msgstr "spam = __import__('spam', globals(), locals(), [], 0)"

#: ../../library/functions.rst:2152
msgid "The statement ``import spam.ham`` results in this call::"
msgstr ""

#: ../../library/functions.rst:2154
msgid "spam = __import__('spam.ham', globals(), locals(), [], 0)"
msgstr "spam = __import__('spam.ham', globals(), locals(), [], 0)"

#: ../../library/functions.rst:2156
msgid ""
"Note how :func:`__import__` returns the toplevel module here because this is "
"the object that is bound to a name by the :keyword:`import` statement."
msgstr ""

#: ../../library/functions.rst:2159
msgid ""
"On the other hand, the statement ``from spam.ham import eggs, sausage as "
"saus`` results in ::"
msgstr ""

#: ../../library/functions.rst:2162
msgid ""
"_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)\n"
"eggs = _temp.eggs\n"
"saus = _temp.sausage"
msgstr ""
"_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)\n"
"eggs = _temp.eggs\n"
"saus = _temp.sausage"

#: ../../library/functions.rst:2166
msgid ""
"Here, the ``spam.ham`` module is returned from :func:`__import__`.  From "
"this object, the names to import are retrieved and assigned to their "
"respective names."
msgstr ""

#: ../../library/functions.rst:2170
msgid ""
"If you simply want to import a module (potentially within a package) by "
"name, use :func:`importlib.import_module`."
msgstr ""

#: ../../library/functions.rst:2173
msgid ""
"Negative values for *level* are no longer supported (which also changes the "
"default value to 0)."
msgstr ""

#: ../../library/functions.rst:2177
msgid ""
"When the command line options :option:`-E` or :option:`-I` are being used, "
"the environment variable :envvar:`PYTHONCASEOK` is now ignored."
msgstr ""

#: ../../library/functions.rst:2182
msgid "Footnotes"
msgstr "註解"

#: ../../library/functions.rst:2183
msgid ""
"Note that the parser only accepts the Unix-style end of line convention. If "
"you are reading the code from a file, make sure to use newline conversion "
"mode to convert Windows or Mac-style newlines."
msgstr ""
"剖析器只接受 Unix 風格的行結束符。如果你從檔案中讀取程式碼，請確保用換行符號"
"轉換模式轉換 Windows 或 Mac 風格的換行符號。"

#: ../../library/functions.rst:154
msgid "Boolean"
msgstr "Boolean（布林值）"

#: ../../library/functions.rst:154 ../../library/functions.rst:1956
msgid "type"
msgstr "type（型別）"

#: ../../library/functions.rst:631
msgid "built-in function"
msgstr "built-in function（內建函式）"

#: ../../library/functions.rst:631
msgid "exec"
msgstr "exec"

#: ../../library/functions.rst:713
msgid "NaN"
msgstr "NaN"

#: ../../library/functions.rst:713
msgid "Infinity"
msgstr "Infinity（無窮）"

#: ../../library/functions.rst:781
msgid "__format__"
msgstr "__format__"

#: ../../library/functions.rst:781 ../../library/functions.rst:1840
msgid "string"
msgstr "string（字串）"

#: ../../library/functions.rst:781
msgid "format() (built-in function)"
msgstr "format()（內建函式）"

#: ../../library/functions.rst:1248
msgid "file object"
msgstr "file object（檔案物件）"

#: ../../library/functions.rst:1248 ../../library/functions.rst:1369
msgid "open() built-in function"
msgstr "open() 內建函式"

#: ../../library/functions.rst:1276
msgid "file"
msgstr "file（檔案）"

#: ../../library/functions.rst:1276
msgid "modes"
msgstr "modes（模式）"

#: ../../library/functions.rst:1369
msgid "universal newlines"
msgstr "universal newlines"

#: ../../library/functions.rst:1430
msgid "line-buffered I/O"
msgstr "line-buffered I/O（行緩衝 I/O）"

#: ../../library/functions.rst:1430
msgid "unbuffered I/O"
msgstr "unbuffered I/O（非緩衝 I/O）"

#: ../../library/functions.rst:1430
msgid "buffer size, I/O"
msgstr "buffer size, I/O（緩衝區大小、I/O）"

#: ../../library/functions.rst:1430
msgid "I/O control"
msgstr "I/O control（I/O 控制）"

#: ../../library/functions.rst:1430
msgid "buffering"
msgstr "buffering（緩衝）"

#: ../../library/functions.rst:1430
msgid "text mode"
msgstr "text mode（文字模式）"

#: ../../library/functions.rst:1430 ../../library/functions.rst:2111
msgid "module"
msgstr "module（模組）"

#: ../../library/functions.rst:1430
msgid "sys"
msgstr "sys"

#: ../../library/functions.rst:1840
msgid "str() (built-in function)"
msgstr "str() （內建函式）"

#: ../../library/functions.rst:1956
msgid "object"
msgstr "object（物件）"

#: ../../library/functions.rst:2111
msgid "statement"
msgstr "statement（陳述式）"

#: ../../library/functions.rst:2111
msgid "import"
msgstr "import（引入）"

#: ../../library/functions.rst:2111
msgid "builtins"
msgstr "builtins（內建）"
