# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-03 11:11+0800\n"
"PO-Revision-Date: 2023-12-08 00:08+0800\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.1\n"

#: ../../library/io.rst:2
msgid ":mod:`!io` --- Core tools for working with streams"
msgstr ":mod:`!io` — 處理資料串流的核心工具"

#: ../../library/io.rst:15
msgid "**Source code:** :source:`Lib/io.py`"
msgstr "**原始碼：**\\ :source:`Lib/io.py`"

#: ../../library/io.rst:22
msgid "Overview"
msgstr "總覽"

#: ../../library/io.rst:27
msgid ""
"The :mod:`io` module provides Python's main facilities for dealing with "
"various types of I/O.  There are three main types of I/O: *text I/O*, "
"*binary I/O* and *raw I/O*.  These are generic categories, and various "
"backing stores can be used for each of them.  A concrete object belonging to "
"any of these categories is called a :term:`file object`.  Other common terms "
"are *stream* and *file-like object*."
msgstr ""
":mod:`io` 模組替 Python 提供處理各種類型 IO 的主要工具。有三種主要的 IO 類"
"型： *文字 I/O (text I/O)*、*二進位 I/O (binary I/O)* 以及\\ *原始 I/O (raw "
"I/O)*。這些均為泛用 (generic) 類型，且每種類型都可以使用各式後端儲存 "
"(backing store)。任一種屬於這些類型的具體物件稱為 :term:`file object`。其它常"
"見的名詞還有\\ *資料串流 (stream)* 以及\\ *類檔案物件 (file-like objects)*。"

#: ../../library/io.rst:34
msgid ""
"Independent of its category, each concrete stream object will also have "
"various capabilities: it can be read-only, write-only, or read-write. It can "
"also allow arbitrary random access (seeking forwards or backwards to any "
"location), or only sequential access (for example in the case of a socket or "
"pipe)."
msgstr ""
"無論其類型為何，每個具體的資料串流物件也將具有各種能力：唯讀的、只接受寫入"
"的、或者讀寫兼具的。它還允許任意的隨機存取（向前或向後尋找至任意位置），或者"
"只能依順序存取（例如 socket 或 pipe 的情形下）。"

#: ../../library/io.rst:40
msgid ""
"All streams are careful about the type of data you give to them.  For "
"example giving a :class:`str` object to the :meth:`!write` method of a "
"binary stream will raise a :exc:`TypeError`.  So will giving a :class:"
"`bytes` object to the :meth:`!write` method of a text stream."
msgstr ""
"所有的資料串流都會謹慎處理你所提供的資料的型別。舉例來說，提供一個 :class:"
"`str` 物件給二進位資料串流的 :meth:`!write` 方法將會引發 :exc:`TypeError`。同"
"樣地，若提供一個 :class:`bytes` 物件給文字資料串流的 :meth:`!write` 方法，也"
"會引發同樣的錯誤。"

#: ../../library/io.rst:45
msgid ""
"Operations that used to raise :exc:`IOError` now raise :exc:`OSError`, "
"since :exc:`IOError` is now an alias of :exc:`OSError`."
msgstr ""
"原本會引發 :exc:`IOError` 的操作，現在將改成引發 :exc:`OSError`。因為 :exc:"
"`IOError` 現在是 :exc:`OSError` 的別名。"

#: ../../library/io.rst:51 ../../library/io.rst:855 ../../library/io.rst:1149
msgid "Text I/O"
msgstr "文字 I/O"

#: ../../library/io.rst:53
msgid ""
"Text I/O expects and produces :class:`str` objects.  This means that "
"whenever the backing store is natively made of bytes (such as in the case of "
"a file), encoding and decoding of data is made transparently as well as "
"optional translation of platform-specific newline characters."
msgstr ""
"文字 I/O 要求和產出 :class:`str` 物件。這意味著每當後端儲存為原生 bytes 時"
"（例如在檔案的情形下），資料的編碼與解碼會以清楚易懂的方式進行，也可選擇同時"
"轉換特定於平台的換行字元。"

#: ../../library/io.rst:58
msgid ""
"The easiest way to create a text stream is with :meth:`open`, optionally "
"specifying an encoding::"
msgstr ""
"建立文字資料串流最簡單的方法是使用 :meth:`open`，可選擇性地指定編碼： ::"

#: ../../library/io.rst:61
msgid "f = open(\"myfile.txt\", \"r\", encoding=\"utf-8\")"
msgstr "f = open(\"myfile.txt\", \"r\", encoding=\"utf-8\")"

#: ../../library/io.rst:63
msgid ""
"In-memory text streams are also available as :class:`StringIO` objects::"
msgstr "記憶體內的文字資料串流也可以使用 :class:`StringIO` 物件建立： ::"

#: ../../library/io.rst:65
msgid "f = io.StringIO(\"some initial text data\")"
msgstr "f = io.StringIO(\"some initial text data\")"

#: ../../library/io.rst:67
msgid ""
"The text stream API is described in detail in the documentation of :class:"
"`TextIOBase`."
msgstr "文字資料串流 API 的詳細說明在 :class:`TextIOBase` 文件當中。"

#: ../../library/io.rst:72 ../../library/io.rst:1137
msgid "Binary I/O"
msgstr "二進位 (Binary) I/O"

#: ../../library/io.rst:74
msgid ""
"Binary I/O (also called *buffered I/O*) expects :term:`bytes-like objects "
"<bytes-like object>` and produces :class:`bytes` objects.  No encoding, "
"decoding, or newline translation is performed.  This category of streams can "
"be used for all kinds of non-text data, and also when manual control over "
"the handling of text data is desired."
msgstr ""
"二進位 I/O（也稱為\\ *緩衝 I/O (buffered I/O)*）要求的是\\ :term:`類位元組物"
"件 (bytes-like objects) <bytes-like object>` 且產生 :class:`bytes` 物件。不進"
"行編碼、解碼或者換行字元轉換。這種類型的資料串流可用於各種非文字資料，以及需"
"要手動控制對文字資料的處理時。"

#: ../../library/io.rst:80
msgid ""
"The easiest way to create a binary stream is with :meth:`open` with ``'b'`` "
"in the mode string::"
msgstr ""
"建立二進位資料串流最簡單的方法是使用 :meth:`open`，並在 mode 字串中加入 "
"``'b'``： ::"

#: ../../library/io.rst:83
msgid "f = open(\"myfile.jpg\", \"rb\")"
msgstr "f = open(\"myfile.jpg\", \"rb\")"

#: ../../library/io.rst:85
msgid ""
"In-memory binary streams are also available as :class:`BytesIO` objects::"
msgstr "記憶體內的二進位資料串流也可以透過 :class:`BytesIO` 物件來建立： ::"

#: ../../library/io.rst:87
msgid "f = io.BytesIO(b\"some initial binary data: \\x00\\x01\")"
msgstr "f = io.BytesIO(b\"some initial binary data: \\x00\\x01\")"

#: ../../library/io.rst:89
msgid ""
"The binary stream API is described in detail in the docs of :class:"
"`BufferedIOBase`."
msgstr "二進位資料串流 API 的詳細說明在 :class:`BufferedIOBase` 文件當中。"

#: ../../library/io.rst:92
msgid ""
"Other library modules may provide additional ways to create text or binary "
"streams.  See :meth:`socket.socket.makefile` for example."
msgstr ""
"其它函式庫模組可能提供額外的方法來建立文字或二進位資料串流。例如 :meth:"
"`socket.socket.makefile`。"

#: ../../library/io.rst:97
msgid "Raw I/O"
msgstr "原始 (Raw) I/O"

#: ../../library/io.rst:99
msgid ""
"Raw I/O (also called *unbuffered I/O*) is generally used as a low-level "
"building-block for binary and text streams; it is rarely useful to directly "
"manipulate a raw stream from user code.  Nevertheless, you can create a raw "
"stream by opening a file in binary mode with buffering disabled::"
msgstr ""
"原始 I/O（也稱為\\ *無緩衝 I/O (unbuffered I/O)*）通常作為二進位以及文字資料"
"串流的低階 building-block 使用；在使用者程式碼中直接操作原始資料串流很少有"
"用。然而，你可以透過以無緩衝的二進位模式開啟一個檔案來建立一個原始資料串"
"流： ::"

#: ../../library/io.rst:104
msgid "f = open(\"myfile.jpg\", \"rb\", buffering=0)"
msgstr "f = open(\"myfile.jpg\", \"rb\", buffering=0)"

#: ../../library/io.rst:106
msgid ""
"The raw stream API is described in detail in the docs of :class:`RawIOBase`."
msgstr "原始串流 API 在 :class:`RawIOBase` 文件中有詳細描述。"

#: ../../library/io.rst:112
msgid "Text Encoding"
msgstr "文字編碼"

#: ../../library/io.rst:114
msgid ""
"The default encoding of :class:`TextIOWrapper` and :func:`open` is locale-"
"specific (:func:`locale.getencoding`)."
msgstr ""
":class:`TextIOWrapper` 和 :func:`open` 預設編碼是根據區域設定的 (locale-"
"specific) (:func:`locale.getencoding`)。"

#: ../../library/io.rst:117
msgid ""
"However, many developers forget to specify the encoding when opening text "
"files encoded in UTF-8 (e.g. JSON, TOML, Markdown, etc...) since most Unix "
"platforms use UTF-8 locale by default. This causes bugs because the locale "
"encoding is not UTF-8 for most Windows users. For example::"
msgstr ""
"然而，許多開發人員在開啟以 UTF-8 編碼的文字檔案（例如：JSON、TOML、Markdown"
"等）時忘記指定編碼，因為多數 Unix 平台預設使用 UTF-8 區域設定。這會導致錯誤，"
"因為對於大多數 Windows 使用者來說，預設地區編碼並非 UTF-8。舉例來說："

#: ../../library/io.rst:122
msgid ""
"# May not work on Windows when non-ASCII characters in the file.\n"
"with open(\"README.md\") as f:\n"
"    long_description = f.read()"
msgstr ""

#: ../../library/io.rst:126
msgid ""
"Accordingly, it is highly recommended that you specify the encoding "
"explicitly when opening text files. If you want to use UTF-8, pass "
"``encoding=\"utf-8\"``. To use the current locale encoding, "
"``encoding=\"locale\"`` is supported since Python 3.10."
msgstr ""
"因此，強烈建議在開啟文字檔案時，明確指定編碼。若你想使用 UTF-8 編碼，請傳入 "
"``encoding=\"utf-8\"``。若想使用目前的地區編碼，Python 3.10 以後的版本支援使"
"用 ``encoding=\"locale\"``。"

#: ../../library/io.rst:133
msgid ":ref:`utf8-mode`"
msgstr ":ref:`utf8-mode`"

#: ../../library/io.rst:134
msgid ""
"Python UTF-8 Mode can be used to change the default encoding to UTF-8 from "
"locale-specific encoding."
msgstr "在 Python UTF-8 模式下，可以將預設編碼從特定地區編碼改為 UTF-8。"

#: ../../library/io.rst:137
msgid ":pep:`686`"
msgstr ":pep:`686`"

#: ../../library/io.rst:138
msgid "Python 3.15 will make :ref:`utf8-mode` default."
msgstr "Python 3.15 將預設使用 :ref:`utf8-mode`。"

#: ../../library/io.rst:143
msgid "Opt-in EncodingWarning"
msgstr "選擇性加入的編碼警告"

#: ../../library/io.rst:145
msgid "See :pep:`597` for more details."
msgstr "更多資訊請見 :pep:`597`。"

#: ../../library/io.rst:148
msgid ""
"To find where the default locale encoding is used, you can enable the :"
"option:`-X warn_default_encoding <-X>` command line option or set the :"
"envvar:`PYTHONWARNDEFAULTENCODING` environment variable, which will emit an :"
"exc:`EncodingWarning` when the default encoding is used."
msgstr ""
"要找出哪些地方使用到預設的地區編碼，你可以啟用 :option:`-X "
"warn_default_encoding <-X>` 命令列選項，或者設定環境變數 :envvar:"
"`PYTHONWARNDEFAULTENCODING`。當使用到預設編碼時，會引發 :exc:"
"`EncodingWarning`。"

#: ../../library/io.rst:153
msgid ""
"If you are providing an API that uses :func:`open` or :class:`TextIOWrapper` "
"and passes ``encoding=None`` as a parameter, you can use :func:"
"`text_encoding` so that callers of the API will emit an :exc:"
"`EncodingWarning` if they don't pass an ``encoding``. However, please "
"consider using UTF-8 by default (i.e. ``encoding=\"utf-8\"``) for new APIs."
msgstr ""
"如果你正在提供一個使用 :func:`open` 或 :class:`TextIOWrapper` 且傳遞 "
"``encoding=None`` 作為參數的 API，你可以使用 :func:`text_encoding`。如此一來"
"如果 API 的呼叫方沒有傳遞 ``encoding``，呼叫方就會發出一個 :exc:"
"`EncodingWarning`。然而，對於新的 API，請考慮預設使用 UTF-8（即 "
"``encoding=\"utf-8\"``）。"

#: ../../library/io.rst:162
msgid "High-level Module Interface"
msgstr "高階模組介面"

#: ../../library/io.rst:166
msgid ""
"An int containing the default buffer size used by the module's buffered I/O "
"classes.  :func:`open` uses the file's blksize (as obtained by :func:`os."
"stat`) if possible."
msgstr ""
"一個包含模組中緩衝 I/O 類別所使用的預設緩衝區大小的整數。若可能的話，:func:"
"`open` 會使用檔案的 blksize （透過 :func:`os.stat` 取得）。"

#: ../../library/io.rst:173
msgid "This is an alias for the builtin :func:`open` function."
msgstr "這是內建函式 :func:`open` 的別名。"

#: ../../library/io.rst:175 ../../library/io.rst:177
msgid ""
"This function raises an :ref:`auditing event <auditing>` ``open`` with "
"arguments *path*, *mode* and *flags*. The *mode* and *flags* arguments may "
"have been modified or inferred from the original call."
msgstr ""
"此函式會引發一個帶有引數 *path*、*mode* 以及 *flags* 的\\ :ref:`稽核事件 "
"(auditing event) <auditing>` ``open``。*mode* 與 *flags* 引數可能已經被修改或"
"者從原始呼叫中被推斷出來。"

#: ../../library/io.rst:184
msgid ""
"Opens the provided file with mode ``'rb'``. This function should be used "
"when the intent is to treat the contents as executable code."
msgstr ""
"以 ``'rb'`` 模式開啟提供的檔案。此函式應用於意圖將內容視為可執行的程式碼的情"
"況下。"

#: ../../library/io.rst:187
msgid "*path* should be a :class:`str` and an absolute path."
msgstr "*path* 應該要屬於 :class:`str` 類別，且是個絕對路徑。"

#: ../../library/io.rst:189
msgid ""
"The behavior of this function may be overridden by an earlier call to the :c:"
"func:`PyFile_SetOpenCodeHook`. However, assuming that *path* is a :class:"
"`str` and an absolute path, ``open_code(path)`` should always behave the "
"same as ``open(path, 'rb')``. Overriding the behavior is intended for "
"additional validation or preprocessing of the file."
msgstr ""
"這個函式的行為可能會被之前對 :c:func:`PyFile_SetOpenCodeHook` 的呼叫覆寫。然"
"而，假設 *path* 是個 :class:`str` 且為絕對路徑，則 ``open_code(path)`` 總是"
"與 ``open(path, 'rb')`` 有相同行為。覆寫這個行為是為了對檔案進行額外驗證或預"
"處理。"

#: ../../library/io.rst:200
msgid ""
"This is a helper function for callables that use :func:`open` or :class:"
"`TextIOWrapper` and have an ``encoding=None`` parameter."
msgstr ""
"這是個輔助函數，適用於使用 :func:`open` 或 :class:`TextIOWrapper` 且具有 "
"``encoding=None`` 參數的可呼叫物件。"

#: ../../library/io.rst:203
msgid ""
"This function returns *encoding* if it is not ``None``. Otherwise, it "
"returns ``\"locale\"`` or ``\"utf-8\"`` depending on :ref:`UTF-8 Mode <utf8-"
"mode>`."
msgstr ""
"若 *encoding* 不為 ``None``，此函式將回傳 *encoding*。否則，將根據 :ref:"
"`UTF-8 Mode <utf8-mode>` 回傳 ``\"locale\"`` 或 ``\"utf-8\"``。"

#: ../../library/io.rst:207
msgid ""
"This function emits an :class:`EncodingWarning` if :data:`sys.flags."
"warn_default_encoding <sys.flags>` is true and *encoding* is ``None``. "
"*stacklevel* specifies where the warning is emitted. For example::"
msgstr ""
"若 :data:`sys.flags.warn_default_encoding <sys.flags>` 為真，且 *encoding* "
"為 ``None``，此函式會發出一個 :class:`EncodingWarning`。*stacklevel* 指定警告"
"在哪層發出。範例： ::"

#: ../../library/io.rst:212
msgid ""
"def read_text(path, encoding=None):\n"
"    encoding = io.text_encoding(encoding)  # stacklevel=2\n"
"    with open(path, encoding) as f:\n"
"        return f.read()"
msgstr ""
"def read_text(path, encoding=None):\n"
"    encoding = io.text_encoding(encoding)  # stacklevel=2\n"
"    with open(path, encoding) as f:\n"
"        return f.read()"

#: ../../library/io.rst:217
msgid ""
"In this example, an :class:`EncodingWarning` is emitted for the caller of "
"``read_text()``."
msgstr ""
"在此範例中，對於 ``read_text()`` 的呼叫方會引發一個 :class:"
"`EncodingWarning`。"

#: ../../library/io.rst:220
msgid "See :ref:`io-text-encoding` for more information."
msgstr "更多資訊請見 :ref:`io-text-encoding`。"

#: ../../library/io.rst:224
msgid ""
":func:`text_encoding` returns \"utf-8\" when UTF-8 mode is enabled and "
"*encoding* is ``None``."
msgstr ""
"當 UTF-8 模式啟用且 *encoding* 為 ``None`` 時，:func:`text_encoding` 會回傳 "
"\"utf-8\"。"

#: ../../library/io.rst:231
msgid ""
"This is a compatibility alias for the builtin :exc:`BlockingIOError` "
"exception."
msgstr "這是內建的 :exc:`BlockingIOError` 例外的相容性別名。"

#: ../../library/io.rst:237
msgid ""
"An exception inheriting :exc:`OSError` and :exc:`ValueError` that is raised "
"when an unsupported operation is called on a stream."
msgstr ""
"當在資料串流上呼叫不支援的操作時，會引發繼承自 :exc:`OSError` 與 :exc:"
"`ValueError` 的例外。"

#: ../../library/io.rst:243
msgid ":mod:`sys`"
msgstr ":mod:`sys`"

#: ../../library/io.rst:244
msgid ""
"contains the standard IO streams: :data:`sys.stdin`, :data:`sys.stdout`, "
"and :data:`sys.stderr`."
msgstr ""
"包含標準的 IO 資料串流：:data:`sys.stdin`、:data:`sys.stdout` 以及 :data:"
"`sys.stderr`。"

#: ../../library/io.rst:249
msgid "Class hierarchy"
msgstr "類別階層"

#: ../../library/io.rst:251
msgid ""
"The implementation of I/O streams is organized as a hierarchy of classes.  "
"First :term:`abstract base classes <abstract base class>` (ABCs), which are "
"used to specify the various categories of streams, then concrete classes "
"providing the standard stream implementations."
msgstr ""
"I/O 串流的實作是由多個類別組合成的階層結構所構成。首先是 :term:`abstract "
"base classes <abstract base class>` （抽象基底類別，ABCs），它們被用來規範各"
"種不同類型的串流，接著具體類別會提供標準串流的實作。"

#: ../../library/io.rst:258
msgid ""
"The abstract base classes also provide default implementations of some "
"methods in order to help implementation of concrete stream classes.  For "
"example, :class:`BufferedIOBase` provides unoptimized implementations of :"
"meth:`!readinto` and :meth:`!readline`."
msgstr ""
"為了協助具體串流類別的實作，抽象基底類別提供了某些方法的預設實作。舉例來說，:"
"class:`BufferedIOBase` 提供未經最佳化的 :meth:`!readinto` 與 :meth:`!"
"readline` 實作。"

#: ../../library/io.rst:263
msgid ""
"At the top of the I/O hierarchy is the abstract base class :class:`IOBase`.  "
"It defines the basic interface to a stream.  Note, however, that there is no "
"separation between reading and writing to streams; implementations are "
"allowed to raise :exc:`UnsupportedOperation` if they do not support a given "
"operation."
msgstr ""
"I/O 階層結構的最上層是抽象基底類別 :class:`IOBase`。它定義了串流的基礎的介"
"面。然而，請注意，讀取串流與寫入串流之間並沒有分離；若不支援給定的操作，實作"
"是允許引發 :exc:`UnsupportedOperation` 例外的。"

#: ../../library/io.rst:268
msgid ""
"The :class:`RawIOBase` ABC extends :class:`IOBase`.  It deals with the "
"reading and writing of bytes to a stream.  :class:`FileIO` subclasses :class:"
"`RawIOBase` to provide an interface to files in the machine's file system."
msgstr ""
"抽象基底類別 :class:`RawIOBase` 繼承 :class:`IOBase`。此類別處理對串流的位元"
"組讀寫。:class:`FileIO` 則繼承 :class:`RawIOBase` 來提供一個介面以存取機器檔"
"案系統內的檔案。"

#: ../../library/io.rst:272
msgid ""
"The :class:`BufferedIOBase` ABC extends :class:`IOBase`.  It deals with "
"buffering on a raw binary stream (:class:`RawIOBase`).  Its subclasses, :"
"class:`BufferedWriter`, :class:`BufferedReader`, and :class:`BufferedRWPair` "
"buffer raw binary streams that are writable, readable, and both readable and "
"writable, respectively. :class:`BufferedRandom` provides a buffered "
"interface to seekable streams. Another :class:`BufferedIOBase` subclass, :"
"class:`BytesIO`, is a stream of in-memory bytes."
msgstr ""
"抽象基底類別 :class:`BufferedIOBase` 繼承 :class:`IOBase`。此類別緩衝原始二進"
"位串流 (:class:`RawIOBase`)。它的子類別 :class:`BufferedWriter`、:class:"
"`BufferedReader` 與 :class:`BufferedRWPair` 分別緩衝可寫、可讀、可讀也可寫的"
"的原始二進位串流。類別 :class:`BufferedRandom` 則提供一個對可搜尋串流 "
"(seekable stream) 的緩衝介面。另一個類別 :class:`BufferedIOBase` 的子類別 :"
"class:`BytesIO`，是一個記憶體內位元組串流。"

#: ../../library/io.rst:280
msgid ""
"The :class:`TextIOBase` ABC extends :class:`IOBase`.  It deals with streams "
"whose bytes represent text, and handles encoding and decoding to and from "
"strings.  :class:`TextIOWrapper`, which extends :class:`TextIOBase`, is a "
"buffered text interface to a buffered raw stream (:class:`BufferedIOBase`).  "
"Finally, :class:`StringIO` is an in-memory stream for text."
msgstr ""
"抽象基底類別 :class:`TextIOBase` 繼承 :class:`IOBase`。此類別處理文本位元組串"
"流，並處理字串的編碼和解碼。類別 :class:`TextIOWrapper` 繼承自 :class:"
"`TextIOBase`，這是個對緩衝原始串流 (:class:`BufferedIOBase`) 的緩衝文本介面。"
"最後，:class:`StringIO` 是個文字記憶體內串流。"

#: ../../library/io.rst:286
msgid ""
"Argument names are not part of the specification, and only the arguments of :"
"func:`open` are intended to be used as keyword arguments."
msgstr "引數名稱不是規範的一部份，只有 :func:`open` 的引數將作為關鍵字引數。"

#: ../../library/io.rst:289
msgid ""
"The following table summarizes the ABCs provided by the :mod:`io` module:"
msgstr "以下表格總結了 :mod:`io` 模組提供的抽象基底類別 (ABC)："

#: ../../library/io.rst:294
msgid "ABC"
msgstr "抽象基底類別 (ABC)"

#: ../../library/io.rst:294
msgid "Inherits"
msgstr "繼承"

#: ../../library/io.rst:294
msgid "Stub Methods"
msgstr "Stub 方法"

#: ../../library/io.rst:294
msgid "Mixin Methods and Properties"
msgstr "Mixin 方法與屬性"

#: ../../library/io.rst:296 ../../library/io.rst:301 ../../library/io.rst:303
#: ../../library/io.rst:305
msgid ":class:`IOBase`"
msgstr ":class:`IOBase`"

#: ../../library/io.rst:296
msgid "``fileno``, ``seek``, and ``truncate``"
msgstr "``fileno``、``seek`` 和 ``truncate``"

#: ../../library/io.rst:296
msgid ""
"``close``, ``closed``, ``__enter__``, ``__exit__``, ``flush``, ``isatty``, "
"``__iter__``, ``__next__``, ``readable``, ``readline``, ``readlines``, "
"``seekable``, ``tell``, ``writable``, and ``writelines``"
msgstr ""
"``close``、``closed``、``__enter__``、``__exit__``、``flush``、``isatty``、"
"``__iter__``、``__next__``、``readable``、``readline``、``readlines``、"
"``seekable``、``tell``、``writable`` 與 ``writelines``"

#: ../../library/io.rst:301
msgid ":class:`RawIOBase`"
msgstr ":class:`RawIOBase`"

#: ../../library/io.rst:301
msgid "``readinto`` and ``write``"
msgstr "``readinto`` 和 ``write``"

#: ../../library/io.rst:301
msgid "Inherited :class:`IOBase` methods, ``read``, and ``readall``"
msgstr "繼承自 :class:`IOBase` 的方法，``read`` 與 ``readall``"

#: ../../library/io.rst:303
msgid ":class:`BufferedIOBase`"
msgstr ":class:`BufferedIOBase`"

#: ../../library/io.rst:303
msgid "``detach``, ``read``, ``read1``, and ``write``"
msgstr "``detach``、``read``、``read1`` 和 ``write``"

#: ../../library/io.rst:303
msgid "Inherited :class:`IOBase` methods, ``readinto``, and ``readinto1``"
msgstr "繼承自 :class:`IOBase` 的方法，``readinto`` 與 ``readinto1``"

#: ../../library/io.rst:305
msgid ":class:`TextIOBase`"
msgstr ":class:`TextIOBase`"

#: ../../library/io.rst:305
msgid "``detach``, ``read``, ``readline``, and ``write``"
msgstr "``detach``、``read``、``readline`` 和 ``write``"

#: ../../library/io.rst:305
msgid ""
"Inherited :class:`IOBase` methods, ``encoding``, ``errors``, and ``newlines``"
msgstr ""
"繼承自 :class:`IOBase` 的方法，``encoding``、``errors`` 與 ``newlines``"

#: ../../library/io.rst:312
msgid "I/O Base Classes"
msgstr "I/O 基礎類別"

#: ../../library/io.rst:316
msgid "The abstract base class for all I/O classes."
msgstr "所有 I/O 類別的抽象基礎類別。"

#: ../../library/io.rst:318
msgid ""
"This class provides empty abstract implementations for many methods that "
"derived classes can override selectively; the default implementations "
"represent a file that cannot be read, written or seeked."
msgstr ""
"為許多方法提供了空的抽象實作，衍生類別可以選擇性地覆寫這些方法；預設的實作代"
"表一個無法讀取、寫入或搜尋的檔案。"

#: ../../library/io.rst:323
msgid ""
"Even though :class:`IOBase` does not declare :meth:`!read` or :meth:`!write` "
"because their signatures will vary, implementations and clients should "
"consider those methods part of the interface.  Also, implementations may "
"raise a :exc:`ValueError` (or :exc:`UnsupportedOperation`) when operations "
"they do not support are called."
msgstr ""
"即使 :class:`IOBase` 因為實作的簽名差異巨大而沒有宣告 :meth:`!read` 或 :meth:"
"`!write` 方法，實作與用戶端應把這些方法視為介面的一部份。此外，當呼叫不被它們"
"支援的操作時，可能會引發 :exc:`ValueError` （或 :exc:`UnsupportedOperation`）"
"例外。"

#: ../../library/io.rst:329
msgid ""
"The basic type used for binary data read from or written to a file is :class:"
"`bytes`.  Other :term:`bytes-like objects <bytes-like object>` are accepted "
"as method arguments too.  Text I/O classes work with :class:`str` data."
msgstr ""

#: ../../library/io.rst:333
msgid ""
"Note that calling any method (even inquiries) on a closed stream is "
"undefined.  Implementations may raise :exc:`ValueError` in this case."
msgstr ""
"請注意，在一個已經關閉的串流上呼叫任何方法（即使只是查詢）都是未定義的。在這"
"種情況下，實作可能會引發 :exc:`ValueError` 例外。"

#: ../../library/io.rst:336
msgid ""
":class:`IOBase` (and its subclasses) supports the iterator protocol, meaning "
"that an :class:`IOBase` object can be iterated over yielding the lines in a "
"stream.  Lines are defined slightly differently depending on whether the "
"stream is a binary stream (yielding bytes), or a text stream (yielding "
"character strings).  See :meth:`~IOBase.readline` below."
msgstr ""

#: ../../library/io.rst:342
msgid ""
":class:`IOBase` is also a context manager and therefore supports the :"
"keyword:`with` statement.  In this example, *file* is closed after the :"
"keyword:`!with` statement's suite is finished---even if an exception occurs::"
msgstr ""
":class:`IOBase` 也是個情境管理器，因此支援 :keyword:`with` 陳述式。在這個例子"
"中，*file* 會在 :keyword:`!with` 陳述式執行完畢後關閉——即使發生了異常。"

#: ../../library/io.rst:346
msgid ""
"with open('spam.txt', 'w') as file:\n"
"    file.write('Spam and eggs!')"
msgstr ""
"with open('spam.txt', 'w') as file:\n"
"    file.write('Spam and eggs!')"

#: ../../library/io.rst:349
msgid ":class:`IOBase` provides these data attributes and methods:"
msgstr ":class:`IOBase` 提供這些資料屬性與方法："

#: ../../library/io.rst:353
msgid ""
"Flush and close this stream. This method has no effect if the file is "
"already closed. Once the file is closed, any operation on the file (e.g. "
"reading or writing) will raise a :exc:`ValueError`."
msgstr ""
"清除並關閉這個串流。若檔案已經關閉，則此方法沒有作用。一旦檔案被關閉，任何對"
"檔案的操作（例如讀取或寫入）將引發 :exc:`ValueError` 異常。"

#: ../../library/io.rst:357
msgid ""
"As a convenience, it is allowed to call this method more than once; only the "
"first call, however, will have an effect."
msgstr "為了方便起見，允許多次呼叫這個方法；然而，只有第一次呼叫會有效果。"

#: ../../library/io.rst:362
msgid "``True`` if the stream is closed."
msgstr "如果串流已關閉，則為 ``True``。"

#: ../../library/io.rst:366
msgid ""
"Return the underlying file descriptor (an integer) of the stream if it "
"exists.  An :exc:`OSError` is raised if the IO object does not use a file "
"descriptor."
msgstr ""
"如果串流存在，則回傳其底層的檔案描述器（一個整數）。如果 IO 物件不使用檔案描"
"述器，則會引發一個 :exc:`OSError` 例外。"

#: ../../library/io.rst:372
msgid ""
"Flush the write buffers of the stream if applicable.  This does nothing for "
"read-only and non-blocking streams."
msgstr ""
"如果適用，清空串流的寫入緩衝區。對於唯讀和非阻塞串流，此操作不會執行任何操"
"作。"

#: ../../library/io.rst:377
msgid ""
"Return ``True`` if the stream is interactive (i.e., connected to a terminal/"
"tty device)."
msgstr "如果串流是互動式的（即連接到終端機/tty 設備），則回傳 ``True``。"

#: ../../library/io.rst:382
msgid ""
"Return ``True`` if the stream can be read from. If ``False``, :meth:`!read` "
"will raise :exc:`OSError`."
msgstr ""
"如果串流可以被讀取，則回傳 ``True``。如果是 ``False``，:meth:`!read` 將會引"
"發 :exc:`OSError` 例外。"

#: ../../library/io.rst:387
msgid ""
"Read and return one line from the stream.  If *size* is specified, at most "
"*size* bytes will be read."
msgstr "從串流讀取並回傳一行。如果指定了 *size*，則最多讀取 *size* 個位元組。"

#: ../../library/io.rst:390
msgid ""
"The line terminator is always ``b'\\n'`` for binary files; for text files, "
"the *newline* argument to :func:`open` can be used to select the line "
"terminator(s) recognized."
msgstr ""
"對於二進位檔案，行結束符總是 ``b'\\n'``；對於文字檔案，可以使用 :func:`open` "
"函式的 *newline* 引數來選擇識別的行結束符號。"

#: ../../library/io.rst:396
msgid ""
"Read and return a list of lines from the stream.  *hint* can be specified to "
"control the number of lines read: no more lines will be read if the total "
"size (in bytes/characters) of all lines so far exceeds *hint*."
msgstr ""
"從串流讀取並回傳一個含有一或多行的 list。可以指定 *hint* 來控制讀取的行數：如"
"果到目前為止所有行的總大小（以位元組/字元計）超過 *hint*，則不會再讀取更多"
"行。"

#: ../../library/io.rst:400
msgid ""
"*hint* values of ``0`` or less, as well as ``None``, are treated as no hint."
msgstr "*hint* 值為 ``0`` 或更小，以及 ``None``，都被視為沒有提供 hint。"

#: ../../library/io.rst:403
msgid ""
"Note that it's already possible to iterate on file objects using ``for line "
"in file: ...`` without calling :meth:`!file.readlines`."
msgstr ""
"請注意，已經可以使用 ``for line in file: ...`` 在檔案物件上進行疊代，而不一定"
"需要呼叫 :meth:`!file.readlines`。"

#: ../../library/io.rst:408
msgid ""
"Change the stream position to the given byte *offset*, interpreted relative "
"to the position indicated by *whence*, and return the new absolute position. "
"Values for *whence* are:"
msgstr ""
"將串流位置改變到給定的位元組 *offset*，此位置是相對於由 *whence* 指示的位置解"
"釋的，並回傳新的絕對位置。*whence* 的值可為："

#: ../../library/io.rst:413
msgid ""
":data:`os.SEEK_SET` or ``0`` -- start of the stream (the default); *offset* "
"should be zero or positive"
msgstr ""
":data:`os.SEEK_SET` 或 ``0`` -- 串流的起點（預設值）；*offset* 應為零或正數"

#: ../../library/io.rst:415
msgid ""
":data:`os.SEEK_CUR` or ``1`` -- current stream position; *offset* may be "
"negative"
msgstr ":data:`os.SEEK_CUR` 或 ``1`` -- 目前串流位置；*offset* 可以是負數"

#: ../../library/io.rst:417
msgid ""
":data:`os.SEEK_END` or ``2`` -- end of the stream; *offset* is usually "
"negative"
msgstr ":data:`os.SEEK_END` 或 ``2`` -- 串流的結尾；*offset* 通常是負數"

#: ../../library/io.rst:420 ../../library/io.rst:930
msgid "The :data:`!SEEK_*` constants."
msgstr ":data:`!SEEK_*` 常數。"

#: ../../library/io.rst:423
msgid ""
"Some operating systems could support additional values, like :const:`os."
"SEEK_HOLE` or :const:`os.SEEK_DATA`. The valid values for a file could "
"depend on it being open in text or binary mode."
msgstr ""
"某些作業系統可以支援額外的值，例如 :const:`os.SEEK_HOLE` 或 :const:`os."
"SEEK_DATA`。檔案的合法值取決於它是以文字模式還是二進位模式開啟。"

#: ../../library/io.rst:430
msgid ""
"Return ``True`` if the stream supports random access.  If ``False``, :meth:"
"`seek`, :meth:`tell` and :meth:`truncate` will raise :exc:`OSError`."
msgstr ""
"如果串流支援隨機存取，則回傳 ``True``。如果是 ``False``，則 :meth:`seek`、:"
"meth:`tell` 和 :meth:`truncate` 會引發 :exc:`OSError`。"

#: ../../library/io.rst:435
msgid "Return the current stream position."
msgstr "回傳目前串流的位置。"

#: ../../library/io.rst:439
msgid ""
"Resize the stream to the given *size* in bytes (or the current position if "
"*size* is not specified).  The current stream position isn't changed. This "
"resizing can extend or reduce the current file size.  In case of extension, "
"the contents of the new file area depend on the platform (on most systems, "
"additional bytes are zero-filled).  The new file size is returned."
msgstr ""
"將串流的大小調整為指定的 *size* 位元組（如果沒有指定 *size*，則調整為目前位"
"置）。目前串流位置不會改變。這種調整可以擴展或縮減當前檔案大小。在擴展的情況"
"下，新檔案區域的內容取決於平台（在大多數系統上，額外的位元組會被填充為零）。"
"回傳新的檔案大小。"

#: ../../library/io.rst:446
msgid "Windows will now zero-fill files when extending."
msgstr "Windows 現在在擴展時會對檔案進行零填充 (zero-fill)。"

#: ../../library/io.rst:451
msgid ""
"Return ``True`` if the stream supports writing.  If ``False``, :meth:`!"
"write` and :meth:`truncate` will raise :exc:`OSError`."
msgstr ""
"如果串流支援寫入，則回傳 ``True``。如果是 ``False``，:meth:`!write` 和 :meth:"
"`truncate` 將會引發 :exc:`OSError`。"

#: ../../library/io.rst:456
msgid ""
"Write a list of lines to the stream.  Line separators are not added, so it "
"is usual for each of the lines provided to have a line separator at the end."
msgstr ""
"將一個包含每一行的 list 寫入串流。這不會新增行分隔符號，因此通常提供的每一行"
"末尾都有一個行分隔符號。"

#: ../../library/io.rst:462
msgid ""
"Prepare for object destruction. :class:`IOBase` provides a default "
"implementation of this method that calls the instance's :meth:`~IOBase."
"close` method."
msgstr ""
"為物件銷毀做準備。:class:`IOBase` 提供了這個方法的預設實作，該實作會呼叫實例"
"的 :meth:`~IOBase.close` 方法。"

#: ../../library/io.rst:469
msgid "Base class for raw binary streams.  It inherits from :class:`IOBase`."
msgstr "原始二進位串流的基底類別。它繼承自 :class:`IOBase`。"

#: ../../library/io.rst:471
msgid ""
"Raw binary streams typically provide low-level access to an underlying OS "
"device or API, and do not try to encapsulate it in high-level primitives "
"(this functionality is done at a higher-level in buffered binary streams and "
"text streams, described later in this page)."
msgstr ""
"原始二進位串流通常提供對底層作業系統設備或 API 的低階存取，並不嘗試將其封裝在"
"高階基元 (primitive) 中（這項功能在緩衝二進位串流和文字串流中的更高階層級完"
"成，後面的頁面會有描述）。"

#: ../../library/io.rst:476
msgid ""
":class:`RawIOBase` provides these methods in addition to those from :class:"
"`IOBase`:"
msgstr ":class:`RawIOBase` 除了 :class:`IOBase` 的方法外，還提供以下這些方法："

#: ../../library/io.rst:481
msgid ""
"Read up to *size* bytes from the object and return them.  As a convenience, "
"if *size* is unspecified or -1, all bytes until EOF are returned. Otherwise, "
"only one system call is ever made.  Fewer than *size* bytes may be returned "
"if the operating system call returns fewer than *size* bytes."
msgstr ""
"從物件中讀取最多 *size* 個位元組並回傳。方便起見，如果 *size* 未指定或為 -1，"
"則回傳直到檔案結尾 (EOF) 的所有位元組。否則，只會進行一次系統呼叫。如果作業系"
"統呼叫回傳的位元組少於 *size*，則可能回傳少於 *size* 的位元組。"

#: ../../library/io.rst:486
msgid ""
"If 0 bytes are returned, and *size* was not 0, this indicates end of file. "
"If the object is in non-blocking mode and no bytes are available, ``None`` "
"is returned."
msgstr ""
"如果回傳了 0 位元組，且 *size* 不是 0，這表示檔案結尾 (end of file)。如果物件"
"處於非阻塞模式且沒有可用的位元組，則回傳 ``None``。"

#: ../../library/io.rst:490
msgid ""
"The default implementation defers to :meth:`readall` and :meth:`readinto`."
msgstr "預設的實作會遵守 :meth:`readall` 和 :meth:`readinto` 的實作。"

#: ../../library/io.rst:495
msgid ""
"Read and return all the bytes from the stream until EOF, using multiple "
"calls to the stream if necessary."
msgstr "讀取並回傳串流中直到檔案結尾的所有位元組，必要時使用多次對串流的呼叫。"

#: ../../library/io.rst:500
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b*, and "
"return the number of bytes read.  For example, *b* might be a :class:"
"`bytearray`. If the object is in non-blocking mode and no bytes are "
"available, ``None`` is returned."
msgstr ""
"將位元組讀入一個預先分配的、可寫的 :term:`bytes-like object` （類位元組物"
"件） *b* 中，並回傳讀取的位元組數量。例如，*b* 可能是一個 :class:"
"`bytearray`。如果物件處於非阻塞模式且沒有可用的位元組，則回傳 ``None``。"

#: ../../library/io.rst:508
msgid ""
"Write the given :term:`bytes-like object`, *b*, to the underlying raw "
"stream, and return the number of bytes written.  This can be less than the "
"length of *b* in bytes, depending on specifics of the underlying raw stream, "
"and especially if it is in non-blocking mode.  ``None`` is returned if the "
"raw stream is set not to block and no single byte could be readily written "
"to it.  The caller may release or mutate *b* after this method returns, so "
"the implementation should only access *b* during the method call."
msgstr ""
"將給定的 :term:`bytes-like object` （類位元組物件），*b*，寫入底層的原始串"
"流，並回傳寫入的位元組大小。根據底層原始串流的具體情況，這可能少於 *b* 的位元"
"組長度，尤其是當它處於非阻塞模式時。如果原始串流設置為非阻塞且無法立即寫入任"
"何單一位元組，則回傳 ``None``。呼叫者在此方法回傳後可以釋放或變更 *b*，因此實"
"作應該只在方法呼叫期間存取 *b*。"

#: ../../library/io.rst:521
msgid ""
"Base class for binary streams that support some kind of buffering. It "
"inherits from :class:`IOBase`."
msgstr "支援某種緩衝的二進位串流的基底類別。它繼承自 :class:`IOBase`。"

#: ../../library/io.rst:524
msgid ""
"The main difference with :class:`RawIOBase` is that methods :meth:`read`, :"
"meth:`readinto` and :meth:`write` will try (respectively) to read as much "
"input as requested or to consume all given output, at the expense of making "
"perhaps more than one system call."
msgstr ""
"與 :class:`RawIOBase` 的主要差異在於，:meth:`read`、:meth:`readinto` 及 :"
"meth:`write` 方法將分別嘗試讀取所請求的盡可能多的輸入，或消耗所有給定的輸出，"
"即使可能需要進行多於一次的系統呼叫。"

#: ../../library/io.rst:529
msgid ""
"In addition, those methods can raise :exc:`BlockingIOError` if the "
"underlying raw stream is in non-blocking mode and cannot take or give enough "
"data; unlike their :class:`RawIOBase` counterparts, they will never return "
"``None``."
msgstr ""
"此外，如果底層的原始串流處於非阻塞模式且無法提供或接收足夠的資料，這些方法可"
"能會引發 :exc:`BlockingIOError` 例外；與 :class:`RawIOBase` 不同之處在於，它"
"們永遠不會回傳 ``None``。"

#: ../../library/io.rst:534
msgid ""
"Besides, the :meth:`read` method does not have a default implementation that "
"defers to :meth:`readinto`."
msgstr "此外，:meth:`read` 方法不存在一個遵從 :meth:`readinto` 的預設實作。"

#: ../../library/io.rst:537
msgid ""
"A typical :class:`BufferedIOBase` implementation should not inherit from a :"
"class:`RawIOBase` implementation, but wrap one, like :class:`BufferedWriter` "
"and :class:`BufferedReader` do."
msgstr ""
"一個典型的 :class:`BufferedIOBase` 實作不應該繼承自一個 :class:`RawIOBase` 的"
"實作，而是應該改用包裝的方式，像 :class:`BufferedWriter` 和 :class:"
"`BufferedReader` 那樣的作法。"

#: ../../library/io.rst:541
msgid ""
":class:`BufferedIOBase` provides or overrides these data attributes and "
"methods in addition to those from :class:`IOBase`:"
msgstr ""
":class:`BufferedIOBase` 除了提供或覆寫來自 :class:`IOBase` 的資料屬性和方法以"
"外，還包含了這些："

#: ../../library/io.rst:546
msgid ""
"The underlying raw stream (a :class:`RawIOBase` instance) that :class:"
"`BufferedIOBase` deals with.  This is not part of the :class:"
"`BufferedIOBase` API and may not exist on some implementations."
msgstr ""
"底層的原始串流（一個 :class:`RawIOBase` 實例），:class:`BufferedIOBase` 處理"
"的對象。這不是 :class:`BufferedIOBase` API 的一部分，且在某些實作可能不存在。"

#: ../../library/io.rst:552
msgid "Separate the underlying raw stream from the buffer and return it."
msgstr "將底層的原始串流從緩衝區中分離出來，並回傳它。"

#: ../../library/io.rst:554
msgid ""
"After the raw stream has been detached, the buffer is in an unusable state."
msgstr "在原始串流被分離後，緩衝區處於一個不可用的狀態。"

#: ../../library/io.rst:557
msgid ""
"Some buffers, like :class:`BytesIO`, do not have the concept of a single raw "
"stream to return from this method.  They raise :exc:`UnsupportedOperation`."
msgstr ""
"某些緩衝區，如 :class:`BytesIO`，沒有單一原始串流的概念可從此方法回傳。它們會"
"引發 :exc:`UnsupportedOperation`。"

#: ../../library/io.rst:565
msgid ""
"Read and return up to *size* bytes.  If the argument is omitted, ``None``, "
"or negative, data is read and returned until EOF is reached.  An empty :"
"class:`bytes` object is returned if the stream is already at EOF."
msgstr ""
"讀取並回傳最多 *size* 個位元組。如果引數被省略、為 ``None`` 或為負值，將讀取"
"並回傳資料直到達到 EOF 為止。如果串流已經處於 EOF，則回傳一個空的 :class:"
"`bytes` 物件。"

#: ../../library/io.rst:569
msgid ""
"If the argument is positive, and the underlying raw stream is not "
"interactive, multiple raw reads may be issued to satisfy the byte count "
"(unless EOF is reached first).  But for interactive raw streams, at most one "
"raw read will be issued, and a short result does not imply that EOF is "
"imminent."
msgstr ""
"如果引數為正數，且底層原始串流不是互動式的，可能會發出多次原始讀取來滿足位元"
"組數量（除非首先達到 EOF）。但對於互動式原始串流，最多只會發出一次原始讀取，"
"且短少的資料不表示 EOF 即將到來。"

#: ../../library/io.rst:575 ../../library/io.rst:598 ../../library/io.rst:608
msgid ""
"A :exc:`BlockingIOError` is raised if the underlying raw stream is in non "
"blocking-mode, and has no data available at the moment."
msgstr ""
"如果底層原始串流處於非阻塞模式，且當前沒有可用資料，則會引發 :exc:"
"`BlockingIOError`。"

#: ../../library/io.rst:580
msgid ""
"Read and return up to *size* bytes, with at most one call to the underlying "
"raw stream's :meth:`~RawIOBase.read` (or :meth:`~RawIOBase.readinto`) "
"method.  This can be useful if you are implementing your own buffering on "
"top of a :class:`BufferedIOBase` object."
msgstr ""
"讀取並回傳最多 *size* 個位元組，最多呼叫一次底層原始串流的 :meth:`~RawIOBase."
"read` (或 :meth:`~RawIOBase.readinto`) 方法。如果你正在 :class:"
"`BufferedIOBase` 物件之上實作自己的緩衝區，這可能會很有用。"

#: ../../library/io.rst:586
msgid ""
"If *size* is ``-1`` (the default), an arbitrary number of bytes are returned "
"(more than zero unless EOF is reached)."
msgstr ""
"如果 *size* 為 ``-1`` （預設值），則會回傳任意數量的位元組（除非達到 EOF，否"
"則會超過零）。"

#: ../../library/io.rst:591
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b* and "
"return the number of bytes read. For example, *b* might be a :class:"
"`bytearray`."
msgstr ""
"讀取位元組到一個預先分配的、可寫的 :term:`bytes-like object` *b* 當中，並回傳"
"讀取的位元組數量。例如，*b* 可能是一個 :class:`bytearray`。"

#: ../../library/io.rst:595
msgid ""
"Like :meth:`read`, multiple reads may be issued to the underlying raw "
"stream, unless the latter is interactive."
msgstr ""
"類似於 :meth:`read`，除非後者是互動式的，否則可能會對底層原始串流發出多次讀"
"取。"

#: ../../library/io.rst:603
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b*, "
"using at most one call to the underlying raw stream's :meth:`~RawIOBase."
"read` (or :meth:`~RawIOBase.readinto`) method. Return the number of bytes "
"read."
msgstr ""
"讀取位元組到一個預先分配的、可寫的 :term:`bytes-like object` *b* 中，最多呼叫"
"一次底層原始串流的 :meth:`~RawIOBase.read` （或 :meth:`~RawIOBase.readinto`）"
"方法。此方法回傳讀取的位元組數量。"

#: ../../library/io.rst:615
msgid ""
"Write the given :term:`bytes-like object`, *b*, and return the number of "
"bytes written (always equal to the length of *b* in bytes, since if the "
"write fails an :exc:`OSError` will be raised).  Depending on the actual "
"implementation, these bytes may be readily written to the underlying stream, "
"or held in a buffer for performance and latency reasons."
msgstr ""
"寫入給定的 :term:`bytes-like object`，*b*，並回傳寫入的位元組數量（總是等於 "
"*b* 的長度，以位元組計，因為如果寫入失敗將會引發 :exc:`OSError`）。根據實際的"
"實作，這些位元組可能會立即寫入底層串流，或出於性能和延遲的緣故而被留在緩衝區"
"當中。"

#: ../../library/io.rst:622
msgid ""
"When in non-blocking mode, a :exc:`BlockingIOError` is raised if the data "
"needed to be written to the raw stream but it couldn't accept all the data "
"without blocking."
msgstr ""
"當處於非阻塞模式時，如果需要將資料寫入原始串流，但它無法接受所有資料而不阻"
"塞，則會引發 :exc:`BlockingIOError`。"

#: ../../library/io.rst:626
msgid ""
"The caller may release or mutate *b* after this method returns, so the "
"implementation should only access *b* during the method call."
msgstr ""
"呼叫者可以在此方法回傳後釋放或變更 *b*，因此實作應該僅在方法呼叫期間存取 "
"*b*。"

#: ../../library/io.rst:631
msgid "Raw File I/O"
msgstr "原始檔案 I/O"

#: ../../library/io.rst:635
msgid ""
"A raw binary stream representing an OS-level file containing bytes data.  It "
"inherits from :class:`RawIOBase`."
msgstr ""
"一個代表包含位元組資料的 OS 層級檔案的原始二進制串流。它繼承自 :class:"
"`RawIOBase`。"

#: ../../library/io.rst:638
msgid "The *name* can be one of two things:"
msgstr "*name* 可以是兩種事物之一："

#: ../../library/io.rst:640
msgid ""
"a character string or :class:`bytes` object representing the path to the "
"file which will be opened. In this case closefd must be ``True`` (the "
"default) otherwise an error will be raised."
msgstr ""
"代表將要打開的檔案路徑的一個字元串或 :class:`bytes` 物件。在這種情況下，"
"closefd 必須是 ``True`` （預設值），否則將引發錯誤。"

#: ../../library/io.rst:643
msgid ""
"an integer representing the number of an existing OS-level file descriptor "
"to which the resulting :class:`FileIO` object will give access. When the "
"FileIO object is closed this fd will be closed as well, unless *closefd* is "
"set to ``False``."
msgstr ""

#: ../../library/io.rst:648
msgid ""
"The *mode* can be ``'r'``, ``'w'``, ``'x'`` or ``'a'`` for reading "
"(default), writing, exclusive creation or appending. The file will be "
"created if it doesn't exist when opened for writing or appending; it will be "
"truncated when opened for writing. :exc:`FileExistsError` will be raised if "
"it already exists when opened for creating. Opening a file for creating "
"implies writing, so this mode behaves in a similar way to ``'w'``. Add a "
"``'+'`` to the mode to allow simultaneous reading and writing."
msgstr ""

#: ../../library/io.rst:656
msgid ""
"The :meth:`~RawIOBase.read` (when called with a positive argument), :meth:"
"`~RawIOBase.readinto` and :meth:`~RawIOBase.write` methods on this class "
"will only make one system call."
msgstr ""

#: ../../library/io.rst:660
msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by calling "
"*opener* with (*name*, *flags*). *opener* must return an open file "
"descriptor (passing :mod:`os.open` as *opener* results in functionality "
"similar to passing ``None``)."
msgstr ""

#: ../../library/io.rst:666
msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr ""

#: ../../library/io.rst:668
msgid ""
"See the :func:`open` built-in function for examples on using the *opener* "
"parameter."
msgstr ""

#: ../../library/io.rst:671
msgid "The *opener* parameter was added. The ``'x'`` mode was added."
msgstr ""

#: ../../library/io.rst:675
msgid "The file is now non-inheritable."
msgstr ""

#: ../../library/io.rst:678
msgid ""
":class:`FileIO` provides these data attributes in addition to those from :"
"class:`RawIOBase` and :class:`IOBase`:"
msgstr ""

#: ../../library/io.rst:683
msgid "The mode as given in the constructor."
msgstr ""

#: ../../library/io.rst:687
msgid ""
"The file name.  This is the file descriptor of the file when no name is "
"given in the constructor."
msgstr ""

#: ../../library/io.rst:692
msgid "Buffered Streams"
msgstr ""

#: ../../library/io.rst:694
msgid ""
"Buffered I/O streams provide a higher-level interface to an I/O device than "
"raw I/O does."
msgstr ""

#: ../../library/io.rst:699
msgid ""
"A binary stream using an in-memory bytes buffer.  It inherits from :class:"
"`BufferedIOBase`.  The buffer is discarded when the :meth:`~IOBase.close` "
"method is called."
msgstr ""

#: ../../library/io.rst:703
msgid ""
"The optional argument *initial_bytes* is a :term:`bytes-like object` that "
"contains initial data."
msgstr ""

#: ../../library/io.rst:706
msgid ""
":class:`BytesIO` provides or overrides these methods in addition to those "
"from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""

#: ../../library/io.rst:711
msgid ""
"Return a readable and writable view over the contents of the buffer without "
"copying them.  Also, mutating the view will transparently update the "
"contents of the buffer::"
msgstr ""

#: ../../library/io.rst:715
msgid ""
">>> b = io.BytesIO(b\"abcdef\")\n"
">>> view = b.getbuffer()\n"
">>> view[2:4] = b\"56\"\n"
">>> b.getvalue()\n"
"b'ab56ef'"
msgstr ""
">>> b = io.BytesIO(b\"abcdef\")\n"
">>> view = b.getbuffer()\n"
">>> view[2:4] = b\"56\"\n"
">>> b.getvalue()\n"
"b'ab56ef'"

#: ../../library/io.rst:722
msgid ""
"As long as the view exists, the :class:`BytesIO` object cannot be resized or "
"closed."
msgstr ""

#: ../../library/io.rst:729
msgid "Return :class:`bytes` containing the entire contents of the buffer."
msgstr ""

#: ../../library/io.rst:734
msgid "In :class:`BytesIO`, this is the same as :meth:`~BufferedIOBase.read`."
msgstr ""

#: ../../library/io.rst:736 ../../library/io.rst:779
msgid "The *size* argument is now optional."
msgstr ""

#: ../../library/io.rst:741
msgid ""
"In :class:`BytesIO`, this is the same as :meth:`~BufferedIOBase.readinto`."
msgstr ""

#: ../../library/io.rst:747
msgid ""
"A buffered binary stream providing higher-level access to a readable, non "
"seekable :class:`RawIOBase` raw binary stream.  It inherits from :class:"
"`BufferedIOBase`."
msgstr ""

#: ../../library/io.rst:751
msgid ""
"When reading data from this object, a larger amount of data may be requested "
"from the underlying raw stream, and kept in an internal buffer. The buffered "
"data can then be returned directly on subsequent reads."
msgstr ""

#: ../../library/io.rst:755
msgid ""
"The constructor creates a :class:`BufferedReader` for the given readable "
"*raw* stream and *buffer_size*.  If *buffer_size* is omitted, :data:"
"`DEFAULT_BUFFER_SIZE` is used."
msgstr ""

#: ../../library/io.rst:759
msgid ""
":class:`BufferedReader` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""

#: ../../library/io.rst:764
msgid ""
"Return bytes from the stream without advancing the position.  At most one "
"single read on the raw stream is done to satisfy the call. The number of "
"bytes returned may be less or more than requested."
msgstr ""

#: ../../library/io.rst:770
msgid ""
"Read and return *size* bytes, or if *size* is not given or negative, until "
"EOF or if the read call would block in non-blocking mode."
msgstr ""

#: ../../library/io.rst:775
msgid ""
"Read and return up to *size* bytes with only one call on the raw stream. If "
"at least one byte is buffered, only buffered bytes are returned. Otherwise, "
"one raw stream read call is made."
msgstr ""

#: ../../library/io.rst:785
msgid ""
"A buffered binary stream providing higher-level access to a writeable, non "
"seekable :class:`RawIOBase` raw binary stream.  It inherits from :class:"
"`BufferedIOBase`."
msgstr ""

#: ../../library/io.rst:789
msgid ""
"When writing to this object, data is normally placed into an internal "
"buffer.  The buffer will be written out to the underlying :class:`RawIOBase` "
"object under various conditions, including:"
msgstr ""

#: ../../library/io.rst:793
msgid "when the buffer gets too small for all pending data;"
msgstr ""

#: ../../library/io.rst:794
msgid "when :meth:`flush` is called;"
msgstr ""

#: ../../library/io.rst:795
msgid ""
"when a :meth:`~IOBase.seek` is requested (for :class:`BufferedRandom` "
"objects);"
msgstr ""

#: ../../library/io.rst:796
msgid "when the :class:`BufferedWriter` object is closed or destroyed."
msgstr ""

#: ../../library/io.rst:798
msgid ""
"The constructor creates a :class:`BufferedWriter` for the given writeable "
"*raw* stream.  If the *buffer_size* is not given, it defaults to :data:"
"`DEFAULT_BUFFER_SIZE`."
msgstr ""

#: ../../library/io.rst:802
msgid ""
":class:`BufferedWriter` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""

#: ../../library/io.rst:807
msgid ""
"Force bytes held in the buffer into the raw stream.  A :exc:"
"`BlockingIOError` should be raised if the raw stream blocks."
msgstr ""

#: ../../library/io.rst:812
msgid ""
"Write the :term:`bytes-like object`, *b*, and return the number of bytes "
"written.  When in non-blocking mode, a :exc:`BlockingIOError` is raised if "
"the buffer needs to be written out but the raw stream blocks."
msgstr ""

#: ../../library/io.rst:820
msgid ""
"A buffered binary stream providing higher-level access to a seekable :class:"
"`RawIOBase` raw binary stream.  It inherits from :class:`BufferedReader` "
"and :class:`BufferedWriter`."
msgstr ""

#: ../../library/io.rst:824
msgid ""
"The constructor creates a reader and writer for a seekable raw stream, given "
"in the first argument.  If the *buffer_size* is omitted it defaults to :data:"
"`DEFAULT_BUFFER_SIZE`."
msgstr ""

#: ../../library/io.rst:828
msgid ""
":class:`BufferedRandom` is capable of anything :class:`BufferedReader` or :"
"class:`BufferedWriter` can do.  In addition, :meth:`~IOBase.seek` and :meth:"
"`~IOBase.tell` are guaranteed to be implemented."
msgstr ""

#: ../../library/io.rst:835
msgid ""
"A buffered binary stream providing higher-level access to two non seekable :"
"class:`RawIOBase` raw binary streams---one readable, the other writeable. It "
"inherits from :class:`BufferedIOBase`."
msgstr ""

#: ../../library/io.rst:839
msgid ""
"*reader* and *writer* are :class:`RawIOBase` objects that are readable and "
"writeable respectively.  If the *buffer_size* is omitted it defaults to :"
"data:`DEFAULT_BUFFER_SIZE`."
msgstr ""

#: ../../library/io.rst:843
msgid ""
":class:`BufferedRWPair` implements all of :class:`BufferedIOBase`\\'s "
"methods except for :meth:`~BufferedIOBase.detach`, which raises :exc:"
"`UnsupportedOperation`."
msgstr ""

#: ../../library/io.rst:849
msgid ""
":class:`BufferedRWPair` does not attempt to synchronize accesses to its "
"underlying raw streams.  You should not pass it the same object as reader "
"and writer; use :class:`BufferedRandom` instead."
msgstr ""

#: ../../library/io.rst:859
msgid ""
"Base class for text streams.  This class provides a character and line based "
"interface to stream I/O.  It inherits from :class:`IOBase`."
msgstr ""

#: ../../library/io.rst:862
msgid ""
":class:`TextIOBase` provides or overrides these data attributes and methods "
"in addition to those from :class:`IOBase`:"
msgstr ""

#: ../../library/io.rst:867
msgid ""
"The name of the encoding used to decode the stream's bytes into strings, and "
"to encode strings into bytes."
msgstr ""

#: ../../library/io.rst:872
msgid "The error setting of the decoder or encoder."
msgstr ""

#: ../../library/io.rst:876
msgid ""
"A string, a tuple of strings, or ``None``, indicating the newlines "
"translated so far.  Depending on the implementation and the initial "
"constructor flags, this may not be available."
msgstr ""

#: ../../library/io.rst:882
msgid ""
"The underlying binary buffer (a :class:`BufferedIOBase` instance) that :"
"class:`TextIOBase` deals with.  This is not part of the :class:`TextIOBase` "
"API and may not exist in some implementations."
msgstr ""

#: ../../library/io.rst:888
msgid ""
"Separate the underlying binary buffer from the :class:`TextIOBase` and "
"return it."
msgstr ""

#: ../../library/io.rst:891
msgid ""
"After the underlying buffer has been detached, the :class:`TextIOBase` is in "
"an unusable state."
msgstr ""

#: ../../library/io.rst:894
msgid ""
"Some :class:`TextIOBase` implementations, like :class:`StringIO`, may not "
"have the concept of an underlying buffer and calling this method will raise :"
"exc:`UnsupportedOperation`."
msgstr ""

#: ../../library/io.rst:902
msgid ""
"Read and return at most *size* characters from the stream as a single :class:"
"`str`.  If *size* is negative or ``None``, reads until EOF."
msgstr ""

#: ../../library/io.rst:907
msgid ""
"Read until newline or EOF and return a single :class:`str`.  If the stream "
"is already at EOF, an empty string is returned."
msgstr ""

#: ../../library/io.rst:910
msgid "If *size* is specified, at most *size* characters will be read."
msgstr ""

#: ../../library/io.rst:914
msgid ""
"Change the stream position to the given *offset*.  Behaviour depends on the "
"*whence* parameter.  The default value for *whence* is :data:`!SEEK_SET`."
msgstr ""

#: ../../library/io.rst:918
msgid ""
":data:`!SEEK_SET` or ``0``: seek from the start of the stream (the default); "
"*offset* must either be a number returned by :meth:`TextIOBase.tell`, or "
"zero.  Any other *offset* value produces undefined behaviour."
msgstr ""

#: ../../library/io.rst:922
msgid ""
":data:`!SEEK_CUR` or ``1``: \"seek\" to the current position; *offset* must "
"be zero, which is a no-operation (all other values are unsupported)."
msgstr ""

#: ../../library/io.rst:925
msgid ""
":data:`!SEEK_END` or ``2``: seek to the end of the stream; *offset* must be "
"zero (all other values are unsupported)."
msgstr ""

#: ../../library/io.rst:928
msgid "Return the new absolute position as an opaque number."
msgstr ""

#: ../../library/io.rst:935
msgid ""
"Return the current stream position as an opaque number.  The number does not "
"usually represent a number of bytes in the underlying binary storage."
msgstr ""

#: ../../library/io.rst:941
msgid ""
"Write the string *s* to the stream and return the number of characters "
"written."
msgstr ""

#: ../../library/io.rst:948
msgid ""
"A buffered text stream providing higher-level access to a :class:"
"`BufferedIOBase` buffered binary stream.  It inherits from :class:"
"`TextIOBase`."
msgstr ""

#: ../../library/io.rst:952
msgid ""
"*encoding* gives the name of the encoding that the stream will be decoded or "
"encoded with.  It defaults to :func:`locale.getencoding`. "
"``encoding=\"locale\"`` can be used to specify the current locale's encoding "
"explicitly. See :ref:`io-text-encoding` for more information."
msgstr ""

#: ../../library/io.rst:957
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled.  Pass ``'strict'`` to raise a :exc:`ValueError` "
"exception if there is an encoding error (the default of ``None`` has the "
"same effect), or pass ``'ignore'`` to ignore errors.  (Note that ignoring "
"encoding errors can lead to data loss.)  ``'replace'`` causes a replacement "
"marker (such as ``'?'``) to be inserted where there is malformed data. "
"``'backslashreplace'`` causes malformed data to be replaced by a backslashed "
"escape sequence.  When writing, ``'xmlcharrefreplace'`` (replace with the "
"appropriate XML character reference)  or ``'namereplace'`` (replace with "
"``\\N{...}`` escape sequences) can be used.  Any other error handling name "
"that has been registered with :func:`codecs.register_error` is also valid."
msgstr ""

#: ../../library/io.rst:973
msgid ""
"*newline* controls how line endings are handled.  It can be ``None``, "
"``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as follows:"
msgstr ""

#: ../../library/io.rst:976
msgid ""
"When reading input from the stream, if *newline* is ``None``, :term:"
"`universal newlines` mode is enabled.  Lines in the input can end in "
"``'\\n'``, ``'\\r'``, or ``'\\r\\n'``, and these are translated into "
"``'\\n'`` before being returned to the caller.  If *newline* is ``''``, "
"universal newlines mode is enabled, but line endings are returned to the "
"caller untranslated.  If *newline* has any of the other legal values, input "
"lines are only terminated by the given string, and the line ending is "
"returned to the caller untranslated."
msgstr ""

#: ../../library/io.rst:985
msgid ""
"When writing output to the stream, if *newline* is ``None``, any ``'\\n'`` "
"characters written are translated to the system default line separator, :"
"data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no translation "
"takes place.  If *newline* is any of the other legal values, any ``'\\n'`` "
"characters written are translated to the given string."
msgstr ""

#: ../../library/io.rst:991
msgid ""
"If *line_buffering* is ``True``, :meth:`~IOBase.flush` is implied when a "
"call to write contains a newline character or a carriage return."
msgstr ""

#: ../../library/io.rst:994
msgid ""
"If *write_through* is ``True``, calls to :meth:`~BufferedIOBase.write` are "
"guaranteed not to be buffered: any data written on the :class:"
"`TextIOWrapper` object is immediately handled to its underlying binary "
"*buffer*."
msgstr ""

#: ../../library/io.rst:998
msgid "The *write_through* argument has been added."
msgstr ""

#: ../../library/io.rst:1001
msgid ""
"The default *encoding* is now ``locale.getpreferredencoding(False)`` instead "
"of ``locale.getpreferredencoding()``. Don't change temporary the locale "
"encoding using :func:`locale.setlocale`, use the current locale encoding "
"instead of the user preferred encoding."
msgstr ""

#: ../../library/io.rst:1007
msgid ""
"The *encoding* argument now supports the ``\"locale\"`` dummy encoding name."
msgstr ""

#: ../../library/io.rst:1010
msgid ""
":class:`TextIOWrapper` provides these data attributes and methods in "
"addition to those from :class:`TextIOBase` and :class:`IOBase`:"
msgstr ""

#: ../../library/io.rst:1015
msgid "Whether line buffering is enabled."
msgstr ""

#: ../../library/io.rst:1019
msgid "Whether writes are passed immediately to the underlying binary buffer."
msgstr ""

#: ../../library/io.rst:1027
msgid ""
"Reconfigure this text stream using new settings for *encoding*, *errors*, "
"*newline*, *line_buffering* and *write_through*."
msgstr ""

#: ../../library/io.rst:1030
msgid ""
"Parameters not specified keep current settings, except ``errors='strict'`` "
"is used when *encoding* is specified but *errors* is not specified."
msgstr ""

#: ../../library/io.rst:1034
msgid ""
"It is not possible to change the encoding or newline if some data has "
"already been read from the stream. On the other hand, changing encoding "
"after write is possible."
msgstr ""

#: ../../library/io.rst:1038
msgid ""
"This method does an implicit stream flush before setting the new parameters."
msgstr ""

#: ../../library/io.rst:1043
msgid "The method supports ``encoding=\"locale\"`` option."
msgstr ""

#: ../../library/io.rst:1048
msgid ""
"Set the stream position. Return the new stream position as an :class:`int`."
msgstr ""

#: ../../library/io.rst:1051
msgid ""
"Four operations are supported, given by the following argument combinations:"
msgstr ""

#: ../../library/io.rst:1054
msgid "``seek(0, SEEK_SET)``: Rewind to the start of the stream."
msgstr ""

#: ../../library/io.rst:1055
msgid ""
"``seek(cookie, SEEK_SET)``: Restore a previous position; *cookie* **must "
"be** a number returned by :meth:`tell`."
msgstr ""

#: ../../library/io.rst:1057
msgid "``seek(0, SEEK_END)``: Fast-forward to the end of the stream."
msgstr ""

#: ../../library/io.rst:1058
msgid "``seek(0, SEEK_CUR)``: Leave the current stream position unchanged."
msgstr ""

#: ../../library/io.rst:1060
msgid "Any other argument combinations are invalid, and may raise exceptions."
msgstr ""

#: ../../library/io.rst:1065
msgid ":data:`os.SEEK_SET`, :data:`os.SEEK_CUR`, and :data:`os.SEEK_END`."
msgstr ""

#: ../../library/io.rst:1069
msgid ""
"Return the stream position as an opaque number. The return value of :meth:`!"
"tell` can be given as input to :meth:`seek`, to restore a previous stream "
"position."
msgstr ""

#: ../../library/io.rst:1076
msgid ""
"A text stream using an in-memory text buffer.  It inherits from :class:"
"`TextIOBase`."
msgstr ""

#: ../../library/io.rst:1079
msgid ""
"The text buffer is discarded when the :meth:`~IOBase.close` method is called."
msgstr ""

#: ../../library/io.rst:1082
msgid ""
"The initial value of the buffer can be set by providing *initial_value*. If "
"newline translation is enabled, newlines will be encoded as if by :meth:"
"`~TextIOBase.write`.  The stream is positioned at the start of the buffer "
"which emulates opening an existing file in a ``w+`` mode, making it ready "
"for an immediate write from the beginning or for a write that would "
"overwrite the initial value.  To emulate opening a file in an ``a+`` mode "
"ready for appending, use ``f.seek(0, io.SEEK_END)`` to reposition the stream "
"at the end of the buffer."
msgstr ""

#: ../../library/io.rst:1091
msgid ""
"The *newline* argument works like that of :class:`TextIOWrapper`, except "
"that when writing output to the stream, if *newline* is ``None``, newlines "
"are written as ``\\n`` on all platforms."
msgstr ""

#: ../../library/io.rst:1095
msgid ""
":class:`StringIO` provides this method in addition to those from :class:"
"`TextIOBase` and :class:`IOBase`:"
msgstr ""

#: ../../library/io.rst:1100
msgid ""
"Return a :class:`str` containing the entire contents of the buffer. Newlines "
"are decoded as if by :meth:`~TextIOBase.read`, although the stream position "
"is not changed."
msgstr ""

#: ../../library/io.rst:1104
msgid "Example usage::"
msgstr "使用範例： ::"

#: ../../library/io.rst:1106
msgid ""
"import io\n"
"\n"
"output = io.StringIO()\n"
"output.write('First line.\\n')\n"
"print('Second line.', file=output)\n"
"\n"
"# Retrieve file contents -- this will be\n"
"# 'First line.\\nSecond line.\\n'\n"
"contents = output.getvalue()\n"
"\n"
"# Close object and discard memory buffer --\n"
"# .getvalue() will now raise an exception.\n"
"output.close()"
msgstr ""

#: ../../library/io.rst:1126
msgid ""
"A helper codec that decodes newlines for :term:`universal newlines` mode. It "
"inherits from :class:`codecs.IncrementalDecoder`."
msgstr ""

#: ../../library/io.rst:1131
msgid "Performance"
msgstr ""

#: ../../library/io.rst:1133
msgid ""
"This section discusses the performance of the provided concrete I/O "
"implementations."
msgstr ""

#: ../../library/io.rst:1139
msgid ""
"By reading and writing only large chunks of data even when the user asks for "
"a single byte, buffered I/O hides any inefficiency in calling and executing "
"the operating system's unbuffered I/O routines.  The gain depends on the OS "
"and the kind of I/O which is performed.  For example, on some modern OSes "
"such as Linux, unbuffered disk I/O can be as fast as buffered I/O.  The "
"bottom line, however, is that buffered I/O offers predictable performance "
"regardless of the platform and the backing device.  Therefore, it is almost "
"always preferable to use buffered I/O rather than unbuffered I/O for binary "
"data."
msgstr ""

#: ../../library/io.rst:1151
msgid ""
"Text I/O over a binary storage (such as a file) is significantly slower than "
"binary I/O over the same storage, because it requires conversions between "
"unicode and binary data using a character codec.  This can become noticeable "
"handling huge amounts of text data like large log files.  Also, :meth:"
"`~TextIOBase.tell` and :meth:`~TextIOBase.seek` are both quite slow due to "
"the reconstruction algorithm used."
msgstr ""

#: ../../library/io.rst:1158
msgid ""
":class:`StringIO`, however, is a native in-memory unicode container and will "
"exhibit similar speed to :class:`BytesIO`."
msgstr ""

#: ../../library/io.rst:1162
msgid "Multi-threading"
msgstr ""

#: ../../library/io.rst:1164
msgid ""
":class:`FileIO` objects are thread-safe to the extent that the operating "
"system calls (such as :manpage:`read(2)` under Unix) they wrap are thread-"
"safe too."
msgstr ""

#: ../../library/io.rst:1167
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` and :class:`BufferedRWPair`) "
"protect their internal structures using a lock; it is therefore safe to call "
"them from multiple threads at once."
msgstr ""

#: ../../library/io.rst:1172
msgid ":class:`TextIOWrapper` objects are not thread-safe."
msgstr ""

#: ../../library/io.rst:1175
msgid "Reentrancy"
msgstr ""

#: ../../library/io.rst:1177
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` and :class:`BufferedRWPair`) are "
"not reentrant.  While reentrant calls will not happen in normal situations, "
"they can arise from doing I/O in a :mod:`signal` handler.  If a thread tries "
"to re-enter a buffered object which it is already accessing, a :exc:"
"`RuntimeError` is raised.  Note this doesn't prohibit a different thread "
"from entering the buffered object."
msgstr ""

#: ../../library/io.rst:1185
msgid ""
"The above implicitly extends to text files, since the :func:`open` function "
"will wrap a buffered object inside a :class:`TextIOWrapper`.  This includes "
"standard streams and therefore affects the built-in :func:`print` function "
"as well."
msgstr ""

#: ../../library/io.rst:24
msgid "file object"
msgstr "file object（檔案物件）"

#: ../../library/io.rst:24
msgid "io module"
msgstr "io 模組"

#: ../../library/io.rst:970 ../../library/io.rst:1121
msgid "universal newlines"
msgstr "universal newlines"

#: ../../library/io.rst:970
msgid "io.TextIOWrapper class"
msgstr "io.TextIOWrapper 類別"

#: ../../library/io.rst:1121
msgid "io.IncrementalNewlineDecoder class"
msgstr "io.IncrementalNewlineDecoder 類別"

#, fuzzy
#~ msgid ""
#~ "This function raises an auditing event open with arguments path, mode and "
#~ "flags. The mode and flags arguments may have been modified or inferred "
#~ "from the original call."
#~ msgstr ""
#~ "此函式會引發一個帶有引數 *path*、*mode* 以及 *flags* 的\\ :ref:`稽核事件 "
#~ "(auditing event) <auditing>` ``open``。*mode* 與 *flags* 引數可能已經被修"
#~ "改或者從原始呼叫中被推斷出來。"

#~ msgid ""
#~ "Raises an :ref:`auditing event <auditing>` ``open`` with arguments "
#~ "``path``, ``mode``, ``flags``."
#~ msgstr ""
#~ "引發一個附帶引數 ``path``、``mode``、``flags`` 的\\ :ref:`稽核事件 "
#~ "<auditing>` ``open``。"
