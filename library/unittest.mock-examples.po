# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-03 11:11+0800\n"
"PO-Revision-Date: 2024-05-06 08:22+0800\n"
"Last-Translator: Liang-Bo Wang <me@liang2.tw>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: ../../library/unittest.mock-examples.rst:2
msgid ":mod:`!unittest.mock` --- getting started"
msgstr ":mod:`!unittest.mock` --- 入門指南"

#: ../../library/unittest.mock-examples.rst:27
msgid "Using Mock"
msgstr "使用 Mock 的方式"

#: ../../library/unittest.mock-examples.rst:30
msgid "Mock Patching Methods"
msgstr "使用 Mock 來 patching 方法"

#: ../../library/unittest.mock-examples.rst:32
msgid "Common uses for :class:`Mock` objects include:"
msgstr ":class:`Mock` 物件的常見用法包含："

#: ../../library/unittest.mock-examples.rst:34
msgid "Patching methods"
msgstr "Patching 方法"

#: ../../library/unittest.mock-examples.rst:35
msgid "Recording method calls on objects"
msgstr "記錄在物件上的方法呼叫"

#: ../../library/unittest.mock-examples.rst:37
msgid ""
"You might want to replace a method on an object to check that it is called "
"with the correct arguments by another part of the system:"
msgstr ""
"你可能會想要取代一個物件上的方法，以便檢查系統的另一部分是否使用正確的引數呼"
"叫它："

#: ../../library/unittest.mock-examples.rst:45
msgid ""
"Once our mock has been used (``real.method`` in this example) it has methods "
"and attributes that allow you to make assertions about how it has been used."
msgstr ""
"一旦我們的 mock 已經被使用（例如在這個範例中的 ``real.method``\\ ），它就有了"
"方法和屬性，允許你對其使用方式進行斷言 (assertions)。"

#: ../../library/unittest.mock-examples.rst:50
msgid ""
"In most of these examples the :class:`Mock` and :class:`MagicMock` classes "
"are interchangeable. As the ``MagicMock`` is the more capable class it makes "
"a sensible one to use by default."
msgstr ""
"在大多數的範例中，:class:`Mock` 和 :class:`MagicMock` 類別是可以互換的。不過"
"由於 ``MagicMock`` 是功能更強大的類別，因此通常它是一個更好的選擇。"

#: ../../library/unittest.mock-examples.rst:54
msgid ""
"Once the mock has been called its :attr:`~Mock.called` attribute is set to "
"``True``. More importantly we can use the :meth:`~Mock.assert_called_with` "
"or :meth:`~Mock.assert_called_once_with` method to check that it was called "
"with the correct arguments."
msgstr ""
"一旦 mock 被呼叫，它的 :attr:`~Mock.called` 屬性將被設定為 ``True``。更重要的"
"是，我們可以使用 :meth:`~Mock.assert_called_with` 或 :meth:`~Mock."
"assert_called_once_with` 方法來檢查它是否被使用正確的引數來呼叫。"

#: ../../library/unittest.mock-examples.rst:59
msgid ""
"This example tests that calling ``ProductionClass().method`` results in a "
"call to the ``something`` method:"
msgstr ""
"這個範例測試呼叫 ``ProductionClass().method`` 是否導致對 ``something`` 方法的"
"呼叫："

#: ../../library/unittest.mock-examples.rst:76
msgid "Mock for Method Calls on an Object"
msgstr "對物件的方法呼叫使用 mock"

#: ../../library/unittest.mock-examples.rst:78
msgid ""
"In the last example we patched a method directly on an object to check that "
"it was called correctly. Another common use case is to pass an object into a "
"method (or some part of the system under test) and then check that it is "
"used in the correct way."
msgstr ""
"在上一個範例中，我們直接對物件上的方法進行 patch，以檢查它是否被正確呼叫。另"
"一個常見的用法是將一個物件傳遞給一個方法（或受測系統的某一部分），然後檢查它"
"是否以正確的方式被使用。"

#: ../../library/unittest.mock-examples.rst:83
msgid ""
"The simple ``ProductionClass`` below has a ``closer`` method. If it is "
"called with an object then it calls ``close`` on it."
msgstr ""
"下面是一個單純的 ``ProductionClass``，含有一個 ``closer`` 方法。如果它被傳入"
"一個物件，它就會呼叫此物件中的 ``close``。"

#: ../../library/unittest.mock-examples.rst:91
msgid ""
"So to test it we need to pass in an object with a ``close`` method and check "
"that it was called correctly."
msgstr ""
"因此，為了對此進行測試，我們需要傳遞一個具有 ``close`` 方法的物件，並檢查它是"
"否被正確的呼叫。"

#: ../../library/unittest.mock-examples.rst:99
msgid ""
"We don't have to do any work to provide the 'close' method on our mock. "
"Accessing close creates it. So, if 'close' hasn't already been called then "
"accessing it in the test will create it, but :meth:`~Mock."
"assert_called_with` will raise a failure exception."
msgstr ""
"我們不必做任何額外的事情來為 mock 提供 'close' 方法，存取 close 會建立它。因"
"此，如果 'close' 並未被呼叫過，在測試中存取 'close' 就會建立它，但 :meth:"
"`~Mock.assert_called_with` 就會引發一個失敗的例外。"

#: ../../library/unittest.mock-examples.rst:106
msgid "Mocking Classes"
msgstr "Mock 類別"

#: ../../library/unittest.mock-examples.rst:108
msgid ""
"A common use case is to mock out classes instantiated by your code under "
"test. When you patch a class, then that class is replaced with a mock. "
"Instances are created by *calling the class*. This means you access the "
"\"mock instance\" by looking at the return value of the mocked class."
msgstr ""
"一個常見的使用案例是在測試的時候 mock 被程式碼實例化的類別。當你 patch 一個類"
"別時，該類別就會被替換為 mock。實例是透過\\ *呼叫類別*\\ 建立的。這代表你可以"
"透過查看被 mock 的類別的回傳值來存取「mock 實例」。"

#: ../../library/unittest.mock-examples.rst:113
msgid ""
"In the example below we have a function ``some_function`` that instantiates "
"``Foo`` and calls a method on it. The call to :func:`patch` replaces the "
"class ``Foo`` with a mock. The ``Foo`` instance is the result of calling the "
"mock, so it is configured by modifying the mock :attr:`~Mock."
"return_value`. ::"
msgstr ""
"在下面的範例中，我們有一個函式 ``some_function``，它實例化 ``Foo`` 並呼叫它的"
"方法。對 :func:`patch` 的呼叫將類別 ``Foo`` 替換為一個 mock。``Foo`` 實例是呼"
"叫 mock 的結果，因此它是透過修改 mock :attr:`~Mock.return_value` 來配置"
"的。： ::"

#: ../../library/unittest.mock-examples.rst:118
msgid ""
">>> def some_function():\n"
"...     instance = module.Foo()\n"
"...     return instance.method()\n"
"...\n"
">>> with patch('module.Foo') as mock:\n"
"...     instance = mock.return_value\n"
"...     instance.method.return_value = 'the result'\n"
"...     result = some_function()\n"
"...     assert result == 'the result'"
msgstr ""
">>> def some_function():\n"
"...     instance = module.Foo()\n"
"...     return instance.method()\n"
"...\n"
">>> with patch('module.Foo') as mock:\n"
"...     instance = mock.return_value\n"
"...     instance.method.return_value = 'the result'\n"
"...     result = some_function()\n"
"...     assert result == 'the result'"

#: ../../library/unittest.mock-examples.rst:130
msgid "Naming your mocks"
msgstr "命名你的 mock"

#: ../../library/unittest.mock-examples.rst:132
msgid ""
"It can be useful to give your mocks a name. The name is shown in the repr of "
"the mock and can be helpful when the mock appears in test failure messages. "
"The name is also propagated to attributes or methods of the mock:"
msgstr ""
"為你的 mock 命名可能會很有用。這個名稱會顯示在 mock 的 repr 中，且當 mock 出"
"現在測試的失敗訊息中時，名稱會很有幫助。該名稱也會傳播到 mock 的屬性或方法："

#: ../../library/unittest.mock-examples.rst:144
msgid "Tracking all Calls"
msgstr "追蹤所有呼叫"

#: ../../library/unittest.mock-examples.rst:146
msgid ""
"Often you want to track more than a single call to a method. The :attr:"
"`~Mock.mock_calls` attribute records all calls to child attributes of the "
"mock - and also to their children."
msgstr ""
"通常你會想要追蹤對一個方法的多個呼叫。:attr:`~Mock.mock_calls` 屬性記錄對 "
"mock 的子屬性以及其子屬性的所有呼叫。"

#: ../../library/unittest.mock-examples.rst:158
msgid ""
"If you make an assertion about ``mock_calls`` and any unexpected methods "
"have been called, then the assertion will fail. This is useful because as "
"well as asserting that the calls you expected have been made, you are also "
"checking that they were made in the right order and with no additional calls:"
msgstr ""
"如果你對 ``mock_calls`` 做出斷言並且有任何不預期的方法被呼叫，則斷言將失敗。"
"這很有用，因為除了斷言你期望的呼叫已經進行之外，你還可以檢查它們是否按正確的"
"順序進行，並且沒有多餘的呼叫："

#: ../../library/unittest.mock-examples.rst:163
msgid ""
"You use the :data:`call` object to construct lists for comparing with "
"``mock_calls``:"
msgstr "你可以使用 :data:`call` 物件來建構串列以與 ``mock_calls`` 進行比較："

#: ../../library/unittest.mock-examples.rst:170
msgid ""
"However, parameters to calls that return mocks are not recorded, which means "
"it is not possible to track nested calls where the parameters used to create "
"ancestors are important:"
msgstr ""
"然而，回傳 mock 的呼叫的參數不會被記錄，這代表在巢狀呼叫中，無法追蹤用於建立"
"上代的參數 important 的值："

#: ../../library/unittest.mock-examples.rst:181
msgid "Setting Return Values and Attributes"
msgstr "設定回傳值和屬性"

#: ../../library/unittest.mock-examples.rst:183
msgid "Setting the return values on a mock object is trivially easy:"
msgstr "在 mock 物件上設定回傳值非常簡單："

#: ../../library/unittest.mock-examples.rst:190
msgid "Of course you can do the same for methods on the mock:"
msgstr "當然，你可以對 mock 上的方法執行相同的操作："

#: ../../library/unittest.mock-examples.rst:197
msgid "The return value can also be set in the constructor:"
msgstr "回傳值也可以在建構函式中設定："

#: ../../library/unittest.mock-examples.rst:203
msgid "If you need an attribute setting on your mock, just do it:"
msgstr "如果你需要在 mock 上進行屬性設置，只需執行以下操作："

#: ../../library/unittest.mock-examples.rst:210
msgid ""
"Sometimes you want to mock up a more complex situation, like for example "
"``mock.connection.cursor().execute(\"SELECT 1\")``. If we wanted this call "
"to return a list, then we have to configure the result of the nested call."
msgstr ""
"有時你想要 mock 更複雜的情況，例如 ``mock.connection.cursor()."
"execute(\"SELECT 1\")``。如果我們希望此呼叫回傳一個串列，那麼我們就必須配置巢"
"狀呼叫的結果。"

#: ../../library/unittest.mock-examples.rst:214
msgid ""
"We can use :data:`call` to construct the set of calls in a \"chained call\" "
"like this for easy assertion afterwards:"
msgstr ""
"如下所示，我們可以使用 :data:`call` 在「鍊接呼叫 (chained call)」中建構呼叫的"
"集合，以便在之後輕鬆的進行斷言："

#: ../../library/unittest.mock-examples.rst:228
msgid ""
"It is the call to ``.call_list()`` that turns our call object into a list of "
"calls representing the chained calls."
msgstr ""
"正是對 ``.call_list()`` 的呼叫將我們的呼叫物件轉換為代表鍊接呼叫的呼叫串列。"

#: ../../library/unittest.mock-examples.rst:233
msgid "Raising exceptions with mocks"
msgstr "透過 mock 引發例外"

#: ../../library/unittest.mock-examples.rst:235
msgid ""
"A useful attribute is :attr:`~Mock.side_effect`. If you set this to an "
"exception class or instance then the exception will be raised when the mock "
"is called."
msgstr ""
"一個有用的屬性是 :attr:`~Mock.side_effect`。如果將其設定為例外類別或實例，則"
"當 mock 被呼叫時將引發例外。"

#: ../../library/unittest.mock-examples.rst:247
msgid "Side effect functions and iterables"
msgstr "Side effect 函式以及可疊代物件"

#: ../../library/unittest.mock-examples.rst:249
msgid ""
"``side_effect`` can also be set to a function or an iterable. The use case "
"for ``side_effect`` as an iterable is where your mock is going to be called "
"several times, and you want each call to return a different value. When you "
"set ``side_effect`` to an iterable every call to the mock returns the next "
"value from the iterable:"
msgstr ""
"``side_effect`` 也可以設定為函式或可疊代物件。``side_effect`` 作為可疊代物件"
"的使用案例是：當你的 mock 將會被多次呼叫，且你希望每次呼叫回傳不同的值。當你"
"將 ``side_effect`` 設定為可疊代物件時，對 mock 的每次呼叫都會傳回可疊代物件中"
"的下一個值："

#: ../../library/unittest.mock-examples.rst:264
msgid ""
"For more advanced use cases, like dynamically varying the return values "
"depending on what the mock is called with, ``side_effect`` can be a "
"function. The function will be called with the same arguments as the mock. "
"Whatever the function returns is what the call returns:"
msgstr ""
"對於更進階的使用案例，例如根據 mock 被呼叫的內容動態變更回傳值，可以將 "
"``side_effect`` 設成一個函式。該函式會使用與 mock 相同的引數被呼叫。函式回傳"
"的內容就會是呼叫回傳的內容："

#: ../../library/unittest.mock-examples.rst:281
msgid "Mocking asynchronous iterators"
msgstr "Mock 非同步可疊代物件"

#: ../../library/unittest.mock-examples.rst:283
msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock :ref:"
"`async-iterators` through ``__aiter__``. The :attr:`~Mock.return_value` "
"attribute of ``__aiter__`` can be used to set the return values to be used "
"for iteration."
msgstr ""
"從 Python 3.8 開始，``AsyncMock`` 和 ``MagicMock`` 支援透過 ``__aiter__`` 來 "
"mock :ref:`async-iterators`。``__aiter__`` 的 :attr:`~Mock.return_value` 屬性"
"可用來設定用於疊代的回傳值。"

#: ../../library/unittest.mock-examples.rst:298
msgid "Mocking asynchronous context manager"
msgstr "Mock 非同步情境管理器"

#: ../../library/unittest.mock-examples.rst:300
msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock :ref:"
"`async-context-managers` through ``__aenter__`` and ``__aexit__``. By "
"default, ``__aenter__`` and ``__aexit__`` are ``AsyncMock`` instances that "
"return an async function."
msgstr ""
"從 Python 3.8 開始，``AsyncMock`` 和 ``MagicMock`` 支援透過 ``__aenter__`` "
"和 ``__aexit__`` 來 mock :ref:`async-context-managers`。預設情況下，"
"``__aenter__`` 和 ``__aexit__`` 是回傳非同步函式的 ``AsyncMock`` 實例。"

#: ../../library/unittest.mock-examples.rst:322
msgid "Creating a Mock from an Existing Object"
msgstr "從現有物件建立 mock"

#: ../../library/unittest.mock-examples.rst:324
msgid ""
"One problem with over use of mocking is that it couples your tests to the "
"implementation of your mocks rather than your real code. Suppose you have a "
"class that implements ``some_method``. In a test for another class, you "
"provide a mock of this object that *also* provides ``some_method``. If later "
"you refactor the first class, so that it no longer has ``some_method`` - "
"then your tests will continue to pass even though your code is now broken!"
msgstr ""
"過度使用 mock 的一個問題是，它將你的測試與 mock 的實作結合在一起，而不是與真"
"實的程式碼結合。假設你有一個實作 ``some_method`` 的類別，在另一個類別的測試"
"中，你提供了一個 mock 的物件，其\\ *也*\\ 提供了 ``some_method``。如果之後你"
"重構第一個類別，使其不再具有 ``some_method`` - 那麼即使你的程式碼已經損壞，你"
"的測試也將繼續通過！"

#: ../../library/unittest.mock-examples.rst:331
msgid ""
":class:`Mock` allows you to provide an object as a specification for the "
"mock, using the *spec* keyword argument. Accessing methods / attributes on "
"the mock that don't exist on your specification object will immediately "
"raise an attribute error. If you change the implementation of your "
"specification, then tests that use that class will start failing immediately "
"without you having to instantiate the class in those tests."
msgstr ""
":class:`Mock` 允許你使用 *spec* 關鍵字引數提供一個物件作為 mock 的規格。對 "
"mock 存取規格物件上不存在的方法或屬性將立即引發一個屬性錯誤。如果你更改規格的"
"實作，那麼使用該類別的測試將立即失敗，而無需在這些測試中實例化該類別。"

#: ../../library/unittest.mock-examples.rst:344
msgid ""
"Using a specification also enables a smarter matching of calls made to the "
"mock, regardless of whether some parameters were passed as positional or "
"named arguments::"
msgstr ""
"使用規格還可以更聰明地匹配對 mock 的呼叫，無論引數是作為位置引數還是命名引數"
"傳遞： ::"

#: ../../library/unittest.mock-examples.rst:348
msgid ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, 3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"
msgstr ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, 3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"

#: ../../library/unittest.mock-examples.rst:355
msgid ""
"If you want this smarter matching to also work with method calls on the "
"mock, you can use :ref:`auto-speccing <auto-speccing>`."
msgstr ""
"如果你希望這種更聰明的匹配也可以應用於 mock 上的方法呼叫，你可以使用\\ :ref:`"
"自動規格 <auto-speccing>`。"

#: ../../library/unittest.mock-examples.rst:358
msgid ""
"If you want a stronger form of specification that prevents the setting of "
"arbitrary attributes as well as the getting of them then you can use "
"*spec_set* instead of *spec*."
msgstr ""
"如果你想要一種更強大的規格形式來防止設定任意屬性以及取得它們，那麼你可以使用 "
"*spec_set* 而不是 *spec*。"

#: ../../library/unittest.mock-examples.rst:364
msgid "Using side_effect to return per file content"
msgstr "使用 side_effect 回傳各別檔案內容"

#: ../../library/unittest.mock-examples.rst:366
msgid ""
":func:`mock_open` is used to patch :func:`open` method. :attr:`~Mock."
"side_effect` can be used to return a new Mock object per call. This can be "
"used to return different contents per file stored in a dictionary::"
msgstr ""
":func:`mock_open` 是用於 patch :func:`open` 方法。:attr:`~Mock.side_effect` "
"可以用來在每次呼叫回傳一個新的 mock 物件。這可以用於回傳儲存在字典中的各別檔"
"案的不同內容： ::"

#: ../../library/unittest.mock-examples.rst:370
msgid ""
"DEFAULT = \"default\"\n"
"data_dict = {\"file1\": \"data1\",\n"
"             \"file2\": \"data2\"}\n"
"\n"
"def open_side_effect(name):\n"
"    return mock_open(read_data=data_dict.get(name, DEFAULT))()\n"
"\n"
"with patch(\"builtins.open\", side_effect=open_side_effect):\n"
"    with open(\"file1\") as file1:\n"
"        assert file1.read() == \"data1\"\n"
"\n"
"    with open(\"file2\") as file2:\n"
"        assert file2.read() == \"data2\"\n"
"\n"
"    with open(\"file3\") as file2:\n"
"        assert file2.read() == \"default\""
msgstr ""
"DEFAULT = \"default\"\n"
"data_dict = {\"file1\": \"data1\",\n"
"             \"file2\": \"data2\"}\n"
"\n"
"def open_side_effect(name):\n"
"    return mock_open(read_data=data_dict.get(name, DEFAULT))()\n"
"\n"
"with patch(\"builtins.open\", side_effect=open_side_effect):\n"
"    with open(\"file1\") as file1:\n"
"        assert file1.read() == \"data1\"\n"
"\n"
"    with open(\"file2\") as file2:\n"
"        assert file2.read() == \"data2\"\n"
"\n"
"    with open(\"file3\") as file2:\n"
"        assert file2.read() == \"default\""

#: ../../library/unittest.mock-examples.rst:389
msgid "Patch Decorators"
msgstr "Patch 裝飾器"

#: ../../library/unittest.mock-examples.rst:393
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"使用 :func:`patch` 時，需注意的是你得在被查找物件的命名空間中（in the "
"namespace where they are looked up）patch 物件。這通常很直接，但若需要快速導"
"引，請參閱\\ :ref:`該 patch 何處 <where-to-patch>`。"

#: ../../library/unittest.mock-examples.rst:398
msgid ""
"A common need in tests is to patch a class attribute or a module attribute, "
"for example patching a builtin or patching a class in a module to test that "
"it is instantiated. Modules and classes are effectively global, so patching "
"on them has to be undone after the test or the patch will persist into other "
"tests and cause hard to diagnose problems."
msgstr ""
"測試中的常見需求是 patch 類別屬性或模組屬性，例如 patch 一個內建函式（built-"
"in）或 patch 模組中的類別以測試它是否已實例化。模組和類別實際上是全域的，因此"
"在測試後必須撤銷它們的 patch，否則 patch 將延續到其他測試中並導致難以診斷問"
"題。"

#: ../../library/unittest.mock-examples.rst:404
msgid ""
"mock provides three convenient decorators for this: :func:`patch`, :func:"
"`patch.object` and :func:`patch.dict`. ``patch`` takes a single string, of "
"the form ``package.module.Class.attribute`` to specify the attribute you are "
"patching. It also optionally takes a value that you want the attribute (or "
"class or whatever) to be replaced with. 'patch.object' takes an object and "
"the name of the attribute you would like patched, plus optionally the value "
"to patch it with."
msgstr ""
"mock 為此提供了三個方便的裝飾器：:func:`patch`、:func:`patch.object` 和 :"
"func:`patch.dict`。``patch`` 接受單一字串，格式為 ``package.module.Class."
"attribute``，用來指定要 patch 的屬性。同時它也可以接受你想要替換的屬性（或類"
"別或其他）的值。``patch.object`` 接受一個物件和你想要 patch 的屬性的名稱，同"
"時也可以接受要 patch 的值。"

#: ../../library/unittest.mock-examples.rst:412
msgid "``patch.object``::"
msgstr "``patch.object``： ::"

#: ../../library/unittest.mock-examples.rst:414
msgid ""
">>> original = SomeClass.attribute\n"
">>> @patch.object(SomeClass, 'attribute', sentinel.attribute)\n"
"... def test():\n"
"...     assert SomeClass.attribute == sentinel.attribute\n"
"...\n"
">>> test()\n"
">>> assert SomeClass.attribute == original\n"
"\n"
">>> @patch('package.module.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import attribute\n"
"...     assert attribute is sentinel.attribute\n"
"...\n"
">>> test()"
msgstr ""
">>> original = SomeClass.attribute\n"
">>> @patch.object(SomeClass, 'attribute', sentinel.attribute)\n"
"... def test():\n"
"...     assert SomeClass.attribute == sentinel.attribute\n"
"...\n"
">>> test()\n"
">>> assert SomeClass.attribute == original\n"
"\n"
">>> @patch('package.module.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import attribute\n"
"...     assert attribute is sentinel.attribute\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock-examples.rst:429
msgid ""
"If you are patching a module (including :mod:`builtins`) then use :func:"
"`patch` instead of :func:`patch.object`:"
msgstr ""
"如果你要 patch 一個模組（包括 :mod:`builtins`），請使用 :func:`patch` 而非 :"
"func:`patch.object`："

#: ../../library/unittest.mock-examples.rst:439
msgid ""
"The module name can be 'dotted', in the form ``package.module`` if needed::"
msgstr "如有需要，模組名稱可以含有 ``.``，形式為 ``package.module``： ::"

#: ../../library/unittest.mock-examples.rst:441
msgid ""
">>> @patch('package.module.ClassName.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import ClassName\n"
"...     assert ClassName.attribute == sentinel.attribute\n"
"...\n"
">>> test()"
msgstr ""
">>> @patch('package.module.ClassName.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import ClassName\n"
"...     assert ClassName.attribute == sentinel.attribute\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock-examples.rst:448
msgid "A nice pattern is to actually decorate test methods themselves:"
msgstr "一個好的模式是實際裝飾測試方法本身："

#: ../../library/unittest.mock-examples.rst:459
msgid ""
"If you want to patch with a Mock, you can use :func:`patch` with only one "
"argument (or :func:`patch.object` with two arguments). The mock will be "
"created for you and passed into the test function / method:"
msgstr ""
"如果你想使用一個 mock 進行 patch，你可以使用僅帶有一個引數的 :func:`patch`\\ "
"（或帶有兩個引數的 :func:`patch.object`\\ ）。Mock 將被建立並被傳遞到測試函"
"式 / 方法中："

#: ../../library/unittest.mock-examples.rst:471
msgid "You can stack up multiple patch decorators using this pattern::"
msgstr "你可以使用這個模式堆疊多個 patch 裝飾器： ::"

#: ../../library/unittest.mock-examples.rst:473
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     @patch('package.module.ClassName1')\n"
"...     @patch('package.module.ClassName2')\n"
"...     def test_something(self, MockClass2, MockClass1):\n"
"...         self.assertIs(package.module.ClassName1, MockClass1)\n"
"...         self.assertIs(package.module.ClassName2, MockClass2)\n"
"...\n"
">>> MyTest('test_something').test_something()"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     @patch('package.module.ClassName1')\n"
"...     @patch('package.module.ClassName2')\n"
"...     def test_something(self, MockClass2, MockClass1):\n"
"...         self.assertIs(package.module.ClassName1, MockClass1)\n"
"...         self.assertIs(package.module.ClassName2, MockClass2)\n"
"...\n"
">>> MyTest('test_something').test_something()"

#: ../../library/unittest.mock-examples.rst:482
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``test_module.ClassName2`` is passed in first."
msgstr ""
"當你巢狀使用 patch 裝飾器時，mock 傳遞到被裝飾函式的順序會跟其被應用的順序相"
"同（一般 *Python* 應用裝飾器的順序）。這意味著由下而上，因此在上面的範例中，"
"``module.ClassName2`` 的 mock 會先被傳入。"

#: ../../library/unittest.mock-examples.rst:487
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr ""
"也有 :func:`patch.dict`，用於在測試範圍中設定字典內的值，並在測試結束時將其恢"
"復為原始狀態："

#: ../../library/unittest.mock-examples.rst:498
msgid ""
"``patch``, ``patch.object`` and ``patch.dict`` can all be used as context "
"managers."
msgstr ""
"``patch``、``patch.object`` 和 ``patch.dict`` 都可以用來作為情境管理器。"

#: ../../library/unittest.mock-examples.rst:500
msgid ""
"Where you use :func:`patch` to create a mock for you, you can get a "
"reference to the mock using the \"as\" form of the with statement:"
msgstr ""
"當你使用 :func:`patch` 為你建立一個 mock 時，你可以使用 with 陳述式的 \"as\" "
"形式來取得 mock 的參照："

#: ../../library/unittest.mock-examples.rst:515
msgid ""
"As an alternative ``patch``, ``patch.object`` and ``patch.dict`` can be used "
"as class decorators. When used in this way it is the same as applying the "
"decorator individually to every method whose name starts with \"test\"."
msgstr ""
"另外，“patch”、“patch.object” 和 “patch.dict” 也可以用來作為類別裝飾器。以這"
"種方式使用時，與將裝飾器單獨應用於每個名稱以 “test” 開頭的方法相同。"

#: ../../library/unittest.mock-examples.rst:523
msgid "Further Examples"
msgstr "更多範例"

#: ../../library/unittest.mock-examples.rst:526
msgid "Here are some more examples for some slightly more advanced scenarios."
msgstr "以下是一些更進階一點的情境的範例。"

#: ../../library/unittest.mock-examples.rst:530
msgid "Mocking chained calls"
msgstr "Mock 鍊接呼叫"

#: ../../library/unittest.mock-examples.rst:532
msgid ""
"Mocking chained calls is actually straightforward with mock once you "
"understand the :attr:`~Mock.return_value` attribute. When a mock is called "
"for the first time, or you fetch its ``return_value`` before it has been "
"called, a new :class:`Mock` is created."
msgstr ""
"一旦你了解了 :attr:`~Mock.return_value` 屬性，mock 鍊接呼叫其實就很簡單了。當"
"一個 mock 第一次被呼叫，或者你在它被呼叫之前取得其 ``return_value`` 時，一個"
"新的 :class:`Mock` 就會被建立。"

#: ../../library/unittest.mock-examples.rst:537
msgid ""
"This means that you can see how the object returned from a call to a mocked "
"object has been used by interrogating the ``return_value`` mock:"
msgstr ""
"這代表你可以透過查問 ``return_value`` mock 來了解一個對被 mock 的物件的呼叫回"
"傳的物件是如何被使用的："

#: ../../library/unittest.mock-examples.rst:545
msgid ""
"From here it is a simple step to configure and then make assertions about "
"chained calls. Of course another alternative is writing your code in a more "
"testable way in the first place..."
msgstr ""
"這裡只需一個簡單的步驟即可進行配置並對鍊接呼叫進行斷言。當然，另一種選擇是先"
"以更容易被測試的方式撰寫程式碼..."

#: ../../library/unittest.mock-examples.rst:549
msgid "So, suppose we have some code that looks a little bit like this:"
msgstr "所以，假設我們有一些程式碼，看起來大概像這樣："

#: ../../library/unittest.mock-examples.rst:558
msgid ""
"Assuming that ``BackendProvider`` is already well tested, how do we test "
"``method()``? Specifically, we want to test that the code section ``# more "
"code`` uses the response object in the correct way."
msgstr ""
"假設 ``BackendProvider`` 已經經過充分測試，那麼我們該如何測試 ``method()``？"
"具體來說，我們要測試程式碼部分 ``# more code`` 是否以正確的方式使用 "
"``response`` 物件。"

#: ../../library/unittest.mock-examples.rst:562
msgid ""
"As this chain of calls is made from an instance attribute we can monkey "
"patch the ``backend`` attribute on a ``Something`` instance. In this "
"particular case we are only interested in the return value from the final "
"call to ``start_call`` so we don't have much configuration to do. Let's "
"assume the object it returns is 'file-like', so we'll ensure that our "
"response object uses the builtin :func:`open` as its ``spec``."
msgstr ""
"由於此呼叫鍊是從實例屬性進行的，因此我們可以在 ``Something`` 實例上 monkey "
"patch ``backend`` 屬性。在這種特定的情況下，我們只對最終呼叫 ``start_call`` "
"的回傳值感興趣，因此我們不需要做太多配置。我們假設它傳回的物件是類檔案物件 "
"(file-like)，因此我們會確保我們的 response 物件使用內建的 :func:`open` 作為"
"其 ``spec``。"

#: ../../library/unittest.mock-examples.rst:569
msgid ""
"To do this we create a mock instance as our mock backend and create a mock "
"response object for it. To set the response as the return value for that "
"final ``start_call`` we could do this::"
msgstr ""
"為此，我們建立一個 mock 實例作為我們的 mock backend，並為其建立一個 mock "
"response 物件。要將 response 設定為最後的 ``start_call`` 的回傳值，我們可以這"
"樣做： ::"

#: ../../library/unittest.mock-examples.rst:573
msgid ""
"mock_backend.get_endpoint.return_value.create_call.return_value.start_call."
"return_value = mock_response"
msgstr ""
"mock_backend.get_endpoint.return_value.create_call.return_value.start_call."
"return_value = mock_response"

#: ../../library/unittest.mock-examples.rst:575
msgid ""
"We can do that in a slightly nicer way using the :meth:`~Mock."
"configure_mock` method to directly set the return value for us::"
msgstr ""
"我們可以使用 :meth:`~Mock.configure_mock` 方法來以稍微好一點的方式為我們直接"
"設定回傳值： ::"

#: ../../library/unittest.mock-examples.rst:578
msgid ""
">>> something = Something()\n"
">>> mock_response = Mock(spec=open)\n"
">>> mock_backend = Mock()\n"
">>> config = {'get_endpoint.return_value.create_call.return_value.start_call."
"return_value': mock_response}\n"
">>> mock_backend.configure_mock(**config)"
msgstr ""
">>> something = Something()\n"
">>> mock_response = Mock(spec=open)\n"
">>> mock_backend = Mock()\n"
">>> config = {'get_endpoint.return_value.create_call.return_value.start_call."
"return_value': mock_response}\n"
">>> mock_backend.configure_mock(**config)"

#: ../../library/unittest.mock-examples.rst:584
msgid ""
"With these we monkey patch the \"mock backend\" in place and can make the "
"real call::"
msgstr ""
"有了這些，我們就可以原地 (in place) monkey patch \"mock backend\"，並且可以進"
"行真正的呼叫： ::"

#: ../../library/unittest.mock-examples.rst:587
msgid ""
">>> something.backend = mock_backend\n"
">>> something.method()"
msgstr ""
">>> something.backend = mock_backend\n"
">>> something.method()"

#: ../../library/unittest.mock-examples.rst:590
msgid ""
"Using :attr:`~Mock.mock_calls` we can check the chained call with a single "
"assert. A chained call is several calls in one line of code, so there will "
"be several entries in ``mock_calls``. We can use :meth:`call.call_list` to "
"create this list of calls for us::"
msgstr ""
"藉由使用 :attr:`~Mock.mock_calls`，我們可以使用單一一個斷言來檢查鍊接呼叫。一"
"個鍊接呼叫是一行程式碼中的多個呼叫，因此 ``mock_calls`` 中會有多個項目。我們"
"可以使用 :meth:`call.call_list` 來為我們建立這個呼叫串列： ::"

#: ../../library/unittest.mock-examples.rst:595
msgid ""
">>> chained = call.get_endpoint('foobar').create_call('spam', 'eggs')."
"start_call()\n"
">>> call_list = chained.call_list()\n"
">>> assert mock_backend.mock_calls == call_list"
msgstr ""
">>> chained = call.get_endpoint('foobar').create_call('spam', 'eggs')."
"start_call()\n"
">>> call_list = chained.call_list()\n"
">>> assert mock_backend.mock_calls == call_list"

#: ../../library/unittest.mock-examples.rst:601
msgid "Partial mocking"
msgstr "部分 mocking"

#: ../../library/unittest.mock-examples.rst:603
msgid ""
"In some tests I wanted to mock out a call to :meth:`datetime.date.today` to "
"return a known date, but I didn't want to prevent the code under test from "
"creating new date objects. Unfortunately :class:`datetime.date` is written "
"in C, and so I couldn't just monkey-patch out the static :meth:`datetime."
"date.today` method."
msgstr ""
"在某些測試中，我們會想 mock 對 :meth:`datetime.date.today` 的呼叫以回傳一個已"
"知日期，但我不想阻止測試中的程式碼建立新的日期物件。不幸的是 :class:"
"`datetime.date` 是用 C 語言寫的，所以們我不能 monkey patch 靜態的 :meth:"
"`datetime.date.today` 方法。"

#: ../../library/unittest.mock-examples.rst:608
msgid ""
"I found a simple way of doing this that involved effectively wrapping the "
"date class with a mock, but passing through calls to the constructor to the "
"real class (and returning real instances)."
msgstr ""
"我們找到了一種簡單的方法來做到這一點，其用 mock 有效地包裝日期類別，但將對建"
"構函式的呼叫傳遞給真實的類別（並返回真實的實例）。"

#: ../../library/unittest.mock-examples.rst:612
msgid ""
"The :func:`patch decorator <patch>` is used here to mock out the ``date`` "
"class in the module under test. The :attr:`~Mock.side_effect` attribute on "
"the mock date class is then set to a lambda function that returns a real "
"date. When the mock date class is called a real date will be constructed and "
"returned by ``side_effect``. ::"
msgstr ""
"這裡使用 :func:`patch 裝飾器 <patch>` 來 mock 被測模組中的 ``date`` 類別。然"
"後，mock 日期類別上的 :attr:`~Mock.side_effect` 屬性會被設定為回傳真實日期的 "
"lambda 函式。當 mock 日期類別被呼叫時，將透過 ``side_effect`` 建構並回傳真實"
"日期。： ::"

#: ../../library/unittest.mock-examples.rst:618
msgid ""
">>> from datetime import date\n"
">>> with patch('mymodule.date') as mock_date:\n"
"...     mock_date.today.return_value = date(2010, 10, 8)\n"
"...     mock_date.side_effect = lambda *args, **kw: date(*args, **kw)\n"
"...\n"
"...     assert mymodule.date.today() == date(2010, 10, 8)\n"
"...     assert mymodule.date(2009, 6, 8) == date(2009, 6, 8)"
msgstr ""
">>> from datetime import date\n"
">>> with patch('mymodule.date') as mock_date:\n"
"...     mock_date.today.return_value = date(2010, 10, 8)\n"
"...     mock_date.side_effect = lambda *args, **kw: date(*args, **kw)\n"
"...\n"
"...     assert mymodule.date.today() == date(2010, 10, 8)\n"
"...     assert mymodule.date(2009, 6, 8) == date(2009, 6, 8)"

#: ../../library/unittest.mock-examples.rst:626
msgid ""
"Note that we don't patch :class:`datetime.date` globally, we patch ``date`` "
"in the module that *uses* it. See :ref:`where to patch <where-to-patch>`."
msgstr ""
"注意，我們沒有全域 patch :class:`datetime.date`，而是在\\ *使用*\\ 它的模組"
"中 patch ``date``。請參閱 :ref:`該 patch 何處 <where-to-patch>`。"

#: ../../library/unittest.mock-examples.rst:629
msgid ""
"When ``date.today()`` is called a known date is returned, but calls to the "
"``date(...)`` constructor still return normal dates. Without this you can "
"find yourself having to calculate an expected result using exactly the same "
"algorithm as the code under test, which is a classic testing anti-pattern."
msgstr ""
"當 ``date.today()`` 被呼叫時，一個已知日期會被回傳，但對 ``date(...)`` 建構函"
"式的呼叫仍然會回傳正常日期。如果不這樣使用，你可能會發現自己必須使用與被測程"
"式碼完全相同的演算法來計算預期結果，這是一個典型的測試的反面模式 (anti-"
"pattern)。"

#: ../../library/unittest.mock-examples.rst:634
msgid ""
"Calls to the date constructor are recorded in the ``mock_date`` attributes "
"(``call_count`` and friends) which may also be useful for your tests."
msgstr ""
"對日期建構函式的呼叫被記錄在 ``mock_date`` 屬性（\\ ``call_count`` 及其相關屬"
"性）中，這對你的測試也可能有用處。"

#: ../../library/unittest.mock-examples.rst:637
msgid ""
"An alternative way of dealing with mocking dates, or other builtin classes, "
"is discussed in `this blog entry <https://williambert.online/2011/07/how-to-"
"unit-testing-in-django-with-mocking-and-patching/>`_."
msgstr ""
"處理 mock 日期或其他內建類別的另一種方法在 `這個 blog <https://williambert."
"online/2011/07/how-to-unit-testing-in-django-with-mocking-and-patching/>`_ 中"
"討論。"

#: ../../library/unittest.mock-examples.rst:643
msgid "Mocking a Generator Method"
msgstr "Mock 產生器方法"

#: ../../library/unittest.mock-examples.rst:645
msgid ""
"A Python generator is a function or method that uses the :keyword:`yield` "
"statement to return a series of values when iterated over [#]_."
msgstr ""
"Python 產生器是一個函式或方法，它使用 :keyword:`yield` 陳述式在疊代 [#]_ 時回"
"傳一系列的值。"

#: ../../library/unittest.mock-examples.rst:648
msgid ""
"A generator method / function is called to return the generator object. It "
"is the generator object that is then iterated over. The protocol method for "
"iteration is :meth:`~container.__iter__`, so we can mock this using a :class:"
"`MagicMock`."
msgstr ""
"產生器方法 / 函式會被呼叫以回傳產生器物件。之後此產生器會進行疊代。疊代的協定"
"方法是 :meth:`~container.__iter__`，所以我們可以使用 :class:`MagicMock` 來 "
"mock 它。"

#: ../../library/unittest.mock-examples.rst:653
msgid ""
"Here's an example class with an \"iter\" method implemented as a generator:"
msgstr "下面是一個範例類別，其包含實作產生器的一個 \"iter\" 方法："

#: ../../library/unittest.mock-examples.rst:665
msgid "How would we mock this class, and in particular its \"iter\" method?"
msgstr "我們該如何 mock 這個類別，特別是它的 \"iter\" 方法呢？"

#: ../../library/unittest.mock-examples.rst:667
msgid ""
"To configure the values returned from the iteration (implicit in the call "
"to :class:`list`), we need to configure the object returned by the call to "
"``foo.iter()``."
msgstr ""
"要配置從疊代回傳的值（隱含在對 :class:`list` 的呼叫中），我們需要配置呼叫 "
"``foo.iter()`` 所回傳的物件。"

#: ../../library/unittest.mock-examples.rst:675
msgid ""
"There are also generator expressions and more `advanced uses <http://www."
"dabeaz.com/coroutines/index.html>`_ of generators, but we aren't concerned "
"about them here. A very good introduction to generators and how powerful "
"they are is: `Generator Tricks for Systems Programmers <http://www.dabeaz."
"com/generators/>`_."
msgstr ""
"還有關於產生器運算式及產生器的更多 `進階用法 <http://www.dabeaz.com/"
"coroutines/index.html>`_ ，但我們在這裡不考慮它們。一個關於產生器及其強大功能"
"的優良說明是：`Generator Tricks for Systems Programmers <http://www.dabeaz."
"com/generators/>`_。"

#: ../../library/unittest.mock-examples.rst:683
msgid "Applying the same patch to every test method"
msgstr "對每個測試方法應用相同的 patch"

#: ../../library/unittest.mock-examples.rst:685
msgid ""
"If you want several patches in place for multiple test methods the obvious "
"way is to apply the patch decorators to every method. This can feel like "
"unnecessary repetition. Instead, you can use :func:`patch` (in all its "
"various forms) as a class decorator. This applies the patches to all test "
"methods on the class. A test method is identified by methods whose names "
"start with ``test``::"
msgstr ""
"如果你希望 patch 能用在多個測試方法上，顯而易見的方式是將 patch 裝飾器應用於"
"每個方法。這感覺是不必要的重複行為，因此你可以使用 :func:`patch`\\ （及其他 "
"patch 的變體）作為類別裝飾器。這會將 patch 應用在該類別的所有測試方法上。測試"
"方法由名稱以 ``test`` 開頭來識別： ::"

#: ../../library/unittest.mock-examples.rst:692
msgid ""
">>> @patch('mymodule.SomeClass')\n"
"... class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_one(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def test_two(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def not_a_test(self):\n"
"...         return 'something'\n"
"...\n"
">>> MyTest('test_one').test_one()\n"
">>> MyTest('test_two').test_two()\n"
">>> MyTest('test_two').not_a_test()\n"
"'something'"
msgstr ""
">>> @patch('mymodule.SomeClass')\n"
"... class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_one(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def test_two(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def not_a_test(self):\n"
"...         return 'something'\n"
"...\n"
">>> MyTest('test_one').test_one()\n"
">>> MyTest('test_two').test_two()\n"
">>> MyTest('test_two').not_a_test()\n"
"'something'"

#: ../../library/unittest.mock-examples.rst:709
msgid ""
"An alternative way of managing patches is to use the :ref:`start-and-stop`. "
"These allow you to move the patching into your ``setUp`` and ``tearDown`` "
"methods. ::"
msgstr ""
"管理 patch 的另一種方式是使用 :ref:`start-and-stop`。這允許你將 patch 移到你"
"的 ``setUp`` 與 ``tearDown`` 方法中。： ::"

#: ../../library/unittest.mock-examples.rst:713
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher = patch('mymodule.foo')\n"
"...         self.mock_foo = self.patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher.stop()\n"
"...\n"
">>> MyTest('test_foo').run()"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher = patch('mymodule.foo')\n"
"...         self.mock_foo = self.patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher.stop()\n"
"...\n"
">>> MyTest('test_foo').run()"

#: ../../library/unittest.mock-examples.rst:726
msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by "
"calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the setUp then tearDown is not called. :meth:"
"`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"如果你使用這個技巧，你必須確保透過呼叫 ``stop`` 來 \"取消\" patch。這可能會比"
"你想像的還要複雜一點，因為如果有例外在 ``setUp`` 中被引發，則 ``tearDown`` 就"
"不會被呼叫。:meth:`unittest.TestCase.addCleanup` 會讓這稍微簡單一點： ::"

#: ../../library/unittest.mock-examples.rst:731
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('mymodule.foo')\n"
"...         self.addCleanup(patcher.stop)\n"
"...         self.mock_foo = patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
">>> MyTest('test_foo').run()"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('mymodule.foo')\n"
"...         self.addCleanup(patcher.stop)\n"
"...         self.mock_foo = patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
">>> MyTest('test_foo').run()"

#: ../../library/unittest.mock-examples.rst:744
msgid "Mocking Unbound Methods"
msgstr "Mock Unbound Methods （未繫結方法）"

#: ../../library/unittest.mock-examples.rst:746
msgid ""
"Whilst writing tests today I needed to patch an *unbound method* (patching "
"the method on the class rather than on the instance). I needed self to be "
"passed in as the first argument because I want to make asserts about which "
"objects were calling this particular method. The issue is that you can't "
"patch with a mock for this, because if you replace an unbound method with a "
"mock it doesn't become a bound method when fetched from the instance, and so "
"it doesn't get self passed in. The workaround is to patch the unbound method "
"with a real function instead. The :func:`patch` decorator makes it so simple "
"to patch out methods with a mock that having to create a real function "
"becomes a nuisance."
msgstr ""
"在撰寫測試時，當我們需要 patch 一個\\ *未繫結方法*\\（patch 類別上的方法而不"
"是實例上的方法）。我們需要將 self 作為第一個引數傳入，因為我們想斷言哪些物件"
"正在呼叫這個特定方法。問題是你無法為此使用 mock 進行 patch，因為就算你用一個 "
"mock 替換未繫結方法，從實例取得它時它也不會成為一個繫結方法，因此 self 並不會"
"被傳遞。解決方法是使用真實的函式來 patch 未繫結方法。:func:`patch` 裝飾器使得"
"用 mock 來 patch out 方法是如此的簡單，以至於建立一個真正的函式相對變得很麻"
"煩。"

#: ../../library/unittest.mock-examples.rst:757
msgid ""
"If you pass ``autospec=True`` to patch then it does the patching with a "
"*real* function object. This function object has the same signature as the "
"one it is replacing, but delegates to a mock under the hood. You still get "
"your mock auto-created in exactly the same way as before. What it means "
"though, is that if you use it to patch out an unbound method on a class the "
"mocked function will be turned into a bound method if it is fetched from an "
"instance. It will have ``self`` passed in as the first argument, which is "
"exactly what I wanted:"
msgstr ""
"如果你將 ``autospec=True`` 傳遞給 patch，那麼它會使用\\ *真的*\\ 函式物件來進"
"行 patch。此函式物件與它所替換的函式物件具有相同的簽名，但實際上委託給 mock。"
"你仍然會以與之前完全相同的方式自動建立 mock。但這意味著，如果你使用它來 "
"patch 類別上的未繫結方法，則從實例取得的 mock 函式將轉換為繫結方法。``self`` "
"會作為其第一個引數傳入，而這正是我們想要的："

#: ../../library/unittest.mock-examples.rst:778
msgid ""
"If we don't use ``autospec=True`` then the unbound method is patched out "
"with a Mock instance instead, and isn't called with ``self``."
msgstr ""
"如果我們不使用 ``autospec=True``，那麼未繫結方法將使用一個 Mock 實例 patch "
"out，並且不被使用 ``self`` 進行呼叫。"

#: ../../library/unittest.mock-examples.rst:783
msgid "Checking multiple calls with mock"
msgstr "使用 mock 檢查多個呼叫"

#: ../../library/unittest.mock-examples.rst:785
msgid ""
"mock has a nice API for making assertions about how your mock objects are "
"used."
msgstr "mock 有很好的 API，用於對 mock 物件的使用方式做出斷言。"

#: ../../library/unittest.mock-examples.rst:792
msgid ""
"If your mock is only being called once you can use the :meth:`~Mock."
"assert_called_once_with` method that also asserts that the :attr:`~Mock."
"call_count` is one."
msgstr ""
"如果你的 mock 只被呼叫一次，你可以使用 :meth:`~Mock.assert_called_once_with` "
"方法，其也斷言 :attr:`~Mock.call_count` 是1。"

#: ../../library/unittest.mock-examples.rst:803
msgid ""
"Both ``assert_called_with`` and ``assert_called_once_with`` make assertions "
"about the *most recent* call. If your mock is going to be called several "
"times, and you want to make assertions about *all* those calls you can use :"
"attr:`~Mock.call_args_list`:"
msgstr ""
"``assert_called_with`` 和 ``assert_called_once_with`` 都對\\ *最近一次*\\ 的"
"呼叫做出斷言。如果你的 mock 將被多次呼叫，並且你想要對\\ *所有*\\ 這些呼叫進"
"行斷言，你可以使用 :attr:`~Mock.call_args_list`："

#: ../../library/unittest.mock-examples.rst:815
msgid ""
"The :data:`call` helper makes it easy to make assertions about these calls. "
"You can build up a list of expected calls and compare it to "
"``call_args_list``. This looks remarkably similar to the repr of the "
"``call_args_list``:"
msgstr ""
":data:`call` 輔助函式可以輕鬆地對這些呼叫做出斷言。你可以建立預期呼叫的清單並"
"將其與 ``call_args_list`` 進行比較。這看起來與 ``call_args_list`` 的 repr 非"
"常相似："

#: ../../library/unittest.mock-examples.rst:825
msgid "Coping with mutable arguments"
msgstr "應對可變引數"

#: ../../library/unittest.mock-examples.rst:827
msgid ""
"Another situation is rare, but can bite you, is when your mock is called "
"with mutable arguments. ``call_args`` and ``call_args_list`` store "
"*references* to the arguments. If the arguments are mutated by the code "
"under test then you can no longer make assertions about what the values were "
"when the mock was called."
msgstr ""
"另一種情況很少見，但可能會困擾你，那就是當你的 mock 被使用可變引數呼叫。"
"``call_args`` 和 ``call_args_list`` 儲存對引數的\\ *參照*。如果引數被測試中的"
"程式碼改變，那麼你將無法再對 mock 被呼叫時的值進行斷言。"

#: ../../library/unittest.mock-examples.rst:832
msgid ""
"Here's some example code that shows the problem. Imagine the following "
"functions defined in 'mymodule'::"
msgstr "這是一些秀出問題的程式碼範例。 想像 'mymodule' 中定義以下函式： ::"

#: ../../library/unittest.mock-examples.rst:835
msgid ""
"def frob(val):\n"
"    pass\n"
"\n"
"def grob(val):\n"
"    \"First frob and then clear val\"\n"
"    frob(val)\n"
"    val.clear()"
msgstr ""

#: ../../library/unittest.mock-examples.rst:843
msgid ""
"When we try to test that ``grob`` calls ``frob`` with the correct argument "
"look what happens::"
msgstr ""
"當我們嘗試測試 ``grob`` 使用正確的引數呼叫 ``frob`` 時，看看會發生什麼： ::"

#: ../../library/unittest.mock-examples.rst:846
msgid ""
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> val\n"
"set()\n"
">>> mock_frob.assert_called_with({6})\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AssertionError: Expected: (({6},), {})\n"
"Called with: ((set(),), {})"
msgstr ""
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> val\n"
"set()\n"
">>> mock_frob.assert_called_with({6})\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AssertionError: Expected: (({6},), {})\n"
"Called with: ((set(),), {})"

#: ../../library/unittest.mock-examples.rst:858
msgid ""
"One possibility would be for mock to copy the arguments you pass in. This "
"could then cause problems if you do assertions that rely on object identity "
"for equality."
msgstr ""
"一種可能是讓 mock 複製你傳入的引數。如果你進行的斷言依賴於物件識別性來確定相"
"等性，這就可能導致問題。"

#: ../../library/unittest.mock-examples.rst:862
msgid ""
"Here's one solution that uses the :attr:`~Mock.side_effect` functionality. "
"If you provide a ``side_effect`` function for a mock then ``side_effect`` "
"will be called with the same args as the mock. This gives us an opportunity "
"to copy the arguments and store them for later assertions. In this example "
"I'm using *another* mock to store the arguments so that I can use the mock "
"methods for doing the assertion. Again a helper function sets this up for "
"me. ::"
msgstr ""
"以下是一種使用 :attr:`~Mock.side_effect` 功能的解法。如果你為 mock 提供一個 "
"``side_effect`` 函式，則 ``side_effect`` 將被使用與 mock 相同的引數呼叫。這使"
"我們有機會複製引數並將其儲存以供之後的斷言。在這個範例中，我們使用\\ *另一個"
"* mock 來儲存引數，以便我們可以使用 mock 方法來執行斷言。同樣的，有一個輔助函"
"式為我們設定了這些。： ::"

#: ../../library/unittest.mock-examples.rst:870
msgid ""
">>> from copy import deepcopy\n"
">>> from unittest.mock import Mock, patch, DEFAULT\n"
">>> def copy_call_args(mock):\n"
"...     new_mock = Mock()\n"
"...     def side_effect(*args, **kwargs):\n"
"...         args = deepcopy(args)\n"
"...         kwargs = deepcopy(kwargs)\n"
"...         new_mock(*args, **kwargs)\n"
"...         return DEFAULT\n"
"...     mock.side_effect = side_effect\n"
"...     return new_mock\n"
"...\n"
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     new_mock = copy_call_args(mock_frob)\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> new_mock.assert_called_with({6})\n"
">>> new_mock.call_args\n"
"call({6})"
msgstr ""
">>> from copy import deepcopy\n"
">>> from unittest.mock import Mock, patch, DEFAULT\n"
">>> def copy_call_args(mock):\n"
"...     new_mock = Mock()\n"
"...     def side_effect(*args, **kwargs):\n"
"...         args = deepcopy(args)\n"
"...         kwargs = deepcopy(kwargs)\n"
"...         new_mock(*args, **kwargs)\n"
"...         return DEFAULT\n"
"...     mock.side_effect = side_effect\n"
"...     return new_mock\n"
"...\n"
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     new_mock = copy_call_args(mock_frob)\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> new_mock.assert_called_with({6})\n"
">>> new_mock.call_args\n"
"call({6})"

#: ../../library/unittest.mock-examples.rst:891
msgid ""
"``copy_call_args`` is called with the mock that will be called. It returns a "
"new mock that we do the assertion on. The ``side_effect`` function makes a "
"copy of the args and calls our ``new_mock`` with the copy."
msgstr ""
"``copy_call_args`` 與將要被呼叫的 mock 一起被呼叫。它回傳一個我們會對其進行斷"
"言的新的 mock。``side_effect`` 函式建立引數們的副本，並用該副本呼叫我們的 "
"``new_mock``。"

#: ../../library/unittest.mock-examples.rst:897
msgid ""
"If your mock is only going to be used once there is an easier way of "
"checking arguments at the point they are called. You can simply do the "
"checking inside a ``side_effect`` function."
msgstr ""
"如果你的 mock 只會被使用一次，則有一種更簡單的方法可以在呼叫引數時檢查它們。"
"你可以簡單地在 ``side_effect`` 函式內進行檢查。"

#: ../../library/unittest.mock-examples.rst:911
msgid ""
"An alternative approach is to create a subclass of :class:`Mock` or :class:"
"`MagicMock` that copies (using :func:`copy.deepcopy`) the arguments. Here's "
"an example implementation:"
msgstr ""
"另一種方法是建立 :class:`Mock` 或 :class:`MagicMock` 的子類別來複製（使用 :"
"func:`copy.deepcopy`\\ ）引數。這是一個實作的例子："

#: ../../library/unittest.mock-examples.rst:935
msgid ""
"When you subclass ``Mock`` or ``MagicMock`` all dynamically created "
"attributes, and the ``return_value`` will use your subclass automatically. "
"That means all children of a ``CopyingMock`` will also have the type "
"``CopyingMock``."
msgstr ""
"當你將 ``Mock`` 或 ``MagicMock`` 子類別化時，所有屬性會被動態建立，且 "
"``return_value`` 會自動使用你的子類別。這代表著 ``CopyingMock`` 的所有子代 "
"(child) 也會具有 ``CopyingMock`` 型別。"

#: ../../library/unittest.mock-examples.rst:941
msgid "Nesting Patches"
msgstr "巢狀使用 Patch"

#: ../../library/unittest.mock-examples.rst:943
msgid ""
"Using patch as a context manager is nice, but if you do multiple patches you "
"can end up with nested with statements indenting further and further to the "
"right::"
msgstr ""
"將 patch 作為情境管理器使用很好，但是如果你使用複數個 patch，你最終可能會得到"
"巢狀的 with 陳述式，並且越來越向右縮排： ::"

#: ../../library/unittest.mock-examples.rst:947
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_foo(self):\n"
"...         with patch('mymodule.Foo') as mock_foo:\n"
"...             with patch('mymodule.Bar') as mock_bar:\n"
"...                 with patch('mymodule.Spam') as mock_spam:\n"
"...                     assert mymodule.Foo is mock_foo\n"
"...                     assert mymodule.Bar is mock_bar\n"
"...                     assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').test_foo()\n"
">>> assert mymodule.Foo is original"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_foo(self):\n"
"...         with patch('mymodule.Foo') as mock_foo:\n"
"...             with patch('mymodule.Bar') as mock_bar:\n"
"...                 with patch('mymodule.Spam') as mock_spam:\n"
"...                     assert mymodule.Foo is mock_foo\n"
"...                     assert mymodule.Bar is mock_bar\n"
"...                     assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').test_foo()\n"
">>> assert mymodule.Foo is original"

#: ../../library/unittest.mock-examples.rst:961
msgid ""
"With unittest ``cleanup`` functions and the :ref:`start-and-stop` we can "
"achieve the same effect without the nested indentation. A simple helper "
"method, ``create_patch``, puts the patch in place and returns the created "
"mock for us::"
msgstr ""
"我們可以使用 unittest 的 ``cleanup`` 函式以及 :ref:`start-and-stop` 來達到相"
"同的效果，而不會出現因巢狀導致的縮排。一個簡單的輔助方法 ``create_patch`` 會"
"將 patch 放置到位並為我們回傳被建立的 mock： ::"

#: ../../library/unittest.mock-examples.rst:966
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def create_patch(self, name):\n"
"...         patcher = patch(name)\n"
"...         thing = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...         return thing\n"
"...\n"
"...     def test_foo(self):\n"
"...         mock_foo = self.create_patch('mymodule.Foo')\n"
"...         mock_bar = self.create_patch('mymodule.Bar')\n"
"...         mock_spam = self.create_patch('mymodule.Spam')\n"
"...\n"
"...         assert mymodule.Foo is mock_foo\n"
"...         assert mymodule.Bar is mock_bar\n"
"...         assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').run()\n"
">>> assert mymodule.Foo is original"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def create_patch(self, name):\n"
"...         patcher = patch(name)\n"
"...         thing = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...         return thing\n"
"...\n"
"...     def test_foo(self):\n"
"...         mock_foo = self.create_patch('mymodule.Foo')\n"
"...         mock_bar = self.create_patch('mymodule.Bar')\n"
"...         mock_spam = self.create_patch('mymodule.Spam')\n"
"...\n"
"...         assert mymodule.Foo is mock_foo\n"
"...         assert mymodule.Bar is mock_bar\n"
"...         assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').run()\n"
">>> assert mymodule.Foo is original"

#: ../../library/unittest.mock-examples.rst:989
msgid "Mocking a dictionary with MagicMock"
msgstr "使用 MagicMock 來 mock 字典"

#: ../../library/unittest.mock-examples.rst:991
msgid ""
"You may want to mock a dictionary, or other container object, recording all "
"access to it whilst having it still behave like a dictionary."
msgstr ""
"你可能會想要 mock 字典或其他容器物件，記錄對它的所有存取，同時讓它仍然像字典"
"一樣運作。"

#: ../../library/unittest.mock-examples.rst:994
msgid ""
"We can do this with :class:`MagicMock`, which will behave like a dictionary, "
"and using :data:`~Mock.side_effect` to delegate dictionary access to a real "
"underlying dictionary that is under our control."
msgstr ""
"我們可以使用 :class:`MagicMock` 來做到這一點，它的行為會與字典一致，並使用 :"
"data:`~Mock.side_effect` 將字典存取委託給我們控制下的真實底層字典。"

#: ../../library/unittest.mock-examples.rst:998
msgid ""
"When the :meth:`~object.__getitem__` and :meth:`~object.__setitem__` methods "
"of our ``MagicMock`` are called (normal dictionary access) then "
"``side_effect`` is called with the key (and in the case of ``__setitem__`` "
"the value too). We can also control what is returned."
msgstr ""
"當 ``MagicMock`` 的 :meth:`~object.__getitem__` 和 :meth:`~object."
"__setitem__` 方法被呼叫時（一般的字典存取）， ``side_effect`` 會被使用鍵 "
"(key) 來呼叫 （在 ``__setitem__`` 的情況也會使用值 (value)）。我們也可以控制"
"回傳的內容。"

#: ../../library/unittest.mock-examples.rst:1003
msgid ""
"After the ``MagicMock`` has been used we can use attributes like :data:"
"`~Mock.call_args_list` to assert about how the dictionary was used:"
msgstr ""
"使用 ``MagicMock`` 後，我們可以使用諸如 :data:`~Mock.call_args_list` 之類的屬"
"性來斷言字典被使用的方式："

#: ../../library/unittest.mock-examples.rst:1019
msgid ""
"An alternative to using ``MagicMock`` is to use ``Mock`` and *only* provide "
"the magic methods you specifically want:"
msgstr ""
"不使用 ``MagicMock`` 的替代方案是使用 ``Mock`` 並且\\ *只*\\ 提供你特別想要的"
"魔術方法："

#: ../../library/unittest.mock-examples.rst:1026
msgid ""
"A *third* option is to use ``MagicMock`` but passing in ``dict`` as the "
"*spec* (or *spec_set*) argument so that the ``MagicMock`` created only has "
"dictionary magic methods available:"
msgstr ""
"*第三個*\\ 選擇是使用 ``MagicMock``，但傳入 ``dict`` 作為 *spec* （或 "
"*spec_set*\\ ）引數，以使被建立的 ``MagicMock`` 僅具有字典可用的魔術方法："

#: ../../library/unittest.mock-examples.rst:1034
msgid ""
"With these side effect functions in place, the ``mock`` will behave like a "
"normal dictionary but recording the access. It even raises a :exc:`KeyError` "
"if you try to access a key that doesn't exist."
msgstr ""
"有了這些 side effect 函式，``mock`` 會像一般的字典一樣運作，但會記錄存取。如"
"果你嘗試存取不存在的鍵，它甚至會引發一個 :exc:`KeyError`。"

#: ../../library/unittest.mock-examples.rst:1053
msgid ""
"After it has been used you can make assertions about the access using the "
"normal mock methods and attributes:"
msgstr "在上述方式被使用後，你就可以使用普通的 mock 方法和屬性對存取進行斷言："

#: ../../library/unittest.mock-examples.rst:1065
msgid "Mock subclasses and their attributes"
msgstr "Mock 子類別及其屬性"

#: ../../library/unittest.mock-examples.rst:1067
msgid ""
"There are various reasons why you might want to subclass :class:`Mock`. One "
"reason might be to add helper methods. Here's a silly example:"
msgstr ""
"你會想子類別化 :class:`Mock` 的原因可能有很多種。其中之一是增加輔助方法。以下"
"是一個有點笨的例子："

#: ../../library/unittest.mock-examples.rst:1083
msgid ""
"The standard behaviour for ``Mock`` instances is that attributes and the "
"return value mocks are of the same type as the mock they are accessed on. "
"This ensures that ``Mock`` attributes are ``Mocks`` and ``MagicMock`` "
"attributes are ``MagicMocks`` [#]_. So if you're subclassing to add helper "
"methods then they'll also be available on the attributes and return value "
"mock of instances of your subclass."
msgstr ""
"``Mock`` 實例的標準行為是屬性 mock 和回傳值 mock 會與存取它們的 mock 具有相同"
"的型別。這確保了 ``Mock`` 屬性是 ``Mocks``，``MagicMock`` 屬性是 "
"``MagicMocks`` [#]_。因此，如果你要子類別化以新增輔助方法，那麼它們也可用於子"
"類別實例的屬性 mock 和回傳值 mock。"

#: ../../library/unittest.mock-examples.rst:1099
msgid ""
"Sometimes this is inconvenient. For example, `one user <https://code.google."
"com/archive/p/mock/issues/105>`_ is subclassing mock to created a `Twisted "
"adaptor <https://twisted.org/documents/11.0.0/api/twisted.python.components."
"html>`_. Having this applied to attributes too actually causes errors."
msgstr ""
"有時候這很不方便。例如，`有一個使用者 <https://code.google.com/archive/p/"
"mock/issues/105>`_\\ 正在子類別化 mock 以建立 `Twisted adaptor <https://"
"twisted.org/documents/11.0.0/api/twisted.python.components.html>`_。將其應用"
"於屬性實際上會導致錯誤。"

#: ../../library/unittest.mock-examples.rst:1105
msgid ""
"``Mock`` (in all its flavours) uses a method called ``_get_child_mock`` to "
"create these \"sub-mocks\" for attributes and return values. You can prevent "
"your subclass being used for attributes by overriding this method. The "
"signature is that it takes arbitrary keyword arguments (``**kwargs``) which "
"are then passed onto the mock constructor:"
msgstr ""
"``Mock`` （及其各種形式）使用名為 ``_get_child_mock`` 的方法來為屬性和回傳值"
"建立這些 \"子 mock\"。你可以透過置換此方法來防止你的子類別被用為屬性。其簽名"
"是取用任意的關鍵字引數（``**kwargs``\\ ），然後將其傳遞給 mock 建構函式："

#: ../../library/unittest.mock-examples.rst:1122
msgid ""
"An exception to this rule are the non-callable mocks. Attributes use the "
"callable variant because otherwise non-callable mocks couldn't have callable "
"methods."
msgstr ""
"此規則的例外是非可呼叫物件的 mock。屬性使用可呼叫物件的變體，否則非可呼叫物件"
"的 mock 無法具有可呼叫的方法。"

#: ../../library/unittest.mock-examples.rst:1128
msgid "Mocking imports with patch.dict"
msgstr "使用 patch.dict 來 mock import"

#: ../../library/unittest.mock-examples.rst:1130
msgid ""
"One situation where mocking can be hard is where you have a local import "
"inside a function. These are harder to mock because they aren't using an "
"object from the module namespace that we can patch out."
msgstr ""
"可能會讓 mock 很困難的一種情況是在函式內部進行區域 import。這些狀況會更難進"
"行 mock，因為它們沒有使用我們可以 patch out 的模組命名空間中的物件。"

#: ../../library/unittest.mock-examples.rst:1134
msgid ""
"Generally local imports are to be avoided. They are sometimes done to "
"prevent circular dependencies, for which there is *usually* a much better "
"way to solve the problem (refactor the code) or to prevent \"up front "
"costs\" by delaying the import. This can also be solved in better ways than "
"an unconditional local import (store the module as a class or module "
"attribute and only do the import on first use)."
msgstr ""
"一般來說，我們應該避免區域 import 的發生。有時這樣做是為了防止循環相依 "
"(circular dependencies)，為此\\ *通常*\\ 有更好的方式來解決問題（例如重構程式"
"碼）或透過延遲 import 來防止「前期成本 (up front costs)」。這也可以透過比無條"
"件的區域 import 更好的方式來解決（例如將模組儲存為類別或模組屬性，並且僅在第"
"一次使用時進行 import）。"

#: ../../library/unittest.mock-examples.rst:1141
msgid ""
"That aside there is a way to use ``mock`` to affect the results of an "
"import. Importing fetches an *object* from the :data:`sys.modules` "
"dictionary. Note that it fetches an *object*, which need not be a module. "
"Importing a module for the first time results in a module object being put "
"in ``sys.modules``, so usually when you import something you get a module "
"back. This need not be the case however."
msgstr ""
"除此之外，還有一種方法可以使用 ``mock`` 來影響 import 的結果。Import 會從 :"
"data:`sys.modules` 字典中取得一個\\ *物件*。請注意，它會取得一個\\ *物件*，而"
"該物件不需要是一個模組。初次 import 模組會導致模組物件被放入 ``sys.modules`` "
"中，因此通常當你 import 某些東西時，你會得到一個模組。但並非一定要如此。"

#: ../../library/unittest.mock-examples.rst:1148
msgid ""
"This means you can use :func:`patch.dict` to *temporarily* put a mock in "
"place in :data:`sys.modules`. Any imports whilst this patch is active will "
"fetch the mock. When the patch is complete (the decorated function exits, "
"the with statement body is complete or ``patcher.stop()`` is called) then "
"whatever was there previously will be restored safely."
msgstr ""
"這代表你可以使用 :func:`patch.dict` 來\\ *暫時*\\ 在 :data:`sys.modules` 中原"
"地放置 mock。在這個 patch 作用時的任何 import 都會取得這個 mock。當 patch 完"
"成時（被裝飾的函式結束、with 陳述式主體完成或 ``patcher.stop()`` 被呼叫），那"
"麼之前在 ``sys.modules`` 中的任何內容都會被安全地復原。"

#: ../../library/unittest.mock-examples.rst:1154
msgid "Here's an example that mocks out the 'fooble' module."
msgstr "下面是一個 mock out 'fooble' 模組的例子。"

#: ../../library/unittest.mock-examples.rst:1166
msgid ""
"As you can see the ``import fooble`` succeeds, but on exit there is no "
"'fooble' left in :data:`sys.modules`."
msgstr ""
"如你所見，``import fooble`` 成功了，但在離開之後，:data:`sys.modules` 中就沒"
"有 'fooble' 了。"

#: ../../library/unittest.mock-examples.rst:1169
msgid "This also works for the ``from module import name`` form:"
msgstr "這也適用於 ``from module import name`` 形式："

#: ../../library/unittest.mock-examples.rst:1179
msgid "With slightly more work you can also mock package imports:"
msgstr "透過稍微多一點的處理，你也可以 mock 套件的引入："

#: ../../library/unittest.mock-examples.rst:1192
msgid "Tracking order of calls and less verbose call assertions"
msgstr "追蹤呼叫順序與更簡潔的呼叫斷言"

#: ../../library/unittest.mock-examples.rst:1194
msgid ""
"The :class:`Mock` class allows you to track the *order* of method calls on "
"your mock objects through the :attr:`~Mock.method_calls` attribute. This "
"doesn't allow you to track the order of calls between separate mock objects, "
"however we can use :attr:`~Mock.mock_calls` to achieve the same effect."
msgstr ""
":class:`Mock` 類別可以讓你透過 :attr:`~Mock.method_calls` 屬性追蹤 mock 物件"
"上方法呼叫的\\ *順序*。這不會讓你可以追蹤不同的 mock 物件之間的呼叫順序，然而"
"我們可以使用 :attr:`~Mock.mock_calls` 來達到相同的效果。"

#: ../../library/unittest.mock-examples.rst:1199
msgid ""
"Because mocks track calls to child mocks in ``mock_calls``, and accessing an "
"arbitrary attribute of a mock creates a child mock, we can create our "
"separate mocks from a parent one. Calls to those child mock will then all be "
"recorded, in order, in the ``mock_calls`` of the parent:"
msgstr ""
"因為 mock 會在 ``mock_calls`` 中追蹤對子 mock 的呼叫，且存取 mock 的任意屬性"
"會建立一個子 mock，所以我們可以從父 mock 建立不同的 mock。之後對這些子 mock "
"的呼叫將依序全部記錄在父 mock 的 ``mock_calls`` 中："

#: ../../library/unittest.mock-examples.rst:1216
msgid ""
"We can then assert about the calls, including the order, by comparing with "
"the ``mock_calls`` attribute on the manager mock:"
msgstr ""
"之後我們可以透過與管理器 (manager) mock 上的 ``mock_calls`` 屬性進行比較來斷"
"言呼叫及其順序："

#: ../../library/unittest.mock-examples.rst:1223
msgid ""
"If ``patch`` is creating, and putting in place, your mocks then you can "
"attach them to a manager mock using the :meth:`~Mock.attach_mock` method. "
"After attaching calls will be recorded in ``mock_calls`` of the manager. ::"
msgstr ""
"如果 ``patch`` 正在被建立並放置為你的 mock，那麼你可以使用 :meth:`~Mock."
"attach_mock` 方法將它們附加到管理器 mock。附加之後，呼叫將被記錄在管理器的 "
"``mock_calls`` 中。： ::"

#: ../../library/unittest.mock-examples.rst:1227
msgid ""
">>> manager = MagicMock()\n"
">>> with patch('mymodule.Class1') as MockClass1:\n"
"...     with patch('mymodule.Class2') as MockClass2:\n"
"...         manager.attach_mock(MockClass1, 'MockClass1')\n"
"...         manager.attach_mock(MockClass2, 'MockClass2')\n"
"...         MockClass1().foo()\n"
"...         MockClass2().bar()\n"
"<MagicMock name='mock.MockClass1().foo()' id='...'>\n"
"<MagicMock name='mock.MockClass2().bar()' id='...'>\n"
">>> manager.mock_calls\n"
"[call.MockClass1(),\n"
"call.MockClass1().foo(),\n"
"call.MockClass2(),\n"
"call.MockClass2().bar()]"
msgstr ""
">>> manager = MagicMock()\n"
">>> with patch('mymodule.Class1') as MockClass1:\n"
"...     with patch('mymodule.Class2') as MockClass2:\n"
"...         manager.attach_mock(MockClass1, 'MockClass1')\n"
"...         manager.attach_mock(MockClass2, 'MockClass2')\n"
"...         MockClass1().foo()\n"
"...         MockClass2().bar()\n"
"<MagicMock name='mock.MockClass1().foo()' id='...'>\n"
"<MagicMock name='mock.MockClass2().bar()' id='...'>\n"
">>> manager.mock_calls\n"
"[call.MockClass1(),\n"
"call.MockClass1().foo(),\n"
"call.MockClass2(),\n"
"call.MockClass2().bar()]"

#: ../../library/unittest.mock-examples.rst:1242
msgid ""
"If many calls have been made, but you're only interested in a particular "
"sequence of them then an alternative is to use the :meth:`~Mock."
"assert_has_calls` method. This takes a list of calls (constructed with the :"
"data:`call` object). If that sequence of calls are in :attr:`~Mock."
"mock_calls` then the assert succeeds."
msgstr ""
"如果進行了多次呼叫，但你只對其中特定呼叫的序列感興趣，則可以使用 :meth:"
"`~Mock.assert_has_calls` 方法。這需要一個呼叫串列（使用 :data:`call` 物件建"
"構）。如果該呼叫序列位於 :attr:`~Mock.mock_calls` 中，則斷言成功。"

#: ../../library/unittest.mock-examples.rst:1256
msgid ""
"Even though the chained call ``m.one().two().three()`` aren't the only calls "
"that have been made to the mock, the assert still succeeds."
msgstr ""
"儘管鍊接呼叫 ``m.one().two().three()`` 並不是對 mock 進行的唯一呼叫，斷言仍會"
"成功。"

#: ../../library/unittest.mock-examples.rst:1259
msgid ""
"Sometimes a mock may have several calls made to it, and you are only "
"interested in asserting about *some* of those calls. You may not even care "
"about the order. In this case you can pass ``any_order=True`` to "
"``assert_has_calls``:"
msgstr ""
"有時可能會對一個 mock 進行多次呼叫，而你只對斷言其中\\ *某些*\\ 呼叫感興趣。"
"你甚至可能不關心順序。在這種情況下，你可以將 ``any_order=True`` 傳遞給 "
"``assert_has_calls``："

#: ../../library/unittest.mock-examples.rst:1271
msgid "More complex argument matching"
msgstr "更複雜的引數匹配"

#: ../../library/unittest.mock-examples.rst:1273
msgid ""
"Using the same basic concept as :data:`ANY` we can implement matchers to do "
"more complex assertions on objects used as arguments to mocks."
msgstr ""
"使用與 :data:`ANY` 相同的基本概念，我們可以實作匹配器 (matcher)，對用來作為 "
"mock 引數的物件進行更複雜的斷言。"

#: ../../library/unittest.mock-examples.rst:1276
msgid ""
"Suppose we expect some object to be passed to a mock that by default "
"compares equal based on object identity (which is the Python default for "
"user defined classes). To use :meth:`~Mock.assert_called_with` we would need "
"to pass in the exact same object. If we are only interested in some of the "
"attributes of this object then we can create a matcher that will check these "
"attributes for us."
msgstr ""
"假設我們預期某個物件會被傳進 mock，預設情況下，該 mock 會根據物件識別性進行相"
"等比較（對使用者定義類別的 Python 預設行為）。要使用 :meth:`~Mock."
"assert_called_with`，我們需要傳入完全相同的物件。如果我們只對該物件的某些屬性"
"感興趣，那麼我們可以建立一個匹配器來為我們檢查這些屬性。"

#: ../../library/unittest.mock-examples.rst:1283
msgid ""
"You can see in this example how a 'standard' call to ``assert_called_with`` "
"isn't sufficient:"
msgstr ""
"你可以在這個範例中看到對 ``assert_called_with`` 的一個「標準」呼叫是不夠的："

#: ../../library/unittest.mock-examples.rst:1298
msgid ""
"A comparison function for our ``Foo`` class might look something like this:"
msgstr "對我們的 ``Foo`` 類別的比較函式看起來可能會像這樣："

#: ../../library/unittest.mock-examples.rst:1310
msgid ""
"And a matcher object that can use comparison functions like this for its "
"equality operation would look something like this:"
msgstr "而可以使用像這樣的比較函式進行其相等性運算的匹配器物件會長得像這樣："

#: ../../library/unittest.mock-examples.rst:1321
msgid "Putting all this together:"
msgstr "把這些都放在一起："

#: ../../library/unittest.mock-examples.rst:1326
msgid ""
"The ``Matcher`` is instantiated with our compare function and the ``Foo`` "
"object we want to compare against. In ``assert_called_with`` the ``Matcher`` "
"equality method will be called, which compares the object the mock was "
"called with against the one we created our matcher with. If they match then "
"``assert_called_with`` passes, and if they don't an :exc:`AssertionError` is "
"raised:"
msgstr ""
"``Matcher`` 是用我們想要比較的 ``Foo`` 物件和比較函式實例化的。在 "
"``assert_called_with`` 中，``Matcher`` 相等方法將被呼叫，它將呼叫 mock 時傳入"
"的物件與我們建立匹配器時傳入的物件進行比較。如果它們匹配，則 "
"``assert_called_with`` 會通過，如果它們不匹配，則會引發 :exc:"
"`AssertionError`："

#: ../../library/unittest.mock-examples.rst:1339
msgid ""
"With a bit of tweaking you could have the comparison function raise the :exc:"
"`AssertionError` directly and provide a more useful failure message."
msgstr ""
"透過一些調整，你可以讓比較函式直接引發 :exc:`AssertionError` 並提供更有用的失"
"敗訊息。"

#: ../../library/unittest.mock-examples.rst:1342
msgid ""
"As of version 1.5, the Python testing library `PyHamcrest <https://"
"pyhamcrest.readthedocs.io/>`_ provides similar functionality, that may be "
"useful here, in the form of its equality matcher (`hamcrest.library."
"integration.match_equality <https://pyhamcrest.readthedocs.io/en/release-1.8/"
"integration/#module-hamcrest.library.integration.match_equality>`_)."
msgstr ""
"從版本 1.5 開始，Python 測試函式庫 `PyHamcrest <https://pyhamcrest."
"readthedocs.io/>`_ 以其相等匹配器的形式，提供了類似的功能，在這裡可能是有用"
"的 (\\ `hamcrest.library.integration.match_equality <https://pyhamcrest."
"readthedocs.io/en/release-1.8/integration/#module-hamcrest.library."
"integration.match_equality>`_\\ )。"
