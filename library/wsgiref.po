# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-18 00:04+0000\n"
"PO-Revision-Date: 2023-12-09 21:29+0800\n"
"Last-Translator: Liang-Bo Wang <me@liang2.tw>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.1\n"

#: ../../library/wsgiref.rst:2
msgid ":mod:`!wsgiref` --- WSGI Utilities and Reference Implementation"
msgstr ":mod:`!wsgiref` --- WSGI 工具與參考實作"

#: ../../library/wsgiref.rst:10
msgid "**Source code:** :source:`Lib/wsgiref`"
msgstr "**原始碼：**\\ :source:`Lib/wsgiref`"

#: ../../library/wsgiref.rst:14
msgid ""
"The Web Server Gateway Interface (WSGI) is a standard interface between web "
"server software and web applications written in Python. Having a standard "
"interface makes it easy to use an application that supports WSGI with a "
"number of different web servers."
msgstr ""
"網頁伺服器閘道介面 (WSGI) 是一個標準介面，用於連接網頁伺服器軟體與使用 "
"Python 撰寫的網頁應用程式，擁有一個標準介面使得支援 WSGI 的應用程式可以與多個"
"不同的網頁伺服器運行。"

#: ../../library/wsgiref.rst:19
msgid ""
"Only authors of web servers and programming frameworks need to know every "
"detail and corner case of the WSGI design.  You don't need to understand "
"every detail of WSGI just to install a WSGI application or to write a web "
"application using an existing framework."
msgstr ""
"只有網頁伺服器與程式框架的作者需要瞭解 WSGI 設計的每個細節與邊角案例，你並不"
"需要為了安裝 WSGI 應用程式或是使用現有框架撰寫網頁應用程式而必須理解每個細"
"節。"

#: ../../library/wsgiref.rst:24
msgid ""
":mod:`wsgiref` is a reference implementation of the WSGI specification that "
"can be used to add WSGI support to a web server or framework.  It provides "
"utilities for manipulating WSGI environment variables and response headers, "
"base classes for implementing WSGI servers, a demo HTTP server that serves "
"WSGI applications, types for static type checking, and a validation tool "
"that checks WSGI servers and applications for conformance to the WSGI "
"specification (:pep:`3333`)."
msgstr ""
":mod:`wsgiref` 是 WSGI 規格的參考實作，可用於新增 WSGI 來支援網頁伺服器或框"
"架，它提供操作 WSGI 環境變數以及回應標頭的工具，用於實作 WSGI 伺服器的基本類"
"別，提供用於示範 HTTP 伺服器的 WSGI 應用程式、靜態型別檢查、以及驗證 WSGI 伺"
"服器與應用程式是否符合 WSGI 規格的驗證工具 (:pep:`3333`)。"

#: ../../library/wsgiref.rst:32
msgid ""
"See `wsgi.readthedocs.io <https://wsgi.readthedocs.io/>`_ for more "
"information about WSGI, and links to tutorials and other resources."
msgstr ""
"參閱 `wsgi.readthedocs.io <https://wsgi.readthedocs.io/>`_ 更多 WSGI 相關資"
"訊，以及教學連結與其他資源。"

#: ../../library/wsgiref.rst:39
msgid ":mod:`wsgiref.util` -- WSGI environment utilities"
msgstr ":mod:`wsgiref.util` -- WSGI 環境工具"

#: ../../library/wsgiref.rst:45
msgid ""
"This module provides a variety of utility functions for working with WSGI "
"environments.  A WSGI environment is a dictionary containing HTTP request "
"variables as described in :pep:`3333`.  All of the functions taking an "
"*environ* parameter expect a WSGI-compliant dictionary to be supplied; "
"please see :pep:`3333` for a detailed specification and :data:`~wsgiref."
"types.WSGIEnvironment` for a type alias that can be used in type annotations."
msgstr ""
"這個模組提供許多用於處理 WSGI 環境運作的功能。WSGI 環境是一個包含 HTTP 請求變"
"數的字典，如 :pep:`3333` 所述。所有接受 *environ* 的參數的函式都需要提供符合 "
"WSGI 標準的字典；請參閱 :pep:`3333` 獲取詳細規格，以及 :data:`~wsgiref.types."
"WSGIEnvironment` 獲取可用於使用型別註釋的型別別名。"

#: ../../library/wsgiref.rst:56
msgid ""
"Return a guess for whether ``wsgi.url_scheme`` should be \"http\" or "
"\"https\", by checking for a ``HTTPS`` environment variable in the *environ* "
"dictionary.  The return value is a string."
msgstr ""
"透過檢查 *environ* 字典中的 ``HTTPS`` 環境變數，回傳 ``wsgi.url_scheme`` 應該"
"是 \"http\" 或 \"https\" 的猜測。回傳值為一個字串。"

#: ../../library/wsgiref.rst:60
msgid ""
"This function is useful when creating a gateway that wraps CGI or a CGI-like "
"protocol such as FastCGI.  Typically, servers providing such protocols will "
"include a ``HTTPS`` variable with a value of \"1\", \"yes\", or \"on\" when "
"a request is received via SSL.  So, this function returns \"https\" if such "
"a value is found, and \"http\" otherwise."
msgstr ""
"當建立一個包裝 CGI 或類似 FastCGI 的 CGI-like 協議閘道時，此函式非常有用。例"
"如 FastCGI，通常提供這類協議的伺服器在通過 SSL 接收到請求時會包含 "
"\"1\"，\"yes\"，或 \"on\" 的 ``HTTPS`` 變數，因此，如果找到這樣的值，此函式回"
"傳 \"https\"，否則回傳 \"http\"。"

#: ../../library/wsgiref.rst:69
msgid ""
"Return the full request URI, optionally including the query string, using "
"the algorithm found in the \"URL Reconstruction\" section of :pep:`3333`.  "
"If *include_query* is false, the query string is not included in the "
"resulting URI."
msgstr ""
"根據 :pep:`3333` 中 \"URL Reconstruction\" 章節所找到的演算法，回傳完整的請"
"求 URI，可選擇性的包含查詢字串，如果 *include_query* 設為 false，查詢字串不會"
"被包含在結果的 URI 中。"

#: ../../library/wsgiref.rst:76
msgid ""
"Similar to :func:`request_uri`, except that the ``PATH_INFO`` and "
"``QUERY_STRING`` variables are ignored.  The result is the base URI of the "
"application object addressed by the request."
msgstr ""
"類似於 :func:`request_uri`，但忽略 ``PATH_INFO`` 和 ``QUERY_STRING`` 變數。結"
"果是請求地址的應用程式物件的的基本 URI。"

#: ../../library/wsgiref.rst:83
msgid ""
"Shift a single name from ``PATH_INFO`` to ``SCRIPT_NAME`` and return the "
"name. The *environ* dictionary is *modified* in-place; use a copy if you "
"need to keep the original ``PATH_INFO`` or ``SCRIPT_NAME`` intact."
msgstr ""
"將單一名稱從 ``PATH_INFO`` 移到 ``SCRIPT_NAME`` 並回傳該名稱。*environ* 字典"
"會在適當時機被 *modified*；如果你需要保留原始完好無損的 ``PATH_INFO`` 或 "
"``SCRIPT_NAME`` 請使用副本。"

#: ../../library/wsgiref.rst:87
msgid ""
"If there are no remaining path segments in ``PATH_INFO``, ``None`` is "
"returned."
msgstr "如果在 ``PATH_INFO`` 中沒有剩餘的路徑片段，則回傳 ``None``。"

#: ../../library/wsgiref.rst:89
msgid ""
"Typically, this routine is used to process each portion of a request URI "
"path, for example to treat the path as a series of dictionary keys. This "
"routine modifies the passed-in environment to make it suitable for invoking "
"another WSGI application that is located at the target URI. For example, if "
"there is a WSGI application at ``/foo``, and the request URI path is ``/foo/"
"bar/baz``, and the WSGI application at ``/foo`` calls :func:"
"`shift_path_info`, it will receive the string \"bar\", and the environment "
"will be updated to be suitable for passing to a WSGI application at ``/foo/"
"bar``.  That is, ``SCRIPT_NAME`` will change from ``/foo`` to ``/foo/bar``, "
"and ``PATH_INFO`` will change from ``/bar/baz`` to ``/baz``."
msgstr ""
"通常，此程式用於處理請求 URI 的每一部分路徑，例如將路徑視為一系列的字典鍵此程"
"式會修改傳入的環境，使其適用於呼叫位於目標 URI 的 WSGI 應用程式。例如，如果"
"在 ``/foo`` 上有一個 WSGI 應用程式且請求 URI 路徑為 ``/foo/bar/baz``，並且位"
"於 ``/foo`` 的 WSGI 應用程式呼叫 :func:`shift_path_info`，它將接收字串 "
"\"bar\"，而環境將被更新為適用於傳遞給位於 ``/foo/bar`` 的 WSGI 應用程式。換句"
"話說，``SCRIPT_NAME`` 將從 ``/foo`` 變更為 ``/foo/bar``，而 ``PATH_INFO`` 將"
"從 ``/bar/baz`` 變更為 ``/baz``。"

#: ../../library/wsgiref.rst:100
msgid ""
"When ``PATH_INFO`` is just a \"/\", this routine returns an empty string and "
"appends a trailing slash to ``SCRIPT_NAME``, even though empty path segments "
"are normally ignored, and ``SCRIPT_NAME`` doesn't normally end in a slash.  "
"This is intentional behavior, to ensure that an application can tell the "
"difference between URIs ending in ``/x`` from ones ending in ``/x/`` when "
"using this routine to do object traversal."
msgstr ""
"當 ``PATH_INFO`` 只是一個 \"/\" 時， 此程式會回傳一個空字串，並在 "
"``SCRIPT_NAME`` 後添加尾部斜號，即使空路徑片段通常是被忽略的，而且 "
"``SCRIPT_NAME`` 通常不會以斜號結尾。這是刻意行為，以確保應用程式在使用這個程"
"式進行物件遍歷時可以區分結尾為 ``/x`` 和結尾為 ``/x/`` 的 URIs。"

#: ../../library/wsgiref.rst:110
msgid "Update *environ* with trivial defaults for testing purposes."
msgstr "為測試目的，以簡單的預設值更新 *environ* 。"

#: ../../library/wsgiref.rst:112
msgid ""
"This routine adds various parameters required for WSGI, including "
"``HTTP_HOST``, ``SERVER_NAME``, ``SERVER_PORT``, ``REQUEST_METHOD``, "
"``SCRIPT_NAME``, ``PATH_INFO``, and all of the :pep:`3333`\\ -defined ``wsgi."
"*`` variables.  It only supplies default values, and does not replace any "
"existing settings for these variables."
msgstr ""
"這個程式新增 WSGI 所需的各種參數，包括 ``HTTP_HOST``、``SERVER_NAME``、"
"``SERVER_PORT``、``REQUEST_METHOD``、``SCRIPT_NAME``、``PATH_INFO``，以及所"
"有 :pep:`3333` 定義的 ``wsgi.*`` 變數，它只提供預設值，並且不會取代現有的這些"
"變數設定。"

#: ../../library/wsgiref.rst:118
msgid ""
"This routine is intended to make it easier for unit tests of WSGI servers "
"and applications to set up dummy environments.  It should NOT be used by "
"actual WSGI servers or applications, since the data is fake!"
msgstr ""
"這個程式目的為了讓 WSGI 伺服器和應用程式的單元測試更容易建置虛擬環境。實際的 "
"WSGI 伺服器或應用程式不應該使用它，因為所產生的數據是假的！"

#: ../../library/wsgiref.rst:122 ../../library/wsgiref.rst:170
#: ../../library/wsgiref.rst:293 ../../library/wsgiref.rst:426
msgid "Example usage::"
msgstr "用法範例： ::"

#: ../../library/wsgiref.rst:124
msgid ""
"from wsgiref.util import setup_testing_defaults\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"# A relatively simple WSGI application. It's going to print out the\n"
"# environment dictionary after being updated by setup_testing_defaults\n"
"def simple_app(environ, start_response):\n"
"    setup_testing_defaults(environ)\n"
"\n"
"    status = '200 OK'\n"
"    headers = [('Content-type', 'text/plain; charset=utf-8')]\n"
"\n"
"    start_response(status, headers)\n"
"\n"
"    ret = [(\"%s: %s\\n\" % (key, value)).encode(\"utf-8\")\n"
"           for key, value in environ.items()]\n"
"    return ret\n"
"\n"
"with make_server('', 8000, simple_app) as httpd:\n"
"    print(\"Serving on port 8000...\")\n"
"    httpd.serve_forever()"
msgstr ""

#: ../../library/wsgiref.rst:146
msgid ""
"In addition to the environment functions above, the :mod:`wsgiref.util` "
"module also provides these miscellaneous utilities:"
msgstr "除了上述的環境功能外，:mod:`wsgiref.util` 模組還提供以下各類工具："

#: ../../library/wsgiref.rst:152
msgid ""
"Return ``True`` if 'header_name' is an HTTP/1.1 \"Hop-by-Hop\" header, as "
"defined by :rfc:`2616`."
msgstr ""
"如果 'header_name' 是根據 :rfc:`2616` 所定義的 HTTP/1.1 \"Hop-by-Hop\" 標頭，"
"則回傳 ``True``。"

#: ../../library/wsgiref.rst:158
msgid ""
"A concrete implementation of the :class:`wsgiref.types.FileWrapper` protocol "
"used to convert a file-like object to an :term:`iterator`. The resulting "
"objects are :term:`iterable`\\ s. As the object is iterated over, the "
"optional *blksize* parameter will be repeatedly passed to the *filelike* "
"object's :meth:`read` method to obtain bytestrings to yield.  When :meth:"
"`read` returns an empty bytestring, iteration is ended and is not resumable."
msgstr ""
":class:`wsgiref.types.FileWrapper` 協議的具體實作，用於將類檔案物件轉換為 :"
"term:`iterator`。產生的物件是 :term:`iterable`。當物件進行疊代時，將可選的 "
"*blksize* 引數重複傳遞給 *filelike* 物件的 :meth:`read` 方法來獲得將產生"
"（yield）的位元組字串。當 :meth:`read` 回傳一個空位元組字串，代表疊代已結束且"
"無法回復。"

#: ../../library/wsgiref.rst:166
msgid ""
"If *filelike* has a :meth:`close` method, the returned object will also have "
"a :meth:`close` method, and it will invoke the *filelike* object's :meth:"
"`close` method when called."
msgstr ""
"如果 *filelike* 有 :meth:`close` 方法，則回傳的物件也會具有 :meth:`close` 方"
"法，並在呼叫時呼叫 *filelike* 物件的 :meth:`close` 方法。"

#: ../../library/wsgiref.rst:172
msgid ""
"from io import StringIO\n"
"from wsgiref.util import FileWrapper\n"
"\n"
"# We're using a StringIO-buffer for as the file-like object\n"
"filelike = StringIO(\"This is an example file-like object\"*10)\n"
"wrapper = FileWrapper(filelike, blksize=5)\n"
"\n"
"for chunk in wrapper:\n"
"    print(chunk)"
msgstr ""

#: ../../library/wsgiref.rst:182
msgid "Support for :meth:`~object.__getitem__` method has been removed."
msgstr "已移除對 :meth:`~object.__getitem__` 方法的支援。"

#: ../../library/wsgiref.rst:187
msgid ":mod:`wsgiref.headers` -- WSGI response header tools"
msgstr ":mod:`wsgiref.headers` -- WSGI 回應標頭工具"

#: ../../library/wsgiref.rst:193
msgid ""
"This module provides a single class, :class:`Headers`, for convenient "
"manipulation of WSGI response headers using a mapping-like interface."
msgstr ""
"這個模組提供單一類別 :class:`Headers`，用於使用類似對映的介面方便地操作 WSGI "
"回應標頭。"

#: ../../library/wsgiref.rst:199
msgid ""
"Create a mapping-like object wrapping *headers*, which must be a list of "
"header name/value tuples as described in :pep:`3333`. The default value of "
"*headers* is an empty list."
msgstr ""
"建立一個類似對映物件並包裝 *headers*，並且必須是符合 :pep:`3333` 描述的 name/"
"value 元組的標頭串列。*headers* 的預設值是一個空串列。"

#: ../../library/wsgiref.rst:203
msgid ""
":class:`Headers` objects support typical mapping operations including :meth:"
"`~object.__getitem__`, :meth:`~dict.get`, :meth:`~object.__setitem__`, :meth:"
"`~dict.setdefault`, :meth:`~object.__delitem__` and :meth:`~object."
"__contains__`.  For each of these methods, the key is the header name "
"(treated case-insensitively), and the value is the first value associated "
"with that header name.  Setting a header deletes any existing values for "
"that header, then adds a new value at the end of the wrapped header list.  "
"Headers' existing order is generally maintained, with new headers added to "
"the end of the wrapped list."
msgstr ""
":class:`Headers` 物件支援典型對映操作包括 :meth:`__getitem__`、:meth:`~dict."
"get`、:meth:`~object.__setitem__`、:meth:`~dict.setdefault`、:meth:`~object."
"__delitem__` 以及 :meth:`~object.__contains__`。對於這些方法中的每一個，鍵是"
"標頭名稱（以不區分大小寫方式處理），而值則是與該標頭名稱關聯的第一個值。設定"
"標頭會刪除該標頭的所有現有值，然後將新值添加到包裝的標頭串列末尾。標頭的現有"
"順序通常保持不變，新標頭會添加到包裝串列的末尾。"

#: ../../library/wsgiref.rst:213
msgid ""
"Unlike a dictionary, :class:`Headers` objects do not raise an error when you "
"try to get or delete a key that isn't in the wrapped header list. Getting a "
"nonexistent header just returns ``None``, and deleting a nonexistent header "
"does nothing."
msgstr ""
"不同於字典，當你嘗試取得或刪除包裝的標頭串列不存在的鍵，:class:`Headers` 物件"
"不會引發例外錯誤。取得不存在的標頭只會回傳 ``None``，而刪除不存在的標頭則不會"
"有任何效果。"

#: ../../library/wsgiref.rst:218
msgid ""
":class:`Headers` objects also support :meth:`keys`, :meth:`values`, and :"
"meth:`items` methods.  The lists returned by :meth:`keys` and :meth:`items` "
"can include the same key more than once if there is a multi-valued header.  "
"The ``len()`` of a :class:`Headers` object is the same as the length of its :"
"meth:`items`, which is the same as the length of the wrapped header list.  "
"In fact, the :meth:`items` method just returns a copy of the wrapped header "
"list."
msgstr ""
":class:`Headers` 物件還支援 :meth:`keys`、:meth:`value`、和 :meth:`items` 方"
"法。由 :meth:`keys` 和 :meth:`items` 回傳的串列在存在多值標頭時可能會包含相同"
"的鍵。:class:`Headers` 物件的 ``len()`` 與 :meth:`items` 的長度相同，也與包裝"
"標頭串列的長度相同。實際上，:meth:`items` 方法只是回傳包裝的標頭串列的副本。"

#: ../../library/wsgiref.rst:225
msgid ""
"Calling ``bytes()`` on a :class:`Headers` object returns a formatted "
"bytestring suitable for transmission as HTTP response headers.  Each header "
"is placed on a line with its value, separated by a colon and a space. Each "
"line is terminated by a carriage return and line feed, and the bytestring is "
"terminated with a blank line."
msgstr ""
"對 :class:`Header` 物件呼叫 ``bytes()`` 會回傳適合作為 HTTP 傳輸回應標頭的格"
"式化的位元組字串。每個標頭都與其值一起置於一行上，由冒號與空格分隔。每行以回"
"車（carriage return）和換行（line feed）結束，而該位元組字串則以空行結束。"

#: ../../library/wsgiref.rst:231
msgid ""
"In addition to their mapping interface and formatting features, :class:"
"`Headers` objects also have the following methods for querying and adding "
"multi-valued headers, and for adding headers with MIME parameters:"
msgstr ""
"除了對映介面和格式化功能外，:class:`Headers` 物件還具有以下查詢及附加多值標頭"
"的以及附加 MIME 參數標頭的方法："

#: ../../library/wsgiref.rst:238
msgid "Return a list of all the values for the named header."
msgstr "回傳指定標頭的所有值的串列。"

#: ../../library/wsgiref.rst:240
msgid ""
"The returned list will be sorted in the order they appeared in the original "
"header list or were added to this instance, and may contain duplicates.  Any "
"fields deleted and re-inserted are always appended to the header list.  If "
"no fields exist with the given name, returns an empty list."
msgstr ""
"回傳的串列按照它們在在原始的標頭串列出現的順序或是被添加到此實例的順序進行排"
"序，並且可能包含重複的內容。任何被刪除並重新插入的欄位都會被添加到標頭串列的"
"末尾。如果不存在指定名稱的欄位，則回傳空串列。"

#: ../../library/wsgiref.rst:248
msgid ""
"Add a (possibly multi-valued) header, with optional MIME parameters "
"specified via keyword arguments."
msgstr ""
"添加一個（可能是多值的）標頭，可通過關鍵字引數來指定選擇性的 MIME 參數。"

#: ../../library/wsgiref.rst:251
msgid ""
"*name* is the header field to add.  Keyword arguments can be used to set "
"MIME parameters for the header field.  Each parameter must be a string or "
"``None``. Underscores in parameter names are converted to dashes, since "
"dashes are illegal in Python identifiers, but many MIME parameter names "
"include dashes.  If the parameter value is a string, it is added to the "
"header value parameters in the form ``name=\"value\"``. If it is ``None``, "
"only the parameter name is added. (This is used for MIME parameters without "
"a value.)  Example usage::"
msgstr ""
"*name* 是要添加的標頭欄位。關鍵字引數可使於設定標頭欄位的 MIME 參數。每一個參"
"數必須是字串或是 ``None``。由於破折號在 Python 識別符中是非法的，但是許多 "
"MIME 參數名稱包含破折號，因此參數名稱的底線會轉換成破折號。如果參數值是字串，"
"則以 ``name=\"value\"`` 的形式添加到標頭值參數中。如果它是 ``None``，則僅添加"
"參數名稱。（這使用於沒有值的 MIME 參數）使用範例： ::"

#: ../../library/wsgiref.rst:259
msgid "h.add_header('content-disposition', 'attachment', filename='bud.gif')"
msgstr "h.add_header('content-disposition', 'attachment', filename='bud.gif')"

#: ../../library/wsgiref.rst:261
msgid "The above will add a header that looks like this::"
msgstr "上述操作將添加看起來像這樣的標頭： ::"

#: ../../library/wsgiref.rst:263
msgid "Content-Disposition: attachment; filename=\"bud.gif\""
msgstr "Content-Disposition: attachment; filename=\"bud.gif\""

#: ../../library/wsgiref.rst:266
msgid "*headers* parameter is optional."
msgstr "*headers* 參數是可選的。"

#: ../../library/wsgiref.rst:271
msgid ":mod:`wsgiref.simple_server` -- a simple WSGI HTTP server"
msgstr ":mod:`wsgiref.simple_server` -- 一個簡單的 WSGI HTTP 伺服器"

#: ../../library/wsgiref.rst:277
msgid ""
"This module implements a simple HTTP server (based on :mod:`http.server`) "
"that serves WSGI applications.  Each server instance serves a single WSGI "
"application on a given host and port.  If you want to serve multiple "
"applications on a single host and port, you should create a WSGI application "
"that parses ``PATH_INFO`` to select which application to invoke for each "
"request.  (E.g., using the :func:`shift_path_info` function from :mod:"
"`wsgiref.util`.)"
msgstr ""
"這個模組實作一個簡單的的 HTTP 伺服器（基於 :mod:`http.server`）用於提供 WSGI "
"應用程式。每個伺服器執行個體在特定的主機與埠提供單一的 WSGI 應用程式。如果你"
"想要在單一主機與埠上提供多個應用程式，你應該建立一個 WSGI 應用程式以剖析 "
"``PATH_INFO`` 去選擇為每個請求呼叫哪個應用程式。（例如，使用來自 :mod:"
"`wsgiref.util` 的 :func:`shift_path_info` 函式。）"

#: ../../library/wsgiref.rst:288
msgid ""
"Create a new WSGI server listening on *host* and *port*, accepting "
"connections for *app*.  The return value is an instance of the supplied "
"*server_class*, and will process requests using the specified "
"*handler_class*.  *app* must be a WSGI application object, as defined by :"
"pep:`3333`."
msgstr ""
"建立一個新的 WSGI 伺服器監聽 *host* 和 *port*，接受 *app* 的連線。回傳值是提"
"供 *server_class* 的實例，並將使用指定的 *handler_class* 處理請求。*app* 必須"
"是一個 WSGI 應用程式物件，如 :pep:`3333` 所定義。"

#: ../../library/wsgiref.rst:295
msgid ""
"from wsgiref.simple_server import make_server, demo_app\n"
"\n"
"with make_server('', 8000, demo_app) as httpd:\n"
"    print(\"Serving HTTP on port 8000...\")\n"
"\n"
"    # Respond to requests until process is killed\n"
"    httpd.serve_forever()\n"
"\n"
"    # Alternative: serve one request, then exit\n"
"    httpd.handle_request()"
msgstr ""

#: ../../library/wsgiref.rst:309
msgid ""
"This function is a small but complete WSGI application that returns a text "
"page containing the message \"Hello world!\" and a list of the key/value "
"pairs provided in the *environ* parameter.  It's useful for verifying that a "
"WSGI server (such as :mod:`wsgiref.simple_server`) is able to run a simple "
"WSGI application correctly."
msgstr ""
"這個函式是一個簡單但完整的 WSGI 應用程式，它回傳一個包含訊息 \"Hello world!"
"\" 和在 *environ* 參數中提供的鍵值對串列的文字頁面。這對於驗證 WSGI 伺服器"
"（例如 :mod:`wsgiref.simple_server`）是否能正確執行簡單的 WSGI 應用程式非常有"
"用。"

#: ../../library/wsgiref.rst:318
msgid ""
"Create a :class:`WSGIServer` instance.  *server_address* should be a ``(host,"
"port)`` tuple, and *RequestHandlerClass* should be the subclass of :class:"
"`http.server.BaseHTTPRequestHandler` that will be used to process requests."
msgstr ""
"建立一個 :class:`WSGIServer` 實例。*server_address* 應該是一個 ``(host, "
"port)`` 元組，而 *RequestHandlerClass* 應該是 :class:`http.server."
"BaseHTTPRequestHandler` 的子類別，將用於處理請求。"

#: ../../library/wsgiref.rst:323
msgid ""
"You do not normally need to call this constructor, as the :func:"
"`make_server` function can handle all the details for you."
msgstr ""
"通常你不需要呼叫這個建構函式（constructor），因為 :func:`make_server` 函式可"
"以為你處理所有細節。"

#: ../../library/wsgiref.rst:326
msgid ""
":class:`WSGIServer` is a subclass of :class:`http.server.HTTPServer`, so all "
"of its methods (such as :meth:`serve_forever` and :meth:`handle_request`) "
"are available. :class:`WSGIServer` also provides these WSGI-specific methods:"
msgstr ""
":class:`WSGIServer` 是 :class:`http.server.HTTPServer` 的子類別，因此它的所有"
"方法（例如 :meth:`serve_forever` 和 :meth:`handle_request`）都可用。:class:"
"`WSGIServer` 也提供這些特定於 WSGI 的方法："

#: ../../library/wsgiref.rst:333
msgid ""
"Sets the callable *application* as the WSGI application that will receive "
"requests."
msgstr "將可呼叫的 *application* 設定為接收請求的 WSGI 應用程式。"

#: ../../library/wsgiref.rst:339
msgid "Returns the currently set application callable."
msgstr "回傳目前設定應用程式的可呼叫物件。"

#: ../../library/wsgiref.rst:341
msgid ""
"Normally, however, you do not need to use these additional methods, as :meth:"
"`set_app` is normally called by :func:`make_server`, and the :meth:`get_app` "
"exists mainly for the benefit of request handler instances."
msgstr ""
"然而，通常情況下你不需要去使用這些額外方法，因為 :meth:`set_app` 通常會被 :"
"func:`make_server` 呼叫而 :meth:`get_app` 主要存在於請求處理程式（handler）實"
"例的好處上。"

#: ../../library/wsgiref.rst:348
msgid ""
"Create an HTTP handler for the given *request* (i.e. a socket), "
"*client_address* (a ``(host,port)`` tuple), and *server* (:class:"
"`WSGIServer` instance)."
msgstr ""
"為給定的 *request*（即一個 socket）、*client_address*（一個 ``(host,port)`` "
"位元組）、*server* (:class:`WSGIServer` 實例) 建立一個 HTTP 處理程式"
"（handler）。"

#: ../../library/wsgiref.rst:351
msgid ""
"You do not need to create instances of this class directly; they are "
"automatically created as needed by :class:`WSGIServer` objects.  You can, "
"however, subclass this class and supply it as a *handler_class* to the :func:"
"`make_server` function.  Some possibly relevant methods for overriding in "
"subclasses:"
msgstr ""
"你不需要直接建立這個類別的實例；它們會在需要時由 :class:`WSGIServer` 物件自動"
"建立。不過，你可以建立這個類別的子類別並將其作為 *handler_class* 提供給 :"
"func:`make_server` 函式。一些可能相關的方法可以在子類別中進行覆寫："

#: ../../library/wsgiref.rst:360
msgid ""
"Return a :data:`~wsgiref.types.WSGIEnvironment` dictionary for a request.  "
"The default implementation copies the contents of the :class:`WSGIServer` "
"object's :attr:`base_environ` dictionary attribute and then adds various "
"headers derived from the HTTP request.  Each call to this method should "
"return a new dictionary containing all of the relevant CGI environment "
"variables as specified in :pep:`3333`."
msgstr ""
"唯一個請求回傳一個 :data:`~wsgiref.types.WSGIEnvironment` 字典。預設的實作會"
"複製 :class:`WSGIServer` 物件的 :attr:`base_environ` 字典屬性的內容以及添加"
"從 HTTP 請求中衍生的各種標頭。每次呼叫這個方法都應該回傳一個包含所有如 :pep:"
"`3333` 所指定的相關 CGI 環境變數的新字典。"

#: ../../library/wsgiref.rst:371
msgid ""
"Return the object that should be used as the ``wsgi.errors`` stream. The "
"default implementation just returns ``sys.stderr``."
msgstr ""
"回傳的物件應該被用作 ``wsgi.errors`` 串流。預設實作只會回傳 ``sys.stderr``。"

#: ../../library/wsgiref.rst:377
msgid ""
"Process the HTTP request.  The default implementation creates a handler "
"instance using a :mod:`wsgiref.handlers` class to implement the actual WSGI "
"application interface."
msgstr ""
"處理 HTTP 請求。預設實作會使用 :mod:`wsgiref.handler` 類別來建立處置程式"
"（handler）實例來實作實際 WSGI 應用程式介面。"

#: ../../library/wsgiref.rst:383
msgid ":mod:`wsgiref.validate` --- WSGI conformance checker"
msgstr ":mod:`wsgiref.validate` --- WSGI 符合性檢查"

#: ../../library/wsgiref.rst:389
msgid ""
"When creating new WSGI application objects, frameworks, servers, or "
"middleware, it can be useful to validate the new code's conformance using :"
"mod:`wsgiref.validate`.  This module provides a function that creates WSGI "
"application objects that validate communications between a WSGI server or "
"gateway and a WSGI application object, to check both sides for protocol "
"conformance."
msgstr ""
"當建立新的 WSGI 應用程式物件、框架、伺服器、或是中介軟體（middleware）時，使"
"用 :mod:`wsgiref.validate` 來驗證新程式碼的符合性可能會很有用。這個模組提供一"
"個函式用於建立 WSGI 應用程式物件，並用於驗證 WSGI 伺服器或是閘道與 WSGI 應用"
"程式物件之間的通訊，以檢查雙方協議的符合性。"

#: ../../library/wsgiref.rst:396
msgid ""
"Note that this utility does not guarantee complete :pep:`3333` compliance; "
"an absence of errors from this module does not necessarily mean that errors "
"do not exist.  However, if this module does produce an error, then it is "
"virtually certain that either the server or application is not 100% "
"compliant."
msgstr ""
"請注意這個工具並不保證完全符合 :pep:`3333`；這個模組中的錯誤不一定代表不存在"
"錯誤。但是，如果如果這個模組產生錯誤，那麼幾乎可以確定伺服器或應用程式不是 "
"100% 符合標準。"

#: ../../library/wsgiref.rst:401
msgid ""
"This module is based on the :mod:`paste.lint` module from Ian Bicking's "
"\"Python Paste\" library."
msgstr ""
"這個模組基於 Ian Bicking 的 \"Python Paste\" 函式庫的 :mod:`paste.lint` 模"
"組。"

#: ../../library/wsgiref.rst:407
msgid ""
"Wrap *application* and return a new WSGI application object.  The returned "
"application will forward all requests to the original *application*, and "
"will check that both the *application* and the server invoking it are "
"conforming to the WSGI specification and to :rfc:`2616`."
msgstr ""
"包裝 *application* 並回傳一個新的 WSGI 應用程式物件。回傳的應用程式將轉發所有"
"請求給原始的 *application*，並檢查 *application* 和呼叫它的伺服器是否符合 "
"WSGI 規範和 :rfc:`2616`。"

#: ../../library/wsgiref.rst:412
msgid ""
"Any detected nonconformance results in an :exc:`AssertionError` being "
"raised; note, however, that how these errors are handled is server-"
"dependent.  For example, :mod:`wsgiref.simple_server` and other servers "
"based on :mod:`wsgiref.handlers` (that don't override the error handling "
"methods to do something else) will simply output a message that an error has "
"occurred, and dump the traceback to ``sys.stderr`` or some other error "
"stream."
msgstr ""
"任何在 :exc:`AssertionError` 中偵測不符合結果都會發起例外；但請注意，如何處理"
"這些錯誤取決於伺服器。例如，基於 :mod:`wsgiref.handlers` 的 :mod:`wsgiref."
"simple_server` 以及其他伺服器（未覆蓋錯誤處理方法以執行其他操作的伺服器）將僅"
"輸出一條錯誤訊息，指示發生錯誤，並將回溯訊息輸出到 ``sys.stderr`` 或是其他錯"
"誤串流。"

#: ../../library/wsgiref.rst:419
msgid ""
"This wrapper may also generate output using the :mod:`warnings` module to "
"indicate behaviors that are questionable but which may not actually be "
"prohibited by :pep:`3333`.  Unless they are suppressed using Python command-"
"line options or the :mod:`warnings` API, any such warnings will be written "
"to ``sys.stderr`` (*not* ``wsgi.errors``, unless they happen to be the same "
"object)."
msgstr ""
"這個包裝器也可以使用 :mod:`warnings` 模組生成輸出去指示一些可能有疑慮但實際上"
"可能不會被 :pep:`3333` 禁止的行為。除非使用 Python 命令列選項或 :mod:"
"`warnings` API，抑制了這些警告，否則這類警告將被寫入到 ``sys.stderr``\\ "
"（*not* ``wsgi.errors``，除非它們碰巧是相同的物件）。"

#: ../../library/wsgiref.rst:428
msgid ""
"from wsgiref.validate import validator\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"# Our callable object which is intentionally not compliant to the\n"
"# standard, so the validator is going to break\n"
"def simple_app(environ, start_response):\n"
"    status = '200 OK'  # HTTP Status\n"
"    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n"
"    start_response(status, headers)\n"
"\n"
"    # This is going to break because we need to return a list, and\n"
"    # the validator is going to inform us\n"
"    return b\"Hello World\"\n"
"\n"
"# This is the application wrapped in a validator\n"
"validator_app = validator(simple_app)\n"
"\n"
"with make_server('', 8000, validator_app) as httpd:\n"
"    print(\"Listening on port 8000....\")\n"
"    httpd.serve_forever()"
msgstr ""

#: ../../library/wsgiref.rst:451
msgid ":mod:`wsgiref.handlers` -- server/gateway base classes"
msgstr ":mod:`wsgiref.handlers` -- 伺服器 / 閘道基本類別"

#: ../../library/wsgiref.rst:457
msgid ""
"This module provides base handler classes for implementing WSGI servers and "
"gateways.  These base classes handle most of the work of communicating with "
"a WSGI application, as long as they are given a CGI-like environment, along "
"with input, output, and error streams."
msgstr ""
"這個模組提供實作 WSGI 伺服器和閘道的基礎處理程式（handler）類別。這些基底類別"
"處理程式大部分與 WSGI 應用程式通訊的工作，只要它們被提供 CGI-like 環境，以及"
"輸入、輸出和錯誤串流。"

#: ../../library/wsgiref.rst:465
msgid ""
"CGI-based invocation via ``sys.stdin``, ``sys.stdout``, ``sys.stderr`` and "
"``os.environ``.  This is useful when you have a WSGI application and want to "
"run it as a CGI script.  Simply invoke ``CGIHandler().run(app)``, where "
"``app`` is the WSGI application object you wish to invoke."
msgstr ""
"這是基於 CGI 的呼叫方式並透過 ``sys.stdin``、``sys.stdout``、``sys.stderr`` "
"和 ``os.environ``。當你擁有一個 WSGI 應用程式並希望將其作為 CGI 腳本運行時是"
"很有用的。只需呼叫 ``CGIHandler().run(app)``，其中 ``app`` 是你希望呼叫的 "
"WSGI 應用程式物件。"

#: ../../library/wsgiref.rst:470
msgid ""
"This class is a subclass of :class:`BaseCGIHandler` that sets ``wsgi."
"run_once`` to true, ``wsgi.multithread`` to false, and ``wsgi.multiprocess`` "
"to true, and always uses :mod:`sys` and :mod:`os` to obtain the necessary "
"CGI streams and environment."
msgstr ""
"這個類別是 :class:`BaseCGIHandler` 的子類別將 ``wsgi.run_once`` 設置為 true，"
"``wsgi.multithread`` 設置為 false，並將 ``wsgi.multiprocess`` 設置為 true，並"
"且始終使用 :mod:`sys` 和 :mod:`os` 來獲取所需的 CGI 串流以及環境。"

#: ../../library/wsgiref.rst:478
msgid ""
"A specialized alternative to :class:`CGIHandler`, for use when deploying on "
"Microsoft's IIS web server, without having set the config allowPathInfo "
"option (IIS>=7) or metabase allowPathInfoForScriptMappings (IIS<7)."
msgstr ""
"這是用於在 Microsoft 的 IIS 網頁伺服器上部署時使用的 :class:`CGIHandler` 的一"
"個專門替代選擇，無需設置 config 的 allowPathInfo 選項（IIS>=7），或 metabase "
"的 allowPathInfoForScriptMappings 選項（IIS<7）。"

#: ../../library/wsgiref.rst:482
msgid ""
"By default, IIS gives a ``PATH_INFO`` that duplicates the ``SCRIPT_NAME`` at "
"the front, causing problems for WSGI applications that wish to implement "
"routing. This handler strips any such duplicated path."
msgstr ""
"預設情況下，IIS 提供的 ``PATH_INFO`` 會在前面複製 ``SCRIPT_NAME``，對於希望實"
"作路由的 WSGI 應用程式造成問題。這個處理程式（handler）會移除任何這樣的重複路"
"徑。"

#: ../../library/wsgiref.rst:486
msgid ""
"IIS can be configured to pass the correct ``PATH_INFO``, but this causes "
"another bug where ``PATH_TRANSLATED`` is wrong. Luckily this variable is "
"rarely used and is not guaranteed by WSGI. On IIS<7, though, the setting can "
"only be made on a vhost level, affecting all other script mappings, many of "
"which break when exposed to the ``PATH_TRANSLATED`` bug. For this reason "
"IIS<7 is almost never deployed with the fix (Even IIS7 rarely uses it "
"because there is still no UI for it.)."
msgstr ""
"IIS 可以配置去傳遞正確的 ``PATH_INFO``，但這會導致 ``PATH_TRANSLATED`` 是錯誤"
"的問題。幸運的是這個變數很少被使用並且不受 WSGI 保證。然而，在 IIS<7 上，這個"
"設置只能在虛擬主機層級進行，影響所有其他腳本的對映，其中許多在暴露 "
"``PATH_TRANSLATED`` 問題時會中斷。由於這個原因幾乎從不會使用修復的 IIS<7（即"
"使是 IIS7 也很少使用它，因為它仍然沒有相應的 UI）。"

#: ../../library/wsgiref.rst:494
msgid ""
"There is no way for CGI code to tell whether the option was set, so a "
"separate handler class is provided.  It is used in the same way as :class:"
"`CGIHandler`, i.e., by calling ``IISCGIHandler().run(app)``, where ``app`` "
"is the WSGI application object you wish to invoke."
msgstr ""
"CGI 程式碼無法知道是否已設置該選項，因此提供了一個獨立的處理程式（handler）類"
"別。它的使用方式與 :class:`CGIHandler` 相同，即透過呼叫 ``IISCGIHandler()."
"run(app)`` 來使用，其中 ``app`` 是你希望呼叫的 WSGI 應用程式物件。"

#: ../../library/wsgiref.rst:504
msgid ""
"Similar to :class:`CGIHandler`, but instead of using the :mod:`sys` and :mod:"
"`os` modules, the CGI environment and I/O streams are specified explicitly. "
"The *multithread* and *multiprocess* values are used to set the ``wsgi."
"multithread`` and ``wsgi.multiprocess`` flags for any applications run by "
"the handler instance."
msgstr ""
"類似於 :class:`CGIHandler`，但不是使用 :mod:`sys` 和 :mod:`os` 模組，而是明確"
"指定 CGI 環境與 I/O 串流。*multithread* 和 *multiprocess* 值用於設置由處理程"
"式（handler）實例運行的任何應用程式的旗標。"

#: ../../library/wsgiref.rst:510
msgid ""
"This class is a subclass of :class:`SimpleHandler` intended for use with "
"software other than HTTP \"origin servers\".  If you are writing a gateway "
"protocol implementation (such as CGI, FastCGI, SCGI, etc.) that uses a "
"``Status:`` header to send an HTTP status, you probably want to subclass "
"this instead of :class:`SimpleHandler`."
msgstr ""
"這個類別是專門為除了 HTTP \"origin servers\" 以外的軟體一起使用的 :class:"
"`SimpleHandler` 的子類別。如果你正在撰寫一個使用 ``Status:`` 標頭來發送 HTTP "
"狀態的閘道協議實作（例如 CGI、FastCGI、SCGI 等），你可能會想要子類化這個類別"
"來替代 :class:`SimpleHandler`。"

#: ../../library/wsgiref.rst:519
msgid ""
"Similar to :class:`BaseCGIHandler`, but designed for use with HTTP origin "
"servers.  If you are writing an HTTP server implementation, you will "
"probably want to subclass this instead of :class:`BaseCGIHandler`."
msgstr ""
"類似於 :class:`BaseCGIHandler`，但是被設計使用在 HTTP origin 伺服器。如果你正"
"在撰寫 HTTP 伺服器的實作，你可能會想要子類別化這個類別來替代 :class:"
"`BaseCGIHandler`。"

#: ../../library/wsgiref.rst:523
msgid ""
"This class is a subclass of :class:`BaseHandler`.  It overrides the :meth:`!"
"__init__`, :meth:`~BaseHandler.get_stdin`, :meth:`~BaseHandler.get_stderr`, :"
"meth:`~BaseHandler.add_cgi_vars`, :meth:`~BaseHandler._write`, and :meth:"
"`~BaseHandler._flush` methods to support explicitly setting the environment "
"and streams via the constructor.  The supplied environment and streams are "
"stored in the :attr:`stdin`, :attr:`stdout`, :attr:`stderr`, and :attr:"
"`environ` attributes."
msgstr ""
"這個類別是 :class:`BaseHandler` 的子類別。它透過建構器去覆寫 :meth:`!"
"__init__`、:meth:`~BaseHandler.get_stdin`、:meth:`~BaseHandler.get_stderr`、:"
"meth:`~BaseHandler.add_cgi_vars`、:meth:`~BaseHandler._write`、和 :meth:"
"`~BaseHandler._flush` 方法來明確提供設置環境與串流。提供的環境與串流被儲存"
"在 :attr:`stdin`、:attr:`stdout`、:attr:`stderr`、和 :attr:`environ` 環境中。"

#: ../../library/wsgiref.rst:532
msgid ""
"The :meth:`~io.BufferedIOBase.write` method of *stdout* should write each "
"chunk in full, like :class:`io.BufferedIOBase`."
msgstr ""
"*stdout* 的 :meth:`~io.BufferedIOBase.write` 方法應該完整地寫入每個塊"
"（chunk），像是 :class:`io.BufferedIOBase`。"

#: ../../library/wsgiref.rst:538
msgid ""
"This is an abstract base class for running WSGI applications.  Each instance "
"will handle a single HTTP request, although in principle you could create a "
"subclass that was reusable for multiple requests."
msgstr ""
"這是一個運行 WSGI 應用程式的抽象基底類別。每個實例將處理單個 HTTP 請求，儘管"
"原則上你可以建立一個可重用於多個請求的子類別。"

#: ../../library/wsgiref.rst:542
msgid ""
":class:`BaseHandler` instances have only one method intended for external "
"use:"
msgstr ":class:`BaseHandler` 實例只有一個供外部使用的方法："

#: ../../library/wsgiref.rst:547
msgid "Run the specified WSGI application, *app*."
msgstr "運行指定 WSGI 應用程式，*app*。"

#: ../../library/wsgiref.rst:549
msgid ""
"All of the other :class:`BaseHandler` methods are invoked by this method in "
"the process of running the application, and thus exist primarily to allow "
"customizing the process."
msgstr ""
"此方法在運行應用程式的過程中呼叫了所有其他 :class:`BaseHandler` 的方法，因此"
"這些方法主要存在是為了允許自定義整個過程。"

#: ../../library/wsgiref.rst:553
msgid "The following methods MUST be overridden in a subclass:"
msgstr "以下方法必須在子類別中覆寫："

#: ../../library/wsgiref.rst:558
msgid ""
"Buffer the bytes *data* for transmission to the client.  It's okay if this "
"method actually transmits the data; :class:`BaseHandler` just separates "
"write and flush operations for greater efficiency when the underlying system "
"actually has such a distinction."
msgstr ""
"緩衝要傳送給用戶端的位元組 *data*。如果這個方法實際上傳送了數據也是可以的；當"
"底層系統實際具有這種區分時，:class:`BaseHandler` 為了更好的效能進而分離寫入和"
"刷新操作。"

#: ../../library/wsgiref.rst:566
msgid ""
"Force buffered data to be transmitted to the client.  It's okay if this "
"method is a no-op (i.e., if :meth:`_write` actually sends the data)."
msgstr ""
"強制將緩衝數據傳送到用戶端。如果這是一個無操作（no-op）的方法（即，如果 :"
"meth:`_write` 實際上發送了數據），那麼是可以的。"

#: ../../library/wsgiref.rst:572
msgid ""
"Return an object compatible with :class:`~wsgiref.types.InputStream` "
"suitable for use as the ``wsgi.input`` of the request currently being "
"processed."
msgstr ""
"回傳一個與 :class:`~wsgiref.types.InputStream` 相容的物件並適用於用作當前正在"
"處理請求的 ``wsgi.input``。"

#: ../../library/wsgiref.rst:579
msgid ""
"Return an object compatible with :class:`~wsgiref.types.ErrorStream` "
"suitable for use as the ``wsgi.errors`` of the request currently being "
"processed."
msgstr ""
"回傳一個與 :class:`~wsgiref.types.ErrorStream` 相容的物件並適用於用作當前正在"
"處理請求的 ``wsgi.errors``。"

#: ../../library/wsgiref.rst:586
msgid ""
"Insert CGI variables for the current request into the :attr:`environ` "
"attribute."
msgstr "將當前請求的 CGI 變數插入到 :attr:`environ` 屬性中。"

#: ../../library/wsgiref.rst:588
msgid ""
"Here are some other methods and attributes you may wish to override. This "
"list is only a summary, however, and does not include every method that can "
"be overridden.  You should consult the docstrings and source code for "
"additional information before attempting to create a customized :class:"
"`BaseHandler` subclass."
msgstr ""
"以下是你可能希望覆寫的其他方法和屬性。這個列表只是一個摘要，然而，不包括可以"
"被覆寫的每個方法。在嘗試建立自定義的 :class:`BaseHandler` 子類別之前，你應該"
"參考文件說明和原始碼以獲得更多資訊。"

#: ../../library/wsgiref.rst:594
msgid "Attributes and methods for customizing the WSGI environment:"
msgstr "用於自定義 WSGI 環境的屬性和方法："

#: ../../library/wsgiref.rst:599
msgid ""
"The value to be used for the ``wsgi.multithread`` environment variable.  It "
"defaults to true in :class:`BaseHandler`, but may have a different default "
"(or be set by the constructor) in the other subclasses."
msgstr ""
"用於 ``wsgi.multithread`` 環境變數的值。在 :class:`BaseHandler` 中預設為 "
"true，但在其他子類別中可能有不同的預設值（或由建構函式設置）。"

#: ../../library/wsgiref.rst:606
msgid ""
"The value to be used for the ``wsgi.multiprocess`` environment variable.  It "
"defaults to true in :class:`BaseHandler`, but may have a different default "
"(or be set by the constructor) in the other subclasses."
msgstr ""
"用於 ``wsgi.multiprocess`` 環境變數的值。在 :class:`BaseHandler` 中預設為 "
"true，但在其他子類別中可能有不同的預設值（或由建構函式設置）。"

#: ../../library/wsgiref.rst:613
msgid ""
"The value to be used for the ``wsgi.run_once`` environment variable.  It "
"defaults to false in :class:`BaseHandler`, but :class:`CGIHandler` sets it "
"to true by default."
msgstr ""
"用於 ``wsgi.run_once`` 環境變數的值。在 :class:`BaseHandler` 中預設為 false，"
"但 :class:`CGIHandler` 預設將其設置為 true。"

#: ../../library/wsgiref.rst:620
msgid ""
"The default environment variables to be included in every request's WSGI "
"environment.  By default, this is a copy of ``os.environ`` at the time that :"
"mod:`wsgiref.handlers` was imported, but subclasses can either create their "
"own at the class or instance level.  Note that the dictionary should be "
"considered read-only, since the default value is shared between multiple "
"classes and instances."
msgstr ""
"預設環境變數包含在每一個請求的 WSGI 環境中。預設情況下，這是在載入 :mod:"
"`wsgiref.handlers` 時的 ``os.environ`` 副本，但子類別可以在類別或實例層級建立"
"自己的副本。注意字典應該被視為唯讀，因為預設值在多個類別與實例中共享。"

#: ../../library/wsgiref.rst:630
msgid ""
"If the :attr:`origin_server` attribute is set, this attribute's value is "
"used to set the default ``SERVER_SOFTWARE`` WSGI environment variable, and "
"also to set a default ``Server:`` header in HTTP responses.  It is ignored "
"for handlers (such as :class:`BaseCGIHandler` and :class:`CGIHandler`) that "
"are not HTTP origin servers."
msgstr ""
"如果設置 :attr:`origin_server` 屬性，則此屬性的值將用於設置預設的 "
"``SERVER_SOFTWARE`` WSGI 環境變數，並且還將用於設置 HTTP 回應中的預設 "
"``Server:`` 標頭。對於不是 HTTP origin 伺服器的處置程式（例如 :class:"
"`BaseCGIHandler` 和 :class:`CGIHandler`），此屬性將被忽略。"

#: ../../library/wsgiref.rst:636
msgid ""
"The term \"Python\" is replaced with implementation specific term like "
"\"CPython\", \"Jython\" etc."
msgstr ""
"將術語 \"Python\" 替換為特定實作的術語，如 \"CPython\"、\"Jython\" 等。"

#: ../../library/wsgiref.rst:642
msgid ""
"Return the URL scheme being used for the current request.  The default "
"implementation uses the :func:`guess_scheme` function from :mod:`wsgiref."
"util` to guess whether the scheme should be \"http\" or \"https\", based on "
"the current request's :attr:`environ` variables."
msgstr ""
"回傳用於當前請求的 URL scheme。預設的實作使用 :mod:`wsgiref.util` 中的 :func:"
"`guess_scheme` 函式去猜測 scheme 是 \"http\" 或是 \"https\"，基於目前請求的 :"
"attr:`environ` 變數。"

#: ../../library/wsgiref.rst:650
msgid ""
"Set the :attr:`environ` attribute to a fully populated WSGI environment.  "
"The default implementation uses all of the above methods and attributes, "
"plus the :meth:`get_stdin`, :meth:`get_stderr`, and :meth:`add_cgi_vars` "
"methods and the :attr:`wsgi_file_wrapper` attribute.  It also inserts a "
"``SERVER_SOFTWARE`` key if not present, as long as the :attr:`origin_server` "
"attribute is a true value and the :attr:`server_software` attribute is set."
msgstr ""
"將 :attr:`environ` 屬性設置為完全填充的 WSGI 環境。預設的實作使用上述所有方法"
"和屬性，以及 :meth:`get_stdin`、:meth:`get_stderr` 和 :meth:`add_cgi_vars` 方"
"法以及 :attr:`wsgi_file_wrapper` 屬性。如果不呈現它也會插入一個 "
"``SERVER_SOFTWARE`` 關鍵字，只要 :attr:`origin_server` 屬性是一個 true 值並"
"且 :attr:`server_software` 屬性被設置。"

#: ../../library/wsgiref.rst:657
msgid "Methods and attributes for customizing exception handling:"
msgstr "用於自定義例外處理的屬性和方法："

#: ../../library/wsgiref.rst:662
msgid ""
"Log the *exc_info* tuple in the server log.  *exc_info* is a ``(type, value, "
"traceback)`` tuple.  The default implementation simply writes the traceback "
"to the request's ``wsgi.errors`` stream and flushes it.  Subclasses can "
"override this method to change the format or retarget the output, mail the "
"traceback to an administrator, or whatever other action may be deemed "
"suitable."
msgstr ""
"將 *exc_info* 元組記錄到伺服器日誌中。*exc_info* 是一個 ``(type, value, "
"traceback)`` 元組。預設實作只是將追蹤資訊寫入到請求的 ``wsgi.errors`` 串流中"
"並刷新它。子類別可以覆蓋此方法以更改格式或重新定向輸出，將追蹤資訊發送給管理"
"員，或執行其他被認為合適的操作。"

#: ../../library/wsgiref.rst:671
msgid ""
"The maximum number of frames to include in tracebacks output by the default :"
"meth:`log_exception` method.  If ``None``, all frames are included."
msgstr ""
"預設的 :meth:`log_exception` 方法追蹤輸出中包含的最大幀數 。如果為 ``None``，"
"則包含所有幀。"

#: ../../library/wsgiref.rst:677
msgid ""
"This method is a WSGI application to generate an error page for the user.  "
"It is only invoked if an error occurs before headers are sent to the client."
msgstr ""
"這個方法是一個為使用者去產生錯誤頁面的 WSGI 應用程式。只有在標頭傳送給用戶端"
"前如果發生錯誤才會被呼叫。"

#: ../../library/wsgiref.rst:680
msgid ""
"This method can access the current error using ``sys.exception()``, and "
"should pass that information to *start_response* when calling it (as "
"described in the \"Error Handling\" section of :pep:`3333`)."
msgstr ""
"此方法使用 ``sys.exception()`` 存取當前的錯誤，當呼叫它（如 :pep:`3333` 的 "
"\"Error Handling\" 部分所描述）時應該傳遞資訊給 *start_response*。"

#: ../../library/wsgiref.rst:684
msgid ""
"The default implementation just uses the :attr:`error_status`, :attr:"
"`error_headers`, and :attr:`error_body` attributes to generate an output "
"page.  Subclasses can override this to produce more dynamic error output."
msgstr ""
"預設的實作只是使用 :attr:`error_status`、:attr:`error_headers` 和 :attr:"
"`error_body` 屬性產生輸出頁面。子類別可以覆蓋此方法以生成更動態的錯誤輸出。"

#: ../../library/wsgiref.rst:688
msgid ""
"Note, however, that it's not recommended from a security perspective to spit "
"out diagnostics to any old user; ideally, you should have to do something "
"special to enable diagnostic output, which is why the default implementation "
"doesn't include any."
msgstr ""
"然而，從安全的角度並不建議向任何普通使用者顯示診斷資訊；理想情況下，你應該需"
"要採取特殊措施才能啟用診斷輸出，這就是預設實作不包括任何診斷資訊的原因。"

#: ../../library/wsgiref.rst:696
msgid ""
"The HTTP status used for error responses.  This should be a status string as "
"defined in :pep:`3333`; it defaults to a 500 code and message."
msgstr ""
"用於錯誤回應的 HTTP 狀態。這應該是一個按照 :pep:`3333` 定義的狀態字串；預設"
"為 500 狀態碼和訊息。"

#: ../../library/wsgiref.rst:702
msgid ""
"The HTTP headers used for error responses.  This should be a list of WSGI "
"response headers (``(name, value)`` tuples), as described in :pep:`3333`.  "
"The default list just sets the content type to ``text/plain``."
msgstr ""
"用於錯誤回應的 HTTP 標頭。這應該是一個 WSGI 回應標頭的串列（``(name, "
"value)`` 元組），如 :pep:`3333` 中所描述。預設串列只設置內容種類為 ``text/"
"plain``。"

#: ../../library/wsgiref.rst:709
msgid ""
"The error response body.  This should be an HTTP response body bytestring. "
"It defaults to the plain text, \"A server error occurred.  Please contact "
"the administrator.\""
msgstr ""
"錯誤回應的主體。這應該是一個 HTTP 回應內容的位元組字串。預設為純文字 \"A "
"server error occurred. Please contact the administrator.\""

#: ../../library/wsgiref.rst:713
msgid ""
"Methods and attributes for :pep:`3333`'s \"Optional Platform-Specific File "
"Handling\" feature:"
msgstr ""
"用於 :pep:`3333` 中的 \"Optional Platform-Specific File Handling\" 功能的方法"
"和屬性："

#: ../../library/wsgiref.rst:719
msgid ""
"A ``wsgi.file_wrapper`` factory, compatible with :class:`wsgiref.types."
"FileWrapper`, or ``None``.  The default value of this attribute is the :"
"class:`wsgiref.util.FileWrapper` class."
msgstr ""
"一個 ``wsgi.file_wrapper`` 工廠函式（factory），與 :class:`wsgiref.types."
"FileWrapper` 相容，或者為 ``None``。這個屬性的預設值是 :class:`wsgiref.util."
"FileWrapper` 類別。"

#: ../../library/wsgiref.rst:726
msgid ""
"Override to implement platform-specific file transmission.  This method is "
"called only if the application's return value is an instance of the class "
"specified by the :attr:`wsgi_file_wrapper` attribute.  It should return a "
"true value if it was able to successfully transmit the file, so that the "
"default transmission code will not be executed. The default implementation "
"of this method just returns a false value."
msgstr ""
"覆蓋以實作特定平台的檔案傳輸。只有當應用程式的回傳值是由 :attr:"
"`wsgi_file_wrapper` 屬性指定的類別實例時才會呼叫此方法。如果它能夠成功傳輸檔"
"案應該回傳一個 true 值，以便不執行預設的傳輸程式碼。該方法的預設實作只回傳一"
"個 false 值。"

#: ../../library/wsgiref.rst:733
msgid "Miscellaneous methods and attributes:"
msgstr "其他方法和屬性："

#: ../../library/wsgiref.rst:738
msgid ""
"This attribute should be set to a true value if the handler's :meth:`_write` "
"and :meth:`_flush` are being used to communicate directly to the client, "
"rather than via a CGI-like gateway protocol that wants the HTTP status in a "
"special ``Status:`` header."
msgstr ""
"這個屬性應該被設置為 true 值，如果處理程式（handler）的 :meth:`_write` 和 :"
"meth:`_flush` 被用於直接與用戶端通訊，而不是透過 CGI-like 的閘道協議希望 "
"HTTP 狀態在特殊的 ``Status:`` 標頭中。"

#: ../../library/wsgiref.rst:743
msgid ""
"This attribute's default value is true in :class:`BaseHandler`, but false "
"in :class:`BaseCGIHandler` and :class:`CGIHandler`."
msgstr ""
"這個屬性在 :class:`BaseCGIHandler` 預設值為 true，但是在 :class:"
"`BaseCGIHandler` 和 :class:`CGIHandler` 為 false。"

#: ../../library/wsgiref.rst:749
msgid ""
"If :attr:`origin_server` is true, this string attribute is used to set the "
"HTTP version of the response set to the client.  It defaults to ``\"1.0\"``."
msgstr ""
"如果 :attr:`origin_server` 為 true，則此字串屬性用於設定傳送給用戶端的回應的 "
"HTTP 版本。預設為 ``\"1.0\"``。"

#: ../../library/wsgiref.rst:755
msgid ""
"Transcode CGI variables from ``os.environ`` to :pep:`3333` \"bytes in "
"unicode\" strings, returning a new dictionary.  This function is used by :"
"class:`CGIHandler` and :class:`IISCGIHandler` in place of directly using "
"``os.environ``, which is not necessarily WSGI-compliant on all platforms and "
"web servers using Python 3 -- specifically, ones where the OS's actual "
"environment is Unicode (i.e. Windows), or ones where the environment is "
"bytes, but the system encoding used by Python to decode it is anything other "
"than ISO-8859-1 (e.g. Unix systems using UTF-8)."
msgstr ""
"從 ``os.environ`` 轉碼 CGI 變數到 :pep:`3333` 中的 \"bytes in unicode\" 字"
"串，並回傳一個新字典。這個函式被 :class:`CGIHandler` 和 :class:"
"`IISCGIHandler` 使用來直接替代 ``os.environ``，在所有平台和使用 Python 3 的網"
"頁伺服器上不一定符合 WSGI 標準，具體來說，在 OS 的實際環境是 Unicode（例如 "
"Windows）的情況下，或者在環境是位元組的情況下，但 Python 用於解碼它的系統編碼"
"不是 ISO-8859-1 （例如使用 UTF-8 的 Unix 系統）。"

#: ../../library/wsgiref.rst:764
msgid ""
"If you are implementing a CGI-based handler of your own, you probably want "
"to use this routine instead of just copying values out of ``os.environ`` "
"directly."
msgstr ""
"如果你自己正在實作 CGI-based 處理程式（handler），你可能想要使用這個函式來替"
"換單純直接從 ``os.environ`` 中複製值。"

#: ../../library/wsgiref.rst:772
msgid ":mod:`wsgiref.types` -- WSGI types for static type checking"
msgstr ":mod:`wsgiref.types` -- 用於靜態型別檢查的 WSGI 型別"

#: ../../library/wsgiref.rst:778
msgid ""
"This module provides various types for static type checking as described in :"
"pep:`3333`."
msgstr "這個模組提供在 :pep:`3333` 中所描述的各種用於靜態型別檢查的型別。"

#: ../../library/wsgiref.rst:786
msgid ""
"A :class:`typing.Protocol` describing :pep:`start_response() <3333#the-start-"
"response-callable>` callables (:pep:`3333`)."
msgstr ""
"一個描述 :pep:`start_response() <3333#the-start-response-callable>` 可呼叫物"
"件的 :class:`typing.Protocol` (:pep:`3333`)。"

#: ../../library/wsgiref.rst:792
msgid "A type alias describing a WSGI environment dictionary."
msgstr "一個描述 WSGI 環境字典的型別別名。"

#: ../../library/wsgiref.rst:796
msgid "A type alias describing a WSGI application callable."
msgstr "一個描述 WSGI 應用程式可呼叫物件的型別別名。"

#: ../../library/wsgiref.rst:800
msgid ""
"A :class:`typing.Protocol` describing a :pep:`WSGI Input Stream <3333#input-"
"and-error-streams>`."
msgstr ""
"一個描述 :pep:`WSGI 輸入串流 <3333#input-and-error-streams>`\\ 的 :class:"
"`typing.Protocol`。"

#: ../../library/wsgiref.rst:805
msgid ""
"A :class:`typing.Protocol` describing a :pep:`WSGI Error Stream <3333#input-"
"and-error-streams>`."
msgstr ""
"一個描述 :pep:`WSGI 錯誤串流 <3333#input-and-error-streams>`\\ 的 :class:"
"`typing.Protocol`。"

#: ../../library/wsgiref.rst:810
msgid ""
"A :class:`typing.Protocol` describing a :pep:`file wrapper <3333#optional-"
"platform-specific-file-handling>`. See :class:`wsgiref.util.FileWrapper` for "
"a concrete implementation of this protocol."
msgstr ""
"一個描述\\ :pep:`檔案包裝器 <3333#optional-platform-specific-file-"
"handling>`\\ 的 :class:`typing.Protocol`。請參閱 :class:`wsgiref.util."
"FileWrapper` 來瞭解此協議的具體實作。"

#: ../../library/wsgiref.rst:817
msgid "Examples"
msgstr "範例"

#: ../../library/wsgiref.rst:819
msgid "This is a working \"Hello World\" WSGI application::"
msgstr "這個一個運作中的 \"Hello World\" WSGI 應用程式： ::"

#: ../../library/wsgiref.rst:821
msgid ""
"\"\"\"\n"
"Every WSGI application must have an application object - a callable\n"
"object that accepts two arguments. For that purpose, we're going to\n"
"use a function (note that you're not limited to a function, you can\n"
"use a class for example). The first argument passed to the function\n"
"is a dictionary containing CGI-style environment variables and the\n"
"second variable is the callable object.\n"
"\"\"\"\n"
"from wsgiref.simple_server import make_server\n"
"\n"
"\n"
"def hello_world_app(environ, start_response):\n"
"    status = \"200 OK\"  # HTTP Status\n"
"    headers = [(\"Content-type\", \"text/plain; charset=utf-8\")]  # HTTP "
"Headers\n"
"    start_response(status, headers)\n"
"\n"
"    # The returned object is going to be printed\n"
"    return [b\"Hello World\"]\n"
"\n"
"with make_server(\"\", 8000, hello_world_app) as httpd:\n"
"    print(\"Serving on port 8000...\")\n"
"\n"
"    # Serve until process is killed\n"
"    httpd.serve_forever()"
msgstr ""

#: ../../library/wsgiref.rst:848
msgid ""
"Example of a WSGI application serving the current directory, accept optional "
"directory and port number (default: 8000) on the command line::"
msgstr ""
"提供當前目錄的 WSGI 應用程式範例，並接受命令列上的可選目錄和埠號（預設："
"8000）： ::"

#: ../../library/wsgiref.rst:851
msgid ""
"\"\"\"\n"
"Small wsgiref based web server. Takes a path to serve from and an\n"
"optional port number (defaults to 8000), then tries to serve files.\n"
"MIME types are guessed from the file names, 404 errors are raised\n"
"if the file is not found.\n"
"\"\"\"\n"
"import mimetypes\n"
"import os\n"
"import sys\n"
"from wsgiref import simple_server, util\n"
"\n"
"\n"
"def app(environ, respond):\n"
"    # Get the file name and MIME type\n"
"    fn = os.path.join(path, environ[\"PATH_INFO\"][1:])\n"
"    if \".\" not in fn.split(os.path.sep)[-1]:\n"
"        fn = os.path.join(fn, \"index.html\")\n"
"    mime_type = mimetypes.guess_type(fn)[0]\n"
"\n"
"    # Return 200 OK if file exists, otherwise 404 Not Found\n"
"    if os.path.exists(fn):\n"
"        respond(\"200 OK\", [(\"Content-Type\", mime_type)])\n"
"        return util.FileWrapper(open(fn, \"rb\"))\n"
"    else:\n"
"        respond(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n"
"        return [b\"not found\"]\n"
"\n"
"\n"
"if __name__ == \"__main__\":\n"
"    # Get the path and port from command-line arguments\n"
"    path = sys.argv[1] if len(sys.argv) > 1 else os.getcwd()\n"
"    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8000\n"
"\n"
"    # Make and start the server until control-c\n"
"    httpd = simple_server.make_server(\"\", port, app)\n"
"    print(f\"Serving {path} on port {port}, control-C to stop\")\n"
"    try:\n"
"        httpd.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"Shutting down.\")\n"
"        httpd.server_close()"
msgstr ""
