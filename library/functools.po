# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Matt Wang <mattwang44@gmail.com>, 2024
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-18 00:04+0000\n"
"PO-Revision-Date: 2024-05-11 16:02+0800\n"
"Last-Translator: Matt Wang <mattwang44@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/functools.rst:2
msgid ""
":mod:`!functools` --- Higher-order functions and operations on callable "
"objects"
msgstr ":mod:`functools` --- 可呼叫物件上的高階函式與操作"

#: ../../library/functools.rst:14
msgid "**Source code:** :source:`Lib/functools.py`"
msgstr "**原始碼：**\\ :source:`Lib/functools.py`"

#: ../../library/functools.rst:23
msgid ""
"The :mod:`functools` module is for higher-order functions: functions that "
"act on or return other functions. In general, any callable object can be "
"treated as a function for the purposes of this module."
msgstr ""
":mod:`functools` 模組用於高階函式：作用於或回傳其他函式的函式。一般來說，任何"
"可呼叫物件都可以被視為用於此模組的函式。"

#: ../../library/functools.rst:27
msgid "The :mod:`functools` module defines the following functions:"
msgstr ":mod:`functools` 模組定義了以下函式："

#: ../../library/functools.rst:31
msgid ""
"Simple lightweight unbounded function cache.  Sometimes called `\"memoize\" "
"<https://en.wikipedia.org/wiki/Memoization>`_."
msgstr ""
"簡單的輕量級無繫結函式快取 (Simple lightweight unbounded function cache)。有"
"時稱之為 `\"memoize\"（記憶化） <https://en.wikipedia.org/wiki/"
"Memoization>`_。"

#: ../../library/functools.rst:34
msgid ""
"Returns the same as ``lru_cache(maxsize=None)``, creating a thin wrapper "
"around a dictionary lookup for the function arguments.  Because it never "
"needs to evict old values, this is smaller and faster than :func:`lru_cache` "
"with a size limit."
msgstr ""
"和 ``lru_cache(maxsize=None)`` 回傳相同的值，為函式引數建立一個字典查找的薄包"
"裝器。因為它永遠不需要丟棄舊值，所以這比有大小限制的 :func:`lru_cache` 更小、"
"更快。"

#: ../../library/functools.rst:39 ../../library/functools.rst:291
msgid "For example::"
msgstr "舉例來說： ::"

#: ../../library/functools.rst:41
msgid ""
"@cache\n"
"def factorial(n):\n"
"    return n * factorial(n-1) if n else 1\n"
"\n"
">>> factorial(10)      # no previously cached result, makes 11 recursive "
"calls\n"
"3628800\n"
">>> factorial(5)       # just looks up cached value result\n"
"120\n"
">>> factorial(12)      # makes two new recursive calls, the other 10 are "
"cached\n"
"479001600"
msgstr ""

#: ../../library/functools.rst:52 ../../library/functools.rst:158
msgid ""
"The cache is threadsafe so that the wrapped function can be used in multiple "
"threads.  This means that the underlying data structure will remain coherent "
"during concurrent updates."
msgstr ""
"該快取是執行緒安全的 (threadsafe)，因此包裝的函式可以在多個執行緒中使用。這意"
"味著底層資料結構在並行更新期間將保持連貫 (coherent)。"

#: ../../library/functools.rst:56 ../../library/functools.rst:162
msgid ""
"It is possible for the wrapped function to be called more than once if "
"another thread makes an additional call before the initial call has been "
"completed and cached."
msgstr ""
"如果另一個執行緒在初始呼叫完成並快取之前進行額外的呼叫，則包裝的函式可能會被"
"多次呼叫。"

#: ../../library/functools.rst:65
msgid ""
"Transform a method of a class into a property whose value is computed once "
"and then cached as a normal attribute for the life of the instance. Similar "
"to :func:`property`, with the addition of caching. Useful for expensive "
"computed properties of instances that are otherwise effectively immutable."
msgstr ""
"將類別的一個方法轉換為屬性 (property)，其值會計算一次，然後在實例的生命週期內"
"快取為普通屬性。類似 :func:`property`，但增加了快取機制。對於除使用該裝飾器的"
"屬性外實質上幾乎是不可變 (immutable) 的實例，針對其所需要繁重計算會很有用。"

#: ../../library/functools.rst:70 ../../library/functools.rst:142
#: ../../library/functools.rst:383
msgid "Example::"
msgstr "範例： ::"

#: ../../library/functools.rst:72
msgid ""
"class DataSet:\n"
"\n"
"    def __init__(self, sequence_of_numbers):\n"
"        self._data = tuple(sequence_of_numbers)\n"
"\n"
"    @cached_property\n"
"    def stdev(self):\n"
"        return statistics.stdev(self._data)"
msgstr ""
"class DataSet:\n"
"\n"
"    def __init__(self, sequence_of_numbers):\n"
"        self._data = tuple(sequence_of_numbers)\n"
"\n"
"    @cached_property\n"
"    def stdev(self):\n"
"        return statistics.stdev(self._data)"

#: ../../library/functools.rst:81
msgid ""
"The mechanics of :func:`cached_property` are somewhat different from :func:"
"`property`.  A regular property blocks attribute writes unless a setter is "
"defined. In contrast, a *cached_property* allows writes."
msgstr ""
":func:`cached_property` 的機制與 :func:`property` 有所不同。除非定義了 "
"setter，否則常規屬性會阻止屬性的寫入。相反地，*cached_property* 則允許寫入。"

#: ../../library/functools.rst:85
msgid ""
"The *cached_property* decorator only runs on lookups and only when an "
"attribute of the same name doesn't exist.  When it does run, the "
"*cached_property* writes to the attribute with the same name. Subsequent "
"attribute reads and writes take precedence over the *cached_property* method "
"and it works like a normal attribute."
msgstr ""
"*cached_property* 裝飾器僅在查找時且僅在同名屬性不存在時運行。當它運行時，"
"*cached_property* 會寫入同名的屬性。後續屬性讀取和寫入優先於 "
"*cached_property* 方法，並且它的工作方式與普通屬性類似。"

#: ../../library/functools.rst:91
msgid ""
"The cached value can be cleared by deleting the attribute.  This allows the "
"*cached_property* method to run again."
msgstr ""
"可以透過刪除屬性來清除快取的值，這使得 *cached_property* 方法可以再次運行。"

#: ../../library/functools.rst:94
msgid ""
"The *cached_property* does not prevent a possible race condition in multi-"
"threaded usage. The getter function could run more than once on the same "
"instance, with the latest run setting the cached value. If the cached "
"property is idempotent or otherwise not harmful to run more than once on an "
"instance, this is fine. If synchronization is needed, implement the "
"necessary locking inside the decorated getter function or around the cached "
"property access."
msgstr ""
"*cached_property* 無法防止多執行緒使用中可能出現的競爭條件 (race condition)。"
"getter 函式可以在同一個實例上運行多次，最後一次運行會設定快取的值。所以快取的"
"屬性最好是冪等的 (idempotent)，或者在一個實例上運行多次不會有害，就不會有問"
"題。如果同步是必要的，請在裝飾的 getter 函式內部或在快取的屬性存取周圍實作必"
"要的鎖。"

#: ../../library/functools.rst:102
msgid ""
"Note, this decorator interferes with the operation of :pep:`412` key-sharing "
"dictionaries.  This means that instance dictionaries can take more space "
"than usual."
msgstr ""
"請注意，此裝飾器會干擾 :pep:`412` 金鑰共用字典的操作。這意味著實例字典可能比"
"平常佔用更多的空間。"

#: ../../library/functools.rst:106
msgid ""
"Also, this decorator requires that the ``__dict__`` attribute on each "
"instance be a mutable mapping. This means it will not work with some types, "
"such as metaclasses (since the ``__dict__`` attributes on type instances are "
"read-only proxies for the class namespace), and those that specify "
"``__slots__`` without including ``__dict__`` as one of the defined slots (as "
"such classes don't provide a ``__dict__`` attribute at all)."
msgstr ""
"此外，此裝飾器要求每個實例上的 ``__dict__`` 屬性是可變對映 (mutable "
"mapping)。這意味著它不適用於某些型別，例如元類別 (metaclass)（因為型別實例上"
"的 ``__dict__`` 屬性是類別命名空間的唯讀代理），以及那些指定 ``__slots__`` 而"
"不包含 ``__dict__`` 的型別作為有定義的插槽之一（因為此種類別根本不提供 "
"``__dict__`` 屬性）。"

#: ../../library/functools.rst:113
msgid ""
"If a mutable mapping is not available or if space-efficient key sharing is "
"desired, an effect similar to :func:`cached_property` can also be achieved "
"by stacking :func:`property` on top of :func:`lru_cache`. See :ref:`faq-"
"cache-method-calls` for more details on how this differs from :func:"
"`cached_property`."
msgstr ""
"如果可變對映不可用或需要金鑰共享以節省空間，則也可以透過在 :func:`lru_cache` "
"之上堆疊 :func:`property` 來實作類似於 :func:`cached_property` 的效果。請參閱"
"\\ :ref:`faq-cache-method-calls`\\ 以了解有關這與 :func:`cached_property` 間"
"不同之處的更多詳細資訊。"

#: ../../library/functools.rst:120
msgid ""
"Prior to Python 3.12, ``cached_property`` included an undocumented lock to "
"ensure that in multi-threaded usage the getter function was guaranteed to "
"run only once per instance. However, the lock was per-property, not per-"
"instance, which could result in unacceptably high lock contention. In Python "
"3.12+ this locking is removed."
msgstr ""
"在 Python 3.12 之前，``cached_property`` 包含一個未以文件記錄的鎖，以確保在多"
"執行緒使用中能保證 getter 函式對於每個實例只會執行一次。然而，鎖是針對每個屬"
"性，而不是針對每個實例，這可能會導致無法被接受的嚴重鎖爭用 (lock "
"contention)。在 Python 3.12+ 中，此鎖已被刪除。"

#: ../../library/functools.rst:130
msgid ""
"Transform an old-style comparison function to a :term:`key function`.  Used "
"with tools that accept key functions (such as :func:`sorted`, :func:`min`, :"
"func:`max`, :func:`heapq.nlargest`, :func:`heapq.nsmallest`, :func:"
"`itertools.groupby`).  This function is primarily used as a transition tool "
"for programs being converted from Python 2 which supported the use of "
"comparison functions."
msgstr ""
"將舊式比較函式轉換為\\ :term:`鍵函式 <key function>`，能與接受鍵函式的工具一"
"起使用（例如 :func:`sorted`、:func:`min`、:func:`max`、:func:`heapq."
"nlargest`、:func:`heapq.nsmallest`、:func:`itertools.groupby`）。此函式主要作"
"為轉換工具，用於從有支援使用比較函式的 Python 2 轉換成的程式。"

#: ../../library/functools.rst:137
msgid ""
"A comparison function is any callable that accepts two arguments, compares "
"them, and returns a negative number for less-than, zero for equality, or a "
"positive number for greater-than.  A key function is a callable that accepts "
"one argument and returns another value to be used as the sort key."
msgstr ""
"比較函式是任何能接受兩個引數、對它們進行比較，並回傳負數（小於）、零（相等）"
"或正數（大於）的可呼叫物件。鍵函式是接受一個引數並回傳另一個用作排序鍵之值的"
"可呼叫物件。"

#: ../../library/functools.rst:144
msgid ""
"sorted(iterable, key=cmp_to_key(locale.strcoll))  # locale-aware sort order"
msgstr ""

#: ../../library/functools.rst:146
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr "有關排序範例和簡短的排序教學，請參閱\\ :ref:`sortinghowto`。"

#: ../../library/functools.rst:154
msgid ""
"Decorator to wrap a function with a memoizing callable that saves up to the "
"*maxsize* most recent calls.  It can save time when an expensive or I/O "
"bound function is periodically called with the same arguments."
msgstr ""
"以記憶化可呼叫物件來包裝函式的裝飾器，最多可省去 *maxsize* 個最近的呼叫。當使"
"用相同引數定期呼叫繁重的或 I/O 密集的函式時，它可以節省時間。"

#: ../../library/functools.rst:166
msgid ""
"Since a dictionary is used to cache results, the positional and keyword "
"arguments to the function must be :term:`hashable`."
msgstr ""
"由於字典用於快取結果，因此函式的位置引數和關鍵字引數必須是\\ :term:`可雜湊的 "
"<hashable>`。"

#: ../../library/functools.rst:169
msgid ""
"Distinct argument patterns may be considered to be distinct calls with "
"separate cache entries.  For example, ``f(a=1, b=2)`` and ``f(b=2, a=1)`` "
"differ in their keyword argument order and may have two separate cache "
"entries."
msgstr ""
"不同的引數模式可以被認為是具有不同快取條目的不同呼叫。例如，``f(a=1, b=2)`` "
"和 ``f(b=2, a=1)`` 的關鍵字引數順序不同，並且可能有兩個不同的快取條目。"

#: ../../library/functools.rst:174
msgid ""
"If *user_function* is specified, it must be a callable. This allows the "
"*lru_cache* decorator to be applied directly to a user function, leaving the "
"*maxsize* at its default value of 128::"
msgstr ""
"如果指定了 *user_function*，則它必須是個可呼叫物件。這使得 *lru_cache* 裝飾器"
"能夠直接應用於使用者函式，將 *maxsize* 保留為其預設值 128： ::"

#: ../../library/functools.rst:178
msgid ""
"@lru_cache\n"
"def count_vowels(sentence):\n"
"    return sum(sentence.count(vowel) for vowel in 'AEIOUaeiou')"
msgstr ""
"@lru_cache\n"
"def count_vowels(sentence):\n"
"    return sum(sentence.count(vowel) for vowel in 'AEIOUaeiou')"

#: ../../library/functools.rst:182
msgid ""
"If *maxsize* is set to ``None``, the LRU feature is disabled and the cache "
"can grow without bound."
msgstr ""
"如果 *maxsize* 設定為 ``None``，則 LRU 功能將被停用，且快取可以無限制地成長。"

#: ../../library/functools.rst:185
msgid ""
"If *typed* is set to true, function arguments of different types will be "
"cached separately.  If *typed* is false, the implementation will usually "
"regard them as equivalent calls and only cache a single result. (Some types "
"such as *str* and *int* may be cached separately even when *typed* is false.)"
msgstr ""
"如果 *typed* 設定為 true，不同型別的函式引數將會被單獨快取起來。如果 *typed* "
"為 false，則實作通常會將它們視為等效呼叫，並且僅快取單一結果。（某些型別，例"
"如 *str* 和 *int* 可能會被單獨快取起來，即使 *typed* 為 false。）"

#: ../../library/functools.rst:191
msgid ""
"Note, type specificity applies only to the function's immediate arguments "
"rather than their contents.  The scalar arguments, ``Decimal(42)`` and "
"``Fraction(42)`` are be treated as distinct calls with distinct results. In "
"contrast, the tuple arguments ``('answer', Decimal(42))`` and ``('answer', "
"Fraction(42))`` are treated as equivalent."
msgstr ""
"請注意，型別特異性 (type specificity) 僅適用於函式的直接引數而不是其內容。純"
"量 (scalar) 引數 ``Decimal(42)`` 和 ``Fraction(42)`` 被視為具有不同結果的不同"
"呼叫。相反地，元組引數 ``('answer', Decimal(42))`` 和 ``('answer', "
"Fraction(42))`` 被視為等效。"

#: ../../library/functools.rst:197
msgid ""
"The wrapped function is instrumented with a :func:`!cache_parameters` "
"function that returns a new :class:`dict` showing the values for *maxsize* "
"and *typed*.  This is for information purposes only.  Mutating the values "
"has no effect."
msgstr ""
"包裝的函式使用一個 :func:`!cache_parameters` 函式來進行偵測，該函式回傳一個新"
"的 :class:`dict` 以顯示 *maxsize* 和 *typed* 的值。這僅能顯示資訊，改變其值不"
"會有任何效果。"

#: ../../library/functools.rst:202
msgid ""
"To help measure the effectiveness of the cache and tune the *maxsize* "
"parameter, the wrapped function is instrumented with a :func:`cache_info` "
"function that returns a :term:`named tuple` showing *hits*, *misses*, "
"*maxsize* and *currsize*."
msgstr ""
"為了輔助測量快取的有效性並調整 *maxsize* 參數，包裝的函式使用了一個 :func:"
"`cache_info` 函式來做檢測，該函式會回傳一個\\ :term:`附名元組 <named "
"tuple>`\\ 來顯示 *hits*、*misses*、*maxsize* 和 *currsize*。"

#: ../../library/functools.rst:207
msgid ""
"The decorator also provides a :func:`cache_clear` function for clearing or "
"invalidating the cache."
msgstr "裝飾器還提供了一個 :func:`cache_clear` 函式來清除或使快取失效。"

#: ../../library/functools.rst:210
msgid ""
"The original underlying function is accessible through the :attr:"
"`__wrapped__` attribute.  This is useful for introspection, for bypassing "
"the cache, or for rewrapping the function with a different cache."
msgstr ""
"原本的底層函式可以透過 :attr:`__wrapped__` 屬性存取。這對於要自我檢查 "
"(introspection)、繞過快取或使用不同的快取重新包裝函式時非常有用。"

#: ../../library/functools.rst:214
msgid ""
"The cache keeps references to the arguments and return values until they age "
"out of the cache or until the cache is cleared."
msgstr ""
"快取會保留對引數和回傳值的參照，直到快取過時 (age out) 或快取被清除為止。"

#: ../../library/functools.rst:217
msgid ""
"If a method is cached, the ``self`` instance argument is included in the "
"cache.  See :ref:`faq-cache-method-calls`"
msgstr ""
"如果方法被快取起來，則 ``self`` 實例引數將包含在快取中。請參閱\\ :ref:`faq-"
"cache-method-calls`"

#: ../../library/functools.rst:220
msgid ""
"An `LRU (least recently used) cache <https://en.wikipedia.org/wiki/"
"Cache_replacement_policies#Least_Recently_Used_(LRU)>`_ works best when the "
"most recent calls are the best predictors of upcoming calls (for example, "
"the most popular articles on a news server tend to change each day).  The "
"cache's size limit assures that the cache does not grow without bound on "
"long-running processes such as web servers."
msgstr ""
"當最近的呼叫是即將發生之呼叫的最佳預測因子時（例如新聞伺服器上最受歡迎的文章"
"往往每天都會發生變化），`LRU (least recently used) 快取 <https://en."
"wikipedia.org/wiki/Cache_replacement_policies#Least_Recently_Used_(LRU)>`_\\ "
"能發揮最好的效果。快取的大小限制可確保快取不會在長時間運行的行程（例如 Web 伺"
"服器）上無限制地成長。"

#: ../../library/functools.rst:227
msgid ""
"In general, the LRU cache should only be used when you want to reuse "
"previously computed values.  Accordingly, it doesn't make sense to cache "
"functions with side-effects, functions that need to create distinct mutable "
"objects on each call (such as generators and async functions), or impure "
"functions such as time() or random()."
msgstr ""
"一般來說，僅當你想要重複使用先前計算的值時才應使用 LRU 快取。因此，快取具有 "
"side-effects 的函式、需要在每次呼叫時建立不同可變物件的函式（例如產生器和非同"
"步函式）或不純函式（impure function，例如 time() 或 random()）是沒有意義的。"

#: ../../library/functools.rst:233
msgid "Example of an LRU cache for static web content::"
msgstr "靜態網頁內容的 LRU 快取範例： ::"

#: ../../library/functools.rst:235
msgid ""
"@lru_cache(maxsize=32)\n"
"def get_pep(num):\n"
"    'Retrieve text of a Python Enhancement Proposal'\n"
"    resource = f'https://peps.python.org/pep-{num:04d}'\n"
"    try:\n"
"        with urllib.request.urlopen(resource) as s:\n"
"            return s.read()\n"
"    except urllib.error.HTTPError:\n"
"        return 'Not Found'\n"
"\n"
">>> for n in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991:\n"
"...     pep = get_pep(n)\n"
"...     print(n, len(pep))\n"
"\n"
">>> get_pep.cache_info()\n"
"CacheInfo(hits=3, misses=8, maxsize=32, currsize=8)"
msgstr ""

#: ../../library/functools.rst:252
msgid ""
"Example of efficiently computing `Fibonacci numbers <https://en.wikipedia."
"org/wiki/Fibonacci_number>`_ using a cache to implement a `dynamic "
"programming <https://en.wikipedia.org/wiki/Dynamic_programming>`_ technique::"
msgstr ""
"使用快取來實作\\ `動態規劃 (dynamic programming) <https://en.wikipedia.org/"
"wiki/Dynamic_programming>`_ 技法以有效率地計算\\ `費波那契數 (Fibonacci "
"numbers) <https://en.wikipedia.org/wiki/Fibonacci_number>`_ 的範例： ::"

#: ../../library/functools.rst:258
msgid ""
"@lru_cache(maxsize=None)\n"
"def fib(n):\n"
"    if n < 2:\n"
"        return n\n"
"    return fib(n-1) + fib(n-2)\n"
"\n"
">>> [fib(n) for n in range(16)]\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]\n"
"\n"
">>> fib.cache_info()\n"
"CacheInfo(hits=28, misses=16, maxsize=None, currsize=16)"
msgstr ""

#: ../../library/functools.rst:272
msgid "Added the *typed* option."
msgstr "新增 *typed* 選項。"

#: ../../library/functools.rst:275
msgid "Added the *user_function* option."
msgstr "新增 *user_function* 選項。"

#: ../../library/functools.rst:278
msgid "Added the function :func:`!cache_parameters`"
msgstr "新增 :func:`!cache_parameters` 函式。"

#: ../../library/functools.rst:283
msgid ""
"Given a class defining one or more rich comparison ordering methods, this "
"class decorator supplies the rest.  This simplifies the effort involved in "
"specifying all of the possible rich comparison operations:"
msgstr ""
"給定一個定義一個或多個 rich comparison 排序方法的類別，該類別裝飾器會提供其餘"
"部分。這簡化了指定所有可能的 rich comparison 操作所涉及的工作："

#: ../../library/functools.rst:287
msgid ""
"The class must define one of :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, "
"or :meth:`__ge__`. In addition, the class should supply an :meth:`__eq__` "
"method."
msgstr ""
"類別必須定義 :meth:`__lt__`、:meth:`__le__`、:meth:`__gt__` 或 :meth:"
"`__ge__` 其中之一。此外，該類別應該提供 :meth:`__eq__` 方法。"

#: ../../library/functools.rst:293
msgid ""
"@total_ordering\n"
"class Student:\n"
"    def _is_valid_operand(self, other):\n"
"        return (hasattr(other, \"lastname\") and\n"
"                hasattr(other, \"firstname\"))\n"
"    def __eq__(self, other):\n"
"        if not self._is_valid_operand(other):\n"
"            return NotImplemented\n"
"        return ((self.lastname.lower(), self.firstname.lower()) ==\n"
"                (other.lastname.lower(), other.firstname.lower()))\n"
"    def __lt__(self, other):\n"
"        if not self._is_valid_operand(other):\n"
"            return NotImplemented\n"
"        return ((self.lastname.lower(), self.firstname.lower()) <\n"
"                (other.lastname.lower(), other.firstname.lower()))"
msgstr ""
"@total_ordering\n"
"class Student:\n"
"    def _is_valid_operand(self, other):\n"
"        return (hasattr(other, \"lastname\") and\n"
"                hasattr(other, \"firstname\"))\n"
"    def __eq__(self, other):\n"
"        if not self._is_valid_operand(other):\n"
"            return NotImplemented\n"
"        return ((self.lastname.lower(), self.firstname.lower()) ==\n"
"                (other.lastname.lower(), other.firstname.lower()))\n"
"    def __lt__(self, other):\n"
"        if not self._is_valid_operand(other):\n"
"            return NotImplemented\n"
"        return ((self.lastname.lower(), self.firstname.lower()) <\n"
"                (other.lastname.lower(), other.firstname.lower()))"

#: ../../library/functools.rst:311
msgid ""
"While this decorator makes it easy to create well behaved totally ordered "
"types, it *does* come at the cost of slower execution and more complex stack "
"traces for the derived comparison methods. If performance benchmarking "
"indicates this is a bottleneck for a given application, implementing all six "
"rich comparison methods instead is likely to provide an easy speed boost."
msgstr ""
"雖然此裝飾器可以輕鬆建立能好好運作的完全有序型別 (totally ordered types)，但"
"它\\ *的確*\\ 以衍生比較方法的執行速度較慢和堆疊追蹤 (stack trace) 較複雜做為"
"其代價。如果效能基準測試顯示這是給定應用程式的效能瓶頸，那麼實作全部六種 "
"rich comparison 方法通常能輕鬆地提升速度。"

#: ../../library/functools.rst:320
msgid ""
"This decorator makes no attempt to override methods that have been declared "
"in the class *or its superclasses*. Meaning that if a superclass defines a "
"comparison operator, *total_ordering* will not implement it again, even if "
"the original method is abstract."
msgstr ""
"此裝飾器不會嘗試覆寫類別\\ *或其超類別 (superclass)*\\ 中宣告的方法。這意味著"
"如果超類別定義了比較運算子，*total_ordering* 將不會再次實作它，即使原始方法是"
"抽象的。"

#: ../../library/functools.rst:327
msgid ""
"Returning ``NotImplemented`` from the underlying comparison function for "
"unrecognised types is now supported."
msgstr "現在支援從底層對於未識別型別的比較函式回傳 ``NotImplemented``。"

#: ../../library/functools.rst:333
msgid ""
"Return a new :ref:`partial object<partial-objects>` which when called will "
"behave like *func* called with the positional arguments *args* and keyword "
"arguments *keywords*. If more arguments are supplied to the call, they are "
"appended to *args*. If additional keyword arguments are supplied, they "
"extend and override *keywords*. Roughly equivalent to::"
msgstr ""
"回傳一個新的 :ref:`partial 物件 <partial-objects>`，它在被呼叫時的行為類似於"
"使用位置引數 *args* 和關鍵字引數 *keywords* 呼叫的 *func*。如果向呼叫提供更多"
"引數，它們將被附加到 *args*。如果提供了額外的關鍵字引數，它們會擴充並覆寫 "
"*keywords*。大致相當於： ::"

#: ../../library/functools.rst:340
msgid ""
"def partial(func, /, *args, **keywords):\n"
"    def newfunc(*fargs, **fkeywords):\n"
"        newkeywords = {**keywords, **fkeywords}\n"
"        return func(*args, *fargs, **newkeywords)\n"
"    newfunc.func = func\n"
"    newfunc.args = args\n"
"    newfunc.keywords = keywords\n"
"    return newfunc"
msgstr ""
"def partial(func, /, *args, **keywords):\n"
"    def newfunc(*fargs, **fkeywords):\n"
"        newkeywords = {**keywords, **fkeywords}\n"
"        return func(*args, *fargs, **newkeywords)\n"
"    newfunc.func = func\n"
"    newfunc.args = args\n"
"    newfunc.keywords = keywords\n"
"    return newfunc"

#: ../../library/functools.rst:349
msgid ""
"The :func:`partial` is used for partial function application which "
"\"freezes\" some portion of a function's arguments and/or keywords resulting "
"in a new object with a simplified signature.  For example, :func:`partial` "
"can be used to create a callable that behaves like the :func:`int` function "
"where the *base* argument defaults to two:"
msgstr ""
":func:`partial` 用於部分函式應用程序，它「凍結」函式引數和/或關鍵字的某些部"
"分，從而產生具有簡化簽名的新物件。例如，:func:`partial` 可用來建立可呼叫函"
"式，其行為類似於 :func:`int` 函式，其中 *base* 引數預設為 2："

#: ../../library/functools.rst:364
msgid ""
"Return a new :class:`partialmethod` descriptor which behaves like :class:"
"`partial` except that it is designed to be used as a method definition "
"rather than being directly callable."
msgstr ""
"回傳一個新的 :class:`partialmethod` 描述器 (descriptor)，其行為類似於 :class:"
"`partial`，只不過它被設計為用於方法定義而不能直接呼叫。"

#: ../../library/functools.rst:368
msgid ""
"*func* must be a :term:`descriptor` or a callable (objects which are both, "
"like normal functions, are handled as descriptors)."
msgstr ""
"*func* 必須是一個 :term:`descriptor` 或可呼叫物件（兩者兼具的物件，就像普通函"
"式一樣，會被當作描述器處理）。"

#: ../../library/functools.rst:371
msgid ""
"When *func* is a descriptor (such as a normal Python function, :func:"
"`classmethod`, :func:`staticmethod`, :func:`abstractmethod` or another "
"instance of :class:`partialmethod`), calls to ``__get__`` are delegated to "
"the underlying descriptor, and an appropriate :ref:`partial object<partial-"
"objects>` returned as the result."
msgstr ""
"當 *func* 是描述器時（例如普通的 Python 函式、:func:`classmethod`、:func:"
"`staticmethod`、:func:`abstractmethod` 或 :class:`partialmethod` 的另一個實"
"例），對 ``__get__`` 的呼叫將被委託 (delegated) 給底層描述器，且一個適當的 :"
"ref:`partial 物件 <partial-objects>`\\ 會被作為結果回傳。"

#: ../../library/functools.rst:377
msgid ""
"When *func* is a non-descriptor callable, an appropriate bound method is "
"created dynamically. This behaves like a normal Python function when used as "
"a method: the *self* argument will be inserted as the first positional "
"argument, even before the *args* and *keywords* supplied to the :class:"
"`partialmethod` constructor."
msgstr ""
"當 *func* 是非描述器可呼叫物件 (non-descriptor callable) 時，會動態建立適當的"
"繫結方法 (bound method)。當被作為方法使用時，其行為類似於普通的 Python 函式："
"*self* 引數將作為第一個位置引數插入，甚至會在提供給 :class:`partialmethod` 建"
"構函式的 *args* 和 *keywords* 的前面。"

#: ../../library/functools.rst:385
msgid ""
">>> class Cell:\n"
"...     def __init__(self):\n"
"...         self._alive = False\n"
"...     @property\n"
"...     def alive(self):\n"
"...         return self._alive\n"
"...     def set_state(self, state):\n"
"...         self._alive = bool(state)\n"
"...     set_alive = partialmethod(set_state, True)\n"
"...     set_dead = partialmethod(set_state, False)\n"
"...\n"
">>> c = Cell()\n"
">>> c.alive\n"
"False\n"
">>> c.set_alive()\n"
">>> c.alive\n"
"True"
msgstr ""
">>> class Cell:\n"
"...     def __init__(self):\n"
"...         self._alive = False\n"
"...     @property\n"
"...     def alive(self):\n"
"...         return self._alive\n"
"...     def set_state(self, state):\n"
"...         self._alive = bool(state)\n"
"...     set_alive = partialmethod(set_state, True)\n"
"...     set_dead = partialmethod(set_state, False)\n"
"...\n"
">>> c = Cell()\n"
">>> c.alive\n"
"False\n"
">>> c.set_alive()\n"
">>> c.alive\n"
"True"

#: ../../library/functools.rst:408
msgid ""
"Apply *function* of two arguments cumulatively to the items of *iterable*, "
"from left to right, so as to reduce the iterable to a single value.  For "
"example, ``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])`` calculates "
"``((((1+2)+3)+4)+5)``. The left argument, *x*, is the accumulated value and "
"the right argument, *y*, is the update value from the *iterable*.  If the "
"optional *initializer* is present, it is placed before the items of the "
"iterable in the calculation, and serves as a default when the iterable is "
"empty.  If *initializer* is not given and *iterable* contains only one item, "
"the first item is returned."
msgstr ""
"從左到右，將兩個引數的 *function* 累加運用到 *iterable* 的項目上，從而將可疊"
"代物件減少為單一值。例如，``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])`` 會計"
"算出 ``((((1+2)+3)+4)+5)``。左邊的引數 *x* 是累積值，右邊的引數 *y* 是來自 "
"*iterable* 的更新值。如果可選的 *initializer* 存在，則在計算中會將其放置在可"
"疊代物件的項目之前，並在可疊代物件為空時作為預設值。如果未給定 *initializer* "
"且 *iterable* 僅包含一個項目，則回傳第一個項目。"

#: ../../library/functools.rst:417
msgid "Roughly equivalent to::"
msgstr "大致相當於： ::"

#: ../../library/functools.rst:419
msgid ""
"def reduce(function, iterable, initializer=None):\n"
"    it = iter(iterable)\n"
"    if initializer is None:\n"
"        value = next(it)\n"
"    else:\n"
"        value = initializer\n"
"    for element in it:\n"
"        value = function(value, element)\n"
"    return value"
msgstr ""
"def reduce(function, iterable, initializer=None):\n"
"    it = iter(iterable)\n"
"    if initializer is None:\n"
"        value = next(it)\n"
"    else:\n"
"        value = initializer\n"
"    for element in it:\n"
"        value = function(value, element)\n"
"    return value"

#: ../../library/functools.rst:429
msgid ""
"See :func:`itertools.accumulate` for an iterator that yields all "
"intermediate values."
msgstr ""
"請參閱 :func:`itertools.accumulate` 以了解產生 (yield) 所有中間值 "
"(intermediate value) 的疊代器。"

#: ../../library/functools.rst:434
msgid ""
"Transform a function into a :term:`single-dispatch <single dispatch>` :term:"
"`generic function`."
msgstr ""
"將函式轉換為\\ :term:`單一調度 <single dispatch>`\\ :term:`泛型函式 <generic "
"function>`。"

#: ../../library/functools.rst:437
msgid ""
"To define a generic function, decorate it with the ``@singledispatch`` "
"decorator. When defining a function using ``@singledispatch``, note that the "
"dispatch happens on the type of the first argument::"
msgstr ""
"若要定義泛型函式，請使用 ``@singledispatch`` 裝飾器對其裝飾。請注意，使用 "
"``@singledispatch`` 定義函式時，分派調度 (dispatch) 是發生在第一個引數的型別"
"上： ::"

#: ../../library/functools.rst:441
msgid ""
">>> from functools import singledispatch\n"
">>> @singledispatch\n"
"... def fun(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Let me just say,\", end=\" \")\n"
"...     print(arg)"
msgstr ""
">>> from functools import singledispatch\n"
">>> @singledispatch\n"
"... def fun(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Let me just say,\", end=\" \")\n"
"...     print(arg)"

#: ../../library/functools.rst:448
msgid ""
"To add overloaded implementations to the function, use the :func:`register` "
"attribute of the generic function, which can be used as a decorator.  For "
"functions annotated with types, the decorator will infer the type of the "
"first argument automatically::"
msgstr ""
"若要為函式新增過載實作，請使用泛型函式的 :func:`register` 屬性，該屬性可用作"
"裝飾器。對於以型別來註釋的函式，裝飾器將自動推斷第一個引數的型別： ::"

#: ../../library/functools.rst:453
msgid ""
">>> @fun.register\n"
"... def _(arg: int, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Strength in numbers, eh?\", end=\" \")\n"
"...     print(arg)\n"
"...\n"
">>> @fun.register\n"
"... def _(arg: list, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Enumerate this:\")\n"
"...     for i, elem in enumerate(arg):\n"
"...         print(i, elem)"
msgstr ""
">>> @fun.register\n"
"... def _(arg: int, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Strength in numbers, eh?\", end=\" \")\n"
"...     print(arg)\n"
"...\n"
">>> @fun.register\n"
"... def _(arg: list, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Enumerate this:\")\n"
"...     for i, elem in enumerate(arg):\n"
"...         print(i, elem)"

#: ../../library/functools.rst:466
msgid ":data:`types.UnionType` and :data:`typing.Union` can also be used::"
msgstr "也可以使用 :data:`types.UnionType` 和 :data:`typing.Union`： ::"

#: ../../library/functools.rst:468
msgid ""
">>> @fun.register\n"
"... def _(arg: int | float, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Strength in numbers, eh?\", end=\" \")\n"
"...     print(arg)\n"
"...\n"
">>> from typing import Union\n"
">>> @fun.register\n"
"... def _(arg: Union[list, set], verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Enumerate this:\")\n"
"...     for i, elem in enumerate(arg):\n"
"...         print(i, elem)\n"
"..."
msgstr ""
">>> @fun.register\n"
"... def _(arg: int | float, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Strength in numbers, eh?\", end=\" \")\n"
"...     print(arg)\n"
"...\n"
">>> from typing import Union\n"
">>> @fun.register\n"
"... def _(arg: Union[list, set], verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Enumerate this:\")\n"
"...     for i, elem in enumerate(arg):\n"
"...         print(i, elem)\n"
"..."

#: ../../library/functools.rst:483
msgid ""
"For code which doesn't use type annotations, the appropriate type argument "
"can be passed explicitly to the decorator itself::"
msgstr ""
"對於不使用型別註釋的程式碼，可以將適當的型別引數明確傳遞給裝飾器本身： ::"

#: ../../library/functools.rst:486
msgid ""
">>> @fun.register(complex)\n"
"... def _(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Better than complicated.\", end=\" \")\n"
"...     print(arg.real, arg.imag)\n"
"..."
msgstr ""
">>> @fun.register(complex)\n"
"... def _(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Better than complicated.\", end=\" \")\n"
"...     print(arg.real, arg.imag)\n"
"..."

#: ../../library/functools.rst:494
msgid ""
"To enable registering :term:`lambdas<lambda>` and pre-existing functions, "
"the :func:`register` attribute can also be used in a functional form::"
msgstr ""
"若要啟用註冊 :term:`lambdas<lambda>` 和預先存在的函式，:func:`register` 屬性"
"也能以函式形式使用： ::"

#: ../../library/functools.rst:497
msgid ""
">>> def nothing(arg, verbose=False):\n"
"...     print(\"Nothing.\")\n"
"...\n"
">>> fun.register(type(None), nothing)"
msgstr ""
">>> def nothing(arg, verbose=False):\n"
"...     print(\"Nothing.\")\n"
"...\n"
">>> fun.register(type(None), nothing)"

#: ../../library/functools.rst:502
msgid ""
"The :func:`register` attribute returns the undecorated function. This "
"enables decorator stacking, :mod:`pickling<pickle>`, and the creation of "
"unit tests for each variant independently::"
msgstr ""
":func:`register` 屬性回傳未加裝飾器的函式。這讓使得裝飾器堆疊 (decorator "
"stacking)、:mod:`pickling<pickle>` 以及為每個變體獨立建立單元測試成為可能："

#: ../../library/functools.rst:506
msgid ""
">>> @fun.register(float)\n"
"... @fun.register(Decimal)\n"
"... def fun_num(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Half of your number:\", end=\" \")\n"
"...     print(arg / 2)\n"
"...\n"
">>> fun_num is fun\n"
"False"
msgstr ""
">>> @fun.register(float)\n"
"... @fun.register(Decimal)\n"
"... def fun_num(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Half of your number:\", end=\" \")\n"
"...     print(arg / 2)\n"
"...\n"
">>> fun_num is fun\n"
"False"

#: ../../library/functools.rst:516
msgid ""
"When called, the generic function dispatches on the type of the first "
"argument::"
msgstr "呼叫時，泛型函式會分派第一個引數的型別： ::"

#: ../../library/functools.rst:519
msgid ""
">>> fun(\"Hello, world.\")\n"
"Hello, world.\n"
">>> fun(\"test.\", verbose=True)\n"
"Let me just say, test.\n"
">>> fun(42, verbose=True)\n"
"Strength in numbers, eh? 42\n"
">>> fun(['spam', 'spam', 'eggs', 'spam'], verbose=True)\n"
"Enumerate this:\n"
"0 spam\n"
"1 spam\n"
"2 eggs\n"
"3 spam\n"
">>> fun(None)\n"
"Nothing.\n"
">>> fun(1.23)\n"
"0.615"
msgstr ""
">>> fun(\"Hello, world.\")\n"
"Hello, world.\n"
">>> fun(\"test.\", verbose=True)\n"
"Let me just say, test.\n"
">>> fun(42, verbose=True)\n"
"Strength in numbers, eh? 42\n"
">>> fun(['spam', 'spam', 'eggs', 'spam'], verbose=True)\n"
"Enumerate this:\n"
"0 spam\n"
"1 spam\n"
"2 eggs\n"
"3 spam\n"
">>> fun(None)\n"
"Nothing.\n"
">>> fun(1.23)\n"
"0.615"

#: ../../library/functools.rst:536
msgid ""
"Where there is no registered implementation for a specific type, its method "
"resolution order is used to find a more generic implementation. The original "
"function decorated with ``@singledispatch`` is registered for the base :"
"class:`object` type, which means it is used if no better implementation is "
"found."
msgstr ""
"如果沒有為特定型別註冊實作，則使用其方法解析順序 (method resolution order) 來"
"尋找更通用的實作。用 ``@singledispatch`` 裝飾的原始函式是為基底 :class:"
"`object` 型別註冊的，這意味著如果沒有找到更好的實作就會使用它。"

#: ../../library/functools.rst:542
msgid ""
"If an implementation is registered to an :term:`abstract base class`, "
"virtual subclasses of the base class will be dispatched to that "
"implementation::"
msgstr ""
"如果一個實作有被註冊到一個\\ :term:`抽象基底類別 <abstract base class>`，則基"
"底類別的虛擬子類別將被分派到該實作： ::"

#: ../../library/functools.rst:546
msgid ""
">>> from collections.abc import Mapping\n"
">>> @fun.register\n"
"... def _(arg: Mapping, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Keys & Values\")\n"
"...     for key, value in arg.items():\n"
"...         print(key, \"=>\", value)\n"
"...\n"
">>> fun({\"a\": \"b\"})\n"
"a => b"
msgstr ""
">>> from collections.abc import Mapping\n"
">>> @fun.register\n"
"... def _(arg: Mapping, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Keys & Values\")\n"
"...     for key, value in arg.items():\n"
"...         print(key, \"=>\", value)\n"
"...\n"
">>> fun({\"a\": \"b\"})\n"
"a => b"

#: ../../library/functools.rst:557
msgid ""
"To check which implementation the generic function will choose for a given "
"type, use the ``dispatch()`` attribute::"
msgstr ""
"若要檢查泛型函式將為給定型別選擇哪種實作，請使用 ``dispatch()`` 屬性： ::"

#: ../../library/functools.rst:560
msgid ""
">>> fun.dispatch(float)\n"
"<function fun_num at 0x1035a2840>\n"
">>> fun.dispatch(dict)    # note: default implementation\n"
"<function fun at 0x103fe0000>"
msgstr ""

#: ../../library/functools.rst:565
msgid ""
"To access all registered implementations, use the read-only ``registry`` "
"attribute::"
msgstr "若要存取所有已註冊的實作，請使用唯讀 ``registry`` 屬性： ::"

#: ../../library/functools.rst:568
msgid ""
">>> fun.registry.keys()\n"
"dict_keys([<class 'NoneType'>, <class 'int'>, <class 'object'>,\n"
"          <class 'decimal.Decimal'>, <class 'list'>,\n"
"          <class 'float'>])\n"
">>> fun.registry[float]\n"
"<function fun_num at 0x1035a2840>\n"
">>> fun.registry[object]\n"
"<function fun at 0x103fe0000>"
msgstr ""
">>> fun.registry.keys()\n"
"dict_keys([<class 'NoneType'>, <class 'int'>, <class 'object'>,\n"
"          <class 'decimal.Decimal'>, <class 'list'>,\n"
"          <class 'float'>])\n"
">>> fun.registry[float]\n"
"<function fun_num at 0x1035a2840>\n"
">>> fun.registry[object]\n"
"<function fun at 0x103fe0000>"

#: ../../library/functools.rst:579
msgid "The :func:`register` attribute now supports using type annotations."
msgstr ":func:`register` 屬性現在支援使用型別註釋。"

#: ../../library/functools.rst:582
msgid ""
"The :func:`register` attribute now supports :data:`types.UnionType` and :"
"data:`typing.Union` as type annotations."
msgstr ""
":func:`register` 屬性現在支援以 :data:`types.UnionType` 和 :data:`typing."
"Union` 作為型別註釋。"

#: ../../library/functools.rst:589
msgid ""
"Transform a method into a :term:`single-dispatch <single dispatch>` :term:"
"`generic function`."
msgstr ""
"將方法轉換為\\ :term:`單一調度 <single dispatch>`\\ :term:`泛型函式 <generic "
"function>`。"

#: ../../library/functools.rst:592
msgid ""
"To define a generic method, decorate it with the ``@singledispatchmethod`` "
"decorator. When defining a function using ``@singledispatchmethod``, note "
"that the dispatch happens on the type of the first non-*self* or non-*cls* "
"argument::"
msgstr ""
"若要定義泛型方法，請使用 ``@singledispatchmethod`` 裝飾器對其裝飾。請注意，使"
"用 ``@singledispatchmethod`` 定義函式時，分派調度是發生在第一個非 *self* 或"
"非 *cls* 引數的型別上： ::"

#: ../../library/functools.rst:597
msgid ""
"class Negator:\n"
"    @singledispatchmethod\n"
"    def neg(self, arg):\n"
"        raise NotImplementedError(\"Cannot negate a\")\n"
"\n"
"    @neg.register\n"
"    def _(self, arg: int):\n"
"        return -arg\n"
"\n"
"    @neg.register\n"
"    def _(self, arg: bool):\n"
"        return not arg"
msgstr ""
"class Negator:\n"
"    @singledispatchmethod\n"
"    def neg(self, arg):\n"
"        raise NotImplementedError(\"Cannot negate a\")\n"
"\n"
"    @neg.register\n"
"    def _(self, arg: int):\n"
"        return -arg\n"
"\n"
"    @neg.register\n"
"    def _(self, arg: bool):\n"
"        return not arg"

#: ../../library/functools.rst:610
msgid ""
"``@singledispatchmethod`` supports nesting with other decorators such as :"
"func:`@classmethod<classmethod>`. Note that to allow for ``dispatcher."
"register``, ``singledispatchmethod`` must be the *outer most* decorator. "
"Here is the ``Negator`` class with the ``neg`` methods bound to the class, "
"rather than an instance of the class::"
msgstr ""
"``@singledispatchmethod`` 支援與其他裝飾器巢狀使用 (nesting)，例如 :func:"
"`@classmethod<classmethod>`。請注意，為了使 ``dispatcher.register`` 可用，"
"``singledispatchmethod`` 必須是\\ *最外面的*\\ 裝飾器。以下範例是 "
"``Negator`` 類別，其 ``neg`` 方法繫結到該類別，而不是該類別的實例： ::"

#: ../../library/functools.rst:616
msgid ""
"class Negator:\n"
"    @singledispatchmethod\n"
"    @classmethod\n"
"    def neg(cls, arg):\n"
"        raise NotImplementedError(\"Cannot negate a\")\n"
"\n"
"    @neg.register\n"
"    @classmethod\n"
"    def _(cls, arg: int):\n"
"        return -arg\n"
"\n"
"    @neg.register\n"
"    @classmethod\n"
"    def _(cls, arg: bool):\n"
"        return not arg"
msgstr ""
"class Negator:\n"
"    @singledispatchmethod\n"
"    @classmethod\n"
"    def neg(cls, arg):\n"
"        raise NotImplementedError(\"Cannot negate a\")\n"
"\n"
"    @neg.register\n"
"    @classmethod\n"
"    def _(cls, arg: int):\n"
"        return -arg\n"
"\n"
"    @neg.register\n"
"    @classmethod\n"
"    def _(cls, arg: bool):\n"
"        return not arg"

#: ../../library/functools.rst:632
msgid ""
"The same pattern can be used for other similar decorators: :func:"
"`@staticmethod<staticmethod>`, :func:`@abstractmethod<abc.abstractmethod>`, "
"and others."
msgstr ""
"相同的模式可用於其他類似的裝飾器：:func:`@staticmethod<staticmethod>`、:func:"
"`@abstractmethod<abc.abstractmethod>` 等。"

#: ../../library/functools.rst:641
msgid ""
"Update a *wrapper* function to look like the *wrapped* function. The "
"optional arguments are tuples to specify which attributes of the original "
"function are assigned directly to the matching attributes on the wrapper "
"function and which attributes of the wrapper function are updated with the "
"corresponding attributes from the original function. The default values for "
"these arguments are the module level constants ``WRAPPER_ASSIGNMENTS`` "
"(which assigns to the wrapper function's ``__module__``, ``__name__``, "
"``__qualname__``, ``__annotations__``, ``__type_params__``, and ``__doc__``, "
"the documentation string) and ``WRAPPER_UPDATES`` (which updates the wrapper "
"function's ``__dict__``, i.e. the instance dictionary)."
msgstr ""
"更新 *wrapper* 函式，使其看起來像 *wrapped* 函式。可選引數是元組，用於指定原"
"始函式的哪些屬性直接賦值給包裝函式上的匹配屬性，以及包裝函式的哪些屬性使用原"
"始函式中的對應屬性進行更新。這些引數的預設值是模組層級的常數 "
"``WRAPPER_ASSIGNMENTS``\\ （它賦值給包裝函式的 ``__module__``、``__name__``、"
"``__qualname__``、``__annotations__`` 和 ``__doc__`` 文件字串 (docstring）和 "
"``WRAPPER_UPDATES``\\ （更新包裝器函式的 ``__dict__``，即實例字典）。"

#: ../../library/functools.rst:652
msgid ""
"To allow access to the original function for introspection and other "
"purposes (e.g. bypassing a caching decorator such as :func:`lru_cache`), "
"this function automatically adds a ``__wrapped__`` attribute to the wrapper "
"that refers to the function being wrapped."
msgstr ""
"為了允許出於內省 (introspection) 和其他目的所對原始函式的存取（例如繞過快取裝"
"飾器，如 :func:`lru_cache`），此函式會自動向包裝器新增 ``__wrapped__`` 屬性，"
"該包裝器參照被包裝的函式。"

#: ../../library/functools.rst:657
msgid ""
"The main intended use for this function is in :term:`decorator` functions "
"which wrap the decorated function and return the wrapper. If the wrapper "
"function is not updated, the metadata of the returned function will reflect "
"the wrapper definition rather than the original function definition, which "
"is typically less than helpful."
msgstr ""
"此函式的主要用途是在 :term:`decorator` 函式中，它包裝函式並回傳包裝器。如果包"
"裝器函式未更新，則回傳函式的元資料 (metadata) 將反映包裝器定義而非原始函式定"
"義，這通常不太會有幫助。"

#: ../../library/functools.rst:663
msgid ""
":func:`update_wrapper` may be used with callables other than functions. Any "
"attributes named in *assigned* or *updated* that are missing from the object "
"being wrapped are ignored (i.e. this function will not attempt to set them "
"on the wrapper function). :exc:`AttributeError` is still raised if the "
"wrapper function itself is missing any attributes named in *updated*."
msgstr ""
":func:`update_wrapper` 可以與函式以外的可呼叫物件一起使用。被包裝的物件中缺少"
"的 *assigned* 或 *updated* 中指定的任何屬性都將被忽略（即此函式不會嘗試在包裝"
"器函式上設定它們）。如果包裝函式本身缺少 *updated* 中指定的任何屬性，仍然會引"
"發 :exc:`AttributeError`。"

#: ../../library/functools.rst:669
msgid ""
"The ``__wrapped__`` attribute is now automatically added. The "
"``__annotations__`` attribute is now copied by default. Missing attributes "
"no longer trigger an :exc:`AttributeError`."
msgstr ""
"現在會自動新增 ``__wrapped__`` 屬性。現在預設會複製 ``__annotations__`` 屬"
"性。缺少的屬性不再觸發 :exc:`AttributeError`。"

#: ../../library/functools.rst:674
msgid ""
"The ``__wrapped__`` attribute now always refers to the wrapped function, "
"even if that function defined a ``__wrapped__`` attribute. (see :issue:"
"`17482`)"
msgstr ""
"``__wrapped__`` 屬性現在都會參照包裝函式，即便函式有定義 ``__wrapped__`` 屬"
"性。（參見 :issue:`17482`）"

#: ../../library/functools.rst:679
msgid "The ``__type_params__`` attribute is now copied by default."
msgstr "現在預設會複製 ``__type_params__`` 屬性。"

#: ../../library/functools.rst:685
msgid ""
"This is a convenience function for invoking :func:`update_wrapper` as a "
"function decorator when defining a wrapper function.  It is equivalent to "
"``partial(update_wrapper, wrapped=wrapped, assigned=assigned, "
"updated=updated)``. For example::"
msgstr ""
"這是一個方便的函式，用於在定義包裝器函式時呼叫 :func:`update_wrapper` 作為函"
"式裝飾器。它相當於 ``partial(update_wrapper, wrapped=wrapped, "
"assigned=assigned, updated=updated)``。例如： ::"

#: ../../library/functools.rst:690
msgid ""
">>> from functools import wraps\n"
">>> def my_decorator(f):\n"
"...     @wraps(f)\n"
"...     def wrapper(*args, **kwds):\n"
"...         print('Calling decorated function')\n"
"...         return f(*args, **kwds)\n"
"...     return wrapper\n"
"...\n"
">>> @my_decorator\n"
"... def example():\n"
"...     \"\"\"Docstring\"\"\"\n"
"...     print('Called example function')\n"
"...\n"
">>> example()\n"
"Calling decorated function\n"
"Called example function\n"
">>> example.__name__\n"
"'example'\n"
">>> example.__doc__\n"
"'Docstring'"
msgstr ""

#: ../../library/functools.rst:711
msgid ""
"Without the use of this decorator factory, the name of the example function "
"would have been ``'wrapper'``, and the docstring of the original :func:"
"`example` would have been lost."
msgstr ""
"如果不使用這個裝飾器工廠 (decorator factory)，範例函式的名稱將會是 "
"``'wrapper'``，並且原始 :func:`example` 的文件字串將會遺失。"

#: ../../library/functools.rst:719
msgid ":class:`partial` Objects"
msgstr ":class:`partial` 物件"

#: ../../library/functools.rst:721
msgid ""
":class:`partial` objects are callable objects created by :func:`partial`. "
"They have three read-only attributes:"
msgstr ""
":class:`partial` 物件是由 :func:`partial` 所建立的可呼叫物件。它們有三個唯讀"
"屬性："

#: ../../library/functools.rst:727
msgid ""
"A callable object or function.  Calls to the :class:`partial` object will be "
"forwarded to :attr:`func` with new arguments and keywords."
msgstr ""
"一個可呼叫的物件或函式。對 :class:`partial` 物件的呼叫將被轉送到帶有新引數和"
"關鍵字的 :attr:`func`。"

#: ../../library/functools.rst:733
msgid ""
"The leftmost positional arguments that will be prepended to the positional "
"arguments provided to a :class:`partial` object call."
msgstr ""
"最左邊的位置引數將會被加入到提供給 :class:`partial` 物件呼叫的位置引數的前"
"面。"

#: ../../library/functools.rst:739
msgid ""
"The keyword arguments that will be supplied when the :class:`partial` object "
"is called."
msgstr "呼叫 :class:`partial` 物件時將提供的關鍵字引數。"

#: ../../library/functools.rst:742
msgid ""
":class:`partial` objects are like :class:`function` objects in that they are "
"callable, weak referenceable, and can have attributes.  There are some "
"important differences.  For instance, the :attr:`~definition.__name__` and :"
"attr:`__doc__` attributes are not created automatically.  Also, :class:"
"`partial` objects defined in classes behave like static methods and do not "
"transform into bound methods during instance attribute look-up."
msgstr ""
":class:`partial` 物件與 :class:`function` 物件類似，因為它們是可呼叫的、可弱"
"參照的 (weak referencable) 且可以具有屬性。有一些重要的區別，例如，:attr:"
"`~definition.__name__` 和 :attr:`__doc__` 屬性不會自動建立。此外，類別中定義"
"的 :class:`partial` 物件的行為類似於靜態方法，並且在實例屬性查找期間不會轉換"
"為繫結方法。"
