<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>audioop --- 操作原始聲音檔案 &#8212; Python 3.12.4 說明文件</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=41b4f12d" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=b20cc3f5" />
    
    <script src="../_static/documentation_options.js?v=6bff4b4f"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f1e884e3"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.12.4 說明文件 中搜尋"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="關於這些文件" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="copyright" title="版權" href="../copyright.html" />
    <link rel="next" title="cgi --- 通用閘道器介面支援" href="cgi.html" />
    <link rel="prev" title="aifc --- 讀寫 AIFF 與 AIFC 檔案" href="aifc.html" />
    
    <link rel="canonical" href="https://docs.python.org/3/library/audioop.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" />
                <input type="submit" value="前往"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="aifc.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">aifc</span></code> --- 讀寫 AIFF 與 AIFC 檔案</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="cgi.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code> --- 通用閘道器介面支援</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/audioop.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="cgi.html" title="cgi --- 通用閘道器介面支援"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="aifc.html" title="aifc --- 讀寫 AIFF 與 AIFC 檔案"
             accesskey="P">上一頁</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準函式庫 (Standard Library)</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="superseded.html" accesskey="U">已被取代的模組</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code> --- 操作原始聲音檔案</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" id="search-box" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-audioop">
<span id="audioop-manipulate-raw-audio-data"></span><h1><a class="reference internal" href="#module-audioop" title="audioop: Manipulate raw audio data.（已棄用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code></a> --- 操作原始聲音檔案<a class="headerlink" href="#module-audioop" title="連結到這個標頭">¶</a></h1>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.11, will be removed in version 3.13: </span><a class="reference internal" href="#module-audioop" title="audioop: Manipulate raw audio data.（已棄用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code></a> 模組 (module) 即將被棄用（詳見 <span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0594/#audioop"><strong>PEP 594</strong></a>）。</p>
</div>
<hr class="docutils" />
<p>The <a class="reference internal" href="#module-audioop" title="audioop: Manipulate raw audio data.（已棄用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code></a> module contains some useful operations on sound fragments.
It operates on sound fragments consisting of signed integer samples 8, 16, 24
or 32 bits wide, stored in <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>.  All scalar items are
integers, unless specified otherwise.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版的變更: </span>Support for 24-bit samples was added.
All functions now accept any <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>.
String input now results in an immediate error.</p>
</div>
<p id="index-1">This module provides support for a-LAW, u-LAW and Intel/DVI ADPCM encodings.</p>
<p>A few of the more complicated operations only take 16-bit samples, otherwise the
sample size (in bytes) is always a parameter of the operation.</p>
<p>The module defines the following variables and functions:</p>
<dl class="py exception">
<dt class="sig sig-object py" id="audioop.error">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">error</span></span><a class="headerlink" href="#audioop.error" title="連結到這個定義">¶</a></dt>
<dd><p>This exception is raised on all errors, such as unknown number of bytes per
sample, etc.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.add">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fragment2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.add" title="連結到這個定義">¶</a></dt>
<dd><p>Return a fragment which is the addition of the two samples passed as parameters.
<em>width</em> is the sample width in bytes, either <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code> or <code class="docutils literal notranslate"><span class="pre">4</span></code>.  Both
fragments should have the same length.  Samples are truncated in case of overflow.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.adpcm2lin">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">adpcm2lin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adpcmfragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.adpcm2lin" title="連結到這個定義">¶</a></dt>
<dd><p>Decode an Intel/DVI ADPCM coded fragment to a linear fragment.  See the
description of <a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><code class="xref py py-func docutils literal notranslate"><span class="pre">lin2adpcm()</span></code></a> for details on ADPCM coding. Return a tuple
<code class="docutils literal notranslate"><span class="pre">(sample,</span> <span class="pre">newstate)</span></code> where the sample has the width specified in <em>width</em>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.alaw2lin">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">alaw2lin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.alaw2lin" title="連結到這個定義">¶</a></dt>
<dd><p>Convert sound fragments in a-LAW encoding to linearly encoded sound fragments.
a-LAW encoding always uses 8 bits samples, so <em>width</em> refers only to the sample
width of the output fragment here.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.avg">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">avg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.avg" title="連結到這個定義">¶</a></dt>
<dd><p>Return the average over all samples in the fragment.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.avgpp">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">avgpp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.avgpp" title="連結到這個定義">¶</a></dt>
<dd><p>Return the average peak-peak value over all samples in the fragment. No
filtering is done, so the usefulness of this routine is questionable.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.bias">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">bias</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.bias" title="連結到這個定義">¶</a></dt>
<dd><p>Return a fragment that is the original fragment with a bias added to each
sample.  Samples wrap around in case of overflow.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.byteswap">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">byteswap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.byteswap" title="連結到這個定義">¶</a></dt>
<dd><p>&quot;Byteswap&quot; all samples in a fragment and returns the modified fragment.
Converts big-endian samples to little-endian and vice versa.</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.4 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.cross">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">cross</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.cross" title="連結到這個定義">¶</a></dt>
<dd><p>Return the number of zero crossings in the fragment passed as an argument.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.findfactor">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">findfactor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.findfactor" title="連結到這個定義">¶</a></dt>
<dd><p>Return a factor <em>F</em> such that <code class="docutils literal notranslate"><span class="pre">rms(add(fragment,</span> <span class="pre">mul(reference,</span> <span class="pre">-F)))</span></code> is
minimal, i.e., return the factor with which you should multiply <em>reference</em> to
make it match as well as possible to <em>fragment</em>.  The fragments should both
contain 2-byte samples.</p>
<p>The time taken by this routine is proportional to <code class="docutils literal notranslate"><span class="pre">len(fragment)</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.findfit">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">findfit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.findfit" title="連結到這個定義">¶</a></dt>
<dd><p>Try to match <em>reference</em> as well as possible to a portion of <em>fragment</em> (which
should be the longer fragment).  This is (conceptually) done by taking slices
out of <em>fragment</em>, using <a class="reference internal" href="#audioop.findfactor" title="audioop.findfactor"><code class="xref py py-func docutils literal notranslate"><span class="pre">findfactor()</span></code></a> to compute the best match, and
minimizing the result.  The fragments should both contain 2-byte samples.
Return a tuple <code class="docutils literal notranslate"><span class="pre">(offset,</span> <span class="pre">factor)</span></code> where <em>offset</em> is the (integer) offset into
<em>fragment</em> where the optimal match started and <em>factor</em> is the (floating-point)
factor as per <a class="reference internal" href="#audioop.findfactor" title="audioop.findfactor"><code class="xref py py-func docutils literal notranslate"><span class="pre">findfactor()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.findmax">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">findmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.findmax" title="連結到這個定義">¶</a></dt>
<dd><p>Search <em>fragment</em> for a slice of length <em>length</em> samples (not bytes!) with
maximum energy, i.e., return <em>i</em> for which <code class="docutils literal notranslate"><span class="pre">rms(fragment[i*2:(i+length)*2])</span></code>
is maximal.  The fragments should both contain 2-byte samples.</p>
<p>The routine takes time proportional to <code class="docutils literal notranslate"><span class="pre">len(fragment)</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.getsample">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">getsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.getsample" title="連結到這個定義">¶</a></dt>
<dd><p>Return the value of sample <em>index</em> from the fragment.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.lin2adpcm">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">lin2adpcm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.lin2adpcm" title="連結到這個定義">¶</a></dt>
<dd><p>Convert samples to 4 bit Intel/DVI ADPCM encoding.  ADPCM coding is an adaptive
coding scheme, whereby each 4 bit number is the difference between one sample
and the next, divided by a (varying) step.  The Intel/DVI ADPCM algorithm has
been selected for use by the IMA, so it may well become a standard.</p>
<p><em>state</em> is a tuple containing the state of the coder.  The coder returns a tuple
<code class="docutils literal notranslate"><span class="pre">(adpcmfrag,</span> <span class="pre">newstate)</span></code>, and the <em>newstate</em> should be passed to the next call
of <a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><code class="xref py py-func docutils literal notranslate"><span class="pre">lin2adpcm()</span></code></a>.  In the initial call, <code class="docutils literal notranslate"><span class="pre">None</span></code> can be passed as the state.
<em>adpcmfrag</em> is the ADPCM coded fragment packed 2 4-bit values per byte.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.lin2alaw">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">lin2alaw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.lin2alaw" title="連結到這個定義">¶</a></dt>
<dd><p>Convert samples in the audio fragment to a-LAW encoding and return this as a
bytes object.  a-LAW is an audio encoding format whereby you get a dynamic
range of about 13 bits using only 8 bit samples.  It is used by the Sun audio
hardware, among others.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.lin2lin">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">lin2lin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newwidth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.lin2lin" title="連結到這個定義">¶</a></dt>
<dd><p>Convert samples between 1-, 2-, 3- and 4-byte formats.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>In some audio formats, such as .WAV files, 16, 24 and 32 bit samples are
signed, but 8 bit samples are unsigned.  So when converting to 8 bit wide
samples for these formats, you need to also add 128 to the result:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">new_frames</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">lin2lin</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">old_width</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">new_frames</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">bias</span><span class="p">(</span><span class="n">new_frames</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
<p>The same, in reverse, has to be applied when converting from 8 to 16, 24
or 32 bit width samples.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.lin2ulaw">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">lin2ulaw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.lin2ulaw" title="連結到這個定義">¶</a></dt>
<dd><p>Convert samples in the audio fragment to u-LAW encoding and return this as a
bytes object.  u-LAW is an audio encoding format whereby you get a dynamic
range of about 14 bits using only 8 bit samples.  It is used by the Sun audio
hardware, among others.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.max">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.max" title="連結到這個定義">¶</a></dt>
<dd><p>Return the maximum of the <em>absolute value</em> of all samples in a fragment.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.maxpp">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">maxpp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.maxpp" title="連結到這個定義">¶</a></dt>
<dd><p>Return the maximum peak-peak value in the sound fragment.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.minmax">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">minmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.minmax" title="連結到這個定義">¶</a></dt>
<dd><p>Return a tuple consisting of the minimum and maximum values of all samples in
the sound fragment.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.mul">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">mul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.mul" title="連結到這個定義">¶</a></dt>
<dd><p>Return a fragment that has all samples in the original fragment multiplied by
the floating-point value <em>factor</em>.  Samples are truncated in case of overflow.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.ratecv">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">ratecv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nchannels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inrate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outrate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">weightA</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">weightB</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#audioop.ratecv" title="連結到這個定義">¶</a></dt>
<dd><p>Convert the frame rate of the input fragment.</p>
<p><em>state</em> is a tuple containing the state of the converter.  The converter returns
a tuple <code class="docutils literal notranslate"><span class="pre">(newfragment,</span> <span class="pre">newstate)</span></code>, and <em>newstate</em> should be passed to the next
call of <a class="reference internal" href="#audioop.ratecv" title="audioop.ratecv"><code class="xref py py-func docutils literal notranslate"><span class="pre">ratecv()</span></code></a>.  The initial call should pass <code class="docutils literal notranslate"><span class="pre">None</span></code> as the state.</p>
<p>The <em>weightA</em> and <em>weightB</em> arguments are parameters for a simple digital filter
and default to <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">0</span></code> respectively.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.reverse">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">reverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.reverse" title="連結到這個定義">¶</a></dt>
<dd><p>Reverse the samples in a fragment and returns the modified fragment.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.rms">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">rms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.rms" title="連結到這個定義">¶</a></dt>
<dd><p>Return the root-mean-square of the fragment, i.e. <code class="docutils literal notranslate"><span class="pre">sqrt(sum(S_i^2)/n)</span></code>.</p>
<p>This is a measure of the power in an audio signal.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.tomono">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">tomono</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lfactor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rfactor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.tomono" title="連結到這個定義">¶</a></dt>
<dd><p>Convert a stereo fragment to a mono fragment.  The left channel is multiplied by
<em>lfactor</em> and the right channel by <em>rfactor</em> before adding the two channels to
give a mono signal.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.tostereo">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">tostereo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lfactor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rfactor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.tostereo" title="連結到這個定義">¶</a></dt>
<dd><p>Generate a stereo fragment from a mono fragment.  Each pair of samples in the
stereo fragment are computed from the mono sample, whereby left channel samples
are multiplied by <em>lfactor</em> and right channel samples by <em>rfactor</em>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="audioop.ulaw2lin">
<span class="sig-prename descclassname"><span class="pre">audioop.</span></span><span class="sig-name descname"><span class="pre">ulaw2lin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.ulaw2lin" title="連結到這個定義">¶</a></dt>
<dd><p>Convert sound fragments in u-LAW encoding to linearly encoded sound fragments.
u-LAW encoding always uses 8 bits samples, so <em>width</em> refers only to the sample
width of the output fragment here.</p>
</dd></dl>

<p>Note that operations such as <a class="reference internal" href="#audioop.mul" title="audioop.mul"><code class="xref py py-func docutils literal notranslate"><span class="pre">mul()</span></code></a> or <a class="reference internal" href="#audioop.max" title="audioop.max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> make no distinction
between mono and stereo fragments, i.e. all samples are treated equal.  If this
is a problem the stereo fragment should be split into two mono fragments first
and recombined later.  Here is an example of how to do that:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mul_stereo</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">lfactor</span><span class="p">,</span> <span class="n">rfactor</span><span class="p">):</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tomono</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tomono</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">lfactor</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">rfactor</span><span class="p">)</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tostereo</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tostereo</span><span class="p">(</span><span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">audioop</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
</pre></div>
</div>
<p>If you use the ADPCM coder to build network packets and you want your protocol
to be stateless (i.e. to be able to tolerate packet loss) you should not only
transmit the data but also the state.  Note that you should send the <em>initial</em>
state (the one you passed to <a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><code class="xref py py-func docutils literal notranslate"><span class="pre">lin2adpcm()</span></code></a>) along to the decoder, not the
final state (as returned by the coder).  If you want to use
<a class="reference internal" href="struct.html#struct.Struct" title="struct.Struct"><code class="xref py py-class docutils literal notranslate"><span class="pre">struct.Struct</span></code></a> to store the state in binary you can code the first
element (the predicted value) in 16 bits and the second (the delta index) in 8.</p>
<p>The ADPCM coders have never been tried against other ADPCM coders, only against
themselves.  It could well be that I misinterpreted the standards in which case
they will not be interoperable with the respective standards.</p>
<p>The <code class="xref py py-func docutils literal notranslate"><span class="pre">find*()</span></code> routines might look a bit funny at first sight. They are
primarily meant to do echo cancellation.  A reasonably fast way to do this is to
pick the most energetic piece of the output sample, locate that in the input
sample and subtract the whole output sample from the input sample:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">echocancel</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span> <span class="n">inputdata</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">findmax</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span> <span class="mi">800</span><span class="p">)</span>    <span class="c1"># one tenth second</span>
    <span class="n">out_test</span> <span class="o">=</span> <span class="n">outputdata</span><span class="p">[</span><span class="n">pos</span><span class="o">*</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">in_test</span> <span class="o">=</span> <span class="n">inputdata</span><span class="p">[</span><span class="n">pos</span><span class="o">*</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">ipos</span><span class="p">,</span> <span class="n">factor</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">findfit</span><span class="p">(</span><span class="n">in_test</span><span class="p">,</span> <span class="n">out_test</span><span class="p">)</span>
    <span class="c1"># Optional (for better cancellation):</span>
    <span class="c1"># factor = audioop.findfactor(in_test[ipos*2:ipos*2+len(out_test)],</span>
    <span class="c1">#              out_test)</span>
    <span class="n">prefill</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">pos</span><span class="o">+</span><span class="n">ipos</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">postfill</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputdata</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">prefill</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">outputdata</span><span class="p">))</span>
    <span class="n">outputdata</span> <span class="o">=</span> <span class="n">prefill</span> <span class="o">+</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">factor</span><span class="p">)</span> <span class="o">+</span> <span class="n">postfill</span>
    <span class="k">return</span> <span class="n">audioop</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">inputdata</span><span class="p">,</span> <span class="n">outputdata</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="aifc.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">aifc</span></code> --- 讀寫 AIFF 與 AIFC 檔案</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="cgi.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code> --- 通用閘道器介面支援</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/audioop.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="收合側邊欄">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="cgi.html" title="cgi --- 通用閘道器介面支援"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="aifc.html" title="aifc --- 讀寫 AIFF 與 AIFC 檔案"
             >上一頁</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準函式庫 (Standard Library)</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="superseded.html" >已被取代的模組</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code> --- 操作原始聲音檔案</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" id="search-box" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    版權
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最後更新於 Jul 20, 2024 (07:35 UTC)。
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    使用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.6 建立。
    </div>

  </body>
</html>