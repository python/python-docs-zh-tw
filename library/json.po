# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Asoul Yang <azx754@gmail.com>, 2016
# SkyLull <jk881222@gmail.com>, 2024
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-18 00:04+0000\n"
"PO-Revision-Date: 2023-08-05 15:25+0800\n"
"Last-Translator: Matt Wang <mattwang44@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.3.2\n"

#: ../../library/json.rst:2
msgid ":mod:`!json` --- JSON encoder and decoder"
msgstr ":mod:`!json` --- JSON 編碼器與解碼器"

#: ../../library/json.rst:10
msgid "**Source code:** :source:`Lib/json/__init__.py`"
msgstr "**原始碼：**\\ :source:`Lib/json/__init__.py`"

#: ../../library/json.rst:14
msgid ""
"`JSON (JavaScript Object Notation) <https://json.org>`_, specified by :rfc:"
"`7159` (which obsoletes :rfc:`4627`) and by `ECMA-404 <https://ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_, is a "
"lightweight data interchange format inspired by `JavaScript <https://en."
"wikipedia.org/wiki/JavaScript>`_ object literal syntax (although it is not a "
"strict subset of JavaScript [#rfc-errata]_ )."
msgstr ""
"`JSON (JavaScript Object Notation) <https://json.org>`_ 是一個輕量化的資料交"
"換格式，在 :rfc:`7159`\\ （其廢棄了 :rfc:`4627`\\ ）及 `ECMA-404 <https://"
"ecma-international.org/publications-and-standards/standards/ecma-404/>`_ 裡面"
"有詳細說明，它啟發自 `JavaScript <https://en.wikipedia.org/wiki/"
"JavaScript>`_ 的物件字面語法 (object literal syntax)（雖然它並不是 "
"JavaScript 的嚴格子集 [#rfc-errata]_\\ ）。"

#: ../../library/json.rst:22
msgid ""
"Be cautious when parsing JSON data from untrusted sources. A malicious JSON "
"string may cause the decoder to consume considerable CPU and memory "
"resources. Limiting the size of data to be parsed is recommended."
msgstr ""
"當剖析無法信任來源的 JSON 資料時要小心。一段惡意的 JSON 字串可能會導致解碼器"
"耗費大量 CPU 與記憶體資源。建議限制剖析資料的大小。"

#: ../../library/json.rst:26
msgid ""
":mod:`json` exposes an API familiar to users of the standard library :mod:"
"`marshal` and :mod:`pickle` modules."
msgstr ""
":mod:`json` 為習慣標準函式庫 :mod:`marshal` 與 :mod:`pickle` 模組的使用者提供"
"熟悉的 API。"

#: ../../library/json.rst:29
msgid "Encoding basic Python object hierarchies::"
msgstr "對基本 Python 物件階層進行編碼： ::"

#: ../../library/json.rst:31
msgid ""
">>> import json\n"
">>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n"
"'[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n"
">>> print(json.dumps(\"\\\"foo\\bar\"))\n"
"\"\\\"foo\\bar\"\n"
">>> print(json.dumps('\\u1234'))\n"
"\"\\u1234\"\n"
">>> print(json.dumps('\\\\'))\n"
"\"\\\\\"\n"
">>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n"
"{\"a\": 0, \"b\": 0, \"c\": 0}\n"
">>> from io import StringIO\n"
">>> io = StringIO()\n"
">>> json.dump(['streaming API'], io)\n"
">>> io.getvalue()\n"
"'[\"streaming API\"]'"
msgstr ""
">>> import json\n"
">>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n"
"'[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n"
">>> print(json.dumps(\"\\\"foo\\bar\"))\n"
"\"\\\"foo\\bar\"\n"
">>> print(json.dumps('\\u1234'))\n"
"\"\\u1234\"\n"
">>> print(json.dumps('\\\\'))\n"
"\"\\\\\"\n"
">>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n"
"{\"a\": 0, \"b\": 0, \"c\": 0}\n"
">>> from io import StringIO\n"
">>> io = StringIO()\n"
">>> json.dump(['streaming API'], io)\n"
">>> io.getvalue()\n"
"'[\"streaming API\"]'"

#: ../../library/json.rst:48
msgid "Compact encoding::"
msgstr "改用緊湊型編碼方式： ::"

#: ../../library/json.rst:50
msgid ""
">>> import json\n"
">>> json.dumps([1, 2, 3, {'4': 5, '6': 7}], separators=(',', ':'))\n"
"'[1,2,3,{\"4\":5,\"6\":7}]'"
msgstr ""

#: ../../library/json.rst:54
msgid "Pretty printing::"
msgstr "美化輸出： ::"

#: ../../library/json.rst:56
msgid ""
">>> import json\n"
">>> print(json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4))\n"
"{\n"
"    \"4\": 5,\n"
"    \"6\": 7\n"
"}"
msgstr ""
">>> import json\n"
">>> print(json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4))\n"
"{\n"
"    \"4\": 5,\n"
"    \"6\": 7\n"
"}"

#: ../../library/json.rst:63
msgid "Decoding JSON::"
msgstr "JSON 解碼： ::"

#: ../../library/json.rst:65
msgid ""
">>> import json\n"
">>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]')\n"
"['foo', {'bar': ['baz', None, 1.0, 2]}]\n"
">>> json.loads('\"\\\\\"foo\\\\bar\"')\n"
"'\"foo\\x08ar'\n"
">>> from io import StringIO\n"
">>> io = StringIO('[\"streaming API\"]')\n"
">>> json.load(io)\n"
"['streaming API']"
msgstr ""
">>> import json\n"
">>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]')\n"
"['foo', {'bar': ['baz', None, 1.0, 2]}]\n"
">>> json.loads('\"\\\\\"foo\\\\bar\"')\n"
"'\"foo\\x08ar'\n"
">>> from io import StringIO\n"
">>> io = StringIO('[\"streaming API\"]')\n"
">>> json.load(io)\n"
"['streaming API']"

#: ../../library/json.rst:75
msgid "Specializing JSON object decoding::"
msgstr "自訂特殊的 JSON 解碼方式： ::"

#: ../../library/json.rst:77
msgid ""
">>> import json\n"
">>> def as_complex(dct):\n"
"...     if '__complex__' in dct:\n"
"...         return complex(dct['real'], dct['imag'])\n"
"...     return dct\n"
"...\n"
">>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n"
"...     object_hook=as_complex)\n"
"(1+2j)\n"
">>> import decimal\n"
">>> json.loads('1.1', parse_float=decimal.Decimal)\n"
"Decimal('1.1')"
msgstr ""
">>> import json\n"
">>> def as_complex(dct):\n"
"...     if '__complex__' in dct:\n"
"...         return complex(dct['real'], dct['imag'])\n"
"...     return dct\n"
"...\n"
">>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n"
"...     object_hook=as_complex)\n"
"(1+2j)\n"
">>> import decimal\n"
">>> json.loads('1.1', parse_float=decimal.Decimal)\n"
"Decimal('1.1')"

#: ../../library/json.rst:90
msgid "Extending :class:`JSONEncoder`::"
msgstr "繼承 :class:`JSONEncoder` 類別並自行擴充額外的編碼方法： ::"

#: ../../library/json.rst:92
msgid ""
">>> import json\n"
">>> class ComplexEncoder(json.JSONEncoder):\n"
"...     def default(self, obj):\n"
"...         if isinstance(obj, complex):\n"
"...             return [obj.real, obj.imag]\n"
"...         # Let the base class default method raise the TypeError\n"
"...         return super().default(obj)\n"
"...\n"
">>> json.dumps(2 + 1j, cls=ComplexEncoder)\n"
"'[2.0, 1.0]'\n"
">>> ComplexEncoder().encode(2 + 1j)\n"
"'[2.0, 1.0]'\n"
">>> list(ComplexEncoder().iterencode(2 + 1j))\n"
"['[2.0', ', 1.0', ']']"
msgstr ""

#: ../../library/json.rst:108
msgid "Using :mod:`json.tool` from the shell to validate and pretty-print:"
msgstr "在命令列介面裡使用 :mod:`json.tool` 來驗證 JSON 語法和美化呈現方式："

#: ../../library/json.rst:110
msgid ""
"$ echo '{\"json\":\"obj\"}' | python -m json.tool\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json.tool\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"
msgstr ""
"$ echo '{\"json\":\"obj\"}' | python -m json.tool\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json.tool\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"

#: ../../library/json.rst:119
msgid "See :ref:`json-commandline` for detailed documentation."
msgstr "更詳盡的文件請見 :ref:`json-commandline`。"

#: ../../library/json.rst:123
msgid ""
"JSON is a subset of `YAML <https://yaml.org/>`_ 1.2.  The JSON produced by "
"this module's default settings (in particular, the default *separators* "
"value) is also a subset of YAML 1.0 and 1.1.  This module can thus also be "
"used as a YAML serializer."
msgstr ""
"JSON 語法是 `YAML <https://yaml.org/>`_ 1.2 語法的一種子集合。所以如果使用預"
"設的設定的話（準確來說，使用預設的 *separators* 分隔符設定的話），這個模組的"
"輸出也符合 YAML 1.0 和 1.1 的子集合規範。因此你也可以利用這個模組來當作 YAML "
"的序列化工具（serializer）。"

#: ../../library/json.rst:130
msgid ""
"This module's encoders and decoders preserve input and output order by "
"default.  Order is only lost if the underlying containers are unordered."
msgstr ""
"這個模組的編、解碼器預設會保存輸入與輸出資料的順序關係，除非一開始的輸入本身"
"就是無序的。"

#: ../../library/json.rst:135
msgid "Basic Usage"
msgstr "基本用法"

#: ../../library/json.rst:142
msgid ""
"Serialize *obj* as a JSON formatted stream to *fp* (a ``.write()``-"
"supporting :term:`file-like object`) using this :ref:`conversion table <py-"
"to-json-table>`."
msgstr ""
"參考這個\\ :ref:`轉換表 <py-to-json-table>`\\ 將 *obj* 序列化為符合 JSON 格式"
"的串流，並寫入到 *fp* （一個支援 ``.write()`` 方法的 :term:`file-like "
"object`）"

#: ../../library/json.rst:146
msgid ""
"If *skipkeys* is true (default: ``False``), then dict keys that are not of a "
"basic type (:class:`str`, :class:`int`, :class:`float`, :class:`bool`, "
"``None``) will be skipped instead of raising a :exc:`TypeError`."
msgstr ""
"如果 *skipkeys* 被設為 true（預設值：``False``），那麼非基本型別（:class:"
"`str`、:class:`int`、:class:`float`、:class:`bool`、``None``）的 dictionary"
"（字典）鍵值將被略過而不會引發 :exc:`TypeError`。"

#: ../../library/json.rst:150
msgid ""
"The :mod:`json` module always produces :class:`str` objects, not :class:"
"`bytes` objects. Therefore, ``fp.write()`` must support :class:`str` input."
msgstr ""
":mod:`json` 模組總是產生 :class:`str` 物件，而非 :class:`bytes` 物件。因此，"
"``fp.write()`` 必須支援 :class:`str` 輸入。"

#: ../../library/json.rst:154 ../../library/json.rst:431
msgid ""
"If *ensure_ascii* is true (the default), the output is guaranteed to have "
"all incoming non-ASCII characters escaped.  If *ensure_ascii* is false, "
"these characters will be output as-is."
msgstr ""
"如果 *ensure_ascii* 被設為 true（預設值），則輸出時將確保所有輸入的非 ASCII "
"字元都會被轉義。若 *ensure_ascii* 為 false，則這些字元將照原樣輸出。"

#: ../../library/json.rst:158
msgid ""
"If *check_circular* is false (default: ``True``), then the circular "
"reference check for container types will be skipped and a circular reference "
"will result in a :exc:`RecursionError` (or worse)."
msgstr ""
"如果 *check_circular* 設為 false（預設是 ``True``），則針對不同容器型別的循環"
"參照 (circular reference) 檢查將會被跳過，若有循環參照則最後將引發 :exc:"
"`RecursionError` （或其他更糟的錯誤）。"

#: ../../library/json.rst:162
msgid ""
"If *allow_nan* is false (default: ``True``), then it will be a :exc:"
"`ValueError` to serialize out of range :class:`float` values (``nan``, "
"``inf``, ``-inf``) in strict compliance of the JSON specification. If "
"*allow_nan* is true, their JavaScript equivalents (``NaN``, ``Infinity``, ``-"
"Infinity``) will be used."
msgstr ""
"如果 *allow_nan* 為 false（預設值：``True``\\ ），則序列化不符合嚴格 JSON 規"
"範的 :class:`float` 值 (``nan``, ``inf``, ``-inf``) 會引發 :exc:"
"`ValueError`。如果 *allow_nan* 為 true，則將使用它們的 JavaScript 等效表示 "
"(``NaN``, ``Infinity``, ``-Infinity``)。"

#: ../../library/json.rst:168 ../../library/json.rst:450
msgid ""
"If *indent* is a non-negative integer or string, then JSON array elements "
"and object members will be pretty-printed with that indent level.  An indent "
"level of 0, negative, or ``\"\"`` will only insert newlines.  ``None`` (the "
"default) selects the most compact representation. Using a positive integer "
"indent indents that many spaces per level.  If *indent* is a string (such as "
"``\"\\t\"``), that string is used to indent each level."
msgstr ""
"如果 *indent* 是非負整數或字串，則 JSON 陣列元素和物件成員將使用該縮排等級進"
"行格式美化。縮排等級 0、負數或 ``\"\"`` 只會插入換行符號。``None``\\ （預設"
"值）等於是選擇最緊湊的表示法。使用正整數縮排可以在每層縮排數量相同的空格。如"
"果 *indent* 是一個字串（例如 ``\"\\t\"``\\ ），則該字串用於縮排每個層級。"

#: ../../library/json.rst:175 ../../library/json.rst:457
msgid "Allow strings for *indent* in addition to integers."
msgstr "除了整數之外，*indent* 還允許使用字串作為輸入。"

#: ../../library/json.rst:178 ../../library/json.rst:460
msgid ""
"If specified, *separators* should be an ``(item_separator, key_separator)`` "
"tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and ``(',', "
"': ')`` otherwise.  To get the most compact JSON representation, you should "
"specify ``(',', ':')`` to eliminate whitespace."
msgstr ""
"如果有指定本引數內容，*separators* 應該是一個 ``(item_separator, "
"key_separator)`` 二元組。如果 *indent* 為 ``None`` 則預設為 ``(', ', ': "
"')``，否則預設為 ``(',', ': ')``。想要獲得最緊湊的 JSON 表示形式，你可以改成"
"指定 ``(',', ':')`` 來消除空格。"

#: ../../library/json.rst:183 ../../library/json.rst:465
msgid "Use ``(',', ': ')`` as default if *indent* is not ``None``."
msgstr "如果 *indent* 不是 ``None``，則使用 ``(',', ': ')`` 作為預設值"

#: ../../library/json.rst:186 ../../library/json.rst:468
msgid ""
"If specified, *default* should be a function that gets called for objects "
"that can't otherwise be serialized.  It should return a JSON encodable "
"version of the object or raise a :exc:`TypeError`.  If not specified, :exc:"
"`TypeError` is raised."
msgstr ""
"如果有指定本參數，*default* 會是一個遭遇無法序列化的物件時會被呼叫的函式。它"
"應該回傳該物件的 JSON 可編碼版本或引發 :exc:`TypeError`。如果未指定，則會直接"
"引發 :exc:`TypeError`。"

#: ../../library/json.rst:191
msgid ""
"If *sort_keys* is true (default: ``False``), then the output of dictionaries "
"will be sorted by key."
msgstr ""
"如果 *sort_keys* 為 true（預設值：``False``），則字典的輸出將按鍵值排序。"

#: ../../library/json.rst:194
msgid ""
"To use a custom :class:`JSONEncoder` subclass (e.g. one that overrides the :"
"meth:`~JSONEncoder.default` method to serialize additional types), specify "
"it with the *cls* kwarg; otherwise :class:`JSONEncoder` is used."
msgstr ""
"若要使用繼承自 :class:`JSONEncoder` 的自訂子類別（例如覆寫 :meth:"
"`~JSONEncoder.default` 方法來序列化其他型別的一個子類別物件），請使用關鍵字引"
"數 *cls* 指定該類別物件；否則預設使用 :class:`JSONEncoder`。"

#: ../../library/json.rst:198 ../../library/json.rst:276
msgid ""
"All optional parameters are now :ref:`keyword-only <keyword-only_parameter>`."
msgstr ""
"所有可選參數現在都是\\ :ref:`僅限關鍵字 <keyword-only_parameter>`\\ 參數了。"

# SkyLull: 我想這裡的 "framed protocol" 指的是
# https://peps.python.org/pep-3154/#framing
#: ../../library/json.rst:203
msgid ""
"Unlike :mod:`pickle` and :mod:`marshal`, JSON is not a framed protocol, so "
"trying to serialize multiple objects with repeated calls to :func:`dump` "
"using the same *fp* will result in an invalid JSON file."
msgstr ""
"與 :mod:`pickle` 和 :mod:`marshal` 不同，JSON 不具有二進位分框（binary "
"framed）的協定，因此嘗試重複呼叫 :func:`dump` 來序列化多個物件到同一個 *fp* "
"裡將導致無效的 JSON 檔案。"

#: ../../library/json.rst:212
msgid ""
"Serialize *obj* to a JSON formatted :class:`str` using this :ref:`conversion "
"table <py-to-json-table>`.  The arguments have the same meaning as in :func:"
"`dump`."
msgstr ""
"使用此\\ :ref:`轉換表 <json-to-py-table>`\\ 來將 *obj* 序列化為 JSON 格式 :"
"class:`str`。這個引數的作用與 :func:`dump` 中的同名引數意義相同。"

#: ../../library/json.rst:218
msgid ""
"Keys in key/value pairs of JSON are always of the type :class:`str`. When a "
"dictionary is converted into JSON, all the keys of the dictionary are "
"coerced to strings. As a result of this, if a dictionary is converted into "
"JSON and then back into a dictionary, the dictionary may not equal the "
"original one. That is, ``loads(dumps(x)) != x`` if x has non-string keys."
msgstr ""
"JSON 鍵/值對中的鍵始終為 :class:`str` 型別。當字典被轉換為 JSON 時，字典的所"
"有鍵值資料型別都會被強制轉換為字串。因此，如果將字典先轉換為 JSON 格式然後再"
"轉換回字典，則該字典可能不等於原始字典。也就是說，如果字典 x 含有非字串鍵值，"
"則 ``loads(dumps(x)) != x``。"

#: ../../library/json.rst:227
msgid ""
"Deserialize *fp* (a ``.read()``-supporting :term:`text file` or :term:"
"`binary file` containing a JSON document) to a Python object using this :ref:"
"`conversion table <json-to-py-table>`."
msgstr ""
"使用此\\ :ref:`轉換表 <json-to-py-table>`\\ 來將 *fp*\\ （一個支援 ``."
"read()``、包含 JSON 文件的\\ :term:`文字檔案 <text file>`\\ 或\\ :term:`二進"
"位檔案 <binary file>`\\ ）去序列化為 Python 物件。"

#: ../../library/json.rst:231
msgid ""
"*object_hook* is an optional function that will be called with the result of "
"any object literal decoded (a :class:`dict`).  The return value of "
"*object_hook* will be used instead of the :class:`dict`.  This feature can "
"be used to implement custom decoders (e.g. `JSON-RPC <https://www.jsonrpc."
"org>`_ class hinting)."
msgstr ""
"*object_hook* 是一個可選引數，其接受一個函式作為輸入。原始的字串解碼結果（一"
"個 :class:`dict`\\ ）將被傳入這個函式、並使用 *object_hook* 的回傳值來取代原"
"先的 :class:`dict` 輸出。此功能可用於實作自訂解碼器（例如 `JSON-RPC <https://"
"www.jsonrpc.org>`_ 類別提示）。"

#: ../../library/json.rst:237
msgid ""
"*object_pairs_hook* is an optional function that will be called with the "
"result of any object literal decoded with an ordered list of pairs.  The "
"return value of *object_pairs_hook* will be used instead of the :class:"
"`dict`.  This feature can be used to implement custom decoders.  If "
"*object_hook* is also defined, the *object_pairs_hook* takes priority."
msgstr ""
"*object_pairs_hook* 是一個可選引數，其接受一個函式作為輸入。原始的有序對串列"
"（ordered list of pairs）解碼結果將被傳入這個函式、並使用 "
"*object_pairs_hook* 的回傳值來取代原先的 :class:`dict` 輸出。此功能可用於實作"
"自訂解碼器。如果也同時給定了 *object_hook*，則 *object_pairs_hook* 優先。"

#: ../../library/json.rst:243 ../../library/json.rst:347
msgid "Added support for *object_pairs_hook*."
msgstr "新增對於 *object_pairs_hook* 的支援。"

#: ../../library/json.rst:246 ../../library/json.rst:350
msgid ""
"*parse_float* is an optional function that will be called with the string of "
"every JSON float to be decoded.  By default, this is equivalent to "
"``float(num_str)``.  This can be used to use another datatype or parser for "
"JSON floats (e.g. :class:`decimal.Decimal`)."
msgstr ""
"*parse_float* 為可選函式，每個要被解碼的 JSON 浮點數字串都會改用這個參數給定"
"的函式來進行解碼。預設情況這等效於 ``float(num_str)``。這個參數可用於將 JSON "
"中的浮點數解碼或剖析為另一種資料型別（例如 :class:`decimal.Decimal`\\ ）。"

#: ../../library/json.rst:251 ../../library/json.rst:355
msgid ""
"*parse_int* is an optional function that will be called with the string of "
"every JSON int to be decoded.  By default, this is equivalent to "
"``int(num_str)``.  This can be used to use another datatype or parser for "
"JSON integers (e.g. :class:`float`)."
msgstr ""
"*parse_int* 為可選函式，當解碼 JSON 整數字串時會被呼叫。預設情況等效於 "
"``int(num_str)``。這個參數可用於將 JSON 中的整數解碼或剖析為另一種資料型別"
"（例如 :class:`float`）。"

#: ../../library/json.rst:256
msgid ""
"The default *parse_int* of :func:`int` now limits the maximum length of the "
"integer string via the interpreter's :ref:`integer string conversion length "
"limitation <int_max_str_digits>` to help avoid denial of service attacks."
msgstr ""
"預設 *parse_int* 使用的 :func:`int` 函式現在有限制整數字串的長度上限了，限制"
"由直譯器的\\ :ref:`整數字串轉換長度限制 <int_max_str_digits>`\\ 機制來達成，"
"這能防止阻斷服務攻擊 (Denial of Service attacks)。"

#: ../../library/json.rst:262 ../../library/json.rst:360
msgid ""
"*parse_constant* is an optional function that will be called with one of the "
"following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This can be "
"used to raise an exception if invalid JSON numbers are encountered."
msgstr ""
"*parse_constant* 為可選函式，在解碼時若遭遇字串 ``'-Infinity'``、"
"``'Infinity'`` 或 ``'NaN'`` 其中之一則會改用這個參數給定的函式來進行解碼。這"
"也可用於使解碼過程中遇到無效的 JSON 數字時引發一個例外。"

#: ../../library/json.rst:266
msgid "*parse_constant* doesn't get called on 'null', 'true', 'false' anymore."
msgstr ""
"遭遇 'null'、'true' 或 'false' 時不再以 *parse_constant* 給定的函式來處理了。"

#: ../../library/json.rst:269
msgid ""
"To use a custom :class:`JSONDecoder` subclass, specify it with the ``cls`` "
"kwarg; otherwise :class:`JSONDecoder` is used.  Additional keyword arguments "
"will be passed to the constructor of the class."
msgstr ""
"若想要使用自訂的 :class:`JSONDecoder` 子類別物件，請以 ``cls`` 關鍵字引數指定"
"之，否則將使用預設的 :class:`JSONDecoder`。其他未使用到的關鍵字引數將繼續傳入"
"給 JSONDecoder 的建構函式使用。"

#: ../../library/json.rst:273 ../../library/json.rst:291
#: ../../library/json.rst:369
msgid ""
"If the data being deserialized is not a valid JSON document, a :exc:"
"`JSONDecodeError` will be raised."
msgstr ""
"如果被去序列化（deserialized）的資料不符合 JSON 格式，將會引發 :exc:"
"`JSONDecodeError` 例外。"

#: ../../library/json.rst:279
msgid ""
"*fp* can now be a :term:`binary file`. The input encoding should be UTF-8, "
"UTF-16 or UTF-32."
msgstr ""
"現在，*fp* 可以是一個\\ :term:`二進位檔案 <binary file>`，前提是其編碼格式為 "
"UTF-8、UTF-16 或 UTF-32。"

#: ../../library/json.rst:285
msgid ""
"Deserialize *s* (a :class:`str`, :class:`bytes` or :class:`bytearray` "
"instance containing a JSON document) to a Python object using this :ref:"
"`conversion table <json-to-py-table>`."
msgstr ""
"使用\\ :ref:`轉換表 <json-to-py-table>`\\ 將 *s* （一個含有 JSON 文件的 :"
"class:`str`、:class:`bytes` 或 :class:`bytearray` 的實例（instance））去序列"
"化（deserialize）為一個 Python 物件"

#: ../../library/json.rst:289
msgid "The other arguments have the same meaning as in :func:`load`."
msgstr "其餘引數的使用方式與意義和 :func:`load` 的相同。"

#: ../../library/json.rst:294
msgid ""
"*s* can now be of type :class:`bytes` or :class:`bytearray`. The input "
"encoding should be UTF-8, UTF-16 or UTF-32."
msgstr ""
"現在，*s* 可以是一個二進位檔案如 :class:`bytes` 或 :class:`bytearray`，前提是"
"其編碼格式為 UTF-8、UTF-16 或 UTF-32。"

#: ../../library/json.rst:298
msgid "The keyword argument *encoding* has been removed."
msgstr "刪除關鍵字引數 *encoding*。"

#: ../../library/json.rst:303
msgid "Encoders and Decoders"
msgstr "編碼器與解碼器"

#: ../../library/json.rst:307
msgid "Simple JSON decoder."
msgstr "簡易 JSON 解碼器"

#: ../../library/json.rst:309
msgid "Performs the following translations in decoding by default:"
msgstr "預設將執行下列資料型別轉換："

#: ../../library/json.rst:314 ../../library/json.rst:402
msgid "JSON"
msgstr "JSON"

#: ../../library/json.rst:314 ../../library/json.rst:402
msgid "Python"
msgstr "Python"

#: ../../library/json.rst:316 ../../library/json.rst:404
msgid "object"
msgstr "object"

#: ../../library/json.rst:316 ../../library/json.rst:404
msgid "dict"
msgstr "dict"

#: ../../library/json.rst:318 ../../library/json.rst:406
msgid "array"
msgstr "array"

#: ../../library/json.rst:318
msgid "list"
msgstr "list"

#: ../../library/json.rst:320 ../../library/json.rst:408
msgid "string"
msgstr "string"

#: ../../library/json.rst:320 ../../library/json.rst:408
msgid "str"
msgstr "str"

#: ../../library/json.rst:322
msgid "number (int)"
msgstr "number (整數)"

#: ../../library/json.rst:322
msgid "int"
msgstr "int"

#: ../../library/json.rst:324
msgid "number (real)"
msgstr "number (實數)"

#: ../../library/json.rst:324
msgid "float"
msgstr "float"

#: ../../library/json.rst:326 ../../library/json.rst:412
msgid "true"
msgstr "true"

#: ../../library/json.rst:326 ../../library/json.rst:412
msgid "True"
msgstr "True"

#: ../../library/json.rst:328 ../../library/json.rst:414
msgid "false"
msgstr "false"

#: ../../library/json.rst:328 ../../library/json.rst:414
msgid "False"
msgstr "False"

#: ../../library/json.rst:330 ../../library/json.rst:416
msgid "null"
msgstr "null"

#: ../../library/json.rst:330 ../../library/json.rst:416
msgid "None"
msgstr "None"

#: ../../library/json.rst:333
msgid ""
"It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as their "
"corresponding ``float`` values, which is outside the JSON spec."
msgstr ""
"雖然 ``NaN``、``Infinity`` 和 ``-Infinity`` 並不符合 JSON 規範，但解碼器依然"
"能正確地將其轉換到相應的 Python ``float`` 值。"

#: ../../library/json.rst:336
msgid ""
"*object_hook* is an optional function that will be called with the result of "
"every JSON object decoded and its return value will be used in place of the "
"given :class:`dict`.  This can be used to provide custom deserializations (e."
"g. to support `JSON-RPC <https://www.jsonrpc.org>`_ class hinting)."
msgstr ""
"*object_hook* 是一個可選函式，其接受一個解碼後的 JSON 物件作為輸入，並使用其"
"回傳值來取代原先的 :class:`dict`。這個功能可用於提供自訂的去序列化（例如支援 "
"`JSON-RPC <https://www.jsonrpc.org>`_ 類別提示）。"

#: ../../library/json.rst:341
msgid ""
"*object_pairs_hook* is an optional function that will be called with the "
"result of every JSON object decoded with an ordered list of pairs.  The "
"return value of *object_pairs_hook* will be used instead of the :class:"
"`dict`.  This feature can be used to implement custom decoders.  If "
"*object_hook* is also defined, the *object_pairs_hook* takes priority."
msgstr ""

#: ../../library/json.rst:364
msgid ""
"If *strict* is false (``True`` is the default), then control characters will "
"be allowed inside strings.  Control characters in this context are those "
"with character codes in the 0--31 range, including ``'\\t'`` (tab), "
"``'\\n'``, ``'\\r'`` and ``'\\0'``."
msgstr ""
"如果 *strict* 被設為 false（預設值為 ``True``），那麼字串中將允許控制字元。此"
"語境中的控制字元指的是 ASCII 字元編碼在 0～31 範圍內的字元，包括 ``'\\t'``"
"（tab）、``'\\n'``、``'\\r'`` 和 ``'\\0'``。"

#: ../../library/json.rst:372 ../../library/json.rst:473
msgid "All parameters are now :ref:`keyword-only <keyword-only_parameter>`."
msgstr ""
"所有參數現在都是\\ :ref:`僅限關鍵字參數 <keyword-only_parameter>`\\ 了。"

#: ../../library/json.rst:377
msgid ""
"Return the Python representation of *s* (a :class:`str` instance containing "
"a JSON document)."
msgstr ""
"回傳用 Python 型式表達的 *s* （一個含有 JSON 文件的 :class:`str` 實例）。"

#: ../../library/json.rst:380
msgid ""
":exc:`JSONDecodeError` will be raised if the given JSON document is not "
"valid."
msgstr "若給定的輸入不符合 JSON 格式會引發 :exc:`JSONDecodeError` 例外。"

#: ../../library/json.rst:385
msgid ""
"Decode a JSON document from *s* (a :class:`str` beginning with a JSON "
"document) and return a 2-tuple of the Python representation and the index in "
"*s* where the document ended."
msgstr ""
"將 *s* （一個開頭部分含有合格 JSON 文件的 :class:`str`） 解碼，並將 JSON 文件"
"結束點的索引值（index）和解碼結果合併為一個二元組（2-tuple）後回傳。"

#: ../../library/json.rst:389
msgid ""
"This can be used to decode a JSON document from a string that may have "
"extraneous data at the end."
msgstr "這個方法可以用來解碼尾段可能帶有 JSON 以外資料的文字。"

#: ../../library/json.rst:395
msgid "Extensible JSON encoder for Python data structures."
msgstr "可擴充的 Python 資料結構 JSON 編碼器。"

#: ../../library/json.rst:397
msgid "Supports the following objects and types by default:"
msgstr "預設可支援下列物件及型別："

#: ../../library/json.rst:406
msgid "list, tuple"
msgstr "list, tuple"

#: ../../library/json.rst:410
msgid "int, float, int- & float-derived Enums"
msgstr ""
"int、float 或可作為整數或浮點數運算的衍生列舉（int- or float-derived Enums）"

#: ../../library/json.rst:410
msgid "number"
msgstr "number"

#: ../../library/json.rst:419
msgid "Added support for int- and float-derived Enum classes."
msgstr ""
"增加對整數（int）、浮點數（float）或可作為整數或浮點數運算的衍生列舉（int- "
"or float-derived Enums）類別的支援性。"

#: ../../library/json.rst:422
msgid ""
"To extend this to recognize other objects, subclass and implement a :meth:"
"`~JSONEncoder.default` method with another method that returns a "
"serializable object for ``o`` if possible, otherwise it should call the "
"superclass implementation (to raise :exc:`TypeError`)."
msgstr ""
"若要擴充此功能來識別其他物件，請繼承並實作一個 :meth:`~JSONEncoder.default` "
"方法。此方法應回傳一個可序列化的 ``o`` 物件，否則此方法應呼叫父類別的 "
"JSONEncoder.default 方法（以引發 :exc:`TypeError` 例外）。"

#: ../../library/json.rst:427
msgid ""
"If *skipkeys* is false (the default), a :exc:`TypeError` will be raised when "
"trying to encode keys that are not :class:`str`, :class:`int`, :class:"
"`float` or ``None``.  If *skipkeys* is true, such items are simply skipped."
msgstr ""
"若 *skipkeys* 為 false（預設值），則當在編碼不是 :class:`str`、:class:"
"`int`、:class:`float` 或 ``None`` 的鍵值時，將引發 :exc:`TypeError`。如果 "
"*skipkeys* 為 true，這些項目將直接被跳過。"

#: ../../library/json.rst:435
msgid ""
"If *check_circular* is true (the default), then lists, dicts, and custom "
"encoded objects will be checked for circular references during encoding to "
"prevent an infinite recursion (which would cause a :exc:`RecursionError`). "
"Otherwise, no such check takes place."
msgstr ""
"如果 *check_circular* 為 true（預設值），則會在編碼期間檢查串列（list）、字典"
"（dict）和自訂編碼物件的循環參照，以防止無限遞迴（一個會導致 :exc:"
"`RecursionError` 例外的問題）。否則不會進行此類檢查。"

#: ../../library/json.rst:440
msgid ""
"If *allow_nan* is true (the default), then ``NaN``, ``Infinity``, and ``-"
"Infinity`` will be encoded as such.  This behavior is not JSON specification "
"compliant, but is consistent with most JavaScript based encoders and "
"decoders.  Otherwise, it will be a :exc:`ValueError` to encode such floats."
msgstr ""
"如果 *allow_nan* 為 true（預設值），則 ``NaN``、``Infinity`` 和 ``-"
"Infinity`` 將按照原樣進行編碼。請記得此行為不符合標準 JSON 規範，但的確與大多"
"數基於 JavaScript 的編碼器和解碼器一致。否則若設為 false，嘗試對這些浮點數進"
"行編碼將引發 :exc:`ValueError` 例外。"

#: ../../library/json.rst:446
msgid ""
"If *sort_keys* is true (default: ``False``), then the output of dictionaries "
"will be sorted by key; this is useful for regression tests to ensure that "
"JSON serializations can be compared on a day-to-day basis."
msgstr ""
"如果 *sort_keys* 為 true（預設值：``False``），則 dictionary（字典）的輸出將"
"按鍵值排序。這項功能可確保 JSON 序列化的結果能被互相比較，能讓日常的回歸測試"
"檢查變得方便一些。"

#: ../../library/json.rst:479
msgid ""
"Implement this method in a subclass such that it returns a serializable "
"object for *o*, or calls the base implementation (to raise a :exc:"
"`TypeError`)."
msgstr ""
"在任意一個子類別裡實作這個方法時須讓其回傳一個可序列化的物件 *o* ，或呼叫原始"
"的實作以引發 :exc:`TypeError` 例外。"

#: ../../library/json.rst:483
msgid ""
"For example, to support arbitrary iterators, you could implement :meth:"
"`~JSONEncoder.default` like this::"
msgstr ""
"舉例來說，想要讓編碼器支援任意疊代器（iterator），你可以實作這樣子的 :meth:"
"`~JSONEncoder.default`： ::"

#: ../../library/json.rst:486
msgid ""
"def default(self, o):\n"
"   try:\n"
"       iterable = iter(o)\n"
"   except TypeError:\n"
"       pass\n"
"   else:\n"
"       return list(iterable)\n"
"   # Let the base class default method raise the TypeError\n"
"   return super().default(o)"
msgstr ""

#: ../../library/json.rst:499
msgid ""
"Return a JSON string representation of a Python data structure, *o*.  For "
"example::"
msgstr "回傳一個 Python 資料結構物件 *o* 的 JSON 的字串表示。例如： ::"

#: ../../library/json.rst:502
msgid ""
">>> json.JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n"
"'{\"foo\": [\"bar\", \"baz\"]}'"
msgstr ""
">>> json.JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n"
"'{\"foo\": [\"bar\", \"baz\"]}'"

#: ../../library/json.rst:508
msgid ""
"Encode the given object, *o*, and yield each string representation as "
"available.  For example::"
msgstr ""
"將物件 *o* 編碼，並將結果統整為一個能依序產生（yield）各結果字串的物件。如下"
"例： ::"

#: ../../library/json.rst:511
msgid ""
"for chunk in json.JSONEncoder().iterencode(bigobject):\n"
"    mysocket.write(chunk)"
msgstr ""
"for chunk in json.JSONEncoder().iterencode(bigobject):\n"
"    mysocket.write(chunk)"

#: ../../library/json.rst:516
msgid "Exceptions"
msgstr "例外"

#: ../../library/json.rst:520
msgid "Subclass of :exc:`ValueError` with the following additional attributes:"
msgstr ":exc:`ValueError` 的子類別具有下列額外屬性："

#: ../../library/json.rst:524
msgid "The unformatted error message."
msgstr "未受格式化的錯誤訊息。"

#: ../../library/json.rst:528
msgid "The JSON document being parsed."
msgstr "正在被剖析的 JSON 文件。"

#: ../../library/json.rst:532
msgid "The start index of *doc* where parsing failed."
msgstr "*doc* 剖析失敗處的起始點的索引值。"

#: ../../library/json.rst:536
msgid "The line corresponding to *pos*."
msgstr "*pos* 所在的列（line）數。"

#: ../../library/json.rst:540
msgid "The column corresponding to *pos*."
msgstr "*pos* 所在的行（column）數。"

#: ../../library/json.rst:546
msgid "Standard Compliance and Interoperability"
msgstr "合規性與互通性（Interoperability）"

#: ../../library/json.rst:548
msgid ""
"The JSON format is specified by :rfc:`7159` and by `ECMA-404 <https://ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_. This "
"section details this module's level of compliance with the RFC. For "
"simplicity, :class:`JSONEncoder` and :class:`JSONDecoder` subclasses, and "
"parameters other than those explicitly mentioned, are not considered."
msgstr ""
"JSON 格式是由 :rfc:`7159` 和 `ECMA-404 <https://ecma-international.org/"
"publications-and-standards/standards/ecma-404/>`_ 規範的。本節詳細說明了本模"
"組對 RFC 的遵循程度。簡單起見，:class:`JSONEncoder` 和 :class:`JSONDecoder` "
"子類別以及未明確提及的參數將不予討論。"

#: ../../library/json.rst:554
msgid ""
"This module does not comply with the RFC in a strict fashion, implementing "
"some extensions that are valid JavaScript but not valid JSON.  In particular:"
msgstr ""
"這個模組的部份實作並未非常嚴格地遵循 RFC 規範。準確來說，下列實際實作符合 "
"JavaScript 語法格式，但並不符合 JSON 格式："

#: ../../library/json.rst:557
msgid "Infinite and NaN number values are accepted and output;"
msgstr "無限（Infinite）和非數字（NaN）值會被接受。"

#: ../../library/json.rst:558
msgid ""
"Repeated names within an object are accepted, and only the value of the last "
"name-value pair is used."
msgstr "同一個物件內可以有重複的名稱，但只有最後一個同名物件是有效的。"

#: ../../library/json.rst:561
msgid ""
"Since the RFC permits RFC-compliant parsers to accept input texts that are "
"not RFC-compliant, this module's deserializer is technically RFC-compliant "
"under default settings."
msgstr ""
"不過 RFC 准許遵循 RFC 的剖析器接受不合規的文字輸入，所以技術上來說若以預設設"
"定運作，本模組的去序列化器（deserializer）是符合 RFC 規範的。"

#: ../../library/json.rst:566
msgid "Character Encodings"
msgstr "字元編碼格式"

#: ../../library/json.rst:568
msgid ""
"The RFC requires that JSON be represented using either UTF-8, UTF-16, or "
"UTF-32, with UTF-8 being the recommended default for maximum "
"interoperability."
msgstr ""
"RFC 要求 JSON 必須以 UTF-8、UTF-16 或 UTF-32 格式編碼。並推薦以 UTF-8 編碼以"
"達成最佳的互通性。"

#: ../../library/json.rst:571
msgid ""
"As permitted, though not required, by the RFC, this module's serializer sets "
"*ensure_ascii=True* by default, thus escaping the output so that the "
"resulting strings only contain ASCII characters."
msgstr ""
"RFC 准許但並不強制編碼器的 *ensure_ascii=True* 行為是預設值，但本模組依然實作"
"了此一選項作為預設，因此本模組預設會轉義所有非 ASCII 字元。"

#: ../../library/json.rst:575
msgid ""
"Other than the *ensure_ascii* parameter, this module is defined strictly in "
"terms of conversion between Python objects and :class:`Unicode strings "
"<str>`, and thus does not otherwise directly address the issue of character "
"encodings."
msgstr ""
"除了 *ensure_ascii* 選項參數之外，本模組嚴格遵循 Python 物件與 :class:"
"`Unicode strings <str>` 之間的轉換規範，因此並不另外處理字元編碼的問題。"

#: ../../library/json.rst:580
msgid ""
"The RFC prohibits adding a byte order mark (BOM) to the start of a JSON "
"text, and this module's serializer does not add a BOM to its output. The RFC "
"permits, but does not require, JSON deserializers to ignore an initial BOM "
"in their input.  This module's deserializer raises a :exc:`ValueError` when "
"an initial BOM is present."
msgstr ""
"RFC 禁止在文件的開頭加上端序記號（Byte Order Mark），因此本模組的序列化器"
"（serializer）也不會在輸出中加入端序記號。RFC 允許但不強制 JSON 去序列化器"
"（deserializer）忽略文件初始的端序記號，因此本模組的去序列化器將在遭遇位於文"
"件開頭的端序記號時引發 :exc:`ValueError` 例外。"

#: ../../library/json.rst:586
msgid ""
"The RFC does not explicitly forbid JSON strings which contain byte sequences "
"that don't correspond to valid Unicode characters (e.g. unpaired UTF-16 "
"surrogates), but it does note that they may cause interoperability problems. "
"By default, this module accepts and outputs (when present in the original :"
"class:`str`) code points for such sequences."
msgstr ""
"RFC 並未明確禁止 JSON 文件包含無法對應有效 Unicode 字元的位元組序列（例如未配"
"對的 UTF-16 代理對（surrogate pairs）），但這個特性的確可能會引起相容性問題。"
"預設情況下，當原始輸入的 :class:`str` 中存在此類序列時，該模組將接受並輸出這"
"些序列的編碼位置（code points）。"

#: ../../library/json.rst:594
msgid "Infinite and NaN Number Values"
msgstr "正負無限與非數值"

#: ../../library/json.rst:596
msgid ""
"The RFC does not permit the representation of infinite or NaN number values. "
"Despite that, by default, this module accepts and outputs ``Infinity``, ``-"
"Infinity``, and ``NaN`` as if they were valid JSON number literal values::"
msgstr ""
"RFC 不允許表現無限大或非數值（NaN）。但預設情況下，這個模組仍接受並輸出 "
"``Infinity``、``-Infinity`` 和 ``NaN``，如同它們是有效的 JSON 數值字面值： ::"

#: ../../library/json.rst:600
msgid ""
">>> # Neither of these calls raises an exception, but the results are not "
"valid JSON\n"
">>> json.dumps(float('-inf'))\n"
"'-Infinity'\n"
">>> json.dumps(float('nan'))\n"
"'NaN'\n"
">>> # Same when deserializing\n"
">>> json.loads('-Infinity')\n"
"-inf\n"
">>> json.loads('NaN')\n"
"nan"
msgstr ""

#: ../../library/json.rst:611
msgid ""
"In the serializer, the *allow_nan* parameter can be used to alter this "
"behavior.  In the deserializer, the *parse_constant* parameter can be used "
"to alter this behavior."
msgstr ""
"在序列化器中，*allow_nan* 參數可以改變這個行為。在去序列化器中，"
"*parse_constant* 參數可以改變這個行為。"

#: ../../library/json.rst:617
msgid "Repeated Names Within an Object"
msgstr "物件內重複的名稱"

#: ../../library/json.rst:619
msgid ""
"The RFC specifies that the names within a JSON object should be unique, but "
"does not mandate how repeated names in JSON objects should be handled.  By "
"default, this module does not raise an exception; instead, it ignores all "
"but the last name-value pair for a given name::"
msgstr ""
"RFC 規範僅表明 JSON 物件中的名字應該是唯一的，但沒有強制要求如何處理重複的名"
"字。預設情況下，本模組不會因此引發例外；相反的，它會忽略該名字的所有重複鍵值"
"對，並只保留最後一個： ::"

#: ../../library/json.rst:624
msgid ""
">>> weird_json = '{\"x\": 1, \"x\": 2, \"x\": 3}'\n"
">>> json.loads(weird_json)\n"
"{'x': 3}"
msgstr ""

#: ../../library/json.rst:628
msgid "The *object_pairs_hook* parameter can be used to alter this behavior."
msgstr "*object_parts_hook* 參數可以改變這個行為。"

#: ../../library/json.rst:632
msgid "Top-level Non-Object, Non-Array Values"
msgstr "位於頂層的非物件及非列表值"

#: ../../library/json.rst:634
msgid ""
"The old version of JSON specified by the obsolete :rfc:`4627` required that "
"the top-level value of a JSON text must be either a JSON object or array "
"(Python :class:`dict` or :class:`list`), and could not be a JSON null, "
"boolean, number, or string value.  :rfc:`7159` removed that restriction, and "
"this module does not and has never implemented that restriction in either "
"its serializer or its deserializer."
msgstr ""
"由已廢棄的 :rfc:`4627` 所規範的舊版 JSON 要求 JSON 文字的頂層值必須是 JSON 物"
"件或陣列（Python :class:`dict` 或 :class:`list`），而且不能是 JSON 的 null、"
"boolean、數字或字串值。 :rfc:`7159` 移除了這個限制，而本模組的序列化器或去串"
"列化器中未曾實施過該限制。"

#: ../../library/json.rst:641
msgid ""
"Regardless, for maximum interoperability, you may wish to voluntarily adhere "
"to the restriction yourself."
msgstr "如果想要最大限度地保留互通性，你可能還是會想要自行施加這個限制。"

#: ../../library/json.rst:646
msgid "Implementation Limitations"
msgstr "實作限制"

#: ../../library/json.rst:648
msgid "Some JSON deserializer implementations may set limits on:"
msgstr "某些 JSON 去序列化器的實作可能會造成下列限制："

#: ../../library/json.rst:650
msgid "the size of accepted JSON texts"
msgstr "JSON 文件長度上限"

#: ../../library/json.rst:651
msgid "the maximum level of nesting of JSON objects and arrays"
msgstr "JSON 物件或陣列的最大巢狀層數（level of nesting）限制"

#: ../../library/json.rst:652
msgid "the range and precision of JSON numbers"
msgstr "數字的精準度或範圍"

#: ../../library/json.rst:653
msgid "the content and maximum length of JSON strings"
msgstr "JSON 字串長度上限"

#: ../../library/json.rst:655
msgid ""
"This module does not impose any such limits beyond those of the relevant "
"Python datatypes themselves or the Python interpreter itself."
msgstr ""
"本模組除了 Python 資料型態本身或 Python 直譯器本身的限制以外，不會設定任何此"
"類限制。"

#: ../../library/json.rst:658
msgid ""
"When serializing to JSON, beware any such limitations in applications that "
"may consume your JSON.  In particular, it is common for JSON numbers to be "
"deserialized into IEEE 754 double precision numbers and thus subject to that "
"representation's range and precision limitations.  This is especially "
"relevant when serializing Python :class:`int` values of extremely large "
"magnitude, or when serializing instances of \"exotic\" numerical types such "
"as :class:`decimal.Decimal`."
msgstr ""
"將資料序列化為 JSON 時，要注意可能會使用該 JSON 輸出的應用程式中的相關限制。"
"特別要注意的是，JSON 數字常會被去序列化為 IEEE 754 雙精度浮點數（double），並"
"因而受到其表示範圍和精度限制的影響。這在序列化極大的 Python :class:`int` 數"
"值、或是序列化特殊數字型別的實例時（例如 :class:`decimal.Decimal`）尤其重要。"

#: ../../library/json.rst:671
msgid "Command Line Interface"
msgstr "命令列介面"

#: ../../library/json.rst:676
msgid "**Source code:** :source:`Lib/json/tool.py`"
msgstr "**原始碼：**\\ :source:`Lib/json/tool.py`"

#: ../../library/json.rst:680
msgid ""
"The :mod:`json.tool` module provides a simple command line interface to "
"validate and pretty-print JSON objects."
msgstr ""
":mod:`json.tool` 模組提供了一個簡易的命令列界面以供校驗與美化呈現 JSON 物件。"

#: ../../library/json.rst:683
msgid ""
"If the optional ``infile`` and ``outfile`` arguments are not specified, :"
"data:`sys.stdin` and :data:`sys.stdout` will be used respectively:"
msgstr ""
"如果沒有指定可選引數 ``infile`` 和 ``outfile`` ，則 :data:`sys.stdin` 和 :"
"data:`sys.stdout` 將各自做為輸入和輸出的預設值。"

#: ../../library/json.rst:686
msgid ""
"$ echo '{\"json\": \"obj\"}' | python -m json.tool\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json.tool\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"
msgstr ""

#: ../../library/json.rst:695
msgid ""
"The output is now in the same order as the input. Use the :option:`--sort-"
"keys` option to sort the output of dictionaries alphabetically by key."
msgstr ""
"現在開始輸出和輸入的資料順序會是相同的。傳入 :option:`--sort-keys` 引數以按照"
"鍵值的字母順序對輸出進行排序。"

#: ../../library/json.rst:702
msgid "Command line options"
msgstr "命令列選項"

#: ../../library/json.rst:706
msgid "The JSON file to be validated or pretty-printed:"
msgstr "將被用於校驗或美化呈現的 JSON 文件："

#: ../../library/json.rst:708
msgid ""
"$ python -m json.tool mp_films.json\n"
"[\n"
"    {\n"
"        \"title\": \"And Now for Something Completely Different\",\n"
"        \"year\": 1971\n"
"    },\n"
"    {\n"
"        \"title\": \"Monty Python and the Holy Grail\",\n"
"        \"year\": 1975\n"
"    }\n"
"]"
msgstr ""
"$ python -m json.tool mp_films.json\n"
"[\n"
"    {\n"
"        \"title\": \"And Now for Something Completely Different\",\n"
"        \"year\": 1971\n"
"    },\n"
"    {\n"
"        \"title\": \"Monty Python and the Holy Grail\",\n"
"        \"year\": 1975\n"
"    }\n"
"]"

#: ../../library/json.rst:722
msgid "If *infile* is not specified, read from :data:`sys.stdin`."
msgstr "如果沒有指定 *infile* 則會從 :data:`sys.stdin` 讀取輸入。"

#: ../../library/json.rst:726
msgid ""
"Write the output of the *infile* to the given *outfile*. Otherwise, write it "
"to :data:`sys.stdout`."
msgstr ""
"將 *infile* 的結果寫入到給定的 *outfile*。若未提供則寫入到 :data:`sys."
"stdout`。"

#: ../../library/json.rst:731
msgid "Sort the output of dictionaries alphabetically by key."
msgstr "按照鍵值的字母順序對輸出字典進行排序。"

#: ../../library/json.rst:737
msgid ""
"Disable escaping of non-ascii characters, see :func:`json.dumps` for more "
"information."
msgstr "關閉非 ASCII 字元的自動轉義功能。詳情請參照 :func:`json.dumps`。"

#: ../../library/json.rst:743
msgid "Parse every input line as separate JSON object."
msgstr "將每一行輸入都單獨輸出為一個 JSON 物件。"

#: ../../library/json.rst:749
msgid "Mutually exclusive options for whitespace control."
msgstr "互斥的空白字元控制選項。"

#: ../../library/json.rst:755
msgid "Show the help message."
msgstr "顯示說明訊息。"

#: ../../library/json.rst:759
msgid "Footnotes"
msgstr "註解"

#: ../../library/json.rst:760
msgid ""
"As noted in `the errata for RFC 7159 <https://www.rfc-editor.org/"
"errata_search.php?rfc=7159>`_, JSON permits literal U+2028 (LINE SEPARATOR) "
"and U+2029 (PARAGRAPH SEPARATOR) characters in strings, whereas JavaScript "
"(as of ECMAScript Edition 5.1) does not."
msgstr ""
"如 `RFC 7159 更正 <https://www.rfc-editor.org/errata_search.php?rfc=7159>`_ "
"所述，JSON 允許字串中出現 U+2028（列分隔符）和 U+2029（段落分隔符）字元，而 "
"JavaScript（截至 ECMAScript 5.1 版）則不允許。"

#~ msgid ""
#~ "*object_pairs_hook*, if specified will be called with the result of every "
#~ "JSON object decoded with an ordered list of pairs.  The return value of "
#~ "*object_pairs_hook* will be used instead of the :class:`dict`.  This "
#~ "feature can be used to implement custom decoders.  If *object_hook* is "
#~ "also defined, the *object_pairs_hook* takes priority."
#~ msgstr ""
#~ "*object_pairs_hook* 是一個可選引數，其接受一個函式作為輸入。原始的有序對串"
#~ "列（ordered list of pairs）解碼結果將被傳入這個函式、並使用 "
#~ "*object_pairs_hook* 的回傳值來取代原先的 :class:`dict` 輸出。此功能可用於"
#~ "實作自訂解碼器。如果也同時給定了 *object_hook*，則 *object_pairs_hook* 優"
#~ "先。"
