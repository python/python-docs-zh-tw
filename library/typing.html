<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>typing --- 支援型別提示 &#8212; Python 3.12.5 說明文件</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=41b4f12d" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=b20cc3f5" />
    
    <script src="../_static/documentation_options.js?v=79397755"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f1e884e3"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.12.5 說明文件 中搜尋"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="關於這些文件" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="copyright" title="版權" href="../copyright.html" />
    <link rel="next" title="pydoc --- 文件產生器與線上幫助系統" href="pydoc.html" />
    <link rel="prev" title="開發工具" href="development.html" />
    
    <link rel="canonical" href="https://docs.python.org/3/library/typing.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" />
                <input type="submit" value="前往"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目錄</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> --- 支援型別提示</a><ul>
<li><a class="reference internal" href="#specification-for-the-python-type-system">Python 型別系統的技術規範</a></li>
<li><a class="reference internal" href="#type-aliases">型別別名</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#annotating-callable-objects">註釋 callable 物件</a></li>
<li><a class="reference internal" href="#generics">泛型</a></li>
<li><a class="reference internal" href="#annotating-tuples">註釋元組 (tuple)</a></li>
<li><a class="reference internal" href="#the-type-of-class-objects">類別物件的型別</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">使用者定義泛型型別</a></li>
<li><a class="reference internal" href="#the-any-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code> 型別</a></li>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping">標稱 (nominal) 子型別 vs 結構子型別</a></li>
<li><a class="reference internal" href="#module-contents">模組內容</a><ul>
<li><a class="reference internal" href="#special-typing-primitives">特別型別原語 (primitive)</a><ul>
<li><a class="reference internal" href="#special-types">特別型別</a></li>
<li><a class="reference internal" href="#special-forms">特別型式</a></li>
<li><a class="reference internal" href="#building-generic-types-and-type-aliases">Building generic types and type aliases</a></li>
<li><a class="reference internal" href="#other-special-directives">Other special directives</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">協定</a></li>
<li><a class="reference internal" href="#abcs-for-working-with-io">ABCs for working with IO</a></li>
<li><a class="reference internal" href="#functions-and-decorators">函式與裝飾器</a></li>
<li><a class="reference internal" href="#introspection-helpers">Introspection helpers</a></li>
<li><a class="reference internal" href="#constant">常數</a></li>
<li><a class="reference internal" href="#deprecated-aliases">棄用的別名</a><ul>
<li><a class="reference internal" href="#aliases-to-built-in-types">內建型別的別名</a></li>
<li><a class="reference internal" href="#aliases-to-types-in-collections"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code> 中型別的別名</a></li>
<li><a class="reference internal" href="#aliases-to-other-concrete-types">Aliases to other concrete types</a></li>
<li><a class="reference internal" href="#aliases-to-container-abcs-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code> 中容器 ABC 的別名</a></li>
<li><a class="reference internal" href="#aliases-to-asynchronous-abcs-in-collections-abc">Aliases to asynchronous ABCs in <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a></li>
<li><a class="reference internal" href="#aliases-to-other-abcs-in-collections-abc">Aliases to other ABCs in <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a></li>
<li><a class="reference internal" href="#aliases-to-contextlib-abcs"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code> ABC 的別名</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#deprecation-timeline-of-major-features">Deprecation Timeline of Major Features</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="development.html"
                          title="上一章">開發工具</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="pydoc.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> --- 文件產生器與線上幫助系統</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/typing.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc --- 文件產生器與線上幫助系統"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="development.html" title="開發工具"
             accesskey="P">上一頁</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準函式庫 (Standard Library)</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">開發工具</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> --- 支援型別提示</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" id="search-box" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="typing-support-for-type-hints">
<h1><a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> --- 支援型別提示<a class="headerlink" href="#typing-support-for-type-hints" title="連結到這個標頭">¶</a></h1>
<div class="versionadded" id="module-typing">
<p><span class="versionmodified added">在 3.5 版被加入.</span></p>
</div>
<p><strong>原始碼：</strong><a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.12/Lib/typing.py">Lib/typing.py</a></p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>Python runtime 不強制要求函式與變數的型別註釋。他們可以被第三方工具使用，如：<a class="reference internal" href="../glossary.html#term-static-type-checker"><span class="xref std std-term">型別檢查器</span></a>、IDE、linter 等。</p>
</div>
<hr class="docutils" />
<p>此模組提供 runtime 型別提示支援。</p>
<p>動腦筋思考下面的函式：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">surface_area_of_cube</span><span class="p">(</span><span class="n">edge_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;The surface area of the cube is </span><span class="si">{</span><span class="mi">6</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">edge_length</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">2</span><span class="si">}</span><span class="s2">.&quot;</span>
</pre></div>
</div>
<p>函式 <code class="docutils literal notranslate"><span class="pre">surface_area_of_cube</span></code> 需要一個引數且預期是一個 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 的實例，如 <code class="docutils literal notranslate"><span class="pre">edge_length:</span> <span class="pre">float</span></code> 所指出的<a class="reference internal" href="../glossary.html#term-type-hint"><span class="xref std std-term">型別提示</span></a>。這個函式預期會回傳一個 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 的實例，如 <code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">str</span></code> 所指出的提示。</p>
<p>儘管型別提示可以是簡單類別，像是 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 或 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>，他們也可以變得更為複雜。模組 <a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 提供一組更高階的型別提示詞彙。</p>
<p>新功能會頻繁的新增至 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 模組中。<a class="extlink-pypi reference external" href="https://pypi.org/project/typing_extensions/">typing_extensions</a> 套件為這些新功能提供了 backport（向後移植的）版本，提供給舊版本的 Python 使用。</p>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<dl class="simple">
<dt><a class="reference external" href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html">&quot;型別小抄 (Typing cheat sheet)&quot;</a></dt><dd><p>型別提示的快速預覽（發布於 mypy 的文件中）</p>
</dd>
<dt><a class="reference external" href="https://mypy.readthedocs.io/en/stable/index.html">mypy 文件</a>的 &quot;型別系統參考資料 (Type System Reference)&quot; 章節</dt><dd><p>Python 的加註型別系統是基於 PEPs 進行標準化，所以這個參照 (reference) 應該在多數 Python 型別檢查器中廣為使用。（某些部分依然是特定給 mypy 使用。）</p>
</dd>
<dt><a class="reference external" href="https://typing.readthedocs.io/en/latest/">&quot;Python 的靜態型別 (Static Typing)&quot;</a></dt><dd><p>由社群編寫的跨平台型別檢查器文件 (type-checker-agnostic) 詳細描述加註型別系統的功能、實用的加註型別衍伸工具、以及加註型別的最佳實踐 (best practice)。</p>
</dd>
</dl>
</div>
<section id="specification-for-the-python-type-system">
<span id="relevant-peps"></span><h2>Python 型別系統的技術規範<a class="headerlink" href="#specification-for-the-python-type-system" title="連結到這個標頭">¶</a></h2>
<p>關於 Python 型別系統標準的 (canonical)、最新的技術規範可以在<a class="reference external" href="https://typing.readthedocs.io/en/latest/spec/index.html">「Python 型別系統的技術規範」</a>找到。</p>
</section>
<section id="type-aliases">
<span id="id2"></span><h2>型別別名<a class="headerlink" href="#type-aliases" title="連結到這個標頭">¶</a></h2>
<p>一個型別別名被定義來使用 <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 陳述式，其建立了 <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a> 的實例。在這個範例中，<code class="docutils literal notranslate"><span class="pre">Vector</span></code> 及 <code class="docutils literal notranslate"><span class="pre">list[float]</span></code> 會被當作和靜態型別檢查器一樣同等對待：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Vector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">scalar</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>

<span class="c1"># passes type checking; a list of floats qualifies as a Vector.</span>
<span class="n">new_vector</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.2</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">])</span>
</pre></div>
</div>
<p>型別別名對於簡化複雜的型別簽名 (complex type signature) 非常好用。舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>

<span class="nb">type</span> <span class="n">ConnectionOptions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="nb">type</span> <span class="n">Address</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="nb">type</span> <span class="n">Server</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Address</span><span class="p">,</span> <span class="n">ConnectionOptions</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Server</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># The static type checker will treat the previous type signature as</span>
<span class="c1"># being exactly equivalent to this one.</span>
<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span>
    <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 陳述式是 Python 3.12 的新功能。為了向後相容性，型別別名可以透過簡單的賦值來建立：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
<p>或是用 <a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> 標記，讓它明確的表示這是一個型別別名，而非一般的變數賦值：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="n">Vector</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="newtype">
<span id="distinct"></span><h2>NewType<a class="headerlink" href="#newtype" title="連結到這個標頭">¶</a></h2>
<p>使用 <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewType</span></code></a> 輔助工具 (helper) 建立獨特型別：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">some_id</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">524313</span><span class="p">)</span>
</pre></div>
</div>
<p>若它是原本型別的子類別，靜態型別檢查器會將其視為一個新的型別。這對於幫助擷取邏輯性錯誤非常有用：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_user_name</span><span class="p">(</span><span class="n">user_id</span><span class="p">:</span> <span class="n">UserId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># passes type checking</span>
<span class="n">user_a</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="n">UserId</span><span class="p">(</span><span class="mi">42351</span><span class="p">))</span>

<span class="c1"># fails type checking; an int is not a UserId</span>
<span class="n">user_b</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>你依然可以在對於型別 <code class="docutils literal notranslate"><span class="pre">UserId</span></code> 的變數中執行所有 <code class="docutils literal notranslate"><span class="pre">int</span></code> 的操作。這讓你可以在預期接受 <code class="docutils literal notranslate"><span class="pre">int</span></code> 的地方傳遞一個 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>，還能預防你意外使用無效的方法建立一個 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &#39;output&#39; is of type &#39;int&#39;, not &#39;UserId&#39;</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">23413</span><span class="p">)</span> <span class="o">+</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">54341</span><span class="p">)</span>
</pre></div>
</div>
<p>注意這只會透過靜態型別檢查器強制檢查。在 runtime 中，陳述式 (statement) <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Base)</span></code> 會使 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 成為一個 callable（可呼叫物件），會立即回傳任何你傳遞的引數。這意味著 expression （運算式）<code class="docutils literal notranslate"><span class="pre">Derived(some_value)</span></code> 不會建立一個新的類別或過度引入原有的函式呼叫。</p>
<p>更精確地說，expression <code class="docutils literal notranslate"><span class="pre">some_value</span> <span class="pre">is</span> <span class="pre">Derived(some_value)</span></code> 在 runtime 永遠為 true。</p>
<p>這會無法建立一個 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 的子型別：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="c1"># Fails at runtime and does not pass type checking</span>
<span class="k">class</span> <span class="nc">AdminUserId</span><span class="p">(</span><span class="n">UserId</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</div>
<p>無論如何，這有辦法基於 '衍生的' <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 建立一個 <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewType</span></code></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="n">ProUserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;ProUserId&#39;</span><span class="p">,</span> <span class="n">UserId</span><span class="p">)</span>
</pre></div>
</div>
<p>以及針對 <code class="docutils literal notranslate"><span class="pre">ProUserId</span></code> 的型別檢查會如期運作。</p>
<p>更多細節請見 <span class="target" id="index-98"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>。</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>請記得使用型別別名是宣告兩種型別是互相<em>相等</em>的。使用 <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">Alias</span> <span class="pre">=</span> <span class="pre">Original</span></code> 則會讓靜態型別檢查器在任何情況之下將 <code class="docutils literal notranslate"><span class="pre">Alias</span></code> 視為與 <code class="docutils literal notranslate"><span class="pre">Original</span></code> <em>完全相等</em>。這當你想把複雜的型別簽名進行簡化時，非常好用。</p>
<p>相反的，<code class="docutils literal notranslate"><span class="pre">NewType</span></code> 宣告一個型別會是另外一種型別的子類別。使用 <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Original)</span></code> 會使靜態型別檢查器將 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 視為 <code class="docutils literal notranslate"><span class="pre">Original</span></code> 的子類別，也意味著一個型別為 <code class="docutils literal notranslate"><span class="pre">Original</span></code> 的值，不能被使用在任何預期接收到型別 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 的值的區域。這當你想用最小的 runtime 成本預防邏輯性錯誤而言，非常有用。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.5.2 版被加入.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版的變更: </span>現在的 <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 比起一個函式更像一個類別。因此，比起一般的函式，呼叫 <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 需要額外的 runtime 成本。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>呼叫 <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 的效能已經恢復與 Python 3.9 相同的水準。</p>
</div>
</section>
<section id="annotating-callable-objects">
<span id="annotating-callables"></span><h2>註釋 callable 物件<a class="headerlink" href="#annotating-callable-objects" title="連結到這個標頭">¶</a></h2>
<p>函式，或者是其他 <a class="reference internal" href="../glossary.html#term-callable"><span class="xref std std-term">callable</span></a> 物件，可以使用 <a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> 或 <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.Callable</span></code></a> 進行註釋。 <code class="docutils literal notranslate"><span class="pre">Callable[[int],</span> <span class="pre">str]</span></code> 象徵為一個函式，可以接受一個型別為 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 的引數，並回傳一個 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>。</p>
<p>舉例來說：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Awaitable</span>

<span class="k">def</span> <span class="nf">feeder</span><span class="p">(</span><span class="n">get_next_item</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># Body</span>

<span class="k">def</span> <span class="nf">async_query</span><span class="p">(</span><span class="n">on_success</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">on_error</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># Body</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">on_update</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># Body</span>

<span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Awaitable</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="n">on_update</span>
</pre></div>
</div>
<p>使用下標語法 (subscription syntax) 時，必須使用到兩個值，分別為引述串列以及回傳類別。引數串列必須為一個型別串列：<a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>、<a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a> 或是一個刪節號 (ellipsis)。回傳類別必為一個單一類別。</p>
<p>若刪節號文字 <code class="docutils literal notranslate"><span class="pre">...</span></code> 被當作引數串列給定，其指出一個具任何、任意參數列表的 callable 會被接受：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">x</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">str</span>     <span class="c1"># OK</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">concat</span>  <span class="c1"># Also OK</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Callable</span></code> 不如有可變數量引數的函式、<a class="reference internal" href="#typing.overload" title="typing.overload"><code class="xref py py-func docutils literal notranslate"><span class="pre">overloaded</span> <span class="pre">functions</span></code></a>、或是僅限關鍵字參數的函式，可以表示複雜簽名。然而，這些簽名可以透過定義一個具有 <a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> 方法的 <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> 類別進行表示：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Protocol</span>

<span class="k">class</span> <span class="nc">Combiner</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">vals</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">batch_proc</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">cb_results</span><span class="p">:</span> <span class="n">Combiner</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="o">...</span>

<span class="k">def</span> <span class="nf">good_cb</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">bad_cb</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">maxitems</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="n">batch_proc</span><span class="p">([],</span> <span class="n">good_cb</span><span class="p">)</span>  <span class="c1"># OK</span>
<span class="n">batch_proc</span><span class="p">([],</span> <span class="n">bad_cb</span><span class="p">)</span>   <span class="c1"># Error! Argument 2 has incompatible type because of</span>
                         <span class="c1"># different name and kind in the callback</span>
</pre></div>
</div>
<p>Callable 物件可以取用其他 callable 當作引數使用，可以透過 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 指出他們的參數型別是個別獨立的。另外，如果這個 callable 從其他 callable 新增或刪除引數時，將會使用到 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a> 運算子。他們可以分別採用 <code class="docutils literal notranslate"><span class="pre">Callable[ParamSpecVariable,</span> <span class="pre">ReturnType]</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">Callable[Concatenate[Arg1Type,</span> <span class="pre">Arg2Type,</span> <span class="pre">...,</span> <span class="pre">ParamSpecVariable],</span> <span class="pre">ReturnType]</span></code> 的形式。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版的變更: </span><code class="docutils literal notranslate"><span class="pre">Callable</span></code> 現已支援 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 以及 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>。請參閱 <span class="target" id="index-99"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> 閱讀詳細內容。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p><a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 以及 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Concatenate</span></code></a> 的文件中，提供範例如何在 <code class="docutils literal notranslate"><span class="pre">Callable</span></code> 中使用。</p>
</div>
</section>
<section id="generics">
<span id="id3"></span><h2>泛型<a class="headerlink" href="#generics" title="連結到這個標頭">¶</a></h2>
<p>因為關於物件的型別資訊留存在容器之內，且無法使用通用的方式進行靜態推論 (statically inferred)，許多標準函式庫的容器類別支援以下標來表示容器內預期的元素。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">class</span> <span class="nc">Employee</span><span class="p">:</span> <span class="o">...</span>

<span class="c1"># Sequence[Employee] indicates that all elements in the sequence</span>
<span class="c1"># must be instances of &quot;Employee&quot;.</span>
<span class="c1"># Mapping[str, str] indicates that all keys and all values in the mapping</span>
<span class="c1"># must be strings.</span>
<span class="k">def</span> <span class="nf">notify_by_email</span><span class="p">(</span><span class="n">employees</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Employee</span><span class="p">],</span>
                    <span class="n">overrides</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>泛型函式及類別可以使用<a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">型別參數語法 (type parameter syntax)</span></a> 進行參數化 (parameterize) ：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>  <span class="c1"># Function is generic over the TypeVar &quot;T&quot;</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>或是直接使用 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 工廠 (factory)：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">U</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>                  <span class="c1"># Declare type variable &quot;U&quot;</span>

<span class="k">def</span> <span class="nf">second</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">U</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">U</span><span class="p">:</span>  <span class="c1"># Function is generic over the TypeVar &quot;U&quot;</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版的變更: </span>在 Python 3.12 中，泛型的語法支援是全新功能。</p>
</div>
</section>
<section id="annotating-tuples">
<span id="id4"></span><h2>註釋元組 (tuple)<a class="headerlink" href="#annotating-tuples" title="連結到這個標頭">¶</a></h2>
<p>在 Python 大多數的容器當中，加註型別系統認為容器內的所有元素會是相同型別。舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>

<span class="c1"># Type checker will infer that all elements in ``x`` are meant to be ints</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Type checker error: ``list`` only accepts a single type argument:</span>
<span class="n">y</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">]</span>

<span class="c1"># Type checker will infer that all keys in ``z`` are meant to be strings,</span>
<span class="c1"># and that all values in ``z`` are meant to be either strings or ints</span>
<span class="n">z</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 只接受一個型別引數，所以型別檢查器可能在上述 <code class="docutils literal notranslate"><span class="pre">y</span></code> 賦值 (assignment) 觸發錯誤。類似的範例，<a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a> 只接受兩個型別引數：第一個引數指出 keys（鍵）的型別；第二個引數指出 values（值）的型別。</p>
<p>然而，與其他多數的 Python 容器不同，在慣用的 (idiomatic) Python 程式碼中，元組可以擁有不完全相同型別的元素是相當常見的。為此，元組在 Python 的加註型別系統中是個特例 (special-cased)。<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 接受<em>任何數量</em>的型別引數：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># OK: ``x`` is assigned to a tuple of length 1 where the sole element is an int</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)</span>

<span class="c1"># OK: ``y`` is assigned to a tuple of length 2;</span>
<span class="c1"># element 1 is an int, element 2 is a str</span>
<span class="n">y</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># Error: the type annotation indicates a tuple of length 1,</span>
<span class="c1"># but ``z`` has been assigned to a tuple of length 3</span>
<span class="n">z</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>為了標示一個元組可以為<em>任意</em>長度，且所有元素皆是相同型別 <code class="docutils literal notranslate"><span class="pre">T</span></code>，請使用 <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">...]</span></code> 進行標示。為了標示一個空元組，請使用 <code class="docutils literal notranslate"><span class="pre">tuple[()]</span></code>。單純使用 <code class="docutils literal notranslate"><span class="pre">tuple</span></code> 作為註釋，會與使用 <code class="docutils literal notranslate"><span class="pre">tuple[Any,</span> <span class="pre">...]</span></code> 是相等的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># These reassignments are OK: ``tuple[int, ...]`` indicates x can be of any length</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">()</span>
<span class="c1"># This reassignment is an error: all elements in ``x`` must be ints</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>

<span class="c1"># ``y`` can only ever be assigned to an empty tuple</span>
<span class="n">y</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[()]</span> <span class="o">=</span> <span class="p">()</span>

<span class="n">z</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="c1"># These reassignments are OK: plain ``tuple`` is equivalent to ``tuple[Any, ...]``</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">()</span>
</pre></div>
</div>
</section>
<section id="the-type-of-class-objects">
<span id="type-of-class-objects"></span><h2>類別物件的型別<a class="headerlink" href="#the-type-of-class-objects" title="連結到這個標頭">¶</a></h2>
<p>一個變數被註釋為 <code class="docutils literal notranslate"><span class="pre">C</span></code> 可以接受一個型別為 <code class="docutils literal notranslate"><span class="pre">C</span></code> 的值。相對的，一個變數備註解為 <code class="docutils literal notranslate"><span class="pre">type[C]</span></code> （或 <a class="reference internal" href="#typing.Type" title="typing.Type"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Type[C]</span></code></a>）可以接受本身為該類別的值 -- 具體來說，他可能會接受 <code class="docutils literal notranslate"><span class="pre">C</span></code> 的<em>類別物件</em>。舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>         <span class="c1"># Has type ``int``</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">int</span>       <span class="c1"># Has type ``type[int]``</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># Also has type ``type[int]``</span>
</pre></div>
</div>
<p>請記得 <code class="docutils literal notranslate"><span class="pre">type[C]</span></code> 是共變 (covariant) 的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">ProUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">TeamUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">make_new_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">User</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">User</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">user_class</span><span class="p">()</span>

<span class="n">make_new_user</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>      <span class="c1"># OK</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="n">ProUser</span><span class="p">)</span>   <span class="c1"># Also OK: ``type[ProUser]`` is a subtype of ``type[User]``</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="n">TeamUser</span><span class="p">)</span>  <span class="c1"># Still fine</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="n">User</span><span class="p">())</span>    <span class="c1"># Error: expected ``type[User]`` but got ``User``</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>       <span class="c1"># Error: ``type[int]`` is not a subtype of ``type[User]``</span>
</pre></div>
</div>
<p><a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 僅有的合法參數是類別、<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>、<a class="reference internal" href="#generics"><span class="std std-ref">型別變數</span></a>以及這些型別任意組合成的聯集。舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">new_non_team_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">BasicUser</span> <span class="o">|</span> <span class="n">ProUser</span><span class="p">]):</span> <span class="o">...</span>

<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">BasicUser</span><span class="p">)</span>  <span class="c1"># OK</span>
<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">ProUser</span><span class="p">)</span>    <span class="c1"># OK</span>
<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">TeamUser</span><span class="p">)</span>   <span class="c1"># Error: ``type[TeamUser]`` is not a subtype</span>
                              <span class="c1"># of ``type[BasicUser | ProUser]``</span>
<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>       <span class="c1"># Also an error</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">type[Any]</span></code> 等價於 <a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> ，其為 Python <a class="reference internal" href="../reference/datamodel.html#metaclasses"><span class="std std-ref">metaclass 階層結構 (hierachy)</span></a>。</p>
</section>
<section id="user-defined-generic-types">
<span id="user-defined-generics"></span><h2>使用者定義泛型型別<a class="headerlink" href="#user-defined-generic-types" title="連結到這個標頭">¶</a></h2>
<p>一個使用者定義的類別可以被定義成一個泛型類別。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">Logger</span>

<span class="k">class</span> <span class="nc">LoggedVar</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Set &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Get &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p>這個語法指出類別 <code class="docutils literal notranslate"><span class="pre">LoggedVar</span></code> 透過一個單一的 <a class="reference internal" href="#typevar"><span class="std std-ref">型別變數</span></a> <code class="docutils literal notranslate"><span class="pre">T</span></code> 進行參數化 (parameterised)。這使得 <code class="docutils literal notranslate"><span class="pre">T</span></code> 在類別中有效的成為型別。</p>
<p>泛型類別隱性繼承了 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>。為了相容 Python 3.11 及更早版本，也可以明確的繼承 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 並指出是一個泛型類別：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LoggedVar</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>泛型類別有 <a class="reference internal" href="../reference/datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> 方法，其意味著可以在 runtime 進行參數化（如下述的 <code class="docutils literal notranslate"><span class="pre">LoggedVar[int]</span></code>）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">def</span> <span class="nf">zero_all_vars</span><span class="p">(</span><span class="nb">vars</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">LoggedVar</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">var</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>一個泛型型別可以有任意數量的型別變數。所有種類的 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 都可以作為泛型型別的參數：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">class</span> <span class="nc">WeirdTrio</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">S</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)]:</span>
    <span class="o">...</span>

<span class="n">OldT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;OldT&#39;</span><span class="p">,</span> <span class="n">contravariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">OldB</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;OldB&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">OldS</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;OldS&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">OldWeirdTrio</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">OldT</span><span class="p">,</span> <span class="n">OldB</span><span class="p">,</span> <span class="n">OldS</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 的每個型別變數引數必不相同。因此以下是無效的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="k">class</span> <span class="nc">Pair</span><span class="p">[</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">]:</span>  <span class="c1"># SyntaxError</span>
    <span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>   <span class="c1"># INVALID</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>泛型類別亦可以繼承其他類別：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sized</span>

<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Sized</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>當繼承泛型類別時，部份的型別參數可固定：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>

<span class="k">class</span> <span class="nc">MyDict</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>在這種情況下 <code class="docutils literal notranslate"><span class="pre">MyDict</span></code> 有一個單一的參數 <code class="docutils literal notranslate"><span class="pre">T</span></code>。</p>
<p>若使用泛型類別卻沒有特指型別參數，則會將每個位置視為 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>。在下列的範例中 <code class="docutils literal notranslate"><span class="pre">MyIterable</span></code> 不是泛型，但隱性繼承了 <code class="docutils literal notranslate"><span class="pre">Iterable[Any]</span></code>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">MyIterable</span><span class="p">(</span><span class="n">Iterable</span><span class="p">):</span> <span class="c1"># Same as Iterable[Any]</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>使用者定義的泛型型別別名也有支援。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="nb">type</span> <span class="n">Response</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span>

<span class="c1"># Return type here is same as Iterable[str] | int</span>
<span class="k">def</span> <span class="nf">response</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="nb">type</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">inproduct</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)](</span><span class="n">v</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="c1"># Same as Iterable[tuple[T, T]]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>為了向後相容性，泛型型別別名可以透過簡單的賦值來建立：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
<span class="n">Response</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 不再是一個自訂的 metaclass。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版的變更: </span>在版本 3.12 新增了泛型及型別別名的語法支援。在之前的版本中，泛型類別必須顯性繼承 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 或是包含一個型別變數在基底類別 (base) 當中。</p>
</div>
<p>使用者定義的參數運算式 (parameter expression) 泛型一樣有支援，透過 <code class="docutils literal notranslate"><span class="pre">[**P]</span></code> 格式的參數規格變數來進行表示。對於上述作為參數規格變數的型別變數，將持續被型別模組視為一個特定的型別變數。對此，其中一個例外是一個型別列表可以替代 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Z</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">P</span><span class="p">]:</span> <span class="o">...</span>  <span class="c1"># T is a TypeVar; P is a ParamSpec</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Z</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span>
<span class="go">__main__.Z[int, [dict, float]]</span>
</pre></div>
</div>
<p>具有 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 的泛型類別可以透過顯性繼承 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 進行建立。在這種情況下，不需要使用 <code class="docutils literal notranslate"><span class="pre">**</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">Generic</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Z</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">P</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>另外一個 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 以及 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 之間的差異是，基於美觀因素，只有一個參數規格變數的泛型可以接受如 <code class="docutils literal notranslate"><span class="pre">X[[Type1,</span> <span class="pre">Type2,</span> <span class="pre">...]]</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">X[Type1,</span> <span class="pre">Type2,</span> <span class="pre">...]</span></code> 的參數列表。在內部中，後者會被轉換為前者，所以在下方的範例中為相等的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">[</span><span class="o">**</span><span class="n">P</span><span class="p">]:</span> <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="go">__main__.X[[int, str]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
<span class="go">__main__.X[[int, str]]</span>
</pre></div>
</div>
<p>請記得，具有 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 的泛型在某些情況下替換之後可能不會有正確的 <code class="docutils literal notranslate"><span class="pre">__parameters__</span></code>，因為參數規格主要還是用於靜態型別檢查。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版的變更: </span><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 現在可以透過參數運算式來進行參數化。詳細內容請見 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 以及 <span class="target" id="index-100"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a>。</p>
</div>
<p>一個使用者定義的泛型類別可以將 ABC 作為他們的基底類別，且不會有 metaclass 衝突。泛型的 metaclass 則不支援。參數化泛型的輸出將被存為快取，而在型別模組中多數的型別皆為 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> 且可以比較相等性。</p>
</section>
<section id="the-any-type">
<h2><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 型別<a class="headerlink" href="#the-any-type" title="連結到這個標頭">¶</a></h2>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 是一種特別的型別。一個靜態型別檢查器會將每個型別視為可相容於 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 且 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 也可以相容於每個型別。</p>
<p>這意味著如果在一個為 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 的值上執行任何操作或呼叫方法是可行的，且可以賦值給任意變數：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>          <span class="c1"># OK</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>           <span class="c1"># OK</span>

<span class="n">s</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">a</span>           <span class="c1"># OK</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Passes type checking; &#39;item&#39; could be any type,</span>
    <span class="c1"># and that type might have a &#39;bar&#39; method</span>
    <span class="n">item</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>請注意，當賦予型別為 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 的值更精確的型別時，將不會執行任何型別檢查。舉例來說，靜態型別檢查器不會在 runtime 中，將 <code class="docutils literal notranslate"><span class="pre">a</span></code> 賦值給 <code class="docutils literal notranslate"><span class="pre">s</span></code> 的情況下回報錯誤，儘管 <code class="docutils literal notranslate"><span class="pre">s</span></code> 是被宣告為型別 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 卻接收到 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 的值！</p>
<p>另外，所有缺少回傳型別或參數型別的函式將會隱性預設為 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="c1"># A static type checker will treat the above</span>
<span class="c1"># as having the same signature as:</span>
<span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p>當你需要混和動態及靜態的型別程式碼，這個行為允許 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 被當作一個<em>緊急出口 (escape hatch)</em>使用。</p>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 的行為對比 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的行為。與 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 相似，所有的型別會作為 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的子型別。然而，不像 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>，反之不亦然：<a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 並<em>不是</em>一個其他型別的子型別。</p>
<p>這意味著當一個值的型別為 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 時，型別檢查器會拒絕幾乎所有的操作，並將賦予這個值到一個特定型別變數（或是當作回傳值使用）視為一個型別錯誤。舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hash_a</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Fails type checking; an object does not have a &#39;magic&#39; method.</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">hash_b</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Passes type checking</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="c1"># Passes type checking, since ints and strs are subclasses of object</span>
<span class="n">hash_a</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_a</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># Passes type checking, since Any is compatible with all types</span>
<span class="n">hash_b</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_b</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> ，將指出在型別安全 (typesafe) 的習慣之下一個值可以為任意型別。使用 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>，將指出這個值是個動態型別。</p>
</section>
<section id="nominal-vs-structural-subtyping">
<h2>標稱 (nominal) 子型別 vs 結構子型別<a class="headerlink" href="#nominal-vs-structural-subtyping" title="連結到這個標頭">¶</a></h2>
<p>最初 <span class="target" id="index-101"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 定義 Python 靜態型別系統使用<em>標稱子型別</em>。這意味著只有 <code class="docutils literal notranslate"><span class="pre">A</span></code> 為 <code class="docutils literal notranslate"><span class="pre">B</span></code> 的子類別時，<code class="docutils literal notranslate"><span class="pre">A</span></code> 才被允許使用在預期是類別 <code class="docutils literal notranslate"><span class="pre">B</span></code> 出現的地方。</p>
<p>這個需求之前也被運用在抽象基底類別，例如 <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>。這種方式的問題在於，一個類別需要顯式的標記來支援他們，這並不符合 Python 風格，也不像一個常見的慣用動態型別 Python 程式碼。舉例來說，下列程式碼符合 <span class="target" id="index-102"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="k">class</span> <span class="nc">Bucket</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p><span class="target" id="index-103"></span><a class="pep reference external" href="https://peps.python.org/pep-0544/"><strong>PEP 544</strong></a> 可以透過使用上方的程式碼，且在類別定義時不用顯式基底類別解決這個問題，讓 <code class="docutils literal notranslate"><span class="pre">Bucket</span></code> 被靜態型別檢查器隱性認為是 <code class="docutils literal notranslate"><span class="pre">Sized</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">Iterable[int]</span></code> 兩者的子型別。這就是眾所周知的<em>結構子型別</em>（或是靜態鴨子型別）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">Bucket</span><span class="p">:</span>  <span class="c1"># Note: no base classes</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">Bucket</span><span class="p">())</span>  <span class="c1"># Passes type check</span>
</pre></div>
</div>
<p>而且，基於一個特別的型別  <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> 建立子型別時，使用者可以定義新的協定並充份發揮結構子型別的優勢（請見下方範例）。</p>
</section>
<section id="module-contents">
<h2>模組內容<a class="headerlink" href="#module-contents" title="連結到這個標頭">¶</a></h2>
<p>模組 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 定義了下列的類別、函式以及裝飾器。</p>
<section id="special-typing-primitives">
<h3>特別型別原語 (primitive)<a class="headerlink" href="#special-typing-primitives" title="連結到這個標頭">¶</a></h3>
<section id="special-types">
<h4>特別型別<a class="headerlink" href="#special-types" title="連結到這個標頭">¶</a></h4>
<p>這些可以在註釋中做為型別。他們並不支援 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 的下標使用。</p>
<dl class="py data">
<dt class="sig sig-object py" id="typing.Any">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Any</span></span><a class="headerlink" href="#typing.Any" title="連結到這個定義">¶</a></dt>
<dd><p>特別型別，指出一個不受約束 (unconstrained) 的型別。</p>
<ul class="simple">
<li><p>所有型別皆與 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 相容。</p></li>
<li><p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 相容於所有型別。</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 可以作為一個基礎類別。這對於在任何地方使用鴨子型別或是高度動態的型別，避免型別檢查器的錯誤是非常有用的。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.AnyStr">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AnyStr</span></span><a class="headerlink" href="#typing.AnyStr" title="連結到這個定義">¶</a></dt>
<dd><p>一個<a class="reference internal" href="#typing-constrained-typevar"><span class="std std-ref">不受約束的型別變數</span></a>。</p>
<p>定義：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">AnyStr</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;AnyStr&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> 是對於函式有用的，他可以接受 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 引數但不可以將此兩種混合。</p>
<p>舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">concat</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>    <span class="c1"># OK, output has type &#39;str&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># OK, output has type &#39;bytes&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>   <span class="c1"># Error, cannot mix str and bytes</span>
</pre></div>
</div>
<p>請注意，儘管他的名稱相近，<code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> 與 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal notranslate"><span class="pre">Any</span></code></a> 型別無關，更不代表是「任何字串」的意思。尤其，<code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> 與 <code class="docutils literal notranslate"><span class="pre">str</span> <span class="pre">|</span> <span class="pre">bytes</span></code> 兩者不同且具有不同的使用情境：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Invalid use of AnyStr:</span>
<span class="c1"># The type variable is used only once in the function signature,</span>
<span class="c1"># so cannot be &quot;solved&quot; by the type checker</span>
<span class="k">def</span> <span class="nf">greet_bad</span><span class="p">(</span><span class="n">cond</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">&quot;hi there!&quot;</span> <span class="k">if</span> <span class="n">cond</span> <span class="k">else</span> <span class="sa">b</span><span class="s2">&quot;greetings!&quot;</span>

<span class="c1"># The better way of annotating this function:</span>
<span class="k">def</span> <span class="nf">greet_proper</span><span class="p">(</span><span class="n">cond</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">bytes</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">&quot;hi there!&quot;</span> <span class="k">if</span> <span class="n">cond</span> <span class="k">else</span> <span class="sa">b</span><span class="s2">&quot;greetings!&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.LiteralString">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">LiteralString</span></span><a class="headerlink" href="#typing.LiteralString" title="連結到這個定義">¶</a></dt>
<dd><p>特別型別，只包含文本字串。</p>
<p>任何文本字串都相容於 <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code>，對於另一個 <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> 亦是如此。然而，若是一個型別僅為 <code class="docutils literal notranslate"><span class="pre">str</span></code> 的物件則不相容。一個字串若是透過組合多個 <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> 型別的物件建立，則此字串也可以視為 <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code>。</p>
<p>舉例來說：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_query</span><span class="p">(</span><span class="n">sql</span><span class="p">:</span> <span class="n">LiteralString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">caller</span><span class="p">(</span><span class="n">arbitrary_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">literal_string</span><span class="p">:</span> <span class="n">LiteralString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM students&quot;</span><span class="p">)</span>  <span class="c1"># OK</span>
    <span class="n">run_query</span><span class="p">(</span><span class="n">literal_string</span><span class="p">)</span>  <span class="c1"># OK</span>
    <span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM &quot;</span> <span class="o">+</span> <span class="n">literal_string</span><span class="p">)</span>  <span class="c1"># OK</span>
    <span class="n">run_query</span><span class="p">(</span><span class="n">arbitrary_string</span><span class="p">)</span>  <span class="c1"># type checker error</span>
    <span class="n">run_query</span><span class="p">(</span>  <span class="c1"># type checker error</span>
        <span class="sa">f</span><span class="s2">&quot;SELECT * FROM students WHERE name = </span><span class="si">{</span><span class="n">arbitrary_string</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> 對於敏感的 API 來說是有用的，其中任意的使用者產生的字串可能會產生問題。舉例來說，上面兩個案例中產生的型別檢查器錯誤是脆弱的且容易受到 SQL 注入攻擊。</p>
<p>更多細節請見 <span class="target" id="index-104"></span><a class="pep reference external" href="https://peps.python.org/pep-0675/"><strong>PEP 675</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Never">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Never</span></span><a class="headerlink" href="#typing.Never" title="連結到這個定義">¶</a></dt>
<dt class="sig sig-object py" id="typing.NoReturn">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NoReturn</span></span><a class="headerlink" href="#typing.NoReturn" title="連結到這個定義">¶</a></dt>
<dd><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code> 和 <code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code> 表示<a class="reference external" href="https://en.wikipedia.org/wiki/Bottom_type">底部型別 (bottom type)</a>，為一個沒有任何成員的型別。</p>
<p>它們可以被用來代表一個不會回傳的函式，像是 <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Never</span>  <span class="c1"># or NoReturn</span>

<span class="k">def</span> <span class="nf">stop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Never</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;no way&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>或被用來定義一個不應被呼叫的函式，因為不會有有效的引數，、像是 <a class="reference internal" href="#typing.assert_never" title="typing.assert_never"><code class="xref py py-func docutils literal notranslate"><span class="pre">assert_never()</span></code></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Never</span>  <span class="c1"># or NoReturn</span>

<span class="k">def</span> <span class="nf">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Never</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">int_or_str</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>  <span class="c1"># type checker error</span>
    <span class="k">match</span> <span class="n">arg</span><span class="p">:</span>
        <span class="k">case</span> <span class="nb">int</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s an int&quot;</span><span class="p">)</span>
        <span class="k">case</span> <span class="nb">str</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s a str&quot;</span><span class="p">)</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="n">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>  <span class="c1"># OK, arg is of type Never (or NoReturn)</span>
</pre></div>
</div>
<p><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code> 以及 <code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code> 在型別系統中具有相同的意義且靜態型別檢查器會將兩者視為相等。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.6.2 版被加入: </span>新增 <a class="reference internal" href="#typing.NoReturn" title="typing.NoReturn"><code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code></a>。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入: </span>新增 <a class="reference internal" href="#typing.Never" title="typing.Never"><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Self">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Self</span></span><a class="headerlink" href="#typing.Self" title="連結到這個定義">¶</a></dt>
<dd><p>特別型別，用來表示當前類別之內 (enclosed class)。</p>
<p>舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Self</span><span class="p">,</span> <span class="n">reveal_type</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">return_self</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="k">class</span> <span class="nc">SubclassOfFoo</span><span class="p">(</span><span class="n">Foo</span><span class="p">):</span> <span class="k">pass</span>

<span class="n">reveal_type</span><span class="p">(</span><span class="n">Foo</span><span class="p">()</span><span class="o">.</span><span class="n">return_self</span><span class="p">())</span>  <span class="c1"># Revealed type is &quot;Foo&quot;</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">SubclassOfFoo</span><span class="p">()</span><span class="o">.</span><span class="n">return_self</span><span class="p">())</span>  <span class="c1"># Revealed type is &quot;SubclassOfFoo&quot;</span>
</pre></div>
</div>
<p>這個註釋在語意上相等於下列內容，且形式更為簡潔：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">Self</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Self&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Foo&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">return_self</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<p>一般來說，如果某個東西回傳 <code class="docutils literal notranslate"><span class="pre">self</span></code> 如上方的範例所示，你則應該使用 <code class="docutils literal notranslate"><span class="pre">Self</span></code> 做為回傳值的註釋。若 <code class="docutils literal notranslate"><span class="pre">Foo.return_self</span></code> 被註釋為回傳 <code class="docutils literal notranslate"><span class="pre">&quot;Foo&quot;</span></code>，則型別檢查器應該推論這個從 <code class="docutils literal notranslate"><span class="pre">SubclassOfFoo.return_self</span></code> 回傳的物件為 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 型別，而並非回傳 <code class="docutils literal notranslate"><span class="pre">SubclassOfFoo</span></code> 型別。</p>
<p>其他常見的使用案例包含：</p>
<ul class="simple">
<li><p><a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a> 被用來作為替代的建構函式 (constructor) 並回傳 <code class="docutils literal notranslate"><span class="pre">cls</span></code> 參數的實例。</p></li>
<li><p>註釋一個回傳自己的 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 方法。</p></li>
</ul>
<p>當類別被子類別化時，若方法不保證回傳一個子類別的實例，你不應該使用 <code class="docutils literal notranslate"><span class="pre">Self</span></code> 作為回傳註釋：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Eggs</span><span class="p">:</span>
    <span class="c1"># Self would be an incorrect return annotation here,</span>
    <span class="c1"># as the object returned is always an instance of Eggs,</span>
    <span class="c1"># even in subclasses</span>
    <span class="k">def</span> <span class="nf">returns_eggs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Eggs&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Eggs</span><span class="p">()</span>
</pre></div>
</div>
<p>更多細節請見 <span class="target" id="index-105"></span><a class="pep reference external" href="https://peps.python.org/pep-0673/"><strong>PEP 673</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.TypeAlias">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeAlias</span></span><a class="headerlink" href="#typing.TypeAlias" title="連結到這個定義">¶</a></dt>
<dd><p>做為明確宣告一個<a class="reference internal" href="#type-aliases"><span class="std std-ref">型別別名</span></a> 的特別註釋。</p>
<p>舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="n">Factors</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypeAlias</span></code> 在舊的 Python 版本中特別有用，其註釋別名可以用來進行傳遞參照 (forward reference)，因為對於型別檢查器來說，分辨這些別名與一般的變數賦值相當困難：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">TypeAlias</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="c1"># &quot;Box&quot; does not exist yet,</span>
<span class="c1"># so we have to use quotes for the forward reference on Python &lt;3.12.</span>
<span class="c1"># Using ``TypeAlias`` tells the type checker that this is a type alias declaration,</span>
<span class="c1"># not a variable assignment to a string.</span>
<span class="n">BoxOfStrings</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="s2">&quot;Box[str]&quot;</span>

<span class="k">class</span> <span class="nc">Box</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">make_box_of_strings</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BoxOfStrings</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>更多細節請見 <span class="target" id="index-106"></span><a class="pep reference external" href="https://peps.python.org/pep-0613/"><strong>PEP 613</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.10 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.12 版之後被棄用: </span><a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> 被棄用，請改用 <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 陳述式來建立 <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a> 的實例，其自然可以支援傳遞參照的使用。請注意，雖然 <a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> 以及 <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a> 提供相似的用途且具有相似的名稱，他們是不同的，且後者不是前者的型別。現在還沒有移除 <a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> 的計畫，但鼓勵使用者們遷移 (migrate) 至 <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 陳述式。</p>
</div>
</dd></dl>

</section>
<section id="special-forms">
<h4>特別型式<a class="headerlink" href="#special-forms" title="連結到這個標頭">¶</a></h4>
<p>這些在註釋中可以當作型別使用。他們全都支援 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 的下標使用，但每個都具有獨特的語法。</p>
<dl class="py data">
<dt class="sig sig-object py" id="typing.Union">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Union</span></span><a class="headerlink" href="#typing.Union" title="連結到這個定義">¶</a></dt>
<dd><p>聯集型別；<code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">Y]</span></code> 與 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code> 是相等的，且都意味著 X 或 Y 兩者其一。</p>
<p>為了定義聯集，例如可以使用 <code class="docutils literal notranslate"><span class="pre">Union[int,</span> <span class="pre">str]</span></code> 或是使用簡寫 (shorthand) <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">|</span> <span class="pre">str</span></code>。使用這種簡寫是非常推薦的。詳細請看：</p>
<ul>
<li><p>引數必須為型別且必須有至少一個。</p></li>
<li><p>聯集中的聯集會是扁平化的 (flattened)，舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>單一引數的聯集會消失不見，舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span>  <span class="c1"># The constructor actually returns int</span>
</pre></div>
</div>
</li>
<li><p>多餘的引數會被略過，舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span>
</pre></div>
</div>
</li>
<li><p>當比較聯集時，引數的順序會被忽略，舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>你不能建立 <code class="docutils literal notranslate"><span class="pre">Union</span></code> 的子類別或是實例。</p></li>
<li><p>你不能寫成 <code class="docutils literal notranslate"><span class="pre">Union[X][Y]</span></code>。</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版的變更: </span>請勿在 runtime 中將顯性子類別從聯集中移除。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版的變更: </span>現在可以將聯集寫成 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code>。請見<a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">聯集型別運算式</span></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Optional">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Optional</span></span><a class="headerlink" href="#typing.Optional" title="連結到這個定義">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Optional[X]</span></code> 與 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">None</span></code> 是相等的（或是 <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">None]</span></code>）。</p>
<p>請注意，這與具有預設值的選擇性引數 (optional argument) 不是相同的概念。一個具有預設值的選擇性引數的型別註釋中不具有 <code class="docutils literal notranslate"><span class="pre">Optional</span></code> 限定符 (qualifier)，單純的因為它就是選擇性的。舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>另一方面，如果一個顯性的值 <code class="docutils literal notranslate"><span class="pre">None</span></code> 是被允許的，不論引數是不是選擇性的，<code class="docutils literal notranslate"><span class="pre">Optional</span></code> 都適用。舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版的變更: </span>現在可以將 Optional 寫成 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">None</span></code>。請見<a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">聯集型別運算式</span></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Concatenate">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Concatenate</span></span><a class="headerlink" href="#typing.Concatenate" title="連結到這個定義">¶</a></dt>
<dd><p>用於註釋高階函式的特別型式。</p>
<p><code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 可以被用在<a class="reference internal" href="#annotating-callables"><span class="std std-ref">可呼叫物件</span></a>與 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 的接合 (conjunction) 並註釋一個高階的 Callable 物件可以新增、移除、轉換另一個 Callable 物件的參數。使用方法是依照這個格式 <code class="docutils literal notranslate"><span class="pre">Concatenate[Arg1Type,</span> <span class="pre">Arg2Type,</span> <span class="pre">...,</span> <span class="pre">ParamSpecVariable]</span></code>。<code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 目前只在 <a class="reference internal" href="#annotating-callables"><span class="std std-ref">Callable 物件</span></a>中第一個引數使用時有效。<code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 的最後一個參數必須為一個 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 或是刪節號 (<code class="docutils literal notranslate"><span class="pre">...</span></code>)。</p>
<p>舉例來說，註釋一個為裝飾過後的函式提供 <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a> 的裝飾器 <code class="docutils literal notranslate"><span class="pre">with_lock</span></code>，<code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 可以用於指出 <code class="docutils literal notranslate"><span class="pre">with_lock</span></code> 預期一個 Callable 物件，該物件可以接受 <code class="docutils literal notranslate"><span class="pre">Lock</span></code> 作為第一引數，並回傳一個具有不同型別簽名 Callable 物件。在這種情況下，<a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 指出回傳的 Callable 物件的參數型別會依賴傳遞的 Callable 物件的參數型別：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Lock</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Concatenate</span>

<span class="c1"># Use this lock to ensure that only one thread is executing a function</span>
<span class="c1"># at any time.</span>
<span class="n">my_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">with_lock</span><span class="p">[</span><span class="o">**</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">](</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">Concatenate</span><span class="p">[</span><span class="n">Lock</span><span class="p">,</span> <span class="n">P</span><span class="p">],</span> <span class="n">R</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A type-safe decorator which provides a lock.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="p">:</span>
        <span class="c1"># Provide the lock as the first argument.</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">my_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="nd">@with_lock</span>
<span class="k">def</span> <span class="nf">sum_threadsafe</span><span class="p">(</span><span class="n">lock</span><span class="p">:</span> <span class="n">Lock</span><span class="p">,</span> <span class="n">numbers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Add a list of numbers together in a thread-safe manner.&#39;&#39;&#39;</span>
    <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>

<span class="c1"># We don&#39;t need to pass in the lock ourselves thanks to the decorator.</span>
<span class="n">sum_threadsafe</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.10 版被加入.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<ul class="simple">
<li><p><span class="target" id="index-107"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> -- 參數技術規範變數</p></li>
<li><p><a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a></p></li>
<li><p><a class="reference internal" href="#annotating-callables"><span class="std std-ref">註釋 callable 物件</span></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Literal">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Literal</span></span><a class="headerlink" href="#typing.Literal" title="連結到這個定義">¶</a></dt>
<dd><p>特殊型別格式，用於定義「文本型別 (literal type)」。</p>
<p><code class="docutils literal notranslate"><span class="pre">Literal</span></code> 可以用於型別檢查器並指出註釋物件具有一個與提供的文本相同的值。</p>
<p>舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">validate_simple</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]:</span>  <span class="c1"># always returns True</span>
    <span class="o">...</span>

<span class="nb">type</span> <span class="n">Mode</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">open_helper</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">Mode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/some/path&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>      <span class="c1"># Passes type check</span>
<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/other/path&#39;</span><span class="p">,</span> <span class="s1">&#39;typo&#39;</span><span class="p">)</span>  <span class="c1"># Error in type checker</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> 不可以進行子類別化。在 runtime 之中，任意的值是允許作為 <code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> 的型別引數，但型別檢查器可能會加強限制。更多有關文本型別的詳細資訊請看 <span class="target" id="index-108"></span><a class="pep reference external" href="https://peps.python.org/pep-0586/"><strong>PEP 586</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.8 版被加入.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9.1 版的變更: </span><code class="docutils literal notranslate"><span class="pre">Literal</span></code> 現在可以刪除重複 (de-deplicate) 的參數。<code class="docutils literal notranslate"><span class="pre">Literal</span></code> 物件的相等性比較不再依照相依性排序。<code class="docutils literal notranslate"><span class="pre">Literal</span></code> 物件現在會在相等性比較期間，若任一個其中的參數無法 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> 時，則會引發一個 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 例外。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.ClassVar">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ClassVar</span></span><a class="headerlink" href="#typing.ClassVar" title="連結到這個定義">¶</a></dt>
<dd><p>特殊型別建構，用來標記類別變數。</p>
<p>如同在 <span class="target" id="index-109"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a> 中的介紹，一個變數註解被包裝在 ClassVar 中時，會指出一個給定的屬性 (attribute) 意圖被當作類別變數使用，且不該被設定成該類別的實例。使用方法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Starship</span><span class="p">:</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># class variable</span>
    <span class="n">damage</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>                     <span class="c1"># instance variable</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 只接受型別請不得使用下標。</p>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 並不代表該類別本身，而且不應該和 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 或是 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 一起使用。<a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 不會改變 Python runtime 的行為，但它可以被第三方的型別檢查器使用。舉例來說，一個型別檢查器可能會標記下方的程式碼為一個錯誤：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">enterprise_d</span> <span class="o">=</span> <span class="n">Starship</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>
<span class="n">enterprise_d</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Error, setting class variable on instance</span>
<span class="n">Starship</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>     <span class="c1"># This is OK</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.5.3 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Final">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Final</span></span><a class="headerlink" href="#typing.Final" title="連結到這個定義">¶</a></dt>
<dd><p>特殊型別建構，用來指出最終名稱給型別檢查器。</p>
<p>最終名稱不可以在任何作用域 (scope) 中重新賦值。在類別作用域中宣告的最終名稱，不得在子類別中進行覆寫 (override)。</p>
<p>舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">MAX_SIZE</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="mi">9000</span>
<span class="n">MAX_SIZE</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Error reported by type checker</span>

<span class="k">class</span> <span class="nc">Connection</span><span class="p">:</span>
    <span class="n">TIMEOUT</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">class</span> <span class="nc">FastConnector</span><span class="p">(</span><span class="n">Connection</span><span class="p">):</span>
    <span class="n">TIMEOUT</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Error reported by type checker</span>
</pre></div>
</div>
<p>這些屬性 (property) 不會在 runtime 時進行檢查。更多詳細資訊請看 <span class="target" id="index-110"></span><a class="pep reference external" href="https://peps.python.org/pep-0591/"><strong>PEP 591</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.8 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Required">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Required</span></span><a class="headerlink" href="#typing.Required" title="連結到這個定義">¶</a></dt>
<dd><p>特殊型別建構，用來標記一個 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 鍵值是必須的。</p>
<p>主要用於 <code class="docutils literal notranslate"><span class="pre">total=False</span></code> 的 TypedDict。更多細節請見 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 與 <span class="target" id="index-111"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.NotRequired">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NotRequired</span></span><a class="headerlink" href="#typing.NotRequired" title="連結到這個定義">¶</a></dt>
<dd><p>特殊型別建構，用來標記一個 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 鍵值是可能消失的。</p>
<p>更多細節請見 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 與 <span class="target" id="index-112"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Annotated">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Annotated</span></span><a class="headerlink" href="#typing.Annotated" title="連結到這個定義">¶</a></dt>
<dd><p>Special typing form to add context-specific metadata to an annotation.</p>
<p>Add metadata <code class="docutils literal notranslate"><span class="pre">x</span></code> to a given type <code class="docutils literal notranslate"><span class="pre">T</span></code> by using the annotation
<code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code>. Metadata added using <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> can be used by
static analysis tools or at runtime. At runtime, the metadata is stored
in a <code class="xref py py-attr docutils literal notranslate"><span class="pre">__metadata__</span></code> attribute.</p>
<p>If a library or tool encounters an annotation <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code> and has
no special logic for the metadata, it should ignore the metadata and simply
treat the annotation as <code class="docutils literal notranslate"><span class="pre">T</span></code>. As such, <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> can be useful for code
that wants to use annotations for purposes outside Python's static typing
system.</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code> as an annotation still allows for static
typechecking of <code class="docutils literal notranslate"><span class="pre">T</span></code>, as type checkers will simply ignore the metadata <code class="docutils literal notranslate"><span class="pre">x</span></code>.
In this way, <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> differs from the
<a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;no_type_check</span></code></a> decorator, which can also be used for
adding annotations outside the scope of the typing system, but
completely disables typechecking for a function or class.</p>
<p>The responsibility of how to interpret the metadata
lies with the tool or library encountering an
<code class="docutils literal notranslate"><span class="pre">Annotated</span></code> annotation. A tool or library encountering an <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> type
can scan through the metadata elements to determine if they are of interest
(e.g., using <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>).</p>
<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">Annotated[&lt;type&gt;,</span> <span class="pre">&lt;metadata&gt;]</span></span></dt>
<dd></dd></dl>

<p>Here is an example of how you might use <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> to add metadata to
type annotations if you were doing range analysis:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ValueRange</span><span class="p">:</span>
    <span class="n">lo</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">hi</span><span class="p">:</span> <span class="nb">int</span>

<span class="n">T1</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
<span class="n">T2</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>Details of the syntax:</p>
<ul>
<li><p>The first argument to <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> must be a valid type</p></li>
<li><p>Multiple metadata elements can be supplied (<code class="docutils literal notranslate"><span class="pre">Annotated</span></code> supports variadic
arguments):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ctype</span><span class="p">:</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p>It is up to the tool consuming the annotations to decide whether the
client is allowed to add multiple metadata elements to one annotation and how to
merge those annotations.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> must be subscripted with at least two arguments (
<code class="docutils literal notranslate"><span class="pre">Annotated[int]</span></code> is not valid)</p></li>
<li><p>The order of the metadata elements is preserved and matters for equality
checks:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>Nested <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> types are flattened. The order of the metadata elements
starts with the innermost annotation:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">==</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>Duplicated metadata elements are not removed:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> can be used with nested and generic aliases:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">MaxLen</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">int</span>

<span class="nb">type</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]],</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

<span class="c1"># When used in a type annotation, a type checker will treat &quot;V&quot; the same as</span>
<span class="c1"># ``Annotated[list[tuple[int, int]], MaxLen(10)]``:</span>
<span class="nb">type</span> <span class="n">V</span> <span class="o">=</span> <span class="n">Vec</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> cannot be used with an unpacked <a class="reference internal" href="#typing.TypeVarTuple" title="typing.TypeVarTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVarTuple</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Variadic</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="n">Ann1</span><span class="p">]</span>  <span class="c1"># NOT valid</span>
</pre></div>
</div>
<p>這會等價於：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">Ann1</span><span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">T1</span></code>, <code class="docutils literal notranslate"><span class="pre">T2</span></code>, etc. are <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVars</span></code></a>. This would be
invalid: only one type should be passed to Annotated.</p>
</li>
<li><p>By default, <a class="reference internal" href="#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_type_hints()</span></code></a> strips the metadata from annotations.
Pass <code class="docutils literal notranslate"><span class="pre">include_extras=True</span></code> to have the metadata preserved:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Annotated</span><span class="p">,</span> <span class="n">get_type_hints</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_type_hints</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="go">{&#39;x&#39;: &lt;class &#39;int&#39;&gt;, &#39;return&#39;: &lt;class &#39;NoneType&#39;&gt;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_type_hints</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{&#39;x&#39;: typing.Annotated[int, &#39;metadata&#39;], &#39;return&#39;: &lt;class &#39;NoneType&#39;&gt;}</span>
</pre></div>
</div>
</li>
<li><p>At runtime, the metadata associated with an <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> type can be
retrieved via the <code class="xref py py-attr docutils literal notranslate"><span class="pre">__metadata__</span></code> attribute:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Annotated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;very&quot;</span><span class="p">,</span> <span class="s2">&quot;important&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>
<span class="go">typing.Annotated[int, &#39;very&#39;, &#39;important&#39;, &#39;metadata&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">__metadata__</span>
<span class="go">(&#39;very&#39;, &#39;important&#39;, &#39;metadata&#39;)</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<dl class="simple">
<dt><span class="target" id="index-15"></span><a class="pep reference external" href="https://peps.python.org/pep-0593/"><strong>PEP 593</strong></a> - Flexible function and variable annotations</dt><dd><p>The PEP introducing <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> to the standard library.</p>
</dd>
</dl>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.9 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.TypeGuard">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeGuard</span></span><a class="headerlink" href="#typing.TypeGuard" title="連結到這個定義">¶</a></dt>
<dd><p>Special typing construct for marking user-defined type guard functions.</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> can be used to annotate the return type of a user-defined
type guard function.  <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> only accepts a single type argument.
At runtime, functions marked this way should return a boolean.</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> aims to benefit <em>type narrowing</em> -- a technique used by static
type checkers to determine a more precise type of an expression within a
program's code flow.  Usually type narrowing is done by analyzing
conditional code flow and applying the narrowing to a block of code.  The
conditional expression here is sometimes referred to as a &quot;type guard&quot;:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_str</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">float</span><span class="p">):</span>
    <span class="c1"># &quot;isinstance&quot; type guard</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Type of ``val`` is narrowed to ``str``</span>
        <span class="o">...</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Else, type of ``val`` is narrowed to ``float``.</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Sometimes it would be convenient to use a user-defined boolean function
as a type guard.  Such a function should use <code class="docutils literal notranslate"><span class="pre">TypeGuard[...]</span></code> as its
return type to alert static type checkers to this intention.</p>
<p>Using  <code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">TypeGuard</span></code> tells the static type checker that for a given
function:</p>
<ol class="arabic simple">
<li><p>The return value is a boolean.</p></li>
<li><p>If the return value is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the type of its argument
is the type inside <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code>.</p></li>
</ol>
<p>舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_str_list</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">object</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TypeGuard</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Determines whether all objects in the list are strings&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">func1</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">object</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">is_str_list</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="c1"># Type of ``val`` is narrowed to ``list[str]``.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Type of ``val`` remains as ``list[object]``.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not a list of strings!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">is_str_list</span></code> is a class or instance method, then the type in
<code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> maps to the type of the second parameter (after <code class="docutils literal notranslate"><span class="pre">cls</span></code> or
<code class="docutils literal notranslate"><span class="pre">self</span></code>).</p>
<p>In short, the form <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">foo(arg:</span> <span class="pre">TypeA)</span> <span class="pre">-&gt;</span> <span class="pre">TypeGuard[TypeB]:</span> <span class="pre">...</span></code>,
means that if <code class="docutils literal notranslate"><span class="pre">foo(arg)</span></code> returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, then <code class="docutils literal notranslate"><span class="pre">arg</span></code> narrows from
<code class="docutils literal notranslate"><span class="pre">TypeA</span></code> to <code class="docutils literal notranslate"><span class="pre">TypeB</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeB</span></code> need not be a narrower form of <code class="docutils literal notranslate"><span class="pre">TypeA</span></code> -- it can even be a
wider form. The main reason is to allow for things like
narrowing <code class="docutils literal notranslate"><span class="pre">list[object]</span></code> to <code class="docutils literal notranslate"><span class="pre">list[str]</span></code> even though the latter
is not a subtype of the former, since <code class="docutils literal notranslate"><span class="pre">list</span></code> is invariant.
The responsibility of writing type-safe type guards is left to the user.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> also works with type variables.  See <span class="target" id="index-16"></span><a class="pep reference external" href="https://peps.python.org/pep-0647/"><strong>PEP 647</strong></a> for more details.</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.10 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Unpack">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Unpack</span></span><a class="headerlink" href="#typing.Unpack" title="連結到這個定義">¶</a></dt>
<dd><p>Typing operator to conceptually mark an object as having been unpacked.</p>
<p>For example, using the unpack operator <code class="docutils literal notranslate"><span class="pre">*</span></code> on a
<a class="reference internal" href="#typevartuple"><span class="std std-ref">type variable tuple</span></a> is equivalent to using <code class="docutils literal notranslate"><span class="pre">Unpack</span></code>
to mark the type variable tuple as having been unpacked:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Ts&#39;</span><span class="p">)</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>
<span class="c1"># Effectively does:</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Unpack</span><span class="p">[</span><span class="n">Ts</span><span class="p">]]</span>
</pre></div>
</div>
<p>In fact, <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> can be used interchangeably with <code class="docutils literal notranslate"><span class="pre">*</span></code> in the context
of <a class="reference internal" href="#typing.TypeVarTuple" title="typing.TypeVarTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypeVarTuple</span></code></a> and
<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.tuple</span></code></a> types. You might see <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> being used
explicitly in older versions of Python, where <code class="docutils literal notranslate"><span class="pre">*</span></code> couldn't be used in
certain places:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># In older versions of Python, TypeVarTuple and Unpack</span>
<span class="c1"># are located in the `typing_extensions` backports package.</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">TypeVarTuple</span><span class="p">,</span> <span class="n">Unpack</span>

<span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Ts&#39;</span><span class="p">)</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>         <span class="c1"># Syntax error on Python &lt;= 3.10!</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Unpack</span><span class="p">[</span><span class="n">Ts</span><span class="p">]]</span>  <span class="c1"># Semantically equivalent, and backwards-compatible</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Unpack</span></code> can also be used along with <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypedDict</span></code></a> for typing
<code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> in a function signature:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Unpack</span>

<span class="k">class</span> <span class="nc">Movie</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">year</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># This function expects two keyword arguments - `name` of type `str`</span>
<span class="c1"># and `year` of type `int`.</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Unpack</span><span class="p">[</span><span class="n">Movie</span><span class="p">]):</span> <span class="o">...</span>
</pre></div>
</div>
<p>See <span class="target" id="index-17"></span><a class="pep reference external" href="https://peps.python.org/pep-0692/"><strong>PEP 692</strong></a> for more details on using <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> for <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> typing.</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
</dd></dl>

</section>
<section id="building-generic-types-and-type-aliases">
<h4>Building generic types and type aliases<a class="headerlink" href="#building-generic-types-and-type-aliases" title="連結到這個標頭">¶</a></h4>
<p>The following classes should not be used directly as annotations.
Their intended purpose is to be building blocks
for creating generic types and type aliases.</p>
<p>These objects can be created through special syntax
(<a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameter lists</span></a> and the <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> statement).
For compatibility with Python 3.11 and earlier, they can also be created
without the dedicated syntax, as documented below.</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Generic">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Generic</span></span><a class="headerlink" href="#typing.Generic" title="連結到這個定義">¶</a></dt>
<dd><p>Abstract base class for generic types.</p>
<p>A generic type is typically declared by adding a list of type parameters
after the class name:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]:</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># Etc.</span>
</pre></div>
</div>
<p>Such a class implicitly inherits from <code class="docutils literal notranslate"><span class="pre">Generic</span></code>.
The runtime semantics of this syntax are discussed in the
<a class="reference internal" href="../reference/compound_stmts.html#generic-classes"><span class="std std-ref">Language Reference</span></a>.</p>
<p>This class can then be used as follows:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">lookup_name</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">](</span><span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Y</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
</pre></div>
</div>
<p>Here the brackets after the function name indicate a
<a class="reference internal" href="../reference/compound_stmts.html#generic-functions"><span class="std std-ref">generic function</span></a>.</p>
<p>For backwards compatibility, generic classes can also be
declared by explicitly inheriting from
<code class="docutils literal notranslate"><span class="pre">Generic</span></code>. In this case, the type parameters must be declared
separately:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">KT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;KT&#39;</span><span class="p">)</span>
<span class="n">VT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;VT&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Mapping</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># Etc.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class" id="typevar">
<dt class="sig sig-object py" id="typing.TypeVar">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeVar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contravariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infer_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeVar" title="連結到這個定義">¶</a></dt>
<dd><p>Type variable.</p>
<p>The preferred way to construct a type variable is via the dedicated syntax
for <a class="reference internal" href="../reference/compound_stmts.html#generic-functions"><span class="std std-ref">generic functions</span></a>,
<a class="reference internal" href="../reference/compound_stmts.html#generic-classes"><span class="std std-ref">generic classes</span></a>, and
<a class="reference internal" href="../reference/compound_stmts.html#generic-type-aliases"><span class="std std-ref">generic type aliases</span></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>  <span class="c1"># T is a TypeVar</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This syntax can also be used to create bound and constrained type
variables:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">StrSequence</span><span class="p">[</span><span class="n">S</span><span class="p">:</span> <span class="nb">str</span><span class="p">]:</span>  <span class="c1"># S is a TypeVar bound to str</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">StrOrBytesSequence</span><span class="p">[</span><span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)]:</span>  <span class="c1"># A is a TypeVar constrained to str or bytes</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>However, if desired, reusable type variables can also be constructed manually, like so:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># Can be anything</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>  <span class="c1"># Can be any subtype of str</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Must be exactly str or bytes</span>
</pre></div>
</div>
<p>Type variables exist primarily for the benefit of static type
checkers.  They serve as the parameters for generic types as well
as for generic function and type alias definitions.
See <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> for more
information on generic types.  Generic functions work as follows:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">repeat</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list containing n references to x.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>


<span class="k">def</span> <span class="nf">print_capitalized</span><span class="p">[</span><span class="n">S</span><span class="p">:</span> <span class="nb">str</span><span class="p">](</span><span class="n">x</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Print x capitalized, and return x.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">capitalize</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">concatenate</span><span class="p">[</span><span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)](</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add two strings or bytes objects together.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>Note that type variables can be <em>bound</em>, <em>constrained</em>, or neither, but
cannot be both bound <em>and</em> constrained.</p>
<p>The variance of type variables is inferred by type checkers when they are created
through the <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameter syntax</span></a> or when
<code class="docutils literal notranslate"><span class="pre">infer_variance=True</span></code> is passed.
Manually created type variables may be explicitly marked covariant or contravariant by passing
<code class="docutils literal notranslate"><span class="pre">covariant=True</span></code> or <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code>.
By default, manually created type variables are invariant.
See <span class="target" id="index-18"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> and <span class="target" id="index-19"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a> for more details.</p>
<p>Bound type variables and constrained type variables have different
semantics in several important ways. Using a <em>bound</em> type variable means
that the <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> will be solved using the most specific type possible:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="s1">&#39;a string&#39;</span><span class="p">)</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># revealed type is str</span>

<span class="k">class</span> <span class="nc">StringSubclass</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;another string&#39;</span><span class="p">))</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># revealed type is StringSubclass</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>  <span class="c1"># error: int is not a subtype of str</span>
</pre></div>
</div>
<p>Type variables can be bound to concrete types, abstract types (ABCs or
protocols), and even unions of types:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Can be anything with an __abs__ method</span>
<span class="k">def</span> <span class="nf">print_abs</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="n">SupportsAbs</span><span class="p">](</span><span class="n">arg</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Absolute value:&quot;</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

<span class="n">U</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="o">|</span><span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Can be any subtype of the union str|bytes</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">SupportsAbs</span><span class="p">)</span>  <span class="c1"># Can be anything with an __abs__ method</span>
</pre></div>
</div>
<p id="typing-constrained-typevar">Using a <em>constrained</em> type variable, however, means that the <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code>
can only ever be solved as being exactly one of the constraints given:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">)</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># revealed type is str</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;two&#39;</span><span class="p">))</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># revealed type is str, despite StringSubclass being passed in</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;two&#39;</span><span class="p">)</span>  <span class="c1"># error: type variable &#39;A&#39; can be either str or bytes in a function call, but not both</span>
</pre></div>
</div>
<p>At runtime, <code class="docutils literal notranslate"><span class="pre">isinstance(x,</span> <span class="pre">T)</span></code> will raise <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.TypeVar.__name__" title="連結到這個定義">¶</a></dt>
<dd><p>The name of the type variable.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__covariant__">
<span class="sig-name descname"><span class="pre">__covariant__</span></span><a class="headerlink" href="#typing.TypeVar.__covariant__" title="連結到這個定義">¶</a></dt>
<dd><p>Whether the type var has been explicitly marked as covariant.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__contravariant__">
<span class="sig-name descname"><span class="pre">__contravariant__</span></span><a class="headerlink" href="#typing.TypeVar.__contravariant__" title="連結到這個定義">¶</a></dt>
<dd><p>Whether the type var has been explicitly marked as contravariant.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__infer_variance__">
<span class="sig-name descname"><span class="pre">__infer_variance__</span></span><a class="headerlink" href="#typing.TypeVar.__infer_variance__" title="連結到這個定義">¶</a></dt>
<dd><p>Whether the type variable's variance should be inferred by type checkers.</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.12 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__bound__">
<span class="sig-name descname"><span class="pre">__bound__</span></span><a class="headerlink" href="#typing.TypeVar.__bound__" title="連結到這個定義">¶</a></dt>
<dd><p>The bound of the type variable, if any.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版的變更: </span>For type variables created through <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameter syntax</span></a>,
the bound is evaluated only when the attribute is accessed, not when
the type variable is created (see <a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">Lazy evaluation</span></a>).</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__constraints__">
<span class="sig-name descname"><span class="pre">__constraints__</span></span><a class="headerlink" href="#typing.TypeVar.__constraints__" title="連結到這個定義">¶</a></dt>
<dd><p>A tuple containing the constraints of the type variable, if any.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版的變更: </span>For type variables created through <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameter syntax</span></a>,
the constraints are evaluated only when the attribute is accessed, not when
the type variable is created (see <a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">Lazy evaluation</span></a>).</p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版的變更: </span>Type variables can now be declared using the
<a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameter</span></a> syntax introduced by <span class="target" id="index-20"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a>.
The <code class="docutils literal notranslate"><span class="pre">infer_variance</span></code> parameter was added.</p>
</div>
</dd></dl>

<dl class="py class" id="typevartuple">
<dt class="sig sig-object py" id="typing.TypeVarTuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeVarTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeVarTuple" title="連結到這個定義">¶</a></dt>
<dd><p>Type variable tuple. A specialized form of <a class="reference internal" href="#typevar"><span class="std std-ref">type variable</span></a>
that enables <em>variadic</em> generics.</p>
<p>Type variable tuples can be declared in <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameter lists</span></a>
using a single asterisk (<code class="docutils literal notranslate"><span class="pre">*</span></code>) before the name:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">move_first_element_to_last</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">](</span><span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Or by explicitly invoking the <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code> constructor:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s2">&quot;Ts&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>A normal type variable enables parameterization with a single type. A type
variable tuple, in contrast, allows parameterization with an
<em>arbitrary</em> number of types by acting like an <em>arbitrary</em> number of type
variables wrapped in a tuple. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># T is bound to int, Ts is bound to ()</span>
<span class="c1"># Return value is (1,), which has type tuple[int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>

<span class="c1"># T is bound to int, Ts is bound to (str,)</span>
<span class="c1"># Return value is (&#39;spam&#39;, 1), which has type tuple[str, int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">))</span>

<span class="c1"># T is bound to int, Ts is bound to (str, float)</span>
<span class="c1"># Return value is (&#39;spam&#39;, 3.0, 1), which has type tuple[str, float, int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">))</span>

<span class="c1"># This fails to type check (and fails at runtime)</span>
<span class="c1"># because tuple[()] is not compatible with tuple[T, *Ts]</span>
<span class="c1"># (at least one element is required)</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">())</span>
</pre></div>
</div>
<p>Note the use of the unpacking operator <code class="docutils literal notranslate"><span class="pre">*</span></code> in <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*Ts]</span></code>.
Conceptually, you can think of <code class="docutils literal notranslate"><span class="pre">Ts</span></code> as a tuple of type variables
<code class="docutils literal notranslate"><span class="pre">(T1,</span> <span class="pre">T2,</span> <span class="pre">...)</span></code>. <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*Ts]</span></code> would then become
<code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*(T1,</span> <span class="pre">T2,</span> <span class="pre">...)]</span></code>, which is equivalent to
<code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">T1,</span> <span class="pre">T2,</span> <span class="pre">...]</span></code>. (Note that in older versions of Python, you might
see this written using <a class="reference internal" href="#typing.Unpack" title="typing.Unpack"><code class="xref py py-data docutils literal notranslate"><span class="pre">Unpack</span></code></a> instead, as
<code class="docutils literal notranslate"><span class="pre">Unpack[Ts]</span></code>.)</p>
<p>Type variable tuples must <em>always</em> be unpacked. This helps distinguish type
variable tuples from normal type variables:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="n">Ts</span>          <span class="c1"># Not valid</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Ts</span><span class="p">]</span>   <span class="c1"># Not valid</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>  <span class="c1"># The correct way to do it</span>
</pre></div>
</div>
<p>Type variable tuples can be used in the same contexts as normal type
variables. For example, in class definitions, arguments, and return types:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Array[*Shape]&quot;</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p>Type variable tuples can be happily combined with normal type variables:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Array</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>  <span class="c1"># This is fine</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Array2</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">,</span> <span class="n">DType</span><span class="p">]:</span>  <span class="c1"># This would also be fine</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Height</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">Width</span><span class="p">:</span> <span class="o">...</span>

<span class="n">float_array_1d</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Height</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>     <span class="c1"># Totally fine</span>
<span class="n">int_array_2d</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>  <span class="c1"># Yup, fine too</span>
</pre></div>
</div>
<p>However, note that at most one type variable tuple may appear in a single
list of type arguments or type parameters:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">]</span>            <span class="c1"># Not valid</span>
<span class="k">class</span> <span class="nc">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>  <span class="c1"># Not valid</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Finally, an unpacked type variable tuple can be used as the type annotation
of <code class="docutils literal notranslate"><span class="pre">*args</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">call_soon</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">](</span>
    <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="o">*</span><span class="n">Ts</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="o">*</span><span class="n">Ts</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="n">callback</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>In contrast to non-unpacked annotations of <code class="docutils literal notranslate"><span class="pre">*args</span></code> - e.g. <code class="docutils literal notranslate"><span class="pre">*args:</span> <span class="pre">int</span></code>,
which would specify that <em>all</em> arguments are <code class="docutils literal notranslate"><span class="pre">int</span></code> - <code class="docutils literal notranslate"><span class="pre">*args:</span> <span class="pre">*Ts</span></code>
enables reference to the types of the <em>individual</em> arguments in <code class="docutils literal notranslate"><span class="pre">*args</span></code>.
Here, this allows us to ensure the types of the <code class="docutils literal notranslate"><span class="pre">*args</span></code> passed
to <code class="docutils literal notranslate"><span class="pre">call_soon</span></code> match the types of the (positional) arguments of
<code class="docutils literal notranslate"><span class="pre">callback</span></code>.</p>
<p>See <span class="target" id="index-21"></span><a class="pep reference external" href="https://peps.python.org/pep-0646/"><strong>PEP 646</strong></a> for more details on type variable tuples.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVarTuple.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.TypeVarTuple.__name__" title="連結到這個定義">¶</a></dt>
<dd><p>The name of the type variable tuple.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版的變更: </span>Type variable tuples can now be declared using the
<a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameter</span></a> syntax introduced by <span class="target" id="index-22"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ParamSpec">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contravariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ParamSpec" title="連結到這個定義">¶</a></dt>
<dd><p>Parameter specification variable.  A specialized version of
<a class="reference internal" href="#typevar"><span class="std std-ref">type variables</span></a>.</p>
<p>In <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameter lists</span></a>, parameter specifications
can be declared with two asterisks (<code class="docutils literal notranslate"><span class="pre">**</span></code>):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">IntFunc</span><span class="p">[</span><span class="o">**</span><span class="n">P</span><span class="p">]</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
<p>For compatibility with Python 3.11 and earlier, <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> objects
can also be created as follows:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Parameter specification variables exist primarily for the benefit of static
type checkers.  They are used to forward the parameter types of one
callable to another callable -- a pattern commonly found in higher order
functions and decorators.  They are only valid when used in <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code>,
or as the first argument to <code class="docutils literal notranslate"><span class="pre">Callable</span></code>, or as parameters for user-defined
Generics.  See <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> for more information on generic types.</p>
<p>For example, to add basic logging to a function, one can create a decorator
<code class="docutils literal notranslate"><span class="pre">add_logging</span></code> to log function calls.  The parameter specification variable
tells the type checker that the callable passed into the decorator and the
new callable returned by it have inter-dependent type parameters:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="k">def</span> <span class="nf">add_logging</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">P</span><span class="p">](</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A type-safe decorator to add logging to a function.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> was called&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="nd">@add_logging</span>
<span class="k">def</span> <span class="nf">add_two</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Add two numbers together.&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>Without <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code>, the simplest way to annotate this previously was to
use a <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> with bound <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">Any]</span></code>.  However this
causes two problems:</p>
<ol class="arabic simple">
<li><p>The type checker can't type check the <code class="docutils literal notranslate"><span class="pre">inner</span></code> function because
<code class="docutils literal notranslate"><span class="pre">*args</span></code> and <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> have to be typed <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#typing.cast" title="typing.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> may be required in the body of the <code class="docutils literal notranslate"><span class="pre">add_logging</span></code>
decorator when returning the <code class="docutils literal notranslate"><span class="pre">inner</span></code> function, or the static type
checker must be told to ignore the <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">inner</span></code>.</p></li>
</ol>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#typing.ParamSpec.args" title="連結到這個定義">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.kwargs">
<span class="sig-name descname"><span class="pre">kwargs</span></span><a class="headerlink" href="#typing.ParamSpec.kwargs" title="連結到這個定義">¶</a></dt>
<dd><p>Since <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> captures both positional and keyword parameters,
<code class="docutils literal notranslate"><span class="pre">P.args</span></code> and <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> can be used to split a <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> into its
components.  <code class="docutils literal notranslate"><span class="pre">P.args</span></code> represents the tuple of positional parameters in a
given call and should only be used to annotate <code class="docutils literal notranslate"><span class="pre">*args</span></code>.  <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code>
represents the mapping of keyword parameters to their values in a given call,
and should be only be used to annotate <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>.  Both
attributes require the annotated parameter to be in scope. At runtime,
<code class="docutils literal notranslate"><span class="pre">P.args</span></code> and <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> are instances respectively of
<a class="reference internal" href="#typing.ParamSpecArgs" title="typing.ParamSpecArgs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code></a> and <a class="reference internal" href="#typing.ParamSpecKwargs" title="typing.ParamSpecKwargs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.ParamSpec.__name__" title="連結到這個定義">¶</a></dt>
<dd><p>The name of the parameter specification.</p>
</dd></dl>

<p>Parameter specification variables created with <code class="docutils literal notranslate"><span class="pre">covariant=True</span></code> or
<code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code> can be used to declare covariant or contravariant
generic types.  The <code class="docutils literal notranslate"><span class="pre">bound</span></code> argument is also accepted, similar to
<a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>.  However the actual semantics of these keywords are yet to
be decided.</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.10 版被加入.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版的變更: </span>Parameter specifications can now be declared using the
<a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameter</span></a> syntax introduced by <span class="target" id="index-23"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>Only parameter specification variables defined in global scope can
be pickled.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<ul class="simple">
<li><p><span class="target" id="index-113"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> -- 參數技術規範變數</p></li>
<li><p><a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a></p></li>
<li><p><a class="reference internal" href="#annotating-callables"><span class="std std-ref">註釋 callable 物件</span></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.ParamSpecArgs">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpecArgs</span></span><a class="headerlink" href="#typing.ParamSpecArgs" title="連結到這個定義">¶</a></dt>
<dt class="sig sig-object py" id="typing.ParamSpecKwargs">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpecKwargs</span></span><a class="headerlink" href="#typing.ParamSpecKwargs" title="連結到這個定義">¶</a></dt>
<dd><p>Arguments and keyword arguments attributes of a <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>. The
<code class="docutils literal notranslate"><span class="pre">P.args</span></code> attribute of a <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> is an instance of <code class="docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code>,
and <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> is an instance of <code class="docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code>. They are intended
for runtime introspection and have no special meaning to static type checkers.</p>
<p>Calling <a class="reference internal" href="#typing.get_origin" title="typing.get_origin"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_origin()</span></code></a> on either of these objects will return the
original <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">get_origin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.10 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.TypeAliasType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeAliasType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeAliasType" title="連結到這個定義">¶</a></dt>
<dd><p>The type of type aliases created through the <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> statement.</p>
<p>舉例來說：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Alias</span><span class="p">)</span>
<span class="go">&lt;class &#39;typing.TypeAliasType&#39;&gt;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.12 版被加入.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.TypeAliasType.__name__" title="連結到這個定義">¶</a></dt>
<dd><p>The name of the type alias:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Alias</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;Alias&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__module__">
<span class="sig-name descname"><span class="pre">__module__</span></span><a class="headerlink" href="#typing.TypeAliasType.__module__" title="連結到這個定義">¶</a></dt>
<dd><p>The module in which the type alias was defined:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Alias</span><span class="o">.</span><span class="vm">__module__</span>
<span class="go">&#39;__main__&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__type_params__">
<span class="sig-name descname"><span class="pre">__type_params__</span></span><a class="headerlink" href="#typing.TypeAliasType.__type_params__" title="連結到這個定義">¶</a></dt>
<dd><p>The type parameters of the type alias, or an empty tuple if the alias is
not generic:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">ListOrSet</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">|</span> <span class="nb">set</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ListOrSet</span><span class="o">.</span><span class="n">__type_params__</span>
<span class="go">(T,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">NotGeneric</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NotGeneric</span><span class="o">.</span><span class="n">__type_params__</span>
<span class="go">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__value__">
<span class="sig-name descname"><span class="pre">__value__</span></span><a class="headerlink" href="#typing.TypeAliasType.__value__" title="連結到這個定義">¶</a></dt>
<dd><p>The type alias's value. This is <a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">lazily evaluated</span></a>,
so names used in the definition of the alias are not resolved until the
<code class="docutils literal notranslate"><span class="pre">__value__</span></code> attribute is accessed:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Mutually</span> <span class="o">=</span> <span class="n">Recursive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Recursive</span> <span class="o">=</span> <span class="n">Mutually</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mutually</span>
<span class="go">Mutually</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Recursive</span>
<span class="go">Recursive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mutually</span><span class="o">.</span><span class="n">__value__</span>
<span class="go">Recursive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Recursive</span><span class="o">.</span><span class="n">__value__</span>
<span class="go">Mutually</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="other-special-directives">
<h4>Other special directives<a class="headerlink" href="#other-special-directives" title="連結到這個標頭">¶</a></h4>
<p>These functions and classes should not be used directly as annotations.
Their intended purpose is to be building blocks for creating and declaring
types.</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.NamedTuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NamedTuple</span></span><a class="headerlink" href="#typing.NamedTuple" title="連結到這個定義">¶</a></dt>
<dd><p>Typed version of <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a>.</p>
<p>Usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>這等價於：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>To give a field a default value, you can assign to it in the class body:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">employee</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">employee</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Fields with a default value must come after any fields without a default.</p>
<p>The resulting class has an extra attribute <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> giving a
dict that maps the field names to the field types.  (The field names are in
the <code class="docutils literal notranslate"><span class="pre">_fields</span></code> attribute and the default values are in the
<code class="docutils literal notranslate"><span class="pre">_field_defaults</span></code> attribute, both of which are part of the <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">namedtuple()</span></code></a>
API.)</p>
<p><code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> subclasses can also have docstrings and methods:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents an employee.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;Employee </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">, id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">&gt;&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> subclasses can be generic:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Group</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
<p>Backward-compatible usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># For creating a generic NamedTuple on Python 3.11 or lower</span>
<span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>

<span class="c1"># A functional syntax is also supported</span>
<span class="n">Employee</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版的變更: </span>Added support for <span class="target" id="index-25"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a> variable annotation syntax.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6.1 版的變更: </span>Added support for default values, methods, and docstrings.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版的變更: </span>The <code class="docutils literal notranslate"><span class="pre">_field_types</span></code> and <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> attributes are
now regular dictionaries instead of instances of <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版的變更: </span>Removed the <code class="docutils literal notranslate"><span class="pre">_field_types</span></code> attribute in favor of the more
standard <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> attribute which has the same information.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>Added support for generic namedtuples.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.NewType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NewType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.NewType" title="連結到這個定義">¶</a></dt>
<dd><p>Helper class to create low-overhead <a class="reference internal" href="#distinct"><span class="std std-ref">distinct types</span></a>.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">NewType</span></code> is considered a distinct type by a typechecker. At runtime,
however, calling a <code class="docutils literal notranslate"><span class="pre">NewType</span></code> returns its argument unchanged.</p>
<p>Usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>  <span class="c1"># Declare the NewType &quot;UserId&quot;</span>
<span class="n">first_user</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># &quot;UserId&quot; returns the argument unchanged at runtime</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.NewType.__module__">
<span class="sig-name descname"><span class="pre">__module__</span></span><a class="headerlink" href="#typing.NewType.__module__" title="連結到這個定義">¶</a></dt>
<dd><p>The module in which the new type is defined.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.NewType.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.NewType.__name__" title="連結到這個定義">¶</a></dt>
<dd><p>The name of the new type.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.NewType.__supertype__">
<span class="sig-name descname"><span class="pre">__supertype__</span></span><a class="headerlink" href="#typing.NewType.__supertype__" title="連結到這個定義">¶</a></dt>
<dd><p>The type that the new type is based on.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">在 3.5.2 版被加入.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版的變更: </span><code class="docutils literal notranslate"><span class="pre">NewType</span></code> is now a class rather than a function.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Protocol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Protocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Generic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Protocol" title="連結到這個定義">¶</a></dt>
<dd><p>Base class for protocol classes.</p>
<p>Protocol classes are defined like this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Proto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Proto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>

<span class="n">func</span><span class="p">(</span><span class="n">C</span><span class="p">())</span>  <span class="c1"># Passes static type check</span>
</pre></div>
</div>
<p>See <span class="target" id="index-26"></span><a class="pep reference external" href="https://peps.python.org/pep-0544/"><strong>PEP 544</strong></a> for more details. Protocol classes decorated with
<a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a> (described later) act as simple-minded runtime
protocols that check only the presence of given attributes, ignoring their
type signatures.</p>
<p>Protocol classes can be generic, for example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GenProto</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>In code that needs to be compatible with Python 3.11 or older, generic
Protocols can be written as follows:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">GenProto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.8 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.runtime_checkable">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">runtime_checkable</span></span><a class="headerlink" href="#typing.runtime_checkable" title="連結到這個定義">¶</a></dt>
<dd><p>Mark a protocol class as a runtime protocol.</p>
<p>Such a protocol can be used with <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> and <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>.
This raises <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> when applied to a non-protocol class.  This
allows a simple-minded structural check, very similar to &quot;one trick ponies&quot;
in <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> such as <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>.  For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">Closable</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/some/file&#39;</span><span class="p">),</span> <span class="n">Closable</span><span class="p">)</span>

<span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">Named</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

<span class="kn">import</span> <span class="nn">threading</span>
<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Bob&#39;</span><span class="p">),</span> <span class="n">Named</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code> will check only the presence of the required
methods or attributes, not their type signatures or types.
For example, <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>
is a class, therefore it passes an <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>
check against <a class="reference internal" href="#annotating-callables"><span class="std std-ref">Callable</span></a>. However, the
<code class="docutils literal notranslate"><span class="pre">ssl.SSLObject.__init__</span></code> method exists only to raise a
<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> with a more informative message, therefore making
it impossible to call (instantiate) <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>An <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> check against a runtime-checkable protocol can be
surprisingly slow compared to an <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code> check against
a non-protocol class. Consider using alternative idioms such as
<a class="reference internal" href="functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> calls for structural checks in performance-sensitive
code.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.8 版被加入.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版的變更: </span>The internal implementation of <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> checks against
runtime-checkable protocols now uses <a class="reference internal" href="inspect.html#inspect.getattr_static" title="inspect.getattr_static"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getattr_static()</span></code></a>
to look up attributes (previously, <a class="reference internal" href="functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> was used).
As a result, some objects which used to be considered instances
of a runtime-checkable protocol may no longer be considered instances
of that protocol on Python 3.12+, and vice versa.
Most users are unlikely to be affected by this change.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版的變更: </span>The members of a runtime-checkable protocol are now considered &quot;frozen&quot;
at runtime as soon as the class has been created. Monkey-patching
attributes onto a runtime-checkable protocol will still work, but will
have no impact on <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> checks comparing objects to the
protocol. See <a class="reference internal" href="../whatsnew/3.12.html#whatsnew-typing-py312"><span class="std std-ref">&quot;What's new in Python 3.12&quot;</span></a>
for more details.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.TypedDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypedDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypedDict" title="連結到這個定義">¶</a></dt>
<dd><p>Special construct to add type hints to a dictionary.
At runtime it is a plain <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> declares a dictionary type that expects all of its
instances to have a certain set of keys, where each key is
associated with a value of a consistent type. This expectation
is not checked at runtime but is only enforced by type checkers.
Usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;good&#39;</span><span class="p">}</span>  <span class="c1"># OK</span>
<span class="n">b</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;bad&#39;</span><span class="p">}</span>           <span class="c1"># Fails type check</span>

<span class="k">assert</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To allow using this feature with older versions of Python that do not
support <span class="target" id="index-27"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>, <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> supports two additional equivalent
syntactic forms:</p>
<ul>
<li><p>Using a literal <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> as the second argument:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})</span>
</pre></div>
</div>
</li>
<li><p>Using keyword arguments:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.11, will be removed in version 3.13: </span>The keyword-argument syntax is deprecated in 3.11 and will be removed
in 3.13. It may also be unsupported by static type checkers.</p>
</div>
</li>
</ul>
<p>The functional syntax should also be used when any of the keys are not valid
<a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">identifiers</span></a>, for example because they are keywords or contain hyphens.
Example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># raises SyntaxError</span>
<span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="ow">in</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># &#39;in&#39; is a keyword</span>
    <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># name with hyphens</span>

<span class="c1"># OK, functional syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;x-y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">})</span>
</pre></div>
</div>
<p>By default, all keys must be present in a <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>. It is possible to
mark individual keys as non-required using <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">label</span><span class="p">:</span> <span class="n">NotRequired</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

<span class="c1"># Alternative syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="n">NotRequired</span><span class="p">[</span><span class="nb">str</span><span class="p">]})</span>
</pre></div>
</div>
<p>This means that a <code class="docutils literal notranslate"><span class="pre">Point2D</span></code> <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> can have the <code class="docutils literal notranslate"><span class="pre">label</span></code>
key omitted.</p>
<p>It is also possible to mark all keys as non-required by default
by specifying a totality of <code class="docutils literal notranslate"><span class="pre">False</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># Alternative syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">},</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>This means that a <code class="docutils literal notranslate"><span class="pre">Point2D</span></code> <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> can have any of the keys
omitted. A type checker is only expected to support a literal <code class="docutils literal notranslate"><span class="pre">False</span></code> or
<code class="docutils literal notranslate"><span class="pre">True</span></code> as the value of the <code class="docutils literal notranslate"><span class="pre">total</span></code> argument. <code class="docutils literal notranslate"><span class="pre">True</span></code> is the default,
and makes all items defined in the class body required.</p>
<p>Individual keys of a <code class="docutils literal notranslate"><span class="pre">total=False</span></code> <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> can be marked as
required using <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>

<span class="c1"># Alternative syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">},</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>It is possible for a <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> type to inherit from one or more other <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> types
using the class-based syntax.
Usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Point3D</span></code> has three items: <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code>. It is equivalent to this
definition:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> cannot inherit from a non-<code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> class,
except for <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">Y</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">Z</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># A non-TypedDict class</span>

<span class="k">class</span> <span class="nc">XY</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># OK</span>

<span class="k">class</span> <span class="nc">XZ</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># raises TypeError</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> can be generic:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Group</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
<p>To create a generic <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> that is compatible with Python 3.11
or lower, inherit from <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> explicitly:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> can be introspected via annotations dicts
(see <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">註釋 (annotation) 最佳實踐</span></a> for more information on annotations best practices),
<a class="reference internal" href="#typing.TypedDict.__total__" title="typing.TypedDict.__total__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__total__</span></code></a>, <a class="reference internal" href="#typing.TypedDict.__required_keys__" title="typing.TypedDict.__required_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__required_keys__</span></code></a>, and <a class="reference internal" href="#typing.TypedDict.__optional_keys__" title="typing.TypedDict.__optional_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__optional_keys__</span></code></a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__total__">
<span class="sig-name descname"><span class="pre">__total__</span></span><a class="headerlink" href="#typing.TypedDict.__total__" title="連結到這個定義">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Point2D.__total__</span></code> gives the value of the <code class="docutils literal notranslate"><span class="pre">total</span></code> argument.
Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point2D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point2D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This attribute reflects <em>only</em> the value of the <code class="docutils literal notranslate"><span class="pre">total</span></code> argument
to the current <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> class, not whether the class is semantically
total. For example, a <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> with <code class="docutils literal notranslate"><span class="pre">__total__</span></code> set to <code class="docutils literal notranslate"><span class="pre">True</span></code> may
have keys marked with <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a>, or it may inherit from another
<code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> with <code class="docutils literal notranslate"><span class="pre">total=False</span></code>. Therefore, it is generally better to use
<a class="reference internal" href="#typing.TypedDict.__required_keys__" title="typing.TypedDict.__required_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__required_keys__</span></code></a> and <a class="reference internal" href="#typing.TypedDict.__optional_keys__" title="typing.TypedDict.__optional_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__optional_keys__</span></code></a> for introspection.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__required_keys__">
<span class="sig-name descname"><span class="pre">__required_keys__</span></span><a class="headerlink" href="#typing.TypedDict.__required_keys__" title="連結到這個定義">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">在 3.9 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__optional_keys__">
<span class="sig-name descname"><span class="pre">__optional_keys__</span></span><a class="headerlink" href="#typing.TypedDict.__optional_keys__" title="連結到這個定義">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Point2D.__required_keys__</span></code> and <code class="docutils literal notranslate"><span class="pre">Point2D.__optional_keys__</span></code> return
<a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> objects containing required and non-required keys, respectively.</p>
<p>Keys marked with <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a> will always appear in <code class="docutils literal notranslate"><span class="pre">__required_keys__</span></code>
and keys marked with <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a> will always appear in <code class="docutils literal notranslate"><span class="pre">__optional_keys__</span></code>.</p>
<p>For backwards compatibility with Python 3.10 and below,
it is also possible to use inheritance to declare both required and
non-required keys in the same <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> . This is done by declaring a
<code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> with one value for the <code class="docutils literal notranslate"><span class="pre">total</span></code> argument and then
inheriting from it in another <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> with a different value for
<code class="docutils literal notranslate"><span class="pre">total</span></code>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">... </span>    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__required_keys__</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;z&#39;</span><span class="p">})</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__optional_keys__</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.9 版被加入.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>If <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code> is used or if annotations
are given as strings, annotations are not evaluated when the
<code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> is defined. Therefore, the runtime introspection that
<code class="docutils literal notranslate"><span class="pre">__required_keys__</span></code> and <code class="docutils literal notranslate"><span class="pre">__optional_keys__</span></code> rely on may not work
properly, and the values of the attributes may be incorrect.</p>
</div>
</dd></dl>

<p>See <span class="target" id="index-28"></span><a class="pep reference external" href="https://peps.python.org/pep-0589/"><strong>PEP 589</strong></a> for more examples and detailed rules of using <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.8 版被加入.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>Added support for marking individual keys as <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a> or <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a>.
See <span class="target" id="index-29"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>Added support for generic <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>s.</p>
</div>
</dd></dl>

</section>
</section>
<section id="protocols">
<h3>協定<a class="headerlink" href="#protocols" title="連結到這個標頭">¶</a></h3>
<p>The following protocols are provided by the typing module. All are decorated
with <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;runtime_checkable</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsAbs">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsAbs</span></span><a class="headerlink" href="#typing.SupportsAbs" title="連結到這個定義">¶</a></dt>
<dd><p>An ABC with one abstract method <code class="docutils literal notranslate"><span class="pre">__abs__</span></code> that is covariant
in its return type.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsBytes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsBytes</span></span><a class="headerlink" href="#typing.SupportsBytes" title="連結到這個定義">¶</a></dt>
<dd><p>一個有抽象方法 <code class="docutils literal notranslate"><span class="pre">__bytes__</span></code> 的 ABC。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsComplex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsComplex</span></span><a class="headerlink" href="#typing.SupportsComplex" title="連結到這個定義">¶</a></dt>
<dd><p>一個有抽象方法 <code class="docutils literal notranslate"><span class="pre">__complex__</span></code> 的 ABC。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsFloat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsFloat</span></span><a class="headerlink" href="#typing.SupportsFloat" title="連結到這個定義">¶</a></dt>
<dd><p>一個有抽象方法 <code class="docutils literal notranslate"><span class="pre">__float__</span></code> 的 ABC。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsIndex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsIndex</span></span><a class="headerlink" href="#typing.SupportsIndex" title="連結到這個定義">¶</a></dt>
<dd><p>一個有抽象方法 <code class="docutils literal notranslate"><span class="pre">__index__</span></code> 的 ABC。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.8 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsInt">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsInt</span></span><a class="headerlink" href="#typing.SupportsInt" title="連結到這個定義">¶</a></dt>
<dd><p>一個有抽象方法 <code class="docutils literal notranslate"><span class="pre">__int__</span></code> 的 ABC。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsRound">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsRound</span></span><a class="headerlink" href="#typing.SupportsRound" title="連結到這個定義">¶</a></dt>
<dd><p>An ABC with one abstract method <code class="docutils literal notranslate"><span class="pre">__round__</span></code>
that is covariant in its return type.</p>
</dd></dl>

</section>
<section id="abcs-for-working-with-io">
<h3>ABCs for working with IO<a class="headerlink" href="#abcs-for-working-with-io" title="連結到這個標頭">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="typing.IO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">IO</span></span><a class="headerlink" href="#typing.IO" title="連結到這個定義">¶</a></dt>
<dt class="sig sig-object py" id="typing.TextIO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TextIO</span></span><a class="headerlink" href="#typing.TextIO" title="連結到這個定義">¶</a></dt>
<dt class="sig sig-object py" id="typing.BinaryIO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">BinaryIO</span></span><a class="headerlink" href="#typing.BinaryIO" title="連結到這個定義">¶</a></dt>
<dd><p>Generic type <code class="docutils literal notranslate"><span class="pre">IO[AnyStr]</span></code> and its subclasses <code class="docutils literal notranslate"><span class="pre">TextIO(IO[str])</span></code>
and <code class="docutils literal notranslate"><span class="pre">BinaryIO(IO[bytes])</span></code>
represent the types of I/O streams such as returned by
<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p>
</dd></dl>

</section>
<section id="functions-and-decorators">
<h3>函式與裝飾器<a class="headerlink" href="#functions-and-decorators" title="連結到這個標頭">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="typing.cast">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.cast" title="連結到這個定義">¶</a></dt>
<dd><p>Cast a value to a type.</p>
<p>This returns the value unchanged.  To the type checker this
signals that the return value has the designated type, but at
runtime we intentionally don't check anything (we want this
to be as fast as possible).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.assert_type">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">assert_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">typ</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.assert_type" title="連結到這個定義">¶</a></dt>
<dd><p>Ask a static type checker to confirm that <em>val</em> has an inferred type of <em>typ</em>.</p>
<p>At runtime this does nothing: it returns the first argument unchanged with no
checks or side effects, no matter the actual type of the argument.</p>
<p>When a static type checker encounters a call to <code class="docutils literal notranslate"><span class="pre">assert_type()</span></code>, it
emits an error if the value is not of the specified type:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>  <span class="c1"># OK, inferred type of `name` is `str`</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>  <span class="c1"># type checker error</span>
</pre></div>
</div>
<p>This function is useful for ensuring the type checker's understanding of a
script is in line with the developer's intentions:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">complex_function</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">object</span><span class="p">):</span>
    <span class="c1"># Do some complex type-narrowing logic,</span>
    <span class="c1"># after which we hope the inferred type will be `int`</span>
    <span class="o">...</span>
    <span class="c1"># Test whether the type checker correctly understands our function</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.assert_never">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">assert_never</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.assert_never" title="連結到這個定義">¶</a></dt>
<dd><p>Ask a static type checker to confirm that a line of code is unreachable.</p>
<p>舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">int_or_str</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">match</span> <span class="n">arg</span><span class="p">:</span>
        <span class="k">case</span> <span class="nb">int</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s an int&quot;</span><span class="p">)</span>
        <span class="k">case</span> <span class="nb">str</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s a str&quot;</span><span class="p">)</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span> <span class="k">as</span> <span class="n">unreachable</span><span class="p">:</span>
            <span class="n">assert_never</span><span class="p">(</span><span class="n">unreachable</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, the annotations allow the type checker to infer that the
last case can never execute, because <code class="docutils literal notranslate"><span class="pre">arg</span></code> is either
an <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, and both options are covered by
earlier cases.</p>
<p>If a type checker finds that a call to <code class="docutils literal notranslate"><span class="pre">assert_never()</span></code> is
reachable, it will emit an error. For example, if the type annotation
for <code class="docutils literal notranslate"><span class="pre">arg</span></code> was instead <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">|</span> <span class="pre">str</span> <span class="pre">|</span> <span class="pre">float</span></code>, the type checker would
emit an error pointing out that <code class="docutils literal notranslate"><span class="pre">unreachable</span></code> is of type <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>.
For a call to <code class="docutils literal notranslate"><span class="pre">assert_never</span></code> to pass type checking, the inferred type of
the argument passed in must be the bottom type, <a class="reference internal" href="#typing.Never" title="typing.Never"><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code></a>, and nothing
else.</p>
<p>At runtime, this throws an exception when called.</p>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p><a class="reference external" href="https://typing.readthedocs.io/en/latest/source/unreachable.html">Unreachable Code and Exhaustiveness Checking</a> has more
information about exhaustiveness checking with static typing.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.reveal_type">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">reveal_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.reveal_type" title="連結到這個定義">¶</a></dt>
<dd><p>Ask a static type checker to reveal the inferred type of an expression.</p>
<p>When a static type checker encounters a call to this function,
it emits a diagnostic with the inferred type of the argument. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Revealed type is &quot;builtins.int&quot;</span>
</pre></div>
</div>
<p>This can be useful when you want to debug how your type checker
handles a particular piece of code.</p>
<p>At runtime, this function prints the runtime type of its argument to
<a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> and returns the argument unchanged (allowing the call to
be used within an expression):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">reveal_type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># prints &quot;Runtime type is int&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># prints &quot;1&quot;</span>
</pre></div>
</div>
<p>Note that the runtime type may be different from (more or less specific
than) the type statically inferred by a type checker.</p>
<p>Most type checkers support <code class="docutils literal notranslate"><span class="pre">reveal_type()</span></code> anywhere, even if the
name is not imported from <code class="docutils literal notranslate"><span class="pre">typing</span></code>. Importing the name from
<code class="docutils literal notranslate"><span class="pre">typing</span></code>, however, allows your code to run without runtime errors and
communicates intent more clearly.</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.dataclass_transform">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">dataclass_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kw_only_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frozen_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_specifiers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.dataclass_transform" title="連結到這個定義">¶</a></dt>
<dd><p>Decorator to mark an object as providing
<a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass</span></code></a>-like behavior.</p>
<p><code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> may be used to
decorate a class, metaclass, or a function that is itself a decorator.
The presence of <code class="docutils literal notranslate"><span class="pre">&#64;dataclass_transform()</span></code> tells a static type checker that the
decorated object performs runtime &quot;magic&quot; that
transforms a class in a similar way to
<a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code></a>.</p>
<p>Example usage with a decorator function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">create_model</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="bp">cls</span>

<span class="nd">@create_model</span>
<span class="k">class</span> <span class="nc">CustomerModel</span><span class="p">:</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p>On a base class:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">ModelBase</span><span class="p">:</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">CustomerModel</span><span class="p">(</span><span class="n">ModelBase</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p>On a metaclass:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">ModelMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">ModelBase</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ModelMeta</span><span class="p">):</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">CustomerModel</span><span class="p">(</span><span class="n">ModelBase</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">CustomerModel</span></code> classes defined above will
be treated by type checkers similarly to classes created with
<a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code></a>.
For example, type checkers will assume these classes have
<code class="docutils literal notranslate"><span class="pre">__init__</span></code> methods that accept <code class="docutils literal notranslate"><span class="pre">id</span></code> and <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<p>The decorated class, metaclass, or function may accept the following bool
arguments which type checkers will assume have the same effect as they
would have on the
<a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code></a> decorator: <code class="docutils literal notranslate"><span class="pre">init</span></code>,
<code class="docutils literal notranslate"><span class="pre">eq</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span></code>, <code class="docutils literal notranslate"><span class="pre">unsafe_hash</span></code>, <code class="docutils literal notranslate"><span class="pre">frozen</span></code>, <code class="docutils literal notranslate"><span class="pre">match_args</span></code>,
<code class="docutils literal notranslate"><span class="pre">kw_only</span></code>, and <code class="docutils literal notranslate"><span class="pre">slots</span></code>. It must be possible for the value of these
arguments (<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>) to be statically evaluated.</p>
<p>The arguments to the <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> decorator can be used to
customize the default behaviors of the decorated class, metaclass, or
function:</p>
<dl class="field-list simple">
<dt class="field-odd">參數<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eq_default</strong> (<a class="reference internal" href="functions.html#bool" title="bool"><em>bool</em></a>) -- Indicates whether the <code class="docutils literal notranslate"><span class="pre">eq</span></code> parameter is assumed to be
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> if it is omitted by the caller.
Defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>order_default</strong> (<a class="reference internal" href="functions.html#bool" title="bool"><em>bool</em></a>) -- Indicates whether the <code class="docutils literal notranslate"><span class="pre">order</span></code> parameter is
assumed to be <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> if it is omitted by the caller.
Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>kw_only_default</strong> (<a class="reference internal" href="functions.html#bool" title="bool"><em>bool</em></a>) -- Indicates whether the <code class="docutils literal notranslate"><span class="pre">kw_only</span></code> parameter is
assumed to be <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> if it is omitted by the caller.
Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>frozen_default</strong> (<a class="reference internal" href="functions.html#bool" title="bool"><em>bool</em></a>) -- <p>Indicates whether the <code class="docutils literal notranslate"><span class="pre">frozen</span></code> parameter is
assumed to be <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> if it is omitted by the caller.
Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.12 版被加入.</span></p>
</div>
</p></li>
<li><p><strong>field_specifiers</strong> (<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><em>tuple</em></a><em>[</em><a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><em>Callable</em></a><em>[</em><em>...</em><em>, </em><em>Any</em><em>]</em><em>, </em><em>...</em><em>]</em>) -- Specifies a static list of supported classes
or functions that describe fields, similar to <a class="reference internal" href="dataclasses.html#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclasses.field()</span></code></a>.
Defaults to <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p></li>
<li><p><strong>**kwargs</strong> (<em>Any</em>) -- Arbitrary other keyword arguments are accepted in order to allow for
possible future extensions.</p></li>
</ul>
</dd>
</dl>
<p>Type checkers recognize the following optional parameters on field
specifiers:</p>
<table class="docutils align-default" id="id6">
<caption><span class="caption-text"><strong>Recognised parameters for field specifiers</strong></span><a class="headerlink" href="#id6" title="連結到這個表格">¶</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 80.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">init</span></code></p></td>
<td><p>Indicates whether the field should be included in the
synthesized <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method. If unspecified, <code class="docutils literal notranslate"><span class="pre">init</span></code> defaults to
<code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">default</span></code></p></td>
<td><p>Provides the default value for the field.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">default_factory</span></code></p></td>
<td><p>Provides a runtime callback that returns the
default value for the field. If neither <code class="docutils literal notranslate"><span class="pre">default</span></code> nor
<code class="docutils literal notranslate"><span class="pre">default_factory</span></code> are specified, the field is assumed to have no
default value and must be provided a value when the class is
instantiated.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">factory</span></code></p></td>
<td><p>An alias for the <code class="docutils literal notranslate"><span class="pre">default_factory</span></code> parameter on field specifiers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">kw_only</span></code></p></td>
<td><p>Indicates whether the field should be marked as
keyword-only. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the field will be keyword-only. If
<code class="docutils literal notranslate"><span class="pre">False</span></code>, it will not be keyword-only. If unspecified, the value of
the <code class="docutils literal notranslate"><span class="pre">kw_only</span></code> parameter on the object decorated with
<code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> will be used, or if that is unspecified, the
value of <code class="docutils literal notranslate"><span class="pre">kw_only_default</span></code> on <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> will be used.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">alias</span></code></p></td>
<td><p>Provides an alternative name for the field. This alternative
name is used in the synthesized <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method.</p></td>
</tr>
</tbody>
</table>
<p>At runtime, this decorator records its arguments in the
<code class="docutils literal notranslate"><span class="pre">__dataclass_transform__</span></code> attribute on the decorated object.
It has no other runtime effect.</p>
<p>更多細節請見 <span class="target" id="index-114"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py function" id="overload">
<dt class="sig sig-object py" id="typing.overload">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">overload</span></span><a class="headerlink" href="#typing.overload" title="連結到這個定義">¶</a></dt>
<dd><p>Decorator for creating overloaded functions and methods.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> decorator allows describing functions and methods
that support multiple different combinations of argument types. A series
of <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated definitions must be followed by exactly one
non-<code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated definition (for the same function/method).</p>
<p><code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated definitions are for the benefit of the
type checker only, since they will be overwritten by the
non-<code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated definition. The non-<code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated
definition, meanwhile, will be used at
runtime but should be ignored by a type checker.  At runtime, calling
an <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated function directly will raise
<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
<p>An example of overload that gives a more
precise type than can be expressed using a union or a type variable:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="o">...</span>  <span class="c1"># actual implementation goes here</span>
</pre></div>
</div>
<p>See <span class="target" id="index-31"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> for more details and comparison with other typing semantics.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>Overloaded functions can now be introspected at runtime using
<a class="reference internal" href="#typing.get_overloads" title="typing.get_overloads"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_overloads()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_overloads">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_overloads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_overloads" title="連結到這個定義">¶</a></dt>
<dd><p>Return a sequence of <a class="reference internal" href="#typing.overload" title="typing.overload"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;overload</span></code></a>-decorated definitions for
<em>func</em>.</p>
<p><em>func</em> is the function object for the implementation of the
overloaded function. For example, given the definition of <code class="docutils literal notranslate"><span class="pre">process</span></code> in
the documentation for <a class="reference internal" href="#typing.overload" title="typing.overload"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;overload</span></code></a>,
<code class="docutils literal notranslate"><span class="pre">get_overloads(process)</span></code> will return a sequence of three function objects
for the three defined overloads. If called on a function with no overloads,
<code class="docutils literal notranslate"><span class="pre">get_overloads()</span></code> returns an empty sequence.</p>
<p><code class="docutils literal notranslate"><span class="pre">get_overloads()</span></code> can be used for introspecting an overloaded function at
runtime.</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.clear_overloads">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">clear_overloads</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.clear_overloads" title="連結到這個定義">¶</a></dt>
<dd><p>Clear all registered overloads in the internal registry.</p>
<p>This can be used to reclaim the memory used by the registry.</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.11 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.final">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">final</span></span><a class="headerlink" href="#typing.final" title="連結到這個定義">¶</a></dt>
<dd><p>Decorator to indicate final methods and final classes.</p>
<p>Decorating a method with <code class="docutils literal notranslate"><span class="pre">&#64;final</span></code> indicates to a type checker that the
method cannot be overridden in a subclass. Decorating a class with <code class="docutils literal notranslate"><span class="pre">&#64;final</span></code>
indicates that it cannot be subclassed.</p>
<p>舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>
<span class="k">class</span> <span class="nc">Sub</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Error reported by type checker</span>
        <span class="o">...</span>

<span class="nd">@final</span>
<span class="k">class</span> <span class="nc">Leaf</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">class</span> <span class="nc">Other</span><span class="p">(</span><span class="n">Leaf</span><span class="p">):</span>  <span class="c1"># Error reported by type checker</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>這些屬性 (property) 不會在 runtime 時進行檢查。更多詳細資訊請看 <span class="target" id="index-115"></span><a class="pep reference external" href="https://peps.python.org/pep-0591/"><strong>PEP 591</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.8 版被加入.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>The decorator will now attempt to set a <code class="docutils literal notranslate"><span class="pre">__final__</span></code> attribute to <code class="docutils literal notranslate"><span class="pre">True</span></code>
on the decorated object. Thus, a check like
<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">getattr(obj,</span> <span class="pre">&quot;__final__&quot;,</span> <span class="pre">False)</span></code> can be used at runtime
to determine whether an object <code class="docutils literal notranslate"><span class="pre">obj</span></code> has been marked as final.
If the decorated object does not support setting attributes,
the decorator returns the object unchanged without raising an exception.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.no_type_check">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">no_type_check</span></span><a class="headerlink" href="#typing.no_type_check" title="連結到這個定義">¶</a></dt>
<dd><p>Decorator to indicate that annotations are not type hints.</p>
<p>This works as a class or function <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>.  With a class, it
applies recursively to all methods and classes defined in that class
(but not to methods defined in its superclasses or subclasses). Type
checkers will ignore all annotations in a function or class with this
decorator.</p>
<p><code class="docutils literal notranslate"><span class="pre">&#64;no_type_check</span></code> mutates the decorated object in place.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.no_type_check_decorator">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">no_type_check_decorator</span></span><a class="headerlink" href="#typing.no_type_check_decorator" title="連結到這個定義">¶</a></dt>
<dd><p>Decorator to give another decorator the <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a> effect.</p>
<p>This wraps the decorator with something that wraps the decorated
function in <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.override">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">override</span></span><a class="headerlink" href="#typing.override" title="連結到這個定義">¶</a></dt>
<dd><p>Decorator to indicate that a method in a subclass is intended to override a
method or attribute in a superclass.</p>
<p>Type checkers should emit an error if a method decorated with <code class="docutils literal notranslate"><span class="pre">&#64;override</span></code>
does not, in fact, override anything.
This helps prevent bugs that may occur when a base class is changed without
an equivalent change to a child class.</p>
<p>舉例來說：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">log_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

<span class="k">class</span> <span class="nc">Sub</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">log_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Okay: overrides Base.log_status</span>
        <span class="o">...</span>

    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Error reported by type checker</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>There is no runtime checking of this property.</p>
<p>The decorator will attempt to set an <code class="docutils literal notranslate"><span class="pre">__override__</span></code> attribute to <code class="docutils literal notranslate"><span class="pre">True</span></code> on
the decorated object. Thus, a check like
<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">getattr(obj,</span> <span class="pre">&quot;__override__&quot;,</span> <span class="pre">False)</span></code> can be used at runtime to determine
whether an object <code class="docutils literal notranslate"><span class="pre">obj</span></code> has been marked as an override.  If the decorated object
does not support setting attributes, the decorator returns the object unchanged
without raising an exception.</p>
<p>更多細節請見 <span class="target" id="index-116"></span><a class="pep reference external" href="https://peps.python.org/pep-0698/"><strong>PEP 698</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.12 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.type_check_only">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">type_check_only</span></span><a class="headerlink" href="#typing.type_check_only" title="連結到這個定義">¶</a></dt>
<dd><p>Decorator to mark a class or function as unavailable at runtime.</p>
<p>This decorator is itself not available at runtime. It is mainly
intended to mark classes that are defined in type stub files if
an implementation returns an instance of a private class:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@type_check_only</span>
<span class="k">class</span> <span class="nc">Response</span><span class="p">:</span>  <span class="c1"># private or not available at runtime</span>
    <span class="n">code</span><span class="p">:</span> <span class="nb">int</span>
    <span class="k">def</span> <span class="nf">get_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">fetch_response</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>Note that returning instances of private classes is not recommended.
It is usually preferable to make such classes public.</p>
</dd></dl>

</section>
<section id="introspection-helpers">
<h3>Introspection helpers<a class="headerlink" href="#introspection-helpers" title="連結到這個標頭">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="typing.get_type_hints">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_type_hints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globalns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">localns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_extras</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_type_hints" title="連結到這個定義">¶</a></dt>
<dd><p>Return a dictionary containing type hints for a function, method, module
or class object.</p>
<p>This is often the same as <code class="docutils literal notranslate"><span class="pre">obj.__annotations__</span></code>, but this function makes
the following changes to the annotations dictionary:</p>
<ul class="simple">
<li><p>Forward references encoded as string literals or <a class="reference internal" href="#typing.ForwardRef" title="typing.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a>
objects are handled by evaluating them in <em>globalns</em>, <em>localns</em>, and
(where applicable) <em>obj</em>'s <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameter</span></a> namespace.
If <em>globalns</em> or <em>localns</em> is not given, appropriate namespace
dictionaries are inferred from <em>obj</em>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> is replaced with <a class="reference internal" href="types.html#types.NoneType" title="types.NoneType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.NoneType</span></code></a>.</p></li>
<li><p>If <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;no_type_check</span></code></a> has been applied to <em>obj</em>, an
empty dictionary is returned.</p></li>
<li><p>If <em>obj</em> is a class <code class="docutils literal notranslate"><span class="pre">C</span></code>, the function returns a dictionary that merges
annotations from <code class="docutils literal notranslate"><span class="pre">C</span></code>'s base classes with those on <code class="docutils literal notranslate"><span class="pre">C</span></code> directly. This
is done by traversing <code class="docutils literal notranslate"><span class="pre">C.__mro__</span></code> and iteratively combining
<code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> dictionaries. Annotations on classes appearing
earlier in the <a class="reference internal" href="../glossary.html#term-method-resolution-order"><span class="xref std std-term">method resolution order</span></a> always take precedence over
annotations on classes appearing later in the method resolution order.</p></li>
<li><p>The function recursively replaces all occurrences of <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">...]</span></code>
with <code class="docutils literal notranslate"><span class="pre">T</span></code>, unless <em>include_extras</em> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (see
<a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Annotated</span></code></a> for more information).</p></li>
</ul>
<p>See also <a class="reference internal" href="inspect.html#inspect.get_annotations" title="inspect.get_annotations"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.get_annotations()</span></code></a>, a lower-level function that
returns annotations more directly.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>If any forward references in the annotations of <em>obj</em> are not resolvable
or are not valid Python code, this function will raise an exception
such as <a class="reference internal" href="exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>. For example, this can happen with imported
<a class="reference internal" href="#type-aliases"><span class="std std-ref">type aliases</span></a> that include forward references,
or with names imported under <a class="reference internal" href="#typing.TYPE_CHECKING" title="typing.TYPE_CHECKING"><code class="xref py py-data docutils literal notranslate"><span class="pre">if</span> <span class="pre">TYPE_CHECKING</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版的變更: </span>新增 <code class="docutils literal notranslate"><span class="pre">include_extras</span></code> 參數（如 <span class="target" id="index-117"></span><a class="pep reference external" href="https://peps.python.org/pep-0593/"><strong>PEP 593</strong></a> 中所述）。更多資訊請見 <a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-data docutils literal notranslate"><span class="pre">Annotated</span></code></a> 的文件。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>Previously, <code class="docutils literal notranslate"><span class="pre">Optional[t]</span></code> was added for function and method annotations
if a default value equal to <code class="docutils literal notranslate"><span class="pre">None</span></code> was set.
Now the annotation is returned unchanged.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_origin">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_origin" title="連結到這個定義">¶</a></dt>
<dd><p>Get the unsubscripted version of a type: for a typing object of the form
<code class="docutils literal notranslate"><span class="pre">X[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> return <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">X</span></code> is a typing-module alias for a builtin or
<a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> class, it will be normalized to the original class.
If <code class="docutils literal notranslate"><span class="pre">X</span></code> is an instance of <a class="reference internal" href="#typing.ParamSpecArgs" title="typing.ParamSpecArgs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code></a> or <a class="reference internal" href="#typing.ParamSpecKwargs" title="typing.ParamSpecKwargs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code></a>,
return the underlying <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>.
Return <code class="docutils literal notranslate"><span class="pre">None</span></code> for unsupported objects.</p>
<p>舉例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Union</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.8 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_args">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_args</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_args" title="連結到這個定義">¶</a></dt>
<dd><p>Get type arguments with all substitutions performed: for a typing object
of the form <code class="docutils literal notranslate"><span class="pre">X[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> return <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">X</span></code> is a union or <a class="reference internal" href="#typing.Literal" title="typing.Literal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Literal</span></code></a> contained in another
generic type, the order of <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code> may be different from the order
of the original arguments <code class="docutils literal notranslate"><span class="pre">[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> due to type caching.
Return <code class="docutils literal notranslate"><span class="pre">()</span></code> for unsupported objects.</p>
<p>舉例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="p">()</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.8 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.is_typeddict">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">is_typeddict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.is_typeddict" title="連結到這個定義">¶</a></dt>
<dd><p>Check if a type is a <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a>.</p>
<p>舉例來說：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Film</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">year</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">assert</span> <span class="n">is_typeddict</span><span class="p">(</span><span class="n">Film</span><span class="p">)</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="n">is_typeddict</span><span class="p">(</span><span class="nb">list</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span>

<span class="c1"># TypedDict is a factory for creating typed dicts,</span>
<span class="c1"># not a typed dict itself</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="n">is_typeddict</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.10 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ForwardRef">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ForwardRef</span></span><a class="headerlink" href="#typing.ForwardRef" title="連結到這個定義">¶</a></dt>
<dd><p>Class used for internal typing representation of string forward references.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">List[&quot;SomeClass&quot;]</span></code> is implicitly transformed into
<code class="docutils literal notranslate"><span class="pre">List[ForwardRef(&quot;SomeClass&quot;)]</span></code>.  <code class="docutils literal notranslate"><span class="pre">ForwardRef</span></code> should not be instantiated by
a user, but may be used by introspection tools.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p><span class="target" id="index-35"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> generic types such as <code class="docutils literal notranslate"><span class="pre">list[&quot;SomeClass&quot;]</span></code> will not be
implicitly transformed into <code class="docutils literal notranslate"><span class="pre">list[ForwardRef(&quot;SomeClass&quot;)]</span></code> and thus
will not automatically resolve to <code class="docutils literal notranslate"><span class="pre">list[SomeClass]</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.7.4 版被加入.</span></p>
</div>
</dd></dl>

</section>
<section id="constant">
<h3>常數<a class="headerlink" href="#constant" title="連結到這個標頭">¶</a></h3>
<dl class="py data">
<dt class="sig sig-object py" id="typing.TYPE_CHECKING">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TYPE_CHECKING</span></span><a class="headerlink" href="#typing.TYPE_CHECKING" title="連結到這個定義">¶</a></dt>
<dd><p>A special constant that is assumed to be <code class="docutils literal notranslate"><span class="pre">True</span></code> by 3rd party static
type checkers. It is <code class="docutils literal notranslate"><span class="pre">False</span></code> at runtime.</p>
<p>Usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">expensive_mod</span>

<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="s1">&#39;expensive_mod.SomeType&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">local_var</span><span class="p">:</span> <span class="n">expensive_mod</span><span class="o">.</span><span class="n">AnotherType</span> <span class="o">=</span> <span class="n">other_fun</span><span class="p">()</span>
</pre></div>
</div>
<p>The first type annotation must be enclosed in quotes, making it a
&quot;forward reference&quot;, to hide the <code class="docutils literal notranslate"><span class="pre">expensive_mod</span></code> reference from the
interpreter runtime.  Type annotations for local variables are not
evaluated, so the second annotation does not need to be enclosed in quotes.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>If <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code> is used,
annotations are not evaluated at function definition time.
Instead, they are stored as strings in <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code>.
This makes it unnecessary to use quotes around the annotation
(see <span class="target" id="index-36"></span><a class="pep reference external" href="https://peps.python.org/pep-0563/"><strong>PEP 563</strong></a>).</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.5.2 版被加入.</span></p>
</div>
</dd></dl>

</section>
<section id="deprecated-aliases">
<span id="generic-concrete-collections"></span><span id="id5"></span><h3>棄用的別名<a class="headerlink" href="#deprecated-aliases" title="連結到這個標頭">¶</a></h3>
<p>This module defines several deprecated aliases to pre-existing
standard library classes. These were originally included in the typing
module in order to support parameterizing these generic classes using <code class="docutils literal notranslate"><span class="pre">[]</span></code>.
However, the aliases became redundant in Python 3.9 when the
corresponding pre-existing classes were enhanced to support <code class="docutils literal notranslate"><span class="pre">[]</span></code> (see
<span class="target" id="index-37"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a>).</p>
<p>The redundant types are deprecated as of Python 3.9. However, while the aliases
may be removed at some point, removal of these aliases is not currently
planned. As such, no deprecation warnings are currently issued by the
interpreter for these aliases.</p>
<p>If at some point it is decided to remove these deprecated aliases, a
deprecation warning will be issued by the interpreter for at least two releases
prior to removal. The aliases are guaranteed to remain in the typing module
without deprecation warnings until at least Python 3.14.</p>
<p>Type checkers are encouraged to flag uses of the deprecated types if the
program they are checking targets a minimum Python version of 3.9 or newer.</p>
<section id="aliases-to-built-in-types">
<span id="corresponding-to-built-in-types"></span><h4>內建型別的別名<a class="headerlink" href="#aliases-to-built-in-types" title="連結到這個標頭">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Dict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">dict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Dict" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 的別名。</p>
<p>Note that to annotate arguments, it is preferred
to use an abstract collection type such as <a class="reference internal" href="#typing.Mapping" title="typing.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a>
rather than to use <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Dict</span></code>.</p>
<p>This type can be used as follows:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_words</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.dict</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-38"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.List">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">List</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">list,</span> <span class="pre">MutableSequence[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.List" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 的別名。</p>
<p>Note that to annotate arguments, it is preferred
to use an abstract collection type such as <a class="reference internal" href="#typing.Sequence" title="typing.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> or
<a class="reference internal" href="#typing.Iterable" title="typing.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> rather than to use <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.List</span></code>.</p>
<p>This type may be used as follows:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">vec2</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)](</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">keep_positives</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)](</span><span class="n">vector</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">vector</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.list</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-39"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Set">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">set,</span> <span class="pre">MutableSet[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Set" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a> 的別名。</p>
<p>Note that to annotate arguments, it is preferred
to use an abstract collection type such as <a class="reference internal" href="#typing.AbstractSet" title="typing.AbstractSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractSet</span></code></a>
rather than to use <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Set</span></code>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-40"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.FrozenSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">FrozenSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">frozenset,</span> <span class="pre">AbstractSet[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.FrozenSet" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a>
now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-41"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Tuple">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Tuple</span></span><a class="headerlink" href="#typing.Tuple" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 的別名。</p>
<p><a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> and <code class="docutils literal notranslate"><span class="pre">Tuple</span></code> are special-cased in the type system; see
<a class="reference internal" href="#annotating-tuples"><span class="std std-ref">註釋元組 (tuple)</span></a> for more details.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.tuple</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-42"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Type">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[CT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Type" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 的別名。</p>
<p>See <a class="reference internal" href="#type-of-class-objects"><span class="std std-ref">類別物件的型別</span></a> for details on using <a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> or
<code class="docutils literal notranslate"><span class="pre">typing.Type</span></code> in type annotations.</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.5.2 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-43"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-types-in-collections">
<span id="corresponding-to-types-in-collections"></span><h4><a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 中型別的別名<a class="headerlink" href="#aliases-to-types-in-collections" title="連結到這個標頭">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.DefaultDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">DefaultDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.defaultdict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.DefaultDict" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a> 的別名。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.5.2 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-44"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.OrderedDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">OrderedDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.OrderedDict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.OrderedDict" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 的別名。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.7.2 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-45"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ChainMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ChainMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.ChainMap,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ChainMap" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a> 的別名。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.6.1 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-46"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Counter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Counter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.Counter,</span> <span class="pre">Dict[T,</span> <span class="pre">int]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Counter" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a> 的別名。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.6.1 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-47"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Deque">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Deque</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">deque,</span> <span class="pre">MutableSequence[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Deque" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a> 的別名。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.6.1 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-48"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-other-concrete-types">
<span id="other-concrete-types"></span><h4>Aliases to other concrete types<a class="headerlink" href="#aliases-to-other-concrete-types" title="連結到這個標頭">¶</a></h4>
<blockquote>
<div><div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.8, will be removed in version 3.13: </span>The <code class="docutils literal notranslate"><span class="pre">typing.io</span></code> namespace is deprecated and will be removed.
These types should be directly imported from <code class="docutils literal notranslate"><span class="pre">typing</span></code> instead.</p>
</div>
</div></blockquote>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Pattern">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Pattern</span></span><a class="headerlink" href="#typing.Pattern" title="連結到這個定義">¶</a></dt>
<dt class="sig sig-object py" id="typing.Match">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Match</span></span><a class="headerlink" href="#typing.Match" title="連結到這個定義">¶</a></dt>
<dd><p>Deprecated aliases corresponding to the return types from
<a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> and <a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a>.</p>
<p>These types (and the corresponding functions) are generic over
<a class="reference internal" href="#typing.AnyStr" title="typing.AnyStr"><code class="xref py py-data docutils literal notranslate"><span class="pre">AnyStr</span></code></a>. <code class="docutils literal notranslate"><span class="pre">Pattern</span></code> can be specialised as <code class="docutils literal notranslate"><span class="pre">Pattern[str]</span></code> or
<code class="docutils literal notranslate"><span class="pre">Pattern[bytes]</span></code>; <code class="docutils literal notranslate"><span class="pre">Match</span></code> can be specialised as <code class="docutils literal notranslate"><span class="pre">Match[str]</span></code> or
<code class="docutils literal notranslate"><span class="pre">Match[bytes]</span></code>.</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.8, will be removed in version 3.13: </span>The <code class="docutils literal notranslate"><span class="pre">typing.re</span></code> namespace is deprecated and will be removed.
These types should be directly imported from <code class="docutils literal notranslate"><span class="pre">typing</span></code> instead.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span>Classes <code class="docutils literal notranslate"><span class="pre">Pattern</span></code> and <code class="docutils literal notranslate"><span class="pre">Match</span></code> from <a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> now support <code class="docutils literal notranslate"><span class="pre">[]</span></code>.
See <span class="target" id="index-49"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Text">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Text</span></span><a class="headerlink" href="#typing.Text" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 的別名。</p>
<p><code class="docutils literal notranslate"><span class="pre">Text</span></code> is provided to supply a forward
compatible path for Python 2 code: in Python 2, <code class="docutils literal notranslate"><span class="pre">Text</span></code> is an alias for
<code class="docutils literal notranslate"><span class="pre">unicode</span></code>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">Text</span></code> to indicate that a value must contain a unicode string in
a manner that is compatible with both Python 2 and Python 3:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_unicode_checkmark</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Text</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">text</span> <span class="o">+</span> <span class="sa">u</span><span class="s1">&#39; </span><span class="se">\u2713</span><span class="s1">&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.5.2 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.11 版之後被棄用: </span>Python 2 is no longer supported, and most type checkers also no longer
support type checking Python 2 code. Removal of the alias is not
currently planned, but users are encouraged to use
<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> instead of <code class="docutils literal notranslate"><span class="pre">Text</span></code>.</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-container-abcs-in-collections-abc">
<span id="corresponding-to-collections-in-collections-abc"></span><span id="abstract-base-classes"></span><h4><a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 中容器 ABC 的別名<a class="headerlink" href="#aliases-to-container-abcs-in-collections-abc" title="連結到這個標頭">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.AbstractSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AbstractSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Collection[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AbstractSet" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-50"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ByteString">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ByteString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sequence[int]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ByteString" title="連結到這個定義">¶</a></dt>
<dd><p>This type represents the types <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>,
and <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> of byte sequences.</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.9, will be removed in version 3.14: </span>Prefer <a class="reference internal" href="collections.abc.html#collections.abc.Buffer" title="collections.abc.Buffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Buffer</span></code></a>, or a union like <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">|</span> <span class="pre">bytearray</span> <span class="pre">|</span> <span class="pre">memoryview</span></code>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Collection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Collection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sized,</span> <span class="pre">Iterable[T_co],</span> <span class="pre">Container[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Collection" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a> 的別名。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.6 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-51"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Container">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Container</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Container" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-52"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ItemsView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ItemsView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">AbstractSet[tuple[KT_co,</span> <span class="pre">VT_co]]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ItemsView" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-53"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.KeysView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">KeysView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">AbstractSet[KT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.KeysView" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-54"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Mapping">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Collection[KT],</span> <span class="pre">Generic[KT,</span> <span class="pre">VT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Mapping" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> 的別名。</p>
<p>This type can be used as follows:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_position_in_index</span><span class="p">(</span><span class="n">word_list</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">word_list</span><span class="p">[</span><span class="n">word</span><span class="p">]</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-55"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MappingView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MappingView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Sized</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MappingView" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-56"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableMapping">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableMapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Mapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableMapping" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a>
now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-57"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableSequence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableSequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sequence[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSequence" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a>
now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-58"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AbstractSet[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSet" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-59"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Sequence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Sequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Reversible[T_co],</span> <span class="pre">Collection[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Sequence" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-60"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ValuesView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ValuesView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">Collection[_VT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ValuesView" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-61"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-asynchronous-abcs-in-collections-abc">
<span id="asynchronous-programming"></span><h4>Aliases to asynchronous ABCs in <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a><a class="headerlink" href="#aliases-to-asynchronous-abcs-in-collections-abc" title="連結到這個標頭">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Coroutine">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Coroutine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Awaitable[ReturnType],</span> <span class="pre">Generic[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Coroutine" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a> 的別名。</p>
<p>The variance and order of type variables
correspond to those of <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>, for example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Coroutine</span>
<span class="n">c</span><span class="p">:</span> <span class="n">Coroutine</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>  <span class="c1"># Some coroutine defined elsewhere</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hi&#39;</span><span class="p">)</span>                   <span class="c1"># Inferred type of &#39;x&#39; is list[str]</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="k">await</span> <span class="n">c</span>                    <span class="c1"># Inferred type of &#39;y&#39; is int</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.5.3 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-62"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncGenerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AsyncIterator[YieldType],</span> <span class="pre">Generic[YieldType,</span> <span class="pre">SendType]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncGenerator" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncGenerator</span></code></a> 的別名。</p>
<p>An async generator can be annotated by the generic type
<code class="docutils literal notranslate"><span class="pre">AsyncGenerator[YieldType,</span> <span class="pre">SendType]</span></code>. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">rounded</span> <span class="o">=</span> <span class="k">await</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">rounded</span>
</pre></div>
</div>
<p>Unlike normal generators, async generators cannot return a value, so there
is no <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> type parameter. As with <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>, the
<code class="docutils literal notranslate"><span class="pre">SendType</span></code> behaves contravariantly.</p>
<p>If your generator will only yield values, set the <code class="docutils literal notranslate"><span class="pre">SendType</span></code> to
<code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, annotate your generator as having a return type of
either <code class="docutils literal notranslate"><span class="pre">AsyncIterable[YieldType]</span></code> or <code class="docutils literal notranslate"><span class="pre">AsyncIterator[YieldType]</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 3.6.1 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncGenerator</span></code></a>
now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-63"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncIterable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncIterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterable" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a> 的別名。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.5.2 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-64"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncIterator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncIterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AsyncIterable[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterator" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a> 的別名。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.5.2 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-65"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Awaitable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Awaitable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Awaitable" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a> 的別名。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.5.2 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-66"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-other-abcs-in-collections-abc">
<span id="corresponding-to-other-types-in-collections-abc"></span><h4>Aliases to other ABCs in <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a><a class="headerlink" href="#aliases-to-other-abcs-in-collections-abc" title="連結到這個標頭">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Iterable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Iterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterable" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-67"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Iterator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterable[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterator" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-68"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Callable">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Callable</span></span><a class="headerlink" href="#typing.Callable" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> 的別名。</p>
<p>See <a class="reference internal" href="#annotating-callables"><span class="std std-ref">註釋 callable 物件</span></a> for details on how to use
<a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> and <code class="docutils literal notranslate"><span class="pre">typing.Callable</span></code> in type annotations.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-69"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版的變更: </span><code class="docutils literal notranslate"><span class="pre">Callable</span></code> 現已支援 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 以及 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>。請參閱 <span class="target" id="index-118"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> 閱讀詳細內容。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Generator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Generator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterator[YieldType],</span> <span class="pre">Generic[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Generator" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Generator</span></code></a> 的別名。</p>
<p>A generator can be annotated by the generic type
<code class="docutils literal notranslate"><span class="pre">Generator[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></code>. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Done&#39;</span>
</pre></div>
</div>
<p>Note that unlike many other generics in the typing module, the <code class="docutils literal notranslate"><span class="pre">SendType</span></code>
of <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> behaves contravariantly, not covariantly or
invariantly.</p>
<p>If your generator will only yield values, set the <code class="docutils literal notranslate"><span class="pre">SendType</span></code> and
<code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> to <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Alternatively, annotate your generator as having a return type of
either <code class="docutils literal notranslate"><span class="pre">Iterable[YieldType]</span></code> or <code class="docutils literal notranslate"><span class="pre">Iterator[YieldType]</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Generator</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-71"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Hashable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Hashable</span></span><a class="headerlink" href="#typing.Hashable" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Hashable</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.12 版之後被棄用: </span>改為直接使用 <a class="reference internal" href="collections.abc.html#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Hashable</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Reversible">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Reversible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterable[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Reversible" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a> now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-72"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Sized">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Sized</span></span><a class="headerlink" href="#typing.Sized" title="連結到這個定義">¶</a></dt>
<dd><p>棄用 <a class="reference internal" href="collections.abc.html#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></a> 的別名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.12 版之後被棄用: </span>改為直接使用 <a class="reference internal" href="collections.abc.html#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></a>。</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-contextlib-abcs">
<span id="context-manager-types"></span><h4><a class="reference internal" href="contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> ABC 的別名<a class="headerlink" href="#aliases-to-contextlib-abcs" title="連結到這個標頭">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.ContextManager">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ContextManager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ContextManager" title="連結到這個定義">¶</a></dt>
<dd><p>Deprecated alias to <a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.5.4 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a>
now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-73"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncContextManager">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncContextManager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncContextManager" title="連結到這個定義">¶</a></dt>
<dd><p>Deprecated alias to <a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.6.2 版被加入.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">在 3.9 版之後被棄用: </span><a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a>
now supports subscripting (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).
See <span class="target" id="index-74"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> and <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a>.</p>
</div>
</dd></dl>

</section>
</section>
</section>
<section id="deprecation-timeline-of-major-features">
<h2>Deprecation Timeline of Major Features<a class="headerlink" href="#deprecation-timeline-of-major-features" title="連結到這個標頭">¶</a></h2>
<p>Certain features in <code class="docutils literal notranslate"><span class="pre">typing</span></code> are deprecated and may be removed in a future
version of Python. The following table summarizes major deprecations for your
convenience. This is subject to change, and not all deprecations are listed.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Feature</p></th>
<th class="head"><p>棄用於</p></th>
<th class="head"><p>Projected removal</p></th>
<th class="head"><p>PEP/issue</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">typing.io</span></code> 和 <code class="docutils literal notranslate"><span class="pre">typing.re</span></code> 子模組</p></td>
<td><p>3.8</p></td>
<td><p>3.13</p></td>
<td><p><a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=38291">bpo-38291</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">typing</span></code> versions of standard collections</p></td>
<td><p>3.9</p></td>
<td><p>Undecided (see <a class="reference internal" href="#deprecated-aliases"><span class="std std-ref">棄用的別名</span></a> for more information)</p></td>
<td><p><span class="target" id="index-75"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#typing.ByteString" title="typing.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.ByteString</span></code></a></p></td>
<td><p>3.9</p></td>
<td><p>3.14</p></td>
<td><p><a class="reference external" href="https://github.com/python/cpython/issues/91896">gh-91896</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#typing.Text" title="typing.Text"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.Text</span></code></a></p></td>
<td><p>3.11</p></td>
<td><p>Undecided</p></td>
<td><p><a class="reference external" href="https://github.com/python/cpython/issues/92332">gh-92332</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#typing.Hashable" title="typing.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Hashable</span></code></a> 和 <a class="reference internal" href="#typing.Sized" title="typing.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Sized</span></code></a></p></td>
<td><p>3.12</p></td>
<td><p>Undecided</p></td>
<td><p><a class="reference external" href="https://github.com/python/cpython/issues/94309">gh-94309</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.TypeAlias</span></code></a></p></td>
<td><p>3.12</p></td>
<td><p>Undecided</p></td>
<td><p><span class="target" id="index-76"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a></p></td>
</tr>
</tbody>
</table>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目錄</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> --- 支援型別提示</a><ul>
<li><a class="reference internal" href="#specification-for-the-python-type-system">Python 型別系統的技術規範</a></li>
<li><a class="reference internal" href="#type-aliases">型別別名</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#annotating-callable-objects">註釋 callable 物件</a></li>
<li><a class="reference internal" href="#generics">泛型</a></li>
<li><a class="reference internal" href="#annotating-tuples">註釋元組 (tuple)</a></li>
<li><a class="reference internal" href="#the-type-of-class-objects">類別物件的型別</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">使用者定義泛型型別</a></li>
<li><a class="reference internal" href="#the-any-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code> 型別</a></li>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping">標稱 (nominal) 子型別 vs 結構子型別</a></li>
<li><a class="reference internal" href="#module-contents">模組內容</a><ul>
<li><a class="reference internal" href="#special-typing-primitives">特別型別原語 (primitive)</a><ul>
<li><a class="reference internal" href="#special-types">特別型別</a></li>
<li><a class="reference internal" href="#special-forms">特別型式</a></li>
<li><a class="reference internal" href="#building-generic-types-and-type-aliases">Building generic types and type aliases</a></li>
<li><a class="reference internal" href="#other-special-directives">Other special directives</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">協定</a></li>
<li><a class="reference internal" href="#abcs-for-working-with-io">ABCs for working with IO</a></li>
<li><a class="reference internal" href="#functions-and-decorators">函式與裝飾器</a></li>
<li><a class="reference internal" href="#introspection-helpers">Introspection helpers</a></li>
<li><a class="reference internal" href="#constant">常數</a></li>
<li><a class="reference internal" href="#deprecated-aliases">棄用的別名</a><ul>
<li><a class="reference internal" href="#aliases-to-built-in-types">內建型別的別名</a></li>
<li><a class="reference internal" href="#aliases-to-types-in-collections"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code> 中型別的別名</a></li>
<li><a class="reference internal" href="#aliases-to-other-concrete-types">Aliases to other concrete types</a></li>
<li><a class="reference internal" href="#aliases-to-container-abcs-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code> 中容器 ABC 的別名</a></li>
<li><a class="reference internal" href="#aliases-to-asynchronous-abcs-in-collections-abc">Aliases to asynchronous ABCs in <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a></li>
<li><a class="reference internal" href="#aliases-to-other-abcs-in-collections-abc">Aliases to other ABCs in <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a></li>
<li><a class="reference internal" href="#aliases-to-contextlib-abcs"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code> ABC 的別名</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#deprecation-timeline-of-major-features">Deprecation Timeline of Major Features</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="development.html"
                          title="上一章">開發工具</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="pydoc.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> --- 文件產生器與線上幫助系統</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/typing.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="收合側邊欄">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc --- 文件產生器與線上幫助系統"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="development.html" title="開發工具"
             >上一頁</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準函式庫 (Standard Library)</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >開發工具</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> --- 支援型別提示</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" id="search-box" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    版權
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最後更新於 Aug 25, 2024 (13:44 UTC)。
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    使用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.0.2 建立。
    </div>

  </body>
</html>