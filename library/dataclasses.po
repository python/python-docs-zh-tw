# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-03 11:11+0800\n"
"PO-Revision-Date: 2023-02-11 15:02+0800\n"
"Last-Translator: \n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../library/dataclasses.rst:2
msgid ":mod:`!dataclasses` --- Data Classes"
msgstr ":mod:`!dataclasses` --- Data Classes"

#: ../../library/dataclasses.rst:10
msgid "**Source code:** :source:`Lib/dataclasses.py`"
msgstr "**原始碼：**\\ :source:`Lib/dataclasses.py`"

#: ../../library/dataclasses.rst:14
#, fuzzy
msgid ""
"This module provides a decorator and functions for automatically adding "
"generated :term:`special methods <special method>` such as :meth:`~object."
"__init__` and :meth:`~object.__repr__` to user-defined classes.  It was "
"originally described in :pep:`557`."
msgstr ""
"該模組提供了一個裝飾器和函式，用於自動新增生成的\\ :term:`特殊方法 <special "
"method>`，例如 :meth:`~object.__init__` 和 :meth:`~object.__repr__` 到使用者"
"定義的類。它最初在 :pep:`557` 中描述。"

#: ../../library/dataclasses.rst:19
#, fuzzy
msgid ""
"The member variables to use in these generated methods are defined using :"
"pep:`526` type annotations.  For example, this code::"
msgstr ""
"在這些生成的方法中使用的成員變數是使用 :pep:`526` 型別註釋定義的。例如，這段"
"程式碼： ::"

#: ../../library/dataclasses.rst:22
msgid ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    \"\"\"Class for keeping track of an item in inventory.\"\"\"\n"
"    name: str\n"
"    unit_price: float\n"
"    quantity_on_hand: int = 0\n"
"\n"
"    def total_cost(self) -> float:\n"
"        return self.unit_price * self.quantity_on_hand"
msgstr ""

#: ../../library/dataclasses.rst:34
#, fuzzy
msgid "will add, among other things, a :meth:`!__init__` that looks like::"
msgstr "將新增，除其他事項外，一個 :meth:`!__init__` 看起來像： ::"

#: ../../library/dataclasses.rst:36
msgid ""
"def __init__(self, name: str, unit_price: float, quantity_on_hand: int = "
"0):\n"
"    self.name = name\n"
"    self.unit_price = unit_price\n"
"    self.quantity_on_hand = quantity_on_hand"
msgstr ""

#: ../../library/dataclasses.rst:41
#, fuzzy
msgid ""
"Note that this method is automatically added to the class: it is not "
"directly specified in the :class:`!InventoryItem` definition shown above."
msgstr ""
"請注意，此方法會自動新增到類中：它不會在上面顯示的“InventoryItem”定義中直接指"
"定。"

#: ../../library/dataclasses.rst:47
msgid "Module contents"
msgstr "模組內容"

#: ../../library/dataclasses.rst:51
#, fuzzy
msgid ""
"This function is a :term:`decorator` that is used to add generated :term:"
"`special methods <special method>` to classes, as described below."
msgstr ""
"此函式是一個 :term:`decorator`，用於將生成的\\ :term:`特殊方法 <special "
"method>`\\新增到類別中，如下所述。"

#: ../../library/dataclasses.rst:54
#, fuzzy
msgid ""
"The ``@dataclass`` decorator examines the class to find ``field``\\s.  A "
"``field`` is defined as a class variable that has a :term:`type annotation "
"<variable annotation>`.  With two exceptions described below, nothing in "
"``@dataclass`` examines the type specified in the variable annotation."
msgstr ""
"``@dataclass`` 裝飾器檢查類以找到 ``field``\\s。 ``field`` 被定義為具有 :"
"term:`type annotation <variable annotation>` 的類變數。除了下面描述的兩個例"
"外，``@dataclass`` 中沒有任何內容檢查變數註釋中指定的型別。"

#: ../../library/dataclasses.rst:60
#, fuzzy
msgid ""
"The order of the fields in all of the generated methods is the order in "
"which they appear in the class definition."
msgstr "所有生成的方法中欄位的順序是它們在類定義中出現的順序。"

#: ../../library/dataclasses.rst:63
#, fuzzy
msgid ""
"The ``@dataclass`` decorator will add various \"dunder\" methods to the "
"class, described below.  If any of the added methods already exist in the "
"class, the behavior depends on the parameter, as documented below. The "
"decorator returns the same class that it is called on; no new class is "
"created."
msgstr ""
"``@dataclass`` 裝飾器將向類新增各種“dunder”方法，如下所述。如果類中已存在任何"
"新增的方法，則行為取決於參數，如下所述。裝飾器回傳呼叫它的同一個類；沒有建立"
"新類。"

#: ../../library/dataclasses.rst:69
#, fuzzy
msgid ""
"If ``@dataclass`` is used just as a simple decorator with no parameters, it "
"acts as if it has the default values documented in this signature.  That is, "
"these three uses of ``@dataclass`` are equivalent::"
msgstr ""
"如果 ``@dataclass`` 僅用作不帶參數的簡單裝飾器，它的行為就好像它具有此簽名中"
"記錄的預設值一樣。也就是說，``@dataclass`` 的這三種用法是等價的： ::"

#: ../../library/dataclasses.rst:74
msgid ""
"@dataclass\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass()\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, "
"frozen=False,\n"
"           match_args=True, kw_only=False, slots=False, weakref_slot=False)\n"
"class C:\n"
"    ..."
msgstr ""

#: ../../library/dataclasses.rst:87
msgid "The parameters to ``@dataclass`` are:"
msgstr "``@dataclass`` 的參數是："

#: ../../library/dataclasses.rst:89
#, fuzzy
msgid ""
"*init*: If true (the default), a :meth:`~object.__init__` method will be "
"generated."
msgstr "*init*：如果為真（預設值），將生成一個 :meth:`~object.__init__` 方法。"

#: ../../library/dataclasses.rst:92
#, fuzzy
msgid ""
"If the class already defines :meth:`!__init__`, this parameter is ignored."
msgstr "如果該類已經定義了 :meth:`!__init__`，則忽略此參數。"

#: ../../library/dataclasses.rst:95
#, fuzzy
msgid ""
"*repr*: If true (the default), a :meth:`~object.__repr__` method will be "
"generated.  The generated repr string will have the class name and the name "
"and repr of each field, in the order they are defined in the class.  Fields "
"that are marked as being excluded from the repr are not included.  For "
"example: ``InventoryItem(name='widget', unit_price=3.0, "
"quantity_on_hand=10)``."
msgstr ""
"*repr*：如果為真（預設值），將生成一個 :meth:`__repr__` 方法。生成的 repr 字"
"串將包含類名以及每個欄位的名稱和 repr，按照它們在類中定義的順序排列。不包括標"
"記為從 repr 中排除的欄位。例如：``InventoryItem(name='widget', "
"unit_price=3.0, quantity_on_hand=10)``。"

#: ../../library/dataclasses.rst:102
#, fuzzy
msgid ""
"If the class already defines :meth:`!__repr__`, this parameter is ignored."
msgstr "如果該類已經定義了 :meth:`!__repr__`，則忽略此參數。"

#: ../../library/dataclasses.rst:105
#, fuzzy
msgid ""
"*eq*: If true (the default), an :meth:`~object.__eq__` method will be "
"generated.  This method compares the class as if it were a tuple of its "
"fields, in order.  Both instances in the comparison must be of the identical "
"type."
msgstr ""
"*eq*：如果為真（預設值），將生成一個 :meth:`~object.__eq__` 方法。此方法按順"
"序比較類，就好像它是其欄位的元組一樣。比較中的兩個實例必須屬於同一型別。"

#: ../../library/dataclasses.rst:110
#, fuzzy
msgid ""
"If the class already defines :meth:`!__eq__`, this parameter is ignored."
msgstr "如果該類已經定義了 :meth:`!__eq__`，則忽略此參數。"

#: ../../library/dataclasses.rst:113
#, fuzzy
msgid ""
"*order*: If true (the default is ``False``), :meth:`~object.__lt__`, :meth:"
"`~object.__le__`, :meth:`~object.__gt__`, and :meth:`~object.__ge__` methods "
"will be generated.  These compare the class as if it were a tuple of its "
"fields, in order.  Both instances in the comparison must be of the identical "
"type.  If *order* is true and *eq* is false, a :exc:`ValueError` is raised."
msgstr ""
"*order*：如果為真（預設為 ``False``），:meth:`~object.__lt__`、:meth:"
"`~object.__le__`、:meth:`~object.__gt__` 和 :meth:`~object.__ge__` 方法將是產"
"生。它們按順序比較類，就好像它是其欄位的元組一樣。比較中的兩個實例必須屬於同"
"一型別。如果 *order* 為真且 *eq* 為假，則會引發 :exc:`ValueError`。"

#: ../../library/dataclasses.rst:120
#, fuzzy
msgid ""
"If the class already defines any of :meth:`!__lt__`, :meth:`!__le__`, :meth:"
"`!__gt__`, or :meth:`!__ge__`, then :exc:`TypeError` is raised."
msgstr ""
"如果該類已經定義了 :meth:`!__lt__`、:meth:`!__le__`、:meth:`!__gt__` 或 :"
"meth:`!__ge__` 中的任何一個，則引發 :exc:`TypeError`。"

#: ../../library/dataclasses.rst:124
#, fuzzy
msgid ""
"*unsafe_hash*: If ``False`` (the default), a :meth:`~object.__hash__` method "
"is generated according to how *eq* and *frozen* are set."
msgstr ""
"*unsafe_hash*：如果 ``False``（預設值），將根據 *eq* 和 *frozen* 的設定生成一"
"個 :meth:`~object.__hash__` 方法。"

#: ../../library/dataclasses.rst:127
#, fuzzy
msgid ""
":meth:`!__hash__` is used by built-in :meth:`hash`, and when objects are "
"added to hashed collections such as dictionaries and sets.  Having a :meth:`!"
"__hash__` implies that instances of the class are immutable. Mutability is a "
"complicated property that depends on the programmer's intent, the existence "
"and behavior of :meth:`!__eq__`, and the values of the *eq* and *frozen* "
"flags in the ``@dataclass`` decorator."
msgstr ""
":meth:`!__hash__` 由內建的 :meth:`hash` 使用，當對像被新增到散列集合（如字典"
"和集合）時。擁有 :meth:`!__hash__` 意味著該類的實例是不可變的。可變性是一個複"
"雜的屬性，它取決於程序員的意圖 :meth:`!__eq__` 的存在和行為，以及 dataclass "
"裝飾器中的 *eq* 和 *frozen* 旗標的值."

#: ../../library/dataclasses.rst:134
#, fuzzy
msgid ""
"By default, ``@dataclass`` will not implicitly add a :meth:`~object."
"__hash__` method unless it is safe to do so.  Neither will it add or change "
"an existing explicitly defined :meth:`!__hash__` method.  Setting the class "
"attribute ``__hash__ = None`` has a specific meaning to Python, as described "
"in the :meth:`!__hash__` documentation."
msgstr ""
"預設情況下，``@dataclass`` 不會隱式新增 :meth:`~object.__hash__` 方法，除非這"
"樣做是安全的。它也不會新增或更改現有的明確定義的 :meth:`!__hash__` 方法。設定"
"類屬性 ``__hash__ = None`` 對 Python 具有特定含義，如 :meth:`!__hash__` 文檔"
"中所述。"

#: ../../library/dataclasses.rst:140
#, fuzzy
msgid ""
"If :meth:`!__hash__` is not explicitly defined, or if it is set to ``None``, "
"then ``@dataclass`` *may* add an implicit :meth:`!__hash__` method. Although "
"not recommended, you can force ``@dataclass`` to create a :meth:`!__hash__` "
"method with ``unsafe_hash=True``. This might be the case if your class is "
"logically immutable but can still be mutated. This is a specialized use case "
"and should be considered carefully."
msgstr ""
"如果 :meth:`!__hash__` 沒有明確定義，或者如果它被設定為 ``None``，那麼 "
"``@dataclass`` *可能* 新增一個隱式的 :meth:`!__hash__` 方法。雖然不推薦，但你"
"可以強制 ``@dataclass`` 使用 ``unsafe_hash=True`` 建立一個 :meth:`!__hash__` "
"方法。如果你的類在邏輯上是不可變的但仍然可以改變，則可能是這種情況。這是一個"
"特殊的用例，應該仔細考慮。"

#: ../../library/dataclasses.rst:147
#, fuzzy
msgid ""
"Here are the rules governing implicit creation of a :meth:`!__hash__` "
"method.  Note that you cannot both have an explicit :meth:`!__hash__` method "
"in your dataclass and set ``unsafe_hash=True``; this will result in a :exc:"
"`TypeError`."
msgstr ""
"以下是管理隱式建立 :meth:`!__hash__` 方法的規則。請注意，你不能在資料類別中既"
"有顯式的 :meth:`!__hash__` 方法又設定 ``unsafe_hash=True``；這將導致 :exc:"
"`TypeError`。"

#: ../../library/dataclasses.rst:152
#, fuzzy
msgid ""
"If *eq* and *frozen* are both true, by default ``@dataclass`` will generate "
"a :meth:`!__hash__` method for you.  If *eq* is true and *frozen* is false, :"
"meth:`!__hash__` will be set to ``None``, marking it unhashable (which it "
"is, since it is mutable).  If *eq* is false, :meth:`!__hash__` will be left "
"untouched meaning the :meth:`!__hash__` method of the superclass will be "
"used (if the superclass is :class:`object`, this means it will fall back to "
"id-based hashing)."
msgstr ""
"如果 *eq* 和 *frozen* 都為真，預設情況下 ``@dataclass`` 會為你生成一個:meth:"
"`!__hash__` 方法。如果 ``eq`` 為真且 ``frozen`` 為假，:meth:`!__hash__` 將被"
"設定為 ``None``，將其標記為不可散列（它是不可散列的，因為它是可變的）。如果 "
"``eq`` 為假，:meth:`!__hash__` 將保持不變，這意味著將使用超類的 :meth:`!"
"__hash__` 方法（如果超類是 :class:`object`，這意味著它將回退到基於 id 的散"
"列）。"

#: ../../library/dataclasses.rst:160
#, fuzzy
msgid ""
"*frozen*: If true (the default is ``False``), assigning to fields will "
"generate an exception.  This emulates read-only frozen instances.  If :meth:"
"`~object.__setattr__` or :meth:`~object.__delattr__` is defined in the "
"class, then :exc:`TypeError` is raised.  See the discussion below."
msgstr ""
"*frozen*：如果為真（預設為 ``False``），分配給欄位將產生例外。這模擬了只讀的"
"凍結實例。如果 :meth:`~object.__setattr__` 或 :meth:`~object.__delattr__` 在"
"類中定義，則 :exc:`TypeError` 被引發。請參閱下面的討論。"

#: ../../library/dataclasses.rst:165
#, fuzzy
msgid ""
"*match_args*: If true (the default is ``True``), the :attr:`~object."
"__match_args__` tuple will be created from the list of parameters to the "
"generated :meth:`~object.__init__` method (even if :meth:`!__init__` is not "
"generated, see above).  If false, or if :attr:`!__match_args__` is already "
"defined in the class, then :attr:`!__match_args__` will not be generated."
msgstr ""
"*match_args*：如果為真（預設為 ``True``），``__match_args__`` 元組將從參數列"
"表建立到生成的 :meth:`~object.__init__` 方法（即使 :meth: `!__init__` 未生"
"成，見上文）。如果為 false，或者類中已經定義了 :attr:`!__match_args__`，則不"
"會生成 :attr:`!__match_args__`。"

#: ../../library/dataclasses.rst:174
#, fuzzy
msgid ""
"*kw_only*: If true (the default value is ``False``), then all fields will be "
"marked as keyword-only.  If a field is marked as keyword-only, then the only "
"effect is that the :meth:`~object.__init__` parameter generated from a "
"keyword-only field must be specified with a keyword when :meth:`!__init__` "
"is called.  There is no effect on any other aspect of dataclasses.  See the :"
"term:`parameter` glossary entry for details.  Also see the :const:`KW_ONLY` "
"section."
msgstr ""
"``kw_only``：如果為 true（預設值為 ``False``），則所有欄位將被標記為僅限關鍵"
"字。如果一個欄位被標記為僅限關鍵字，那麼唯一的影響是從僅限關鍵字欄位生成的 :"
"meth:`~object.__init__` 參數必須在呼叫 :meth:`!__init__` 時指定關鍵字。對資料"
"類別的任何其他方面都沒有影響。有關詳細資訊，請參閱 :term:`parameter` 詞彙表條"
"目。另請參閱 :const:`KW_ONLY` 部分。"

#: ../../library/dataclasses.rst:185
#, fuzzy
msgid ""
"*slots*: If true (the default is ``False``), :attr:`~object.__slots__` "
"attribute will be generated and new class will be returned instead of the "
"original one. If :attr:`!__slots__` is already defined in the class, then :"
"exc:`TypeError` is raised."
msgstr ""
"``slots``：如果為 true（預設為 ``False``），將生成 :attr:`~object.__slots__` "
"屬性並回傳新類而不是原始類。如果 :attr:`!__slots__` 已經在類中定義，則 :exc:"
"`TypeError` 被引發。"

#: ../../library/dataclasses.rst:191
#, fuzzy
msgid ""
"Calling no-arg :func:`super` in dataclasses using ``slots=True`` will result "
"in the following exception being raised: ``TypeError: super(type, obj): obj "
"must be an instance or subtype of type``. The two-arg :func:`super` is a "
"valid workaround. See :gh:`90562` for full details."
msgstr ""
"``slots``：如果為 true（預設為 ``False``），將生成 :attr:`~object.__slots__` "
"屬性並回傳新類而不是原始類。如果 :attr:`!__slots__` 已經在類中定義，則 :exc:"
"`TypeError` 被引發。"

#: ../../library/dataclasses.rst:198
msgid ""
"Passing parameters to a base class :meth:`~object.__init_subclass__` when "
"using ``slots=True`` will result in a :exc:`TypeError`. Either use "
"``__init_subclass__`` with no parameters or use default values as a "
"workaround. See :gh:`91126` for full details."
msgstr ""

#: ../../library/dataclasses.rst:206
#, fuzzy
msgid ""
"If a field name is already included in the :attr:`!__slots__` of a base "
"class, it will not be included in the generated :attr:`!__slots__` to "
"prevent :ref:`overriding them <datamodel-note-slots>`. Therefore, do not "
"use :attr:`!__slots__` to retrieve the field names of a dataclass. Use :func:"
"`fields` instead. To be able to determine inherited slots, base class :attr:"
"`!__slots__` may be any iterable, but *not* an iterator."
msgstr ""
"如果欄位名稱已經包含在基底類別的 :attr:`!__slots__` 中，它將不會包含在生成"
"的 :attr:`!__slots__` 中以防止 :ref:`覆蓋它們 <datamodel-note-slots>`。因此，"
"不要使用 __slots__ 來檢索資料類別的欄位名稱。使用 :func:`fields` 代替。為了能"
"夠確定繼承的插槽，基底類別 :attr:`!__slots__` 可以是任何可疊代的，但*不是*疊"
"代器。"

#: ../../library/dataclasses.rst:216
#, fuzzy
msgid ""
"*weakref_slot*: If true (the default is ``False``), add a slot named "
"\"__weakref__\", which is required to make an instance :func:`weakref-able "
"<weakref.ref>`. It is an error to specify ``weakref_slot=True`` without also "
"specifying ``slots=True``."
msgstr ""
"*weakref_slot*：如果為真（預設為 ``False``），新增一個名為 \"__weakref__\" 的"
"插槽，這是使實例可弱引用所必需的。在沒有指定 ``slots=True`` 的情況下指定 "
"``weakref_slot=True`` 是錯誤的。"

#: ../../library/dataclasses.rst:224
#, fuzzy
msgid ""
"``field``\\s may optionally specify a default value, using normal Python "
"syntax::"
msgstr "``field``\\s 可以選擇指定一個預設值，使用普通的 Python 語法： ::"

#: ../../library/dataclasses.rst:227
msgid ""
"@dataclass\n"
"class C:\n"
"    a: int       # 'a' has no default value\n"
"    b: int = 0   # assign a default value for 'b'"
msgstr ""

#: ../../library/dataclasses.rst:232
#, fuzzy
msgid ""
"In this example, both :attr:`!a` and :attr:`!b` will be included in the "
"added :meth:`~object.__init__` method, which will be defined as::"
msgstr ""
"在此示例中，:attr:`!a` 和 :attr:`!b` 都將包含在新增的 :meth:`~object."
"__init__` 方法中，該方法將定義為： ::"

#: ../../library/dataclasses.rst:235
msgid "def __init__(self, a: int, b: int = 0):"
msgstr ""

#: ../../library/dataclasses.rst:237
#, fuzzy
msgid ""
":exc:`TypeError` will be raised if a field without a default value follows a "
"field with a default value.  This is true whether this occurs in a single "
"class, or as a result of class inheritance."
msgstr ""
":exc:`TypeError` 如果沒有預設值的欄位跟在具有預設值的欄位之後，將引發。無論這"
"發生在單個類中還是作為類繼承的結果，都是如此。"

#: ../../library/dataclasses.rst:243
#, fuzzy
msgid ""
"For common and simple use cases, no other functionality is required.  There "
"are, however, some dataclass features that require additional per-field "
"information.  To satisfy this need for additional information, you can "
"replace the default field value with a call to the provided :func:`!field` "
"function.  For example::"
msgstr ""
"對於常見和簡單的用例，不需要其他功能。但是，有些資料類別功能需要額外的每個欄"
"位資訊。為了滿足這種對附加資訊的需求，你可以通過呼叫提供的 :func:`!field` 函"
"式來替換預設欄位值。例如： ::"

#: ../../library/dataclasses.rst:249
msgid ""
"@dataclass\n"
"class C:\n"
"    mylist: list[int] = field(default_factory=list)\n"
"\n"
"c = C()\n"
"c.mylist += [1, 2, 3]"
msgstr ""

#: ../../library/dataclasses.rst:256
#, fuzzy
msgid ""
"As shown above, the :const:`MISSING` value is a sentinel object used to "
"detect if some parameters are provided by the user. This sentinel is used "
"because ``None`` is a valid value for some parameters with a distinct "
"meaning.  No code should directly use the :const:`MISSING` value."
msgstr ""
"如上所示，:const:`MISSING` 值是一個哨兵物件，用於檢測某些參數是否由使用者提"
"供。使用此標記是因為“None”對於某些具有不同含義的參數是有效值。任何程式碼都不"
"應直接使用 :const:`MISSING` 值。"

#: ../../library/dataclasses.rst:261
msgid "The parameters to :func:`!field` are:"
msgstr ":func:`!field` 的參數是："

#: ../../library/dataclasses.rst:263
#, fuzzy
msgid ""
"*default*: If provided, this will be the default value for this field.  This "
"is needed because the :func:`!field` call itself replaces the normal "
"position of the default value."
msgstr ""
"*default*：如果提供，這將是該欄位的預設值。這是必需的，因為 :meth:`!field` 呼"
"叫本身會替換預設值的正常位置。"

#: ../../library/dataclasses.rst:267
#, fuzzy
msgid ""
"*default_factory*: If provided, it must be a zero-argument callable that "
"will be called when a default value is needed for this field.  Among other "
"purposes, this can be used to specify fields with mutable default values, as "
"discussed below.  It is an error to specify both *default* and "
"*default_factory*."
msgstr ""
"*default_factory*：如果提供，它必須是一個零引數可呼叫函式，當此欄位需要預設值"
"時將被呼叫。除其他用途外，這可用於指定具有可變預設值的欄位，如下所述。同時指"
"定 *default* 和 *default_factory* 是錯誤的。"

#: ../../library/dataclasses.rst:273
#, fuzzy
msgid ""
"*init*: If true (the default), this field is included as a parameter to the "
"generated :meth:`~object.__init__` method."
msgstr ""
"*init*：如果為 true（預設值），則此欄位將作為生成的 :meth:`~object.__init__` "
"方法的參數包含在內。"

#: ../../library/dataclasses.rst:276
#, fuzzy
msgid ""
"*repr*: If true (the default), this field is included in the string returned "
"by the generated :meth:`~object.__repr__` method."
msgstr ""
"*repr*：如果為真（預設值），則此欄位包含在生成的 :meth:`~object.__repr__` 方"
"法回傳的字串中。"

#: ../../library/dataclasses.rst:279
#, fuzzy
msgid ""
"*hash*: This can be a bool or ``None``.  If true, this field is included in "
"the generated :meth:`~object.__hash__` method.  If ``None`` (the default), "
"use the value of *compare*: this would normally be the expected behavior.  A "
"field should be considered in the hash if it's used for comparisons.  "
"Setting this value to anything other than ``None`` is discouraged."
msgstr ""
"*hash*：這可以是 bool 或 ``None``。如果為真，則此欄位包含在生成的 :meth:"
"`__hash__` 方法中。如果“無”（預設值），則使用“比較”的值：這通常是預期的行為。"
"如果一個欄位用於比較，則應在雜湊中考慮該欄位。不鼓勵將此值設定為“無”以外的任"
"何值。"

#: ../../library/dataclasses.rst:286
#, fuzzy
msgid ""
"One possible reason to set ``hash=False`` but ``compare=True`` would be if a "
"field is expensive to compute a hash value for, that field is needed for "
"equality testing, and there are other fields that contribute to the type's "
"hash value.  Even if a field is excluded from the hash, it will still be "
"used for comparisons."
msgstr ""
"設定 ``hash=False`` 但 ``compare=True`` 的一個可能原因是，如果一個欄位計算雜"
"湊值的成本很高，則需要該欄位進行相等性測試，並且還有其他欄位有助於型別的雜湊"
"值。即使一個欄位被排除在雜湊之外，它仍然會被用於比較。"

#: ../../library/dataclasses.rst:292
#, fuzzy
msgid ""
"*compare*: If true (the default), this field is included in the generated "
"equality and comparison methods (:meth:`~object.__eq__`, :meth:`~object."
"__gt__`, et al.)."
msgstr ""
"*compare*：如果為真（預設值），則此欄位包含在生成的相等和比較方法中（:meth:"
"`~object.__eq__`、:meth:`~object.__gt__` 等）。"

#: ../../library/dataclasses.rst:296
#, fuzzy
msgid ""
"*metadata*: This can be a mapping or ``None``. ``None`` is treated as an "
"empty dict.  This value is wrapped in :func:`~types.MappingProxyType` to "
"make it read-only, and exposed on the :class:`Field` object. It is not used "
"at all by Data Classes, and is provided as a third-party extension "
"mechanism. Multiple third-parties can each have their own key, to use as a "
"namespace in the metadata."
msgstr ""
"*metadata*：這可以是映射或無。 None 被視為空字典。此值包含在 :func:`~types."
"MappingProxyType` 中以使其成為只讀的，並暴露在 :class:`Field` 對像上。它根本"
"不被資料類別使用，而是作為第三方擴充機制提供的。多個第三方可以各自擁有自己的"
"密鑰，用作元資料中的命名空間。"

#: ../../library/dataclasses.rst:304
#, fuzzy
msgid ""
"*kw_only*: If true, this field will be marked as keyword-only. This is used "
"when the generated :meth:`~object.__init__` method's parameters are computed."
msgstr ""
"*kw_only*：如果為真，該欄位將被標記為僅限關鍵字。這在計算生成的 :meth:"
"`~object.__init__` 方法的參數時使用。"

#: ../../library/dataclasses.rst:310
#, fuzzy
msgid ""
"If the default value of a field is specified by a call to :func:`!field`, "
"then the class attribute for this field will be replaced by the specified "
"*default* value.  If *default* is not provided, then the class attribute "
"will be deleted.  The intent is that after the :func:`@dataclass "
"<dataclass>` decorator runs, the class attributes will all contain the "
"default values for the fields, just as if the default value itself were "
"specified.  For example, after::"
msgstr ""
"如果欄位的預設值是通過呼叫 :func:`!field` 指定的，那麼該欄位的類別屬性將被指"
"定的 *default* 值替換。如果沒有提供 *default*，那麼類別屬性將被刪除。目的是"
"在 :func:`@dataclass <dataclass>` 裝飾器運行後，類別屬性將全部包含欄位的預設"
"值，就像預設值本身已指定一樣。例如，在： ::"

#: ../../library/dataclasses.rst:319
msgid ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: int = field(repr=False)\n"
"    z: int = field(repr=False, default=10)\n"
"    t: int = 20"
msgstr ""

#: ../../library/dataclasses.rst:326
#, fuzzy
msgid ""
"The class attribute :attr:`!C.z` will be ``10``, the class attribute :attr:`!"
"C.t` will be ``20``, and the class attributes :attr:`!C.x` and :attr:`!C.y` "
"will not be set."
msgstr ""
"類別屬性 :attr:`!C.z` 將為 ``10``，類別屬性 :attr:`!C.t` 將為 ``20``，類別屬"
"性 :attr:`!C.x` 和 :attr:`!C.y` 將不會放。"

#: ../../library/dataclasses.rst:332
#, fuzzy
msgid ""
":class:`!Field` objects describe each defined field. These objects are "
"created internally, and are returned by the :func:`fields` module-level "
"method (see below).  Users should never instantiate a :class:`!Field` object "
"directly.  Its documented attributes are:"
msgstr ""
":class:`!Field` 物件描述每個定義的欄位。這些對像在內部建立，並由 :func:"
"`fields` 模組級方法回傳（見下文）。使用者不應該直接實例化 :class:`!Field` 物"
"件。它記錄的屬性是："

#: ../../library/dataclasses.rst:337
msgid ":attr:`!name`: The name of the field."
msgstr ":attr:`!name`：欄位的名稱。"

#: ../../library/dataclasses.rst:338
msgid ":attr:`!type`: The type of the field."
msgstr ":attr:`!type`：欄位的型別。"

#: ../../library/dataclasses.rst:339
#, fuzzy
msgid ""
":attr:`!default`, :attr:`!default_factory`, :attr:`!init`, :attr:`!repr`, :"
"attr:`!hash`, :attr:`!compare`, :attr:`!metadata`, and :attr:`!kw_only` have "
"the identical meaning and values as they do in the :func:`field` function."
msgstr ""
":attr:`!default`、:attr:`!default_factory`、:attr:`!init`、:attr:`!repr`、:"
"attr:`!hash`、:attr:`!compare`, :attr:`!metadata` 和 :attr:`!kw_only` 有與它"
"們在 :func:`field` 函式中的含義和值相同。"

#: ../../library/dataclasses.rst:343
#, fuzzy
msgid ""
"Other attributes may exist, but they are private and must not be inspected "
"or relied on."
msgstr "可能存在其他屬性，但它們是私有的，不得檢查或依賴。"

#: ../../library/dataclasses.rst:348
#, fuzzy
msgid ""
"Returns a tuple of :class:`Field` objects that define the fields for this "
"dataclass.  Accepts either a dataclass, or an instance of a dataclass. "
"Raises :exc:`TypeError` if not passed a dataclass or instance of one. Does "
"not return pseudo-fields which are ``ClassVar`` or ``InitVar``."
msgstr ""
"回傳定義此資料類別欄位的 :class:`Field` 物件的元組。接受資料類別或資料類別的"
"實例。如果未傳遞資料類別或其中一個實例，則引發 :exc:`TypeError`。不回傳 "
"``ClassVar`` 或 ``InitVar`` 的偽欄位。"

#: ../../library/dataclasses.rst:355
#, fuzzy
msgid ""
"Converts the dataclass *obj* to a dict (by using the factory function "
"*dict_factory*).  Each dataclass is converted to a dict of its fields, as "
"``name: value`` pairs.  dataclasses, dicts, lists, and tuples are recursed "
"into.  Other objects are copied with :func:`copy.deepcopy`."
msgstr ""
"將資料類別 *obj* 轉換為字典（通過使用工廠函式 *dict_factory*）。每個資料類別"
"都被轉換為其欄位的字典，作為 ``name: value`` 對。資料類別、字典、列表和元組被"
"遞迴到。其他物件使用 :func:`copy.deepcopy` 複製。"

#: ../../library/dataclasses.rst:361
#, fuzzy
msgid "Example of using :func:`!asdict` on nested dataclasses::"
msgstr "在嵌套資料類別上使用 :func:`!asdict` 的範例： ::"

#: ../../library/dataclasses.rst:363
msgid ""
"@dataclass\n"
"class Point:\n"
"     x: int\n"
"     y: int\n"
"\n"
"@dataclass\n"
"class C:\n"
"     mylist: list[Point]\n"
"\n"
"p = Point(10, 20)\n"
"assert asdict(p) == {'x': 10, 'y': 20}\n"
"\n"
"c = C([Point(0, 0), Point(10, 4)])\n"
"assert asdict(c) == {'mylist': [{'x': 0, 'y': 0}, {'x': 10, 'y': 4}]}"
msgstr ""

#: ../../library/dataclasses.rst:378 ../../library/dataclasses.rst:398
#, fuzzy
msgid "To create a shallow copy, the following workaround may be used::"
msgstr "要建立淺複製，可以使用以下解決方法："

#: ../../library/dataclasses.rst:380
msgid "{field.name: getattr(obj, field.name) for field in fields(obj)}"
msgstr ""

#: ../../library/dataclasses.rst:382
#, fuzzy
msgid ""
":func:`!asdict` raises :exc:`TypeError` if *obj* is not a dataclass instance."
msgstr ":func:`!asdict` 如果 *obj* 不是資料類別實例，則引發 :exc:`TypeError`。"

#: ../../library/dataclasses.rst:387
#, fuzzy
msgid ""
"Converts the dataclass *obj* to a tuple (by using the factory function "
"*tuple_factory*).  Each dataclass is converted to a tuple of its field "
"values.  dataclasses, dicts, lists, and tuples are recursed into. Other "
"objects are copied with :func:`copy.deepcopy`."
msgstr ""
"將資料類別 *obj* 轉換為元組（通過使用工廠函式 *tuple_factory*）。每個資料類別"
"都被轉換為其欄位值的元組。資料類別、字典、列表和元組被遞迴到。其他物件使用 :"
"func:`copy.deepcopy` 複製。"

#: ../../library/dataclasses.rst:393
msgid "Continuing from the previous example::"
msgstr "從前面的例子繼續： ::"

#: ../../library/dataclasses.rst:395
msgid ""
"assert astuple(p) == (10, 20)\n"
"assert astuple(c) == ([(0, 0), (10, 4)],)"
msgstr ""

#: ../../library/dataclasses.rst:400
msgid "tuple(getattr(obj, field.name) for field in dataclasses.fields(obj))"
msgstr ""

#: ../../library/dataclasses.rst:402
#, fuzzy
msgid ""
":func:`!astuple` raises :exc:`TypeError` if *obj* is not a dataclass "
"instance."
msgstr ""
":func:`!astuple` 如果 *obj* 不是資料類別實例，則引發 :exc:`TypeError`。"

#: ../../library/dataclasses.rst:407
#, fuzzy
msgid ""
"Creates a new dataclass with name *cls_name*, fields as defined in *fields*, "
"base classes as given in *bases*, and initialized with a namespace as given "
"in *namespace*.  *fields* is an iterable whose elements are each either "
"``name``, ``(name, type)``, or ``(name, type, Field)``.  If just ``name`` is "
"supplied, :data:`typing.Any` is used for ``type``.  The values of *init*, "
"*repr*, *eq*, *order*, *unsafe_hash*, *frozen*, *match_args*, *kw_only*, "
"*slots*, and *weakref_slot* have the same meaning as they do in :func:"
"`@dataclass <dataclass>`."
msgstr ""
"建立一個名為 *cls_name* 的新資料類別，欄位在 *fields* 中定義，基底類別在 "
"*bases* 中給出，並使用 *namespace* 中給出的命名空間進行初始化。 ``fields`` 是"
"一個疊代器，其元素分別是 ``name``、``(name, type)`` 或 ``(name, type, "
"Field)``。如果只提供 ``name``，則 ``typing.Any`` 用於 ``type``。 ``init``、"
"``repr``、``eq``、``order``、``unsafe_hash``、``frozen``、``match_args``、"
"``kw_only`` 的值, ``slots`` 和 ``weakref_slot`` 與它們在 :func:`dataclass` 中"
"的含義相同。"

#: ../../library/dataclasses.rst:417
msgid ""
"If *module* is defined, the :attr:`!__module__` attribute of the dataclass "
"is set to that value. By default, it is set to the module name of the caller."
msgstr ""

#: ../../library/dataclasses.rst:421
#, fuzzy
msgid ""
"This function is not strictly required, because any Python mechanism for "
"creating a new class with :attr:`!__annotations__` can then apply the :func:"
"`@dataclass <dataclass>` function to convert that class to a dataclass.  "
"This function is provided as a convenience.  For example::"
msgstr ""
"這個函式不是嚴格要求的，因為任何使用 ``__annotations__`` 建立新類的 Python 機"
"制都可以應用 :func:`dataclass` 函式將該類轉換為資料類別。提供此功能是為了方"
"便。例如： ::"

#: ../../library/dataclasses.rst:427
msgid ""
"C = make_dataclass('C',\n"
"                   [('x', int),\n"
"                     'y',\n"
"                    ('z', int, field(default=5))],\n"
"                   namespace={'add_one': lambda self: self.x + 1})"
msgstr ""

#: ../../library/dataclasses.rst:433
msgid "Is equivalent to::"
msgstr "相當於： ::"

#: ../../library/dataclasses.rst:435
msgid ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: 'typing.Any'\n"
"    z: int = 5\n"
"\n"
"    def add_one(self):\n"
"        return self.x + 1"
msgstr ""

#: ../../library/dataclasses.rst:446
#, fuzzy
msgid ""
"Creates a new object of the same type as *obj*, replacing fields with values "
"from *changes*.  If *obj* is not a Data Class, raises :exc:`TypeError`.  If "
"keys in *changes* are not field names of the given dataclass, raises :exc:"
"`TypeError`."
msgstr ""
"建立一個與 ``obj`` 型別相同的新物件，用 ``changes`` 中的值替換欄位。如果 "
"``obj`` 不是資料類別，則引發 :exc:`TypeError`。如果 ``changes`` 中的值未指定"
"欄位，則引發 :exc:`TypeError`。"

#: ../../library/dataclasses.rst:451
#, fuzzy
msgid ""
"The newly returned object is created by calling the :meth:`~object.__init__` "
"method of the dataclass.  This ensures that :meth:`__post_init__`, if "
"present, is also called."
msgstr ""
"新回傳的對像是通過呼叫資料類別的 :meth:`~object.__init__` 方法建立的。這確"
"保 :meth:`__post_init__`（如果存在）也被呼叫。"

#: ../../library/dataclasses.rst:455
#, fuzzy
msgid ""
"Init-only variables without default values, if any exist, must be specified "
"on the call to :func:`!replace` so that they can be passed to :meth:`!"
"__init__` and :meth:`__post_init__`."
msgstr ""
"沒有預設值的僅初始化變數（如果存在）必須在呼叫 :func:`replace` 時指定，以便它"
"們可以傳遞給 :meth:`__init__` 和 :meth:`__post_init__`。"

#: ../../library/dataclasses.rst:459
#, fuzzy
msgid ""
"It is an error for *changes* to contain any fields that are defined as "
"having ``init=False``.  A :exc:`ValueError` will be raised in this case."
msgstr ""
"*changes* 包含任何定義為具有 ``init=False`` 的欄位是錯誤的。在這種情況下將引"
"發 :exc:`ValueError`。"

#: ../../library/dataclasses.rst:463
#, fuzzy
msgid ""
"Be forewarned about how ``init=False`` fields work during a call to :func:`!"
"replace`.  They are not copied from the source object, but rather are "
"initialized in :meth:`__post_init__`, if they're initialized at all.  It is "
"expected that ``init=False`` fields will be rarely and judiciously used.  If "
"they are used, it might be wise to have alternate class constructors, or "
"perhaps a custom :func:`!replace` (or similarly named) method which handles "
"instance copying."
msgstr ""
"預先警告 ``init=False`` 欄位在呼叫 :func:`!replace` 期間是如何工作的。它們不"
"是從源物件複製的，而是在 :meth:`__post_init__` 中初始化的，如果它們被初始化的"
"話。預計 ``init=False`` 欄位將很少被明智地使用。如果使用它們，使用替代的類構"
"造函式可能是明智的，或者可能是處理實例複製的自定義:func:`!replace` （或類似命"
"名的）方法。"

#: ../../library/dataclasses.rst:474
#, fuzzy
msgid ""
"Return ``True`` if its parameter is a dataclass (including subclasses of a "
"dataclass) or an instance of one, otherwise return ``False``."
msgstr ""
"如果它的參數是一個資料類別或一個實例，則回傳 ``True``，否則回傳 ``False``。"

#: ../../library/dataclasses.rst:477
#, fuzzy
msgid ""
"If you need to know if a class is an instance of a dataclass (and not a "
"dataclass itself), then add a further check for ``not isinstance(obj, "
"type)``::"
msgstr ""
"如果你需要知道一個類是否是資料類別的實例（而不是資料類別本身），那麼新增一個"
"進一步的檢查 ``not isinstance(obj, type)``： ::"

#: ../../library/dataclasses.rst:481
msgid ""
"def is_dataclass_instance(obj):\n"
"    return is_dataclass(obj) and not isinstance(obj, type)"
msgstr ""

#: ../../library/dataclasses.rst:486
#, fuzzy
msgid "A sentinel value signifying a missing default or default_factory."
msgstr "表示缺少 default 或 default_factory 的標記值。"

#: ../../library/dataclasses.rst:490
#, fuzzy
msgid ""
"A sentinel value used as a type annotation.  Any fields after a pseudo-field "
"with the type of :const:`!KW_ONLY` are marked as keyword-only fields.  Note "
"that a pseudo-field of type :const:`!KW_ONLY` is otherwise completely "
"ignored.  This includes the name of such a field.  By convention, a name of "
"``_`` is used for a :const:`!KW_ONLY` field.  Keyword-only fields signify :"
"meth:`~object.__init__` parameters that must be specified as keywords when "
"the class is instantiated."
msgstr ""
"用作型別註釋的標記值。型別為 :const:`!KW_ONLY` 的偽欄位之後的任何欄位都被標記"
"為僅關鍵字欄位。請注意，:const:`!KW_ONLY` 型別的偽欄位將被完全忽略。這包括此"
"類欄位的名稱。按照慣例，名稱 ``_`` 用於 :const:`!KW_ONLY` 欄位。僅關鍵字欄位"
"表示 :meth:`~object.__init__` 參數，在實例化類時必須將其指定為關鍵字。"

#: ../../library/dataclasses.rst:499
#, fuzzy
msgid ""
"In this example, the fields ``y`` and ``z`` will be marked as keyword-only "
"fields::"
msgstr "在此示例中，欄位 ``y`` 和 ``z`` 將被標記為僅關鍵字欄位： ::"

#: ../../library/dataclasses.rst:501
msgid ""
"@dataclass\n"
"class Point:\n"
"    x: float\n"
"    _: KW_ONLY\n"
"    y: float\n"
"    z: float\n"
"\n"
"p = Point(0, y=1.5, z=2.0)"
msgstr ""

#: ../../library/dataclasses.rst:510
#, fuzzy
msgid ""
"In a single dataclass, it is an error to specify more than one field whose "
"type is :const:`!KW_ONLY`."
msgstr "在單個資料類別中，指定多個型別為 :const:`!KW_ONLY` 的欄位是錯誤的。"

#: ../../library/dataclasses.rst:517
#, fuzzy
msgid ""
"Raised when an implicitly defined :meth:`~object.__setattr__` or :meth:"
"`~object.__delattr__` is called on a dataclass which was defined with "
"``frozen=True``. It is a subclass of :exc:`AttributeError`."
msgstr ""
"當在使用 frozen=True 定義的資料類別上呼叫隱式定義的 :meth:`__setattr__` 或 :"
"meth:`__delattr__` 時引發。它是 :exc:`AttributeError` 的子類別。"

#: ../../library/dataclasses.rst:524
#, fuzzy
msgid "Post-init processing"
msgstr "初始化後處理"

#: ../../library/dataclasses.rst:528
#, fuzzy
msgid ""
"When defined on the class, it will be called by the generated :meth:`~object."
"__init__`, normally as :meth:`!self.__post_init__`. However, if any "
"``InitVar`` fields are defined, they will also be passed to :meth:`!"
"__post_init__` in the order they were defined in the class.  If no :meth:`!"
"__init__` method is generated, then :meth:`!__post_init__` will not "
"automatically be called."
msgstr ""
"生成的 :meth:`~object.__init__` 程式碼將呼叫一個名為 :meth:`!self."
"__post_init__` 的方法，如果 :meth:`!__post_init__` 是在類上定義的。它通常被稱"
"為 ``self.!__post_init__()``。但是，如果定義了任何 ``InitVar`` 欄位，它們也將"
"按照它們在類中定義的順序傳遞給 :meth:`!__post_init__` 。如果沒有生成 :meth:`!"
"__init__` 方法，那麼 :meth:`!__post_init__` 將不會被自動呼叫。"

#: ../../library/dataclasses.rst:535
#, fuzzy
msgid ""
"Among other uses, this allows for initializing field values that depend on "
"one or more other fields.  For example::"
msgstr "在其他用途中，這允許初始化依賴於一個或多個其他欄位的欄位值。例如： ::"

#: ../../library/dataclasses.rst:538
msgid ""
"@dataclass\n"
"class C:\n"
"    a: float\n"
"    b: float\n"
"    c: float = field(init=False)\n"
"\n"
"    def __post_init__(self):\n"
"        self.c = self.a + self.b"
msgstr ""

#: ../../library/dataclasses.rst:547
#, fuzzy
msgid ""
"The :meth:`~object.__init__` method generated by :func:`@dataclass "
"<dataclass>` does not call base class :meth:`!__init__` methods. If the base "
"class has an :meth:`!__init__` method that has to be called, it is common to "
"call this method in a :meth:`__post_init__` method::"
msgstr ""
":func:`@dataclass <dataclass>` 生成的 :meth:`~object.__init__` 方法不呼叫基底"
"類別 :meth:`!__init__` 方法。如果基底類別有一個必須呼叫的 :meth:`!__init__` "
"方法，通常在 :meth:`__post_init__` 方法中呼叫此方法： ::"

#: ../../library/dataclasses.rst:552
msgid ""
"class Rectangle:\n"
"    def __init__(self, height, width):\n"
"      self.height = height\n"
"      self.width = width\n"
"\n"
"@dataclass\n"
"class Square(Rectangle):\n"
"    side: float\n"
"\n"
"    def __post_init__(self):\n"
"        super().__init__(self.side, self.side)"
msgstr ""

#: ../../library/dataclasses.rst:564
#, fuzzy
msgid ""
"Note, however, that in general the dataclass-generated :meth:`!__init__` "
"methods don't need to be called, since the derived dataclass will take care "
"of initializing all fields of any base class that is a dataclass itself."
msgstr ""
"但是請注意，通常不需要呼叫資料類別生成的 :meth:`!__init__` 方法，因為派生資料"
"類別將負責初始化作為資料類別本身的任何基底類別的所有欄位。"

#: ../../library/dataclasses.rst:568
#, fuzzy
msgid ""
"See the section below on init-only variables for ways to pass parameters to :"
"meth:`!__post_init__`.  Also see the warning about how :func:`replace` "
"handles ``init=False`` fields."
msgstr ""
"請參閱下面有關僅初始化變數的部分，了解將參數傳遞給 :meth:`!__post_init__` 的"
"方法。另請參閱有關 :func:`replace` 如何處理 ``init=False`` 欄位的警告。"

#: ../../library/dataclasses.rst:575
msgid "Class variables"
msgstr "類別變數"

#: ../../library/dataclasses.rst:577
#, fuzzy
msgid ""
"One of the few places where :func:`@dataclass <dataclass>` actually inspects "
"the type of a field is to determine if a field is a class variable as "
"defined in :pep:`526`.  It does this by checking if the type of the field "
"is :data:`typing.ClassVar`.  If a field is a ``ClassVar``, it is excluded "
"from consideration as a field and is ignored by the dataclass mechanisms.  "
"Such ``ClassVar`` pseudo-fields are not returned by the module-level :func:"
"`fields` function."
msgstr ""
":func:`@dataclass <dataclass>` 實際檢查欄位型別的少數地方之一是確定欄位是否"
"是 :pep:`526` 中定義的類變數。它通過檢查欄位的型別是否為 :data:`typing."
"ClassVar` 來做到這一點。如果一個欄位是一個 ``ClassVar``，它就被排除在考慮之"
"外，並被資料類別機制忽略。模組級 :func:`fields` 函式不會回傳此類別 "
"``ClassVar`` 偽欄位。"

#: ../../library/dataclasses.rst:588
#, fuzzy
msgid "Init-only variables"
msgstr "僅初始化變數"

#: ../../library/dataclasses.rst:590
#, fuzzy
msgid ""
"Another place where :func:`@dataclass <dataclass>` inspects a type "
"annotation is to determine if a field is an init-only variable.  It does "
"this by seeing if the type of a field is of type ``dataclasses.InitVar``.  "
"If a field is an ``InitVar``, it is considered a pseudo-field called an init-"
"only field.  As it is not a true field, it is not returned by the module-"
"level :func:`fields` function.  Init-only fields are added as parameters to "
"the generated :meth:`~object.__init__` method, and are passed to the "
"optional :meth:`__post_init__` method.  They are not otherwise used by "
"dataclasses."
msgstr ""
":func:`dataclass` 檢查型別註解的另一個地方是確定欄位是否是僅初始化變數。它通"
"過查看欄位的型別是否為 ``dataclasses.InitVar`` 型別來執行此操作。如果一個欄位"
"是一個 ``InitVar``，它被認為是一個偽欄位，稱為 init-only 欄位。由於它不是真正"
"的欄位，因此它不會由模組級 fields 函式回傳。 Init-only 欄位作為參數新增到生成"
"的 :meth:`~object.__init__` 方法，並傳遞給可選的 :meth:`__post_init__` 方法。"
"它們不被資料類使用。"

#: ../../library/dataclasses.rst:600
#, fuzzy
msgid ""
"For example, suppose a field will be initialized from a database, if a value "
"is not provided when creating the class::"
msgstr "例如，假設一個欄位將從資料庫中初始化，如果在建立類時沒有提供值： ::"

#: ../../library/dataclasses.rst:603
msgid ""
"@dataclass\n"
"class C:\n"
"    i: int\n"
"    j: int | None = None\n"
"    database: InitVar[DatabaseType | None] = None\n"
"\n"
"    def __post_init__(self, database):\n"
"        if self.j is None and database is not None:\n"
"            self.j = database.lookup('j')\n"
"\n"
"c = C(10, database=my_database)"
msgstr ""

#: ../../library/dataclasses.rst:615
#, fuzzy
msgid ""
"In this case, :func:`fields` will return :class:`Field` objects for :attr:`!"
"i` and :attr:`!j`, but not for :attr:`!database`."
msgstr ""
"在這種情況下，:func:`fields` 將為 :attr:`!i` 和 :attr:`!j` 回傳 :class:"
"`Field` 物件，但不會為 :attr:`!database` 回傳。"

#: ../../library/dataclasses.rst:621
msgid "Frozen instances"
msgstr "凍結實例"

#: ../../library/dataclasses.rst:623
#, fuzzy
msgid ""
"It is not possible to create truly immutable Python objects.  However, by "
"passing ``frozen=True`` to the :func:`@dataclass <dataclass>` decorator you "
"can emulate immutability.  In that case, dataclasses will add :meth:`~object."
"__setattr__` and :meth:`~object.__delattr__` methods to the class.  These "
"methods will raise a :exc:`FrozenInstanceError` when invoked."
msgstr ""
"不可能建立真正不可變的 Python 物件。但是，通過將 ``frozen=True`` 傳遞給 :"
"func:`@dataclass <dataclass>` 裝飾器，你可以模擬不變性。在這種情況下，資料類"
"別將向類新增 :meth:`~object.__setattr__` 和 :meth:`~object.__delattr__` 方"
"法。這些方法在呼叫時會引發 :exc:`FrozenInstanceError`。"

#: ../../library/dataclasses.rst:629
#, fuzzy
msgid ""
"There is a tiny performance penalty when using ``frozen=True``: :meth:"
"`~object.__init__` cannot use simple assignment to initialize fields, and "
"must use :meth:`!object.__setattr__`."
msgstr ""
"使用 ``frozen=True`` 時有一個微小的性能損失：:meth:`~object.__init__` 不能使"
"用簡單賦值來初始化欄位，必須使用 :meth:`!object.__setattr__`。"

#: ../../library/dataclasses.rst:638
msgid "Inheritance"
msgstr "繼承"

#: ../../library/dataclasses.rst:640
#, fuzzy
msgid ""
"When the dataclass is being created by the :func:`@dataclass <dataclass>` "
"decorator, it looks through all of the class's base classes in reverse MRO "
"(that is, starting at :class:`object`) and, for each dataclass that it "
"finds, adds the fields from that base class to an ordered mapping of fields. "
"After all of the base class fields are added, it adds its own fields to the "
"ordered mapping.  All of the generated methods will use this combined, "
"calculated ordered mapping of fields.  Because the fields are in insertion "
"order, derived classes override base classes.  An example::"
msgstr ""
"當 :func:`@dataclass <dataclass>` 裝飾器建立資料類別時，它會以反向 MRO（即"
"從 :class:`object` 開始）查看該類的所有基底類別，並且對於它找到的每個資料類"
"別，將該基底類別中的欄位新增到欄位的有序映射中。新增所有基底類別欄位後，它會"
"將自己的欄位新增到有序映射中。所有生成的方法都將使用這種組合的、計算的有序欄"
"位映射。因為欄位是按插入順序排列的，所以派生類會覆蓋基底類別。一個例子： ::"

#: ../../library/dataclasses.rst:650
msgid ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    y: int = 0\n"
"\n"
"@dataclass\n"
"class C(Base):\n"
"    z: int = 10\n"
"    x: int = 15"
msgstr ""

#: ../../library/dataclasses.rst:660
#, fuzzy
msgid ""
"The final list of fields is, in order, :attr:`!x`, :attr:`!y`, :attr:`!z`.  "
"The final type of :attr:`!x` is :class:`int`, as specified in class :class:`!"
"C`."
msgstr ""
"最終的欄位列表按順序為 :attr:`!x`、:attr:`!y`、:attr:`!z`。:attr:`!x` 的最終"
"型別是 :class:`int`，如類別 :class:`!C` 中指定的那樣。"

#: ../../library/dataclasses.rst:663
#, fuzzy
msgid ""
"The generated :meth:`~object.__init__` method for :class:`!C` will look "
"like::"
msgstr "為 :class:`!C` 生成的 :meth:`~object.__init__` 方法將如下所示： ::"

#: ../../library/dataclasses.rst:665
msgid "def __init__(self, x: int = 15, y: int = 0, z: int = 10):"
msgstr ""

#: ../../library/dataclasses.rst:668
#, fuzzy
msgid "Re-ordering of keyword-only parameters in :meth:`!__init__`"
msgstr ":meth:`!__init__` 中僅關鍵字參數的重新排序"

#: ../../library/dataclasses.rst:670
#, fuzzy
msgid ""
"After the parameters needed for :meth:`~object.__init__` are computed, any "
"keyword-only parameters are moved to come after all regular (non-keyword-"
"only) parameters.  This is a requirement of how keyword-only parameters are "
"implemented in Python: they must come after non-keyword-only parameters."
msgstr ""
"在計算 :meth:`__init__` 所需的參數後，任何僅關鍵字參數都將移動到所有常規（非"
"僅關鍵字）參數之後。這是如何在 Python 中實作僅關鍵字參數的要求：它們必須位於"
"非僅關鍵字參數之後。"

#: ../../library/dataclasses.rst:676
#, fuzzy
msgid ""
"In this example, :attr:`!Base.y`, :attr:`!Base.w`, and :attr:`!D.t` are "
"keyword-only fields, and :attr:`!Base.x` and :attr:`!D.z` are regular "
"fields::"
msgstr ""
"在此示例中，:attr:`!Base.y`、:attr:`!Base.w` 和 :attr:`!D.t` 是僅限關鍵字的欄"
"位，:attr:`!Base.x` 和 :attr:`!D.z` 是常規欄位： ::"

#: ../../library/dataclasses.rst:679
msgid ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    _: KW_ONLY\n"
"    y: int = 0\n"
"    w: int = 1\n"
"\n"
"@dataclass\n"
"class D(Base):\n"
"    z: int = 10\n"
"    t: int = field(kw_only=True, default=0)"
msgstr ""

#: ../../library/dataclasses.rst:691
#, fuzzy
msgid "The generated :meth:`!__init__` method for :class:`!D` will look like::"
msgstr "為 :class:`!D` 生成的 :meth:`!__init__` 方法將如下所示： ::"

#: ../../library/dataclasses.rst:693
msgid ""
"def __init__(self, x: Any = 15.0, z: int = 10, *, y: int = 0, w: int = 1, t: "
"int = 0):"
msgstr ""

#: ../../library/dataclasses.rst:695
#, fuzzy
msgid ""
"Note that the parameters have been re-ordered from how they appear in the "
"list of fields: parameters derived from regular fields are followed by "
"parameters derived from keyword-only fields."
msgstr ""
"請注意，參數已根據它們在欄位列表中的顯示方式重新排序：從常規欄位派生的參數後"
"跟從僅關鍵字欄位派生的參數。"

#: ../../library/dataclasses.rst:699
#, fuzzy
msgid ""
"The relative ordering of keyword-only parameters is maintained in the re-"
"ordered :meth:`!__init__` parameter list."
msgstr "僅關鍵字參數的相對順序在重新排序的 :meth:`!__init__` 參數列表中維護。"

#: ../../library/dataclasses.rst:704
msgid "Default factory functions"
msgstr "預設工廠函式"

#: ../../library/dataclasses.rst:706
#, fuzzy
msgid ""
"If a :func:`field` specifies a *default_factory*, it is called with zero "
"arguments when a default value for the field is needed.  For example, to "
"create a new instance of a list, use::"
msgstr ""
"如果 :func:`field` 指定了 *default_factory*，當需要該欄位的預設值時，它會以零"
"引數呼叫。例如，要建立列表的新實例，請使用： ::"

#: ../../library/dataclasses.rst:710
msgid "mylist: list = field(default_factory=list)"
msgstr ""

#: ../../library/dataclasses.rst:712
#, fuzzy
msgid ""
"If a field is excluded from :meth:`~object.__init__` (using ``init=False``) "
"and the field also specifies *default_factory*, then the default factory "
"function will always be called from the generated :meth:`!__init__` "
"function.  This happens because there is no other way to give the field an "
"initial value."
msgstr ""
"如果一個欄位從 :meth:`~object.__init__` 中排除（使用 ``init=False``）並且該欄"
"位還指定了 ``default_factory``，那麼預設工廠函式將始終從生成的 :meth:"
"`__init__ 中呼叫`功能。發生這種情況是因為沒有其他方法可以為該欄位賦予初始值。"

#: ../../library/dataclasses.rst:719
msgid "Mutable default values"
msgstr "可變預設值"

#: ../../library/dataclasses.rst:721
#, fuzzy
msgid ""
"Python stores default member variable values in class attributes. Consider "
"this example, not using dataclasses::"
msgstr ""
"Python 將預設成員變數值存儲在類別屬性中。考慮這個例子，不使用資料類別： ::"

#: ../../library/dataclasses.rst:724
msgid ""
"class C:\n"
"    x = []\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"o1 = C()\n"
"o2 = C()\n"
"o1.add(1)\n"
"o2.add(2)\n"
"assert o1.x == [1, 2]\n"
"assert o1.x is o2.x"
msgstr ""

#: ../../library/dataclasses.rst:736
#, fuzzy
msgid ""
"Note that the two instances of class :class:`!C` share the same class "
"variable :attr:`!x`, as expected."
msgstr ""
"請注意，類別 :class:`!C` 的兩個實例共享同一個類別變數 :attr:`!x`，正如預期的"
"那樣。"

#: ../../library/dataclasses.rst:739
#, fuzzy
msgid "Using dataclasses, *if* this code was valid::"
msgstr "使用資料類別，*如果*此程式碼有效： ::"

#: ../../library/dataclasses.rst:741
msgid ""
"@dataclass\n"
"class D:\n"
"    x: list = []      # This code raises ValueError\n"
"    def add(self, element):\n"
"        self.x.append(element)"
msgstr ""

#: ../../library/dataclasses.rst:747
msgid "it would generate code similar to::"
msgstr "它會生成類似的程式碼： ::"

#: ../../library/dataclasses.rst:749
msgid ""
"class D:\n"
"    x = []\n"
"    def __init__(self, x=x):\n"
"        self.x = x\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"assert D().x is D().x"
msgstr ""

#: ../../library/dataclasses.rst:758
#, fuzzy
msgid ""
"This has the same issue as the original example using class :class:`!C`. "
"That is, two instances of class :class:`!D` that do not specify a value for :"
"attr:`!x` when creating a class instance will share the same copy of :attr:`!"
"x`.  Because dataclasses just use normal Python class creation they also "
"share this behavior.  There is no general way for Data Classes to detect "
"this condition.  Instead, the :func:`@dataclass <dataclass>` decorator will "
"raise a :exc:`ValueError` if it detects an unhashable default parameter.  "
"The assumption is that if a value is unhashable, it is mutable.  This is a "
"partial solution, but it does protect against many common errors."
msgstr ""
"這與使用類別 :class:`!C` 的原始示例存在相同的問題。也就是說，類別 :class:`!"
"D` 的兩個實例在建立類實例時沒有為 :attr:`!x` 指定值，它們將共享 :attr:`!x` 的"
"同一個副本。因為資料類別只是使用普通的 Python 類建立，所以它們也有這種行為。"
"資料類別沒有通用的方法來檢測這種情況。相反，如果 :func:`dataclass` 裝飾器檢測"
"到不可散列的預設參數，它將引發 :exc:`TypeError`。假設是如果一個值是不可散列"
"的，那麼它就是可變的。這是一個部分解決方案，但它確實可以防止許多常見錯誤。"

#: ../../library/dataclasses.rst:769
#, fuzzy
msgid ""
"Using default factory functions is a way to create new instances of mutable "
"types as default values for fields::"
msgstr "使用預設工廠函式是一種建立可變型別的新實例作為欄位預設值的方法： ::"

#: ../../library/dataclasses.rst:772
msgid ""
"@dataclass\n"
"class D:\n"
"    x: list = field(default_factory=list)\n"
"\n"
"assert D().x is not D().x"
msgstr ""

#: ../../library/dataclasses.rst:778
#, fuzzy
msgid ""
"Instead of looking for and disallowing objects of type :class:`list`, :class:"
"`dict`, or :class:`set`, unhashable objects are now not allowed as default "
"values.  Unhashability is used to approximate mutability."
msgstr ""
"不再查找和禁止型別為 :class:`list`、:class:`dict` 或 :class:`set` 的物件，現"
"在不允許使用不可散列的對像作為預設值。不可散列性用於近似可變性。"

#: ../../library/dataclasses.rst:785
#, fuzzy
msgid "Descriptor-typed fields"
msgstr "描述器型別的欄位"

#: ../../library/dataclasses.rst:787
#, fuzzy
msgid ""
"Fields that are assigned :ref:`descriptor objects <descriptors>` as their "
"default value have the following special behaviors:"
msgstr ""
"指定為\\ :ref:`描述器物件 <descriptors>`\\ 作為預設值的欄位具有以下特殊行為："

#: ../../library/dataclasses.rst:790
#, fuzzy
msgid ""
"The value for the field passed to the dataclass's :meth:`~object.__init__` "
"method is passed to the descriptor's :meth:`~object.__set__` method rather "
"than overwriting the descriptor object."
msgstr ""
"傳遞給資料類別的 :meth:`~object.__init__` 方法的欄位值被傳遞給描述器的 :meth:"
"`~object.__set__` 方法，而不是覆蓋描述器物件。"

#: ../../library/dataclasses.rst:794
#, fuzzy
msgid ""
"Similarly, when getting or setting the field, the descriptor's :meth:"
"`~object.__get__` or :meth:`!__set__` method is called rather than returning "
"or overwriting the descriptor object."
msgstr ""
"同樣，在獲取或設定欄位時，將呼叫描述器的 :meth:`~object.__get__` 或 :meth:`!"
"__set__` 方法，而不是回傳或覆蓋描述器物件。"

#: ../../library/dataclasses.rst:798
#, fuzzy
msgid ""
"To determine whether a field contains a default value, :func:`@dataclass "
"<dataclass>` will call the descriptor's :meth:`!__get__` method using its "
"class access form: ``descriptor.__get__(obj=None, type=cls)``.  If the "
"descriptor returns a value in this case, it will be used as the field's "
"default. On the other hand, if the descriptor raises :exc:`AttributeError` "
"in this situation, no default value will be provided for the field."
msgstr ""
"為了確定一個欄位是否包含預設值，:func:`@dataclass <dataclass>` 將使用其類訪問"
"形式呼叫描述器的 :meth:`!__get__` 方法（即 ``descriptor.__get__(obj=None, "
"type=cls)``。如果在這種情況下，描述器回傳一個值，它將用作欄位的預設值。另一方"
"面，如果描述器在這種情況下引發 :exc:`AttributeError`，則不會為該欄位提供預設"
"值。"

#: ../../library/dataclasses.rst:808
msgid ""
"class IntConversionDescriptor:\n"
"    def __init__(self, *, default):\n"
"        self._default = default\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self._name = \"_\" + name\n"
"\n"
"    def __get__(self, obj, type):\n"
"        if obj is None:\n"
"            return self._default\n"
"\n"
"        return getattr(obj, self._name, self._default)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        setattr(obj, self._name, int(value))\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    quantity_on_hand: IntConversionDescriptor = "
"IntConversionDescriptor(default=100)\n"
"\n"
"i = InventoryItem()\n"
"print(i.quantity_on_hand)   # 100\n"
"i.quantity_on_hand = 2.5    # calls __set__ with 2.5\n"
"print(i.quantity_on_hand)   # 2"
msgstr ""

#: ../../library/dataclasses.rst:833
#, fuzzy
msgid ""
"Note that if a field is annotated with a descriptor type, but is not "
"assigned a descriptor object as its default value, the field will act like a "
"normal field."
msgstr ""
"請注意，如果一個欄位用描述器型別註釋，但未分配描述器對像作為其預設值，則該欄"
"位將像普通欄位一樣工作。"
