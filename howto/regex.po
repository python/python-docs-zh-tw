# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Albin Sun <yunpin.sun@gmail.com>, 2015
# Kai-han Chang <rasca0027@gmail.com>, 2015
# CTHua <illiew2470+pythonTW@gmail.com>, 2023
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-24 16:01+0800\n"
"PO-Revision-Date: 2023-03-26 18:25+0000\n"
"Last-Translator: CTHua <illiew2470+pythonTW@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.16.4\n"

#: ../../howto/regex.rst:5
msgid "Regular Expression HOWTO"
msgstr "如何使用正規表示式 (Regular Expression)"

#: ../../howto/regex.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/regex.rst:7
msgid "A.M. Kuchling <amk@amk.ca>"
msgstr "A.M. Kuchling <amk@amk.ca>"

#: ../../howto/regex.rst:-1
msgid "Abstract"
msgstr "摘要"

#: ../../howto/regex.rst:18
msgid ""
"This document is an introductory tutorial to using regular expressions in "
"Python with the :mod:`re` module.  It provides a gentler introduction than "
"the corresponding section in the Library Reference."
msgstr ""
"此文件為如何在 Python 中使用 :mod:`re` 模組來撰寫正規表示式的入門指導。進階使"
"用及參考文件請見函式庫參考一章。"

#: ../../howto/regex.rst:24
msgid "Introduction"
msgstr "簡介"

#: ../../howto/regex.rst:26
msgid ""
"Regular expressions (called REs, or regexes, or regex patterns) are "
"essentially a tiny, highly specialized programming language embedded inside "
"Python and made available through the :mod:`re` module. Using this little "
"language, you specify the rules for the set of possible strings that you "
"want to match; this set might contain English sentences, or e-mail "
"addresses, or TeX commands, or anything you like.  You can then ask "
"questions such as \"Does this string match the pattern?\", or \"Is there a "
"match for the pattern anywhere in this string?\".  You can also use REs to "
"modify a string or to split it apart in various ways."
msgstr ""
"正規表示式（也稱為 REs、regexes 或 regex patterns）是一個輕量且高專業化的程式"
"語言。在 Python 中可透過內建的 :mod:`re` 模組直接使用。你可以使用此輕量化的語"
"言針對想要匹配的一組字串撰寫規則，這組字串可能包含了英語句子、e-mail 地址、"
"TeX 命令或任何東西。你可以檢查如「這組字串是否匹配這個規則？」或「這組字串中"
"是否有任一處匹配這個規則？」。除此之外，你也可以使用 REs 來修改或是切割字串。"

#: ../../howto/regex.rst:35
#, fuzzy
msgid ""
"Regular expression patterns are compiled into a series of bytecodes which "
"are then executed by a matching engine written in C.  For advanced use, it "
"may be necessary to pay careful attention to how the engine will execute a "
"given RE, and write the RE in a certain way in order to produce bytecode "
"that runs faster. Optimization isn't covered in this document, because it "
"requires that you have a good understanding of the matching engine's "
"internals."
msgstr ""
"正規表示式模式會被編譯成一系列 C 語言的匹配引擎可執行之位元碼，進而由該引擎來"
"進行匹配。若想要針對高階使用方式做最佳化，則需仔細考量引擎如何處理特定正規表"
"示式，在其產生能更快執行之 bytecode 的前提下編寫正規表示式。本文件並未涉及有"
"關最佳化方面的內容，因為它需要你對匹配引擎具有深入了解。"

#: ../../howto/regex.rst:42
#, fuzzy
msgid ""
"The regular expression language is relatively small and restricted, so not "
"all possible string processing tasks can be done using regular expressions.  "
"There are also tasks that *can* be done with regular expressions, but the "
"expressions turn out to be very complicated.  In these cases, you may be "
"better off writing Python code to do the processing; while Python code will "
"be slower than an elaborate regular expression, it will also probably be "
"more understandable."
msgstr ""
"正規表示式語言相對小而受限，因此並非所有可能的字串處理任務都可以使用正規表示"
"式完成。有些任務 *可以* 使用正規表示式完成，但表達會變得非常複雜。在這些情況"
"下，你最好撰寫 Python 程式碼來處理；雖然 Python 程式碼比精心設計的正則表達式"
"要慢，但也更容易被理解。"

#: ../../howto/regex.rst:51
msgid "Simple Patterns"
msgstr "簡單模式"

#: ../../howto/regex.rst:53
#, fuzzy
msgid ""
"We'll start by learning about the simplest possible regular expressions.  "
"Since regular expressions are used to operate on strings, we'll begin with "
"the most common task: matching characters."
msgstr ""
"讓我們從學習最簡單的正規表示式開始。由於正規表示式是用來操作字串的，因此我們"
"先從最常見的任務開始：匹配字符。"

#: ../../howto/regex.rst:57
#, fuzzy
msgid ""
"For a detailed explanation of the computer science underlying regular "
"expressions (deterministic and non-deterministic finite automata), you can "
"refer to almost any textbook on writing compilers."
msgstr ""
"關於正規表示式底層的計算機科學原理（如有限狀態自動機之決定性及非決定性），你"
"可以參考幾乎任何編寫編譯器的教科書以得到詳細解釋。"

#: ../../howto/regex.rst:63
#, fuzzy
msgid "Matching Characters"
msgstr "匹配字元"

#: ../../howto/regex.rst:65
#, fuzzy
msgid ""
"Most letters and characters will simply match themselves.  For example, the "
"regular expression ``test`` will match the string ``test`` exactly.  (You "
"can enable a case-insensitive mode that would let this RE match ``Test`` or "
"``TEST`` as well; more about this later.)"
msgstr ""
"大部分的字母和符號只會跟它們自己配對。例如，正規表示式「test」只會精確地匹配"
"到字串「test」。（你可以啟用不分大小寫模式來讓這個 RE 匹配 「Test」或"
"「TEST」；等等再詳細說明。）"

#: ../../howto/regex.rst:70
#, fuzzy
msgid ""
"There are exceptions to this rule; some characters are special :dfn:"
"`metacharacters`, and don't match themselves.  Instead, they signal that "
"some out-of-the-ordinary thing should be matched, or they affect other "
"portions of the RE by repeating them or changing their meaning.  Much of "
"this document is devoted to discussing various metacharacters and what they "
"do."
msgstr ""
"有例外情形，其中一些字元是特殊的 dfn:`metacharacters`\\ （元字元），並非匹配"
"它們自己，而是表示某些需要匹配但非常規的東西，或透過重複其他部分或改變其含義"
"來影響 RE 的其他部分。本文件的大部分內容都是討論各種 \"metacharacters\" 及其"
"用法。"

#: ../../howto/regex.rst:76
#, fuzzy
msgid ""
"Here's a complete list of the metacharacters; their meanings will be "
"discussed in the rest of this HOWTO."
msgstr "下面是元字符的完整清單；它們的含義將在本 HOWTO 的其餘部分中討論。"

#: ../../howto/regex.rst:79
msgid ". ^ $ * + ? { } [ ] \\ | ( )"
msgstr ". ^ $ * + ? { } [ ] \\ | ( )"

#: ../../howto/regex.rst:83
#, fuzzy
msgid ""
"The first metacharacters we'll look at are ``[`` and ``]``. They're used for "
"specifying a character class, which is a set of characters that you wish to "
"match.  Characters can be listed individually, or a range of characters can "
"be indicated by giving two characters and separating them by a ``'-'``.  For "
"example, ``[abc]`` will match any of the characters ``a``, ``b``, or ``c``; "
"this is the same as ``[a-c]``, which uses a range to express the same set of "
"characters.  If you wanted to match only lowercase letters, your RE would be "
"``[a-z]``."
msgstr ""
"我們要查看的第一個元字元是 ``[`` 和 ``]``。它們用於指定字元類，這是你希望匹配"
"的一組字元。可以單獨列出字元，也可以透過給出兩個字元並用 ``'-'`` 分隔它們來指"
"示字元範圍。例如，``[abc]`` 將匹配任何字元 ``a``、``b`` 或 ``c``；這與 ``[a-"
"c]`` 相同，它使用範圍來表示同一組字元。如果你只想匹配小寫字母，你的 RE 將是 "
"``[a-z]``。"

#: ../../howto/regex.rst:92
#, fuzzy
msgid ""
"Metacharacters (except ``\\``) are not active inside classes.  For example, "
"``[akm$]`` will match any of the characters ``'a'``, ``'k'``, ``'m'``, or "
"``'$'``; ``'$'`` is usually a metacharacter, but inside a character class "
"it's stripped of its special nature."
msgstr ""
"元字符（除了``\\``）在字符類中不起作用。例如，「[akm $]」將與任何一個字元"
"「'a'」、「'k'」、「 'm '」或者「 '$' 」匹配; 「 '$' 」通常是一個元字符，但在"
"字符集合裡就被剝離了特殊的本質。"

#: ../../howto/regex.rst:97
#, fuzzy
msgid ""
"You can match the characters not listed within the class by :dfn:"
"`complementing` the set.  This is indicated by including a ``'^'`` as the "
"first character of the class. For example, ``[^5]`` will match any character "
"except ``'5'``.  If the caret appears elsewhere in a character class, it "
"does not have special meaning. For example: ``[5^]`` will match either a "
"``'5'`` or a ``'^'``."
msgstr ""
"你可以透過 :dfn:`complementing`（補充集合）來匹配類別中未列出的字元。這是透過"
"包含 ``'^'`` 作為類別的第一個字元來指示的。例如，``[^5]`` 將符合除``'5'`` 之"
"外的任何字元。如果插入符號出現在字元類別的其他位置，則它沒有特殊意義。例如："
"``[5^]`` 將符合 ``'5'`` 或 ``'^'``。"

#: ../../howto/regex.rst:103
#, fuzzy
msgid ""
"Perhaps the most important metacharacter is the backslash, ``\\``.   As in "
"Python string literals, the backslash can be followed by various characters "
"to signal various special sequences.  It's also used to escape all the "
"metacharacters so you can still match them in patterns; for example, if you "
"need to match a ``[`` or  ``\\``, you can precede them with a backslash to "
"remove their special meaning: ``\\[`` or ``\\\\``."
msgstr ""
"也許最重要的是反斜線 ``\\`` 這個元字符。如同 Python 字串文字，反斜線後面可以"
"跟著各種字元來表示不同的特殊序列。它也被用來轉義所有的元字符，所以你仍然可以"
"在模式中匹配它們；例如，如果你需要匹配 \"[\" 或 \"\\\" ，則可以在它們前面加上"
"一條反斜線使其失去特殊意義：\"\\[\" 或者 \"\\\\\\\\\"."

#: ../../howto/regex.rst:110
#, fuzzy
msgid ""
"Some of the special sequences beginning with ``'\\'`` represent predefined "
"sets of characters that are often useful, such as the set of digits, the set "
"of letters, or the set of anything that isn't whitespace."
msgstr ""
"有些以``'\\'``開頭的特殊序列代表已事先定義好，並常用到的一組字元，例如數字、"
"字母或空白之外的任何東西。"

#: ../../howto/regex.rst:115
#, fuzzy
msgid ""
"Let's take an example: ``\\w`` matches any alphanumeric character.  If the "
"regex pattern is expressed in bytes, this is equivalent to the class ``[a-zA-"
"Z0-9_]``.  If the regex pattern is a string, ``\\w`` will match all the "
"characters marked as letters in the Unicode database provided by the :mod:"
"`unicodedata` module.  You can use the more restricted definition of ``\\w`` "
"in a string pattern by supplying the :const:`re.ASCII` flag when compiling "
"the regular expression."
msgstr ""
"讓我們舉一個例子：``\\w`` 匹配任何字母或數字字符。如果正則表達式模式採用位元"
"組表示，這等同於類別 ``[a-zA-Z0-9_]``。如果正則表達式模式是一個字符串，那麼 "
"``\\w`` 將匹配由 :mod:`unicodedata` 模組提供的 Unicode 資料庫中標記為文字的所"
"有字符。你可以在編譯正則表達式時提供 :const:`re.ASCII` 旗幟來使用更受限定義下"
"的 ``\\w`` 字符串模式。"

#: ../../howto/regex.rst:123
#, fuzzy
msgid ""
"The following list of special sequences isn't complete. For a complete list "
"of sequences and expanded class definitions for Unicode string patterns, see "
"the last part of :ref:`Regular Expression Syntax <re-syntax>` in the "
"Standard Library reference.  In general, the Unicode versions match any "
"character that's in the appropriate category in the Unicode database."
msgstr ""
"下列特殊序列的列表不是完整的，要查看Unicode字串模式的所有定義和擴展類別，請參"
"考標準函式庫參考資料中 :ref:`Regular Expression Syntax <re-syntax>` 的最後部"
"分。一般而言，Unicode 版本會將該合適種類在 Unicode 資料庫內任何字元配對。"

#: ../../howto/regex.rst:130
msgid "``\\d``"
msgstr "``\\d``"

#: ../../howto/regex.rst:131
#, fuzzy
msgid "Matches any decimal digit; this is equivalent to the class ``[0-9]``."
msgstr "匹配所有十進位數字；等價於類別 ``[0-9]``。"

#: ../../howto/regex.rst:133
msgid "``\\D``"
msgstr "``\\D``"

#: ../../howto/regex.rst:134
#, fuzzy
msgid ""
"Matches any non-digit character; this is equivalent to the class ``[^0-9]``."
msgstr "匹配任何非數字字符；這等同於類別 ``[^0-9]``。"

#: ../../howto/regex.rst:136
msgid "``\\s``"
msgstr "``\\s``"

#: ../../howto/regex.rst:137
#, fuzzy
msgid ""
"Matches any whitespace character; this is equivalent to the class "
"``[ \\t\\n\\r\\f\\v]``."
msgstr "符合所有空格字符，相當於類別 ``[ \\t\\n\\r\\f\\v]``。"

#: ../../howto/regex.rst:140
msgid "``\\S``"
msgstr "``\\S``"

#: ../../howto/regex.rst:141
#, fuzzy
msgid ""
"Matches any non-whitespace character; this is equivalent to the class ``[^ "
"\\t\\n\\r\\f\\v]``."
msgstr "符合任何非空白字元，這相當於目錄 ``[^ \\t\\n\\r\\f\\v]``。"

#: ../../howto/regex.rst:144
msgid "``\\w``"
msgstr "``\\w``"

#: ../../howto/regex.rst:145
#, fuzzy
msgid ""
"Matches any alphanumeric character; this is equivalent to the class ``[a-zA-"
"Z0-9_]``."
msgstr "匹配任何字母、數字的字符，這等價於類別 ``[a-zA-Z0-9_]``。"

#: ../../howto/regex.rst:148
msgid "``\\W``"
msgstr "``\\W``"

#: ../../howto/regex.rst:149
#, fuzzy
msgid ""
"Matches any non-alphanumeric character; this is equivalent to the class "
"``[^a-zA-Z0-9_]``."
msgstr "匹配任何一個非字母或數字的字符；這相當於類別``[^a-zA-Z0-9_]``。"

#: ../../howto/regex.rst:152
#, fuzzy
msgid ""
"These sequences can be included inside a character class.  For example, "
"``[\\s,.]`` is a character class that will match any whitespace character, "
"or ``','`` or ``'.'``."
msgstr ""
"這些字元序列可包含在字元類別內。例如，``[\\s,.]``是一個字元類別，可以匹配任何"
"空白字元、``','``或``'.'``。"

#: ../../howto/regex.rst:156
#, fuzzy
msgid ""
"The final metacharacter in this section is ``.``.  It matches anything "
"except a newline character, and there's an alternate mode (:const:`re."
"DOTALL`) where it will match even a newline.  ``.`` is often used where you "
"want to match \"any character\"."
msgstr ""
"本節的最後一個元字符是``.``。它匹配除了換行符號以外的任何字元，並且有另一種模"
"式 (:const:`re.DOTALL`) 可以匹配包含企業符號在內的所有字元。``.`` 常用於想要"
"匹配\"任意字元\" 的情況下。"

#: ../../howto/regex.rst:163
#, fuzzy
msgid "Repeating Things"
msgstr "重複的事情"

#: ../../howto/regex.rst:165
#, fuzzy
msgid ""
"Being able to match varying sets of characters is the first thing regular "
"expressions can do that isn't already possible with the methods available on "
"strings.  However, if that was the only additional capability of regexes, "
"they wouldn't be much of an advance. Another capability is that you can "
"specify that portions of the RE must be repeated a certain number of times."
msgstr ""
"正規表示式的第一個優點是，能夠使用不同字符集合匹配。這在字串方法中並不可行。"
"然而，如果只有此能力，在正則表達式上的進展就不會太大。另一個技巧包括：你可以"
"指定 RE 的某些部分必須重複幾次。"

#: ../../howto/regex.rst:171
#, fuzzy
msgid ""
"The first metacharacter for repeating things that we'll look at is ``*``.  "
"``*`` doesn't match the literal character ``'*'``; instead, it specifies "
"that the previous character can be matched zero or more times, instead of "
"exactly once."
msgstr ""
"我們要介紹的第一個用於重複事物的元字符是「*」。星號不代表字面上的星號；它代表"
"先前出現過的 字元可以匹配零次或多次，而非只能出現一次。"

#: ../../howto/regex.rst:175
#, fuzzy
msgid ""
"For example, ``ca*t`` will match ``'ct'`` (0 ``'a'`` characters), ``'cat'`` "
"(1 ``'a'``), ``'caaat'`` (3 ``'a'`` characters), and so forth."
msgstr ""
"例如，「ca*t」會符合 「ct」（0個「a」字元）、「cat」（1個「a」字元）、 "
"「caaat」（3 個「a」字元）等。"

#: ../../howto/regex.rst:178
#, fuzzy
msgid ""
"Repetitions such as ``*`` are :dfn:`greedy`; when repeating a RE, the "
"matching engine will try to repeat it as many times as possible. If later "
"portions of the pattern don't match, the matching engine will then back up "
"and try again with fewer repetitions."
msgstr ""
"重複使用如 ``*`` 的正規表示式（RE）稱為 :dfn:`貪婪`，即當 RE 重複時，匹配引擎"
"會試圖盡可能多次地重複。如果模式的後續部分不符合，則匹配引擎將往回跳並嘗試減"
"少重複次數。"

#: ../../howto/regex.rst:183
#, fuzzy
msgid ""
"A step-by-step example will make this more obvious.  Let's consider the "
"expression ``a[bcd]*b``.  This matches the letter ``'a'``, zero or more "
"letters from the class ``[bcd]``, and finally ends with a ``'b'``.  Now "
"imagine matching this RE against the string ``'abcbd'``."
msgstr ""
"一個逐步解釋的範例會更加清晰。讓我們考慮表達式``a[bcd]*b``，它可以匹配字母 "
"'a'，來自類別 ``[bcd]`` 中的零或多個字母，最後以 'b' 結尾。現在想像一下將此正"
"規表示式與字符串 \"abcbd\" 進行匹配的情況。"

#: ../../howto/regex.rst:189
#, fuzzy
msgid "Step"
msgstr "步驟"

#: ../../howto/regex.rst:189
#, fuzzy
msgid "Matched"
msgstr "符合"

#: ../../howto/regex.rst:189
#, fuzzy
msgid "Explanation"
msgstr "解釋"

#: ../../howto/regex.rst:191
msgid "1"
msgstr "1"

#: ../../howto/regex.rst:191
msgid "``a``"
msgstr "``a``"

#: ../../howto/regex.rst:191
#, fuzzy
msgid "The ``a`` in the RE matches."
msgstr "RE 中的 ``a`` 符合。"

#: ../../howto/regex.rst:193
msgid "2"
msgstr "2"

#: ../../howto/regex.rst:193
msgid "``abcbd``"
msgstr "``abcbd``"

#: ../../howto/regex.rst:193
#, fuzzy
msgid ""
"The engine matches ``[bcd]*``, going as far as it can, which is to the end "
"of the string."
msgstr "引擎會以盡可能長的方式比對``[bcd]*``，一直到字串的結束。"

#: ../../howto/regex.rst:197
msgid "3"
msgstr "3"

#: ../../howto/regex.rst:197 ../../howto/regex.rst:205
#, fuzzy
msgid "*Failure*"
msgstr "*失敗*"

#: ../../howto/regex.rst:197
#, fuzzy
msgid ""
"The engine tries to match ``b``, but the current position is at the end of "
"the string, so it fails."
msgstr "引擎試圖配對「b」，但目前位置在字串結束處，因此失敗。"

#: ../../howto/regex.rst:202
msgid "4"
msgstr "4"

#: ../../howto/regex.rst:202 ../../howto/regex.rst:213
msgid "``abcb``"
msgstr "``abcb``"

#: ../../howto/regex.rst:202
#, fuzzy
msgid "Back up, so that  ``[bcd]*`` matches one less character."
msgstr "倒退一個字符，這樣 ``[bcd]*`` 能夠少匹配一個字元。"

#: ../../howto/regex.rst:205
msgid "5"
msgstr "5"

#: ../../howto/regex.rst:205
#, fuzzy
msgid ""
"Try ``b`` again, but the current position is at the last character, which is "
"a ``'d'``."
msgstr ""
"嘗試再次執行 ``b``，但目前的位置已經在最後一個字元上，而這個字元是一個「d」。"

#: ../../howto/regex.rst:209 ../../howto/regex.rst:213
msgid "6"
msgstr "6"

#: ../../howto/regex.rst:209
msgid "``abc``"
msgstr "``abc``"

#: ../../howto/regex.rst:209
#, fuzzy
msgid "Back up again, so that ``[bcd]*`` is only matching ``bc``."
msgstr "再次進行備份，這樣 ``[bcd]*`` 將只匹配到 ``bc``。"

#: ../../howto/regex.rst:213
#, fuzzy
msgid ""
"Try ``b`` again.  This time the character at the current position is "
"``'b'``, so it succeeds."
msgstr "請再試一次 ``b``。這次目前位置的字元是``'b'``，所以它成功了"

#: ../../howto/regex.rst:219
#, fuzzy
msgid ""
"The end of the RE has now been reached, and it has matched ``'abcb'``.  This "
"demonstrates how the matching engine goes as far as it can at first, and if "
"no match is found it will then progressively back up and retry the rest of "
"the RE again and again.  It will back up until it has tried zero matches for "
"``[bcd]*``, and if that subsequently fails, the engine will conclude that "
"the string doesn't match the RE at all."
msgstr ""
"RE（正規表示式）已經到達結尾，並匹配了「abcb」。這演示了匹配引擎一開始盡可能"
"地前行，如果沒有找到任何匹配項目則會回溯並不斷再試驗 RE 其餘部分。它會一直倒"
"退，直到都嘗試完「[bcd]*」的零次數匹配；如果之後仍然失敗，引擎就會得出結論："
"這個字串根本不符合這個 RE。"

#: ../../howto/regex.rst:226
#, fuzzy
msgid ""
"Another repeating metacharacter is ``+``, which matches one or more times.  "
"Pay careful attention to the difference between ``*`` and ``+``; ``*`` "
"matches *zero* or more times, so whatever's being repeated may not be "
"present at all, while ``+`` requires at least *one* occurrence.  To use a "
"similar example, ``ca+t`` will match ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 "
"``'a'``\\ s), but won't match ``'ct'``."
msgstr ""
"另一個重複元字符是「+」，它可配對出現一或多次。要特別留意「*」和「+」之間的差"
"異。「*」可以匹配*零個或多個次數*，所以被重複配對的字元可能完全不會出現；相反"
"地，用了「+」就必須至少出現 * 一次。舉例來說，像 ``ca+t`` 就能配對到 "
"``'cat'``（其中只有1個\"a\"）、``'caaat'``（其中有3 個 \"a\"），但無法匹配到 "
"``'ct'``。"

#: ../../howto/regex.rst:233
#, fuzzy
msgid ""
"There are two more repeating operators or quantifiers.  The question mark "
"character, ``?``, matches either once or zero times; you can think of it as "
"marking something as being optional.  For example, ``home-?brew`` matches "
"either ``'homebrew'`` or ``'home-brew'``."
msgstr ""
"有兩個更多的重複運算子或量詞。問號字元「?」會匹配一次或零次；你可以將它視為可"
"選項目的標記。例如，「home-?brew」匹配「'homebrew'」或者是「'home-brew'」。"

#: ../../howto/regex.rst:238
#, fuzzy
msgid ""
"The most complicated quantifier is ``{m,n}``, where *m* and *n* are decimal "
"integers.  This quantifier means there must be at least *m* repetitions, and "
"at most *n*.  For example, ``a/{1,3}b`` will match ``'a/b'``, ``'a//b'``, "
"and ``'a///b'``.  It won't match ``'ab'``, which has no slashes, or ``'a////"
"b'``, which has four."
msgstr ""
"最複雜的量詞是 ``{m,n}``，其中 *m* 和 *n* 為十進制整數。這個量詞意味著必須至"
"少重複 *m* 次，最多為 *n*。例如，``a/{1,3}b`` 將匹配 ``'a/b'``, ``'a//b'`` "
"和 ``'a///b'``。它不會匹配沒有斜杠的 ``'ab'` `，也不會匹配有四個斜杠的 `,' "
"a//// b '`."

#: ../../howto/regex.rst:244
#, fuzzy
msgid ""
"You can omit either *m* or *n*; in that case, a reasonable value is assumed "
"for the missing value.  Omitting *m* is interpreted as a lower limit of 0, "
"while omitting *n* results in an upper bound of infinity."
msgstr ""
"你可以省略 *m* 或 *n* 的其中一項，這種情況下將會自動指定一個合理的值。如果省"
"略 *m* 則被解釋為最小值是 0，而如果忽略了 `n` 就視為上限無窮大。"

#: ../../howto/regex.rst:248
#, fuzzy
msgid ""
"The simplest case ``{m}`` matches the preceding item exactly *m* times. For "
"example, ``a/{2}b`` will only match ``'a//b'``."
msgstr ""
"最簡單的情況 ``{m}`` 與前面的項正好符合 *m* 次。例如，``a/{2}b`` 將僅符合"
"``'a//b'``。"

#: ../../howto/regex.rst:251
msgid ""
"Readers of a reductionist bent may notice that the three other quantifiers "
"can all be expressed using this notation.  ``{0,}`` is the same as ``*``, "
"``{1,}`` is equivalent to ``+``, and ``{0,1}`` is the same as ``?``.  It's "
"better to use ``*``, ``+``, or ``?`` when you can, simply because they're "
"shorter and easier to read."
msgstr ""
"若有節制觀念的讀者可能會注意到，其餘三種量詞都可以用這種表示法表達。``{0,}`` "
"同於 ``*``, ``{1,}`` 相當於 ``+``, 而 ``{0,1}`` 與 ``?`` 相同。如果可以，建議"
"使用簡潔易讀的 `*`, `+`, 或 `?`"

#: ../../howto/regex.rst:259
#, fuzzy
msgid "Using Regular Expressions"
msgstr "使用正規表示式"

#: ../../howto/regex.rst:261
#, fuzzy
msgid ""
"Now that we've looked at some simple regular expressions, how do we actually "
"use them in Python?  The :mod:`re` module provides an interface to the "
"regular expression engine, allowing you to compile REs into objects and then "
"perform matches with them."
msgstr ""
"現在我們已經看過了一些簡單的正規表示式，那麼我們該如何在Python中實際使用它們"
"呢？ :mod:`re`模組提供了與正規表示引擎的介面，允許你將 RE 編譯成物件，然後使"
"用它們執行匹配。"

#: ../../howto/regex.rst:268
#, fuzzy
msgid "Compiling Regular Expressions"
msgstr "編譯正規表示式 (Regular Expression)"

#: ../../howto/regex.rst:270
#, fuzzy
msgid ""
"Regular expressions are compiled into pattern objects, which have methods "
"for various operations such as searching for pattern matches or performing "
"string substitutions. ::"
msgstr ""
"正規表示式會被編譯成模式物件(pattern object)，這些物件擁有各種方法可以進行多"
"種操作，例如尋找符合該模式的字串或執行字串替換： ::"

#: ../../howto/regex.rst:274
msgid ""
">>> import re\n"
">>> p = re.compile('ab*')\n"
">>> p\n"
"re.compile('ab*')"
msgstr ""
">>> import re\n"
">>> p = re.compile('ab*')\n"
">>> p\n"
"re.compile('ab*')"

#: ../../howto/regex.rst:279
#, fuzzy
msgid ""
":func:`re.compile` also accepts an optional *flags* argument, used to enable "
"various special features and syntax variations.  We'll go over the available "
"settings later, but for now a single example will do::"
msgstr ""
":func:`re.compile` 函式也可以接受一個選擇性的 *flags* 引數，用於啟用各種特殊"
"功能和語法變化。我們稍後將介紹可用的設置，但現在單獨舉一個例子即可： ::"

#: ../../howto/regex.rst:283
msgid ">>> p = re.compile('ab*', re.IGNORECASE)"
msgstr ">>> p = re.compile('ab*', re.IGNORECASE)"

#: ../../howto/regex.rst:285
#, fuzzy
msgid ""
"The RE is passed to :func:`re.compile` as a string.  REs are handled as "
"strings because regular expressions aren't part of the core Python language, "
"and no special syntax was created for expressing them.  (There are "
"applications that don't need REs at all, so there's no need to bloat the "
"language specification by including them.) Instead, the :mod:`re` module is "
"simply a C extension module included with Python, just like the :mod:"
"`socket` or :mod:`zlib` modules."
msgstr ""
"正規表示式（RE）被當作字串傳遞給 :func:`re.compile`。因為正規表示式並不是"
"Python核心語言的一部分，也沒有特殊的語法來表達它們。有些應用程式根本不需要使"
"用正規表示式，所以無需將其包含在語言规範中。相反地，:mod:`re` 模組只是 "
"Python 的 C 擴展模組之一，就像 :mod:`socket` 或 :mod:`zlib` 模組一樣。"

#: ../../howto/regex.rst:292
#, fuzzy
msgid ""
"Putting REs in strings keeps the Python language simpler, but has one "
"disadvantage which is the topic of the next section."
msgstr ""
"將正規表示式放入字串中可使 Python 語言保持簡潔，但有一個缺點──下一節的主題。"

#: ../../howto/regex.rst:299
#, fuzzy
msgid "The Backslash Plague"
msgstr "反斜線之患"

#: ../../howto/regex.rst:301
#, fuzzy
msgid ""
"As stated earlier, regular expressions use the backslash character "
"(``'\\'``) to indicate special forms or to allow special characters to be "
"used without invoking their special meaning. This conflicts with Python's "
"usage of the same character for the same purpose in string literals."
msgstr ""
"如前所述，正規表示式使用反斜線字元（``'\\'``）來指示特殊形式或允許使用特殊字"
"符而不引起其特殊意義。這與Python在字符串常量中使用相同字符的目的產生了衝突。"

#: ../../howto/regex.rst:306
#, fuzzy
msgid ""
"Let's say you want to write a RE that matches the string ``\\section``, "
"which might be found in a LaTeX file.  To figure out what to write in the "
"program code, start with the desired string to be matched.  Next, you must "
"escape any backslashes and other metacharacters by preceding them with a "
"backslash, resulting in the string ``\\\\section``.  The resulting string "
"that must be passed to :func:`re.compile` must be ``\\\\section``.  However, "
"to express this as a Python string literal, both backslashes must be escaped "
"*again*."
msgstr ""
"假設你要寫一個正規表示式，以匹配 LaTeX 文件中可能出現的字串 ``\\section``。為"
"了找出在程序程式碼中應該怎麼寫，必須從需要匹配的字串開始。接下來，你必須使用"
"反斜線來轉義任何反斜線和其他元字符 ，這導致輸入 \\\\section 字符串。最後傳遞"
"給 :func:`re.compile` 的字符串必須是 '\\\\\\\\section'。但是，在 Python 字符"
"串文字中表達此值時，兩個反斜杠 *再次* 必須被轉義。"

#: ../../howto/regex.rst:315
msgid "Characters"
msgstr "字元"

#: ../../howto/regex.rst:315
msgid "Stage"
msgstr "階段"

#: ../../howto/regex.rst:317
msgid "``\\section``"
msgstr "``\\section``"

#: ../../howto/regex.rst:317
msgid "Text string to be matched"
msgstr "要被匹配的文字字串"

#: ../../howto/regex.rst:319
msgid "``\\\\section``"
msgstr "``\\\\section``"

#: ../../howto/regex.rst:319
msgid "Escaped backslash for :func:`re.compile`"
msgstr "在 :func:`re.compile` 中跳脫反斜線"

#: ../../howto/regex.rst:321 ../../howto/regex.rst:348
msgid "``\"\\\\\\\\section\"``"
msgstr "``\"\\\\\\\\section\"``"

#: ../../howto/regex.rst:321
#, fuzzy
msgid "Escaped backslashes for a string literal"
msgstr "為字串字面值跳脫反斜線。"

#: ../../howto/regex.rst:324
#, fuzzy
msgid ""
"In short, to match a literal backslash, one has to write ``'\\\\\\\\'`` as "
"the RE string, because the regular expression must be ``\\\\``, and each "
"backslash must be expressed as ``\\\\`` inside a regular Python string "
"literal.  In REs that feature backslashes repeatedly, this leads to lots of "
"repeated backslashes and makes the resulting strings difficult to understand."
msgstr ""
"簡而言之，若要匹配反斜線字元本身，在正規表示式中要寫成 ``'\\\\\\\\'``。這是因"
"為正規表示式必須寫成 ``\\\\``，而每個反斜線又需要以在 Python 字串常值內表示的"
"方式寫成 ``\\\\``，所以在多次出現反斜線的正規表示式中會有很多重複使用的反斜"
"線，讓結果字串難以理解。"

#: ../../howto/regex.rst:330
#, fuzzy
msgid ""
"The solution is to use Python's raw string notation for regular expressions; "
"backslashes are not handled in any special way in a string literal prefixed "
"with ``'r'``, so ``r\"\\n\"`` is a two-character string containing ``'\\'`` "
"and ``'n'``, while ``\"\\n\"`` is a one-character string containing a "
"newline. Regular expressions will often be written in Python code using this "
"raw string notation."
msgstr ""
"解決方法是使用 Python 的原始字串記號來表達正規表示式；在以 ``'r'`` 為前綴的字"
"串文字中，反斜線不會有任何特別的處理方式，因此 ``r\"\\n\"`` 是一個包含兩個字"
"符 ``'\\'`` 和 ``'n'`` 的字串, 而 ``\"\\n\"`` 則是一個包含換行符的單個字符。"
"在撰寫 Python 程式碼時，通常會採用這種原始字符串形式來撰寫正規表示式。"

#: ../../howto/regex.rst:336
#, fuzzy
msgid ""
"In addition, special escape sequences that are valid in regular expressions, "
"but not valid as Python string literals, now result in a :exc:"
"`DeprecationWarning` and will eventually become a :exc:`SyntaxError`, which "
"means the sequences will be invalid if raw string notation or escaping the "
"backslashes isn't used."
msgstr ""
"此外，現在正規表示式中有效但不是 Python 字串實體所用的特殊 Escape sequence，"
"會產生 :exc:`DeprecationWarning` 警告且最終可能會變成 :exc:`SyntaxError`, 也"
"就是說如果沒有使用 raw string 標記或反斜線進行字符轉義，該序列將無效。"

#: ../../howto/regex.rst:344
#, fuzzy
msgid "Regular String"
msgstr "正規字串"

#: ../../howto/regex.rst:344
msgid "Raw string"
msgstr "原始字串"

#: ../../howto/regex.rst:346
msgid "``\"ab*\"``"
msgstr "``\"ab*\"``"

#: ../../howto/regex.rst:346
msgid "``r\"ab*\"``"
msgstr "``r\"ab*\"``"

#: ../../howto/regex.rst:348
msgid "``r\"\\\\section\"``"
msgstr "``r\"\\\\section\"``"

#: ../../howto/regex.rst:350
msgid "``\"\\\\w+\\\\s+\\\\1\"``"
msgstr "``\"\\\\w+\\\\s+\\\\1\"``"

#: ../../howto/regex.rst:350
msgid "``r\"\\w+\\s+\\1\"``"
msgstr "``r\"\\w+\\s+\\1\"``"

#: ../../howto/regex.rst:355
msgid "Performing Matches"
msgstr "進行匹配比對"

#: ../../howto/regex.rst:357
#, fuzzy
msgid ""
"Once you have an object representing a compiled regular expression, what do "
"you do with it?  Pattern objects have several methods and attributes. Only "
"the most significant ones will be covered here; consult the :mod:`re` docs "
"for a complete listing."
msgstr ""
"編譯正規表示式後，你需要對其進行操作。模式物件有多個方法和屬性，這裡只介紹最"
"重要的幾個；請參考 :mod:`re` 文件以獲取完整列表。"

#: ../../howto/regex.rst:363 ../../howto/regex.rst:417
#: ../../howto/regex.rst:1065
msgid "Method/Attribute"
msgstr "方法/屬性"

#: ../../howto/regex.rst:363 ../../howto/regex.rst:417
#: ../../howto/regex.rst:1065
msgid "Purpose"
msgstr "目的"

#: ../../howto/regex.rst:365
msgid "``match()``"
msgstr "``match()``"

#: ../../howto/regex.rst:365
#, fuzzy
msgid "Determine if the RE matches at the beginning of the string."
msgstr "判斷正規表示式是否在字串開頭符合。"

#: ../../howto/regex.rst:368
msgid "``search()``"
msgstr "``search()``"

#: ../../howto/regex.rst:368
#, fuzzy
msgid "Scan through a string, looking for any location where this RE matches."
msgstr "掃描字串，尋找任何符合正規表示式的位置。"

#: ../../howto/regex.rst:371
msgid "``findall()``"
msgstr "``findall()``"

#: ../../howto/regex.rst:371
msgid "Find all substrings where the RE matches, and returns them as a list."
msgstr "尋找所有和正規表示式匹配的子字串，並將其以串列形式回傳。"

#: ../../howto/regex.rst:374
msgid "``finditer()``"
msgstr "``finditer()``"

#: ../../howto/regex.rst:374
#, fuzzy
msgid ""
"Find all substrings where the RE matches, and returns them as an :term:"
"`iterator`."
msgstr "尋找所有和正規表示式匹配的子字串，並以 :term:`iterator` 形式回傳它們。"

#: ../../howto/regex.rst:378
#, fuzzy
msgid ""
":meth:`~re.Pattern.match` and :meth:`~re.Pattern.search` return ``None`` if "
"no match can be found.  If they're successful, a :ref:`match object <match-"
"objects>` instance is returned, containing information about the match: "
"where it starts and ends, the substring it matched, and more."
msgstr ""
":meth:`~re.Pattern.match` 和 :meth:`~re.Pattern.search` 如果沒有成功匹配則會"
"回傳 ``None``。如果成功了，將回傳一個 :ref:`match object <match-objects>` 物"
"件實例，包含有關匹配的資訊: 匹配開始和結束位置、它所匹配的子字串等等。"

#: ../../howto/regex.rst:383
#, fuzzy
msgid ""
"You can learn about this by interactively experimenting with the :mod:`re` "
"module."
msgstr ""
"你可以透過互動式的方式在 `re` 模組中實驗學習。如果你有可用的 `tkinter`，也可"
"以參考 Python 發行版附帶的演示程式 :source:`Tools/demo/redemo.py`。它允許你輸"
"入正規表示式以及字串，並顯示正規表示式是否符合或失敗。當嘗試除錯複雜的正則表"
"達式時，:file:`redemo.py` 可能非常實用。"

#: ../../howto/regex.rst:386
#, fuzzy
msgid ""
"This HOWTO uses the standard Python interpreter for its examples. First, run "
"the Python interpreter, import the :mod:`re` module, and compile a RE::"
msgstr ""
"這份 HOWTO 使用Python標準解譯器進行範例演示。首先，啟動Python解譯器，匯入 "
"``re`` 模組，並編譯一個正規表示式 (RE)： ::"

#: ../../howto/regex.rst:389
msgid ""
">>> import re\n"
">>> p = re.compile('[a-z]+')\n"
">>> p\n"
"re.compile('[a-z]+')"
msgstr ""
">>> import re\n"
">>> p = re.compile('[a-z]+')\n"
">>> p\n"
"re.compile('[a-z]+')"

#: ../../howto/regex.rst:394
#, fuzzy
msgid ""
"Now, you can try matching various strings against the RE ``[a-z]+``.  An "
"empty string shouldn't match at all, since ``+`` means 'one or more "
"repetitions'. :meth:`~re.Pattern.match` should return ``None`` in this case, "
"which will cause the interpreter to print no output.  You can explicitly "
"print the result of :meth:`!match` to make this clear. ::"
msgstr ""
"現在，你可以嘗試將各種字串與正規表示式 ``[a-z]+`` 進行匹配。由於 ``+`` 的含義"
"是「出現一次或多次」，因此空字串應該根本沒有匹配。這種情況下，:meth:`~re."
"Pattern.match` 應回傳 ``None``，進解譯器不會輸出任何內容。你可以明確地打印 :"
"meth:`!match` 的結果以使其清楚明白： ::"

#: ../../howto/regex.rst:400
msgid ""
">>> p.match(\"\")\n"
">>> print(p.match(\"\"))\n"
"None"
msgstr ""
">>> p.match(\"\")\n"
">>> print(p.match(\"\"))\n"
"None"

#: ../../howto/regex.rst:404
#, fuzzy
msgid ""
"Now, let's try it on a string that it should match, such as ``tempo``.  In "
"this case, :meth:`~re.Pattern.match` will return a :ref:`match object <match-"
"objects>`, so you should store the result in a variable for later use. ::"
msgstr ""
"現在讓我們把它應用到一個應該符合的字串，例如 \"tempo\"。在這種情況下，:meth:"
"`~re.Pattern.match` 會回傳一個 :ref:`match object <match-objects>`，所以你應"
"當將結果存入變數中以供後續使用： ::"

#: ../../howto/regex.rst:408
msgid ""
">>> m = p.match('tempo')\n"
">>> m\n"
"<re.Match object; span=(0, 5), match='tempo'>"
msgstr ""
">>> m = p.match('tempo')\n"
">>> m\n"
"<re.Match object; span=(0, 5), match='tempo'>"

#: ../../howto/regex.rst:412
#, fuzzy
msgid ""
"Now you can query the :ref:`match object <match-objects>` for information "
"about the matching string.  Match object instances also have several methods "
"and attributes; the most important ones are:"
msgstr ""
"現在你可以查詢 :ref:`match object <match-objects>` 來獲取有關匹配字串的資訊，"
"而且 Match object 實例還具有多種方法和屬性；其中最重要的是："

#: ../../howto/regex.rst:419
msgid "``group()``"
msgstr "``group()``"

#: ../../howto/regex.rst:419
#, fuzzy
msgid "Return the string matched by the RE"
msgstr "回傳正規表示式 (RE) 所匹配的字串。"

#: ../../howto/regex.rst:421
msgid "``start()``"
msgstr "``start()``"

#: ../../howto/regex.rst:421
#, fuzzy
msgid "Return the starting position of the match"
msgstr "回傳符合項目的起始位置"

#: ../../howto/regex.rst:423
msgid "``end()``"
msgstr "``end()``"

#: ../../howto/regex.rst:423
#, fuzzy
msgid "Return the ending position of the match"
msgstr "回傳匹配項目結束的位置"

#: ../../howto/regex.rst:425
msgid "``span()``"
msgstr "``span()``"

#: ../../howto/regex.rst:425
#, fuzzy
msgid "Return a tuple containing the (start, end) positions  of the match"
msgstr "回傳一個包含匹配位置 (起始，結束) 的元組"

#: ../../howto/regex.rst:429
#, fuzzy
msgid "Trying these methods will soon clarify their meaning::"
msgstr "嘗試這些方法很快就會澄清它們的意思： ::"

#: ../../howto/regex.rst:431
msgid ""
">>> m.group()\n"
"'tempo'\n"
">>> m.start(), m.end()\n"
"(0, 5)\n"
">>> m.span()\n"
"(0, 5)"
msgstr ""
">>> m.group()\n"
"'tempo'\n"
">>> m.start(), m.end()\n"
"(0, 5)\n"
">>> m.span()\n"
"(0, 5)"

#: ../../howto/regex.rst:438
#, fuzzy
msgid ""
":meth:`~re.Match.group` returns the substring that was matched by the RE.  :"
"meth:`~re.Match.start` and :meth:`~re.Match.end` return the starting and "
"ending index of the match. :meth:`~re.Match.span` returns both start and end "
"indexes in a single tuple.  Since the :meth:`~re.Pattern.match` method only "
"checks if the RE matches at the start of a string, :meth:`!start` will "
"always be zero.  However, the :meth:`~re.Pattern.search` method of patterns "
"scans through the string, so  the match may not start at zero in that "
"case. ::"
msgstr ""
":meth:`~re.Match.group` 方法會回傳由正則表達式匹配的子字串。:meth:`~re.Match."
"start` 和 :meth:`~re.Match.end` 方法分別回傳匹配開始和結束的索引，而 :meth:"
"`~re.Match.span` 會一次性回傳起始和結束位置。因為:meth:`~re.Pattern.match`方"
"法只是檢查 RE 是否從字符串開頭進行匹配，所以:meth:`!start` 總是等於零。但是，"
"在模式使用的:meth:`~re.Pattern.search`方法中，掃描整個字符串時匹配可能不從零"
"位置開始。 ::"

#: ../../howto/regex.rst:446
msgid ""
">>> print(p.match('::: message'))\n"
"None\n"
">>> m = p.search('::: message'); print(m)\n"
"<re.Match object; span=(4, 11), match='message'>\n"
">>> m.group()\n"
"'message'\n"
">>> m.span()\n"
"(4, 11)"
msgstr ""
">>> print(p.match('::: message'))\n"
"None\n"
">>> m = p.search('::: message'); print(m)\n"
"<re.Match object; span=(4, 11), match='message'>\n"
">>> m.group()\n"
"'message'\n"
">>> m.span()\n"
"(4, 11)"

#: ../../howto/regex.rst:455
#, fuzzy
msgid ""
"In actual programs, the most common style is to store the :ref:`match object "
"<match-objects>` in a variable, and then check if it was ``None``.  This "
"usually looks like::"
msgstr ""
"在實際的程式中，最常見的樣式是將 :ref:`match object <match-objects>` 存儲在一"
"個變量中，然後檢查它是否為 ``None``。通常看起來像這樣： ::"

#: ../../howto/regex.rst:459
msgid ""
"p = re.compile( ... )\n"
"m = p.match( 'string goes here' )\n"
"if m:\n"
"    print('Match found: ', m.group())\n"
"else:\n"
"    print('No match')"
msgstr ""
"p = re.compile( ... )\n"
"m = p.match( 'string goes here' )\n"
"if m:\n"
"    print('Match found: ', m.group())\n"
"else:\n"
"    print('No match')"

#: ../../howto/regex.rst:466
#, fuzzy
msgid ""
"Two pattern methods return all of the matches for a pattern. :meth:`~re."
"Pattern.findall` returns a list of matching strings::"
msgstr ""
"兩種模式方法可回傳符合樣式的所有結果。:meth:`~re.Pattern.findall` 回傳匹配字"
"串列表： ::"

#: ../../howto/regex.rst:469
msgid ""
">>> p = re.compile(r'\\d+')\n"
">>> p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')\n"
"['12', '11', '10']"
msgstr ""
">>> p = re.compile(r'\\d+')\n"
">>> p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')\n"
"['12', '11', '10']"

#: ../../howto/regex.rst:473
#, fuzzy
msgid ""
"The ``r`` prefix, making the literal a raw string literal, is needed in this "
"example because escape sequences in a normal \"cooked\" string literal that "
"are not recognized by Python, as opposed to regular expressions, now result "
"in a :exc:`DeprecationWarning` and will eventually become a :exc:"
"`SyntaxError`.  See :ref:`the-backslash-plague`."
msgstr ""
"在此例子中，必須使用``r``前綴來將字面值變成一個原始字串文字(r raw string "
"literal)，因為在正常的 \"cooked\" 字串文字中轉義字元如果不被Python識別（相較"
"於正則表達式），現在會產生 :exc:`DeprecationWarning` 錯誤訊息並最終成為 :exc:"
"`SyntaxError`. 觀看 :ref:`the-backslash-plague`."

#: ../../howto/regex.rst:479
#, fuzzy
msgid ""
":meth:`~re.Pattern.findall` has to create the entire list before it can be "
"returned as the result.  The :meth:`~re.Pattern.finditer` method returns a "
"sequence of :ref:`match object <match-objects>` instances as an :term:"
"`iterator`::"
msgstr ""
":meth:`~re.Pattern.findall` 方法必須在回傳結果之前先建立整個列表。:meth:`~re."
"Pattern.finditer`方法以疊代器的形式回傳一系列:ref:`match object <match-"
"objects>`實例： ::"

#: ../../howto/regex.rst:483
msgid ""
">>> iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')\n"
">>> iterator  \n"
"<callable_iterator object at 0x...>\n"
">>> for match in iterator:\n"
"...     print(match.span())\n"
"...\n"
"(0, 2)\n"
"(22, 24)\n"
"(29, 31)"
msgstr ""
">>> iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')\n"
">>> iterator  \n"
"<callable_iterator object at 0x...>\n"
">>> for match in iterator:\n"
"...     print(match.span())\n"
"...\n"
"(0, 2)\n"
"(22, 24)\n"
"(29, 31)"

#: ../../howto/regex.rst:495
#, fuzzy
msgid "Module-Level Functions"
msgstr "模組級函式"

#: ../../howto/regex.rst:497
#, fuzzy
msgid ""
"You don't have to create a pattern object and call its methods; the :mod:"
"`re` module also provides top-level functions called :func:`~re.match`, :"
"func:`~re.search`, :func:`~re.findall`, :func:`~re.sub`, and so forth.  "
"These functions take the same arguments as the corresponding pattern method "
"with the RE string added as the first argument, and still return either "
"``None`` or a :ref:`match object <match-objects>` instance. ::"
msgstr ""
"你不必建立一個模式對象並調用其方法；相應的 :mod:`re` 模組還提供了頂級函式，"
"如：:func:`~re.match`, :func:`~re.search`, :func:`~re.findall`, :func:`~re."
"sub`。這些函式與相應的模式方法具有相同的引數（以 RE 字串作為第一個引數），仍"
"然回傳 ``None`` 或者是匹配對象 (:ref:`match-objects`) 實例。 ::"

#: ../../howto/regex.rst:504
msgid ""
">>> print(re.match(r'From\\s+', 'Fromage amk'))\n"
"None\n"
">>> re.match(r'From\\s+', 'From amk Thu May 14 19:12:10 1998')  \n"
"<re.Match object; span=(0, 5), match='From '>"
msgstr ""
">>> print(re.match(r'From\\s+', 'Fromage amk'))\n"
"None\n"
">>> re.match(r'From\\s+', 'From amk Thu May 14 19:12:10 1998')  \n"
"<re.Match object; span=(0, 5), match='From '>"

#: ../../howto/regex.rst:509
#, fuzzy
msgid ""
"Under the hood, these functions simply create a pattern object for you and "
"call the appropriate method on it.  They also store the compiled object in a "
"cache, so future calls using the same RE won't need to parse the pattern "
"again and again."
msgstr ""
"在幕後，這些函式只是為你建立一個模式物件，並調用其適當的方法。它們還會將已編"
"譯的物件儲存在快取中，因此未來使用相同的正規表示式時不需要再次解析模式。"

#: ../../howto/regex.rst:514
#, fuzzy
msgid ""
"Should you use these module-level functions, or should you get the pattern "
"and call its methods yourself?  If you're accessing a regex within a loop, "
"pre-compiling it will save a few function calls. Outside of loops, there's "
"not much difference thanks to the internal cache."
msgstr ""
"如果你正在迴圈中存取正規表示式，事前編譯可以減少一些函式呼叫。在迴圈外部由於"
"內部快取的原因，使用這些模組級別函式和直接調用它的方法沒有太大區別。"

#: ../../howto/regex.rst:522
msgid "Compilation Flags"
msgstr "編譯旗標"

#: ../../howto/regex.rst:526
#, fuzzy
msgid ""
"Compilation flags let you modify some aspects of how regular expressions "
"work. Flags are available in the :mod:`re` module under two names, a long "
"name such as :const:`IGNORECASE` and a short, one-letter form such as :const:"
"`I`.  (If you're familiar with Perl's pattern modifiers, the one-letter "
"forms use the same letters; the short form of :const:`re.VERBOSE` is :const:"
"`re.X`, for example.) Multiple flags can be specified by bitwise OR-ing "
"them; ``re.I | re.M`` sets both the :const:`I` and :const:`M` flags, for "
"example."
msgstr ""
"編譯旗標可讓你修改正規表示式運作方式的某些方面。旗標在 re 模組中有兩個名稱，"
"一個是長名稱，例如 IGNORECASE，另一個是短的單字母形式，例如 I。 （如果你熟悉 "
"Perl 的模式修飾符，單字母形式使用相同的字母；例如，:const:`re.VERBOSE` 的縮寫"
"形式是 :const:`re.X`。）多個旗標可以透過按位或對它們進行指定； ``re.I |例"
"如， re.M`` 設定 :const:`I` 和 :const:`M` 旗標。"

#: ../../howto/regex.rst:534
#, fuzzy
msgid ""
"Here's a table of the available flags, followed by a more detailed "
"explanation of each one."
msgstr "下表列出了可用的旗標，接下來是每個旗標的更詳細說明。"

#: ../../howto/regex.rst:538
msgid "Flag"
msgstr "旗標"

#: ../../howto/regex.rst:538
msgid "Meaning"
msgstr "含義"

#: ../../howto/regex.rst:540
msgid ":const:`ASCII`, :const:`A`"
msgstr ":const:`ASCII`、:const:`A`"

#: ../../howto/regex.rst:540
#, fuzzy
msgid ""
"Makes several escapes like ``\\w``, ``\\b``, ``\\s`` and ``\\d`` match only "
"on ASCII characters with the respective property."
msgstr ""
"會使 ``\\w``、``\\b``、``\\s`` 和 ``\\d`` 這幾種跳脫字元，只能匹配 ASCII 字符"
"上該屬性的對應值。"

#: ../../howto/regex.rst:544
msgid ":const:`DOTALL`, :const:`S`"
msgstr ":const:`DOTALL`、:const:`S`"

#: ../../howto/regex.rst:544
msgid "Make ``.`` match any character, including newlines."
msgstr "讓 ``.`` 匹配任何字元，包括換行符號。"

#: ../../howto/regex.rst:547
msgid ":const:`IGNORECASE`, :const:`I`"
msgstr ":const:`IGNORECASE`、:const:`I`"

#: ../../howto/regex.rst:547
#, fuzzy
msgid "Do case-insensitive matches."
msgstr "進行不分大小寫的比對。"

#: ../../howto/regex.rst:549
msgid ":const:`LOCALE`, :const:`L`"
msgstr ":const:`LOCALE`、:const:`L`"

#: ../../howto/regex.rst:549
#, fuzzy
msgid "Do a locale-aware match."
msgstr "進行區域敏感字串比對。"

#: ../../howto/regex.rst:551
msgid ":const:`MULTILINE`, :const:`M`"
msgstr ":const:`MULTILINE`、:const:`M`"

#: ../../howto/regex.rst:551
msgid "Multi-line matching, affecting ``^`` and ``$``."
msgstr "多行匹配，會影響到 ``^`` 和 ``$``。"

#: ../../howto/regex.rst:554
#, fuzzy
msgid ":const:`VERBOSE`, :const:`X` (for 'extended')"
msgstr "`:const:`VERBOSE`、:const:`X`（代表 'extended'）"

#: ../../howto/regex.rst:554
#, fuzzy
msgid ""
"Enable verbose REs, which can be organized more cleanly and understandably."
msgstr "啟用語意清晰且易於整理的冗長正規表示式（verbose REs）。"

#: ../../howto/regex.rst:563
#, fuzzy
msgid ""
"Perform case-insensitive matching; character class and literal strings will "
"match letters by ignoring case.  For example, ``[A-Z]`` will match lowercase "
"letters, too. Full Unicode matching also works unless the :const:`ASCII` "
"flag is used to disable non-ASCII matches.  When the Unicode patterns ``[a-"
"z]`` or ``[A-Z]`` are used in combination with the :const:`IGNORECASE` flag, "
"they will match the 52 ASCII letters and 4 additional non-ASCII letters: 'İ' "
"(U+0130, Latin capital letter I with dot above), 'ı' (U+0131, Latin small "
"letter dotless i), 'ſ' (U+017F, Latin small letter long s) and 'K' (U+212A, "
"Kelvin sign).  ``Spam`` will match ``'Spam'``, ``'spam'``, ``'spAM'``, or "
"``'ſpam'`` (the latter is matched only in Unicode mode). This lowercasing "
"doesn't take the current locale into account; it will if you also set the :"
"const:`LOCALE` flag."
msgstr ""
"執行不分大小寫比對；字元類別和直接字串會忽略大小寫來比對，舉例來說，``[A-Z]``"
"可以找到小寫字母。如果沒使用 :const:`ASCII` 旗標禁用非 ASCII 匹配的話，完整"
"的 Unicode 比對也是有效的。而當 Unicode 的模式 ``[a-z]`` 或 ``[A-Z]`` 與 :"
"const:`IGNORECASE` 旗標一起使用時，它們會匹配52個 ASCII 字母以及另外4個非 "
"ASCII 字母: 'İ' (U+0130, 土耳其大寫點I)，'ı' (U+0131, 土耳其小寫無點"
"i)，'ſ' (U+017F, Latin small letter long s) 和 'K' (U+212A, Kelvin "
"sign)。\"Spam\" 可以被匹配為 ``'Spam'``, ``"

#: ../../howto/regex.rst:581
#, fuzzy
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale instead of the Unicode database."
msgstr ""
"將 ``\\w``、``\\W``、``\\b``、``\\B`` 和不區分大小寫的比對方式改為依賴於當前"
"語系 (locale) 而非 Unicode 資料庫。"

#: ../../howto/regex.rst:584
#, fuzzy
msgid ""
"Locales are a feature of the C library intended to help in writing programs "
"that take account of language differences.  For example, if you're "
"processing encoded French text, you'd want to be able to write ``\\w+`` to "
"match words, but ``\\w`` only matches the character class ``[A-Za-z]`` in "
"bytes patterns; it won't match bytes corresponding to ``é`` or ``ç``. If "
"your system is configured properly and a French locale is selected, certain "
"C functions will tell the program that the byte corresponding to ``é`` "
"should also be considered a letter. Setting the :const:`LOCALE` flag when "
"compiling a regular expression will cause the resulting compiled object to "
"use these C functions for ``\\w``; this is slower, but also enables ``\\w+`` "
"to match French words as you'd expect. The use of this flag is discouraged "
"in Python 3 as the locale mechanism is very unreliable, it only handles one "
"\"culture\" at a time, and it only works with 8-bit locales.  Unicode "
"matching is already enabled by default in Python 3 for Unicode (str) "
"patterns, and it is able to handle different locales/languages."
msgstr ""
"區域設定是 C 函式庫的一項功能，旨在幫助編寫考慮語言差異的程式。例如，如果你正"
"在處理編碼的法語文本，你希望能夠編寫 ``\\w+`` 來匹配單詞，但 ``\\w`` 只匹配字"
"元類 ``[A-Za- z]`` 以位元組模式表示；它不會匹配對應於 ``é`` 或 ``ç`` 的位元"
"組。如果你的系統配置正確並且選擇了法語語言環境，某些 C 函式將告訴程式與「é」"
"對應的位元組也應該被視為字母。在編譯正規表示式時設定 LOCALE 旗標將導致產生的"
"編譯物件將這些 C 函式用於 ``\\w``；這速度較慢，但也使 ``\\w+`` 能夠按照你的預"
"期匹配法語單字。在 Python 3 中不鼓勵使用此旗標，因為區域設定機制非常不可靠，"
"它一次只能處理一種“區域性”，並且僅適用於 8 位元區域設定。 Python 3 中已預設啟"
"用 Unicode 匹配（str）模式，並且它能夠處理不同的區域設定/語言。"

#: ../../howto/regex.rst:606
#, fuzzy
msgid ""
"(``^`` and ``$`` haven't been explained yet;  they'll be introduced in "
"section :ref:`more-metacharacters`.)"
msgstr ""
"（``^`` 和 ``$`` 尚未解釋，接下來將在 :ref:`more-metacharacters` 章節中介"
"紹。)"

#: ../../howto/regex.rst:609
#, fuzzy
msgid ""
"Usually ``^`` matches only at the beginning of the string, and ``$`` matches "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string. When this flag is specified, ``^`` matches at the "
"beginning of the string and at the beginning of each line within the string, "
"immediately following each newline.  Similarly, the ``$`` metacharacter "
"matches either at the end of the string and at the end of each line "
"(immediately preceding each newline)."
msgstr ""
"通常 ``^`` 會只比對字串一開始出現的位置，而 ``$`` 則會只比對字串結束和行末 "
"(如果有) 的位置。若指定此旗標時，``^`` 不僅僅會比對字串開頭，也會在每個換行符"
"號之後立即與下一行的內容做比對。同理地，元字符 ``$`` 已可匹配到字符串或每行"
"(BOL 或 EOL) 的结尾（EOL 前一个任意且必须是换行符）。"

#: ../../howto/regex.rst:622
#, fuzzy
msgid ""
"Makes the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"開啟 ``'.'`` 特殊字元，可匹配任何字符，包括換行；否則，``'.'`` 會匹配除了換行"
"之外的其它所有字符。"

#: ../../howto/regex.rst:630
#, fuzzy
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` perform ASCII-"
"only matching instead of full Unicode matching. This is only meaningful for "
"Unicode patterns, and is ignored for byte patterns."
msgstr ""
"讓 ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` 和 ``\\S`` 僅進行 ASCII 字元的"
"比對，而非全字串 Unicode 範圍比對。此設置只在使用 Unicode 的情況下有效，且不"
"用於位元組型別式。"

#: ../../howto/regex.rst:639
#, fuzzy
msgid ""
"This flag allows you to write regular expressions that are more readable by "
"granting you more flexibility in how you can format them.  When this flag "
"has been specified, whitespace within the RE string is ignored, except when "
"the whitespace is in a character class or preceded by an unescaped "
"backslash; this lets you organize and indent the RE more clearly.  This flag "
"also lets you put comments within a RE that will be ignored by the engine; "
"comments are marked by a ``'#'`` that's neither in a character class or "
"preceded by an unescaped backslash."
msgstr ""
"這個旗標讓你更自由地編排和縮排正規表示式，使其更易讀。當設定此旗標後，除非空"
"格在字元類別 (class) 中或是沒有轉移符 (escape character) 時否則都會被忽略。這"
"能夠幫助你更清晰地整理和縮進正規表示式的內容。同時，它也允許你在 RE 中添加被"
"引擎忽略的註解；只要以 ``'#'`` 開頭即可（不包括那些位於字元類別或前面已脫逸過"
"的）。"

#: ../../howto/regex.rst:648
#, fuzzy
msgid ""
"For example, here's a RE that uses :const:`re.VERBOSE`; see how much easier "
"it is to read? ::"
msgstr ""
"舉例來說，這是一個使用 :const:`re.VERBOSE` 的正規表示式；看起來容易閱讀許多了"
"吧？ ::"

#: ../../howto/regex.rst:651
msgid ""
"charref = re.compile(r\"\"\"\n"
" &[#]                # Start of a numeric entity reference\n"
" (\n"
"     0[0-7]+         # Octal form\n"
"   | [0-9]+          # Decimal form\n"
"   | x[0-9a-fA-F]+   # Hexadecimal form\n"
" )\n"
" ;                   # Trailing semicolon\n"
"\"\"\", re.VERBOSE)"
msgstr ""

#: ../../howto/regex.rst:661
#, fuzzy
msgid "Without the verbose setting, the RE would look like this::"
msgstr "如果不啟用冗長模式，正規表示式會長這樣： ::"

#: ../../howto/regex.rst:663
msgid ""
"charref = re.compile(\"&#(0[0-7]+\"\n"
"                     \"|[0-9]+\"\n"
"                     \"|x[0-9a-fA-F]+);\")"
msgstr ""
"charref = re.compile(\"&#(0[0-7]+\"\n"
"                     \"|[0-9]+\"\n"
"                     \"|x[0-9a-fA-F]+);\")"

#: ../../howto/regex.rst:667
#, fuzzy
msgid ""
"In the above example, Python's automatic concatenation of string literals "
"has been used to break up the RE into smaller pieces, but it's still more "
"difficult to understand than the version using :const:`re.VERBOSE`."
msgstr ""
"在上述例子中，Python 的自動字串連接功能被用來將正規表示式 (RE) 拆成較小的片"
"段，但仍比使用 :const:`re.VERBOSE` 更難理解。"

#: ../../howto/regex.rst:673
#, fuzzy
msgid "More Pattern Power"
msgstr "更強大的模式綜合利用"

#: ../../howto/regex.rst:675
#, fuzzy
msgid ""
"So far we've only covered a part of the features of regular expressions.  In "
"this section, we'll cover some new metacharacters, and how to use groups to "
"retrieve portions of the text that was matched."
msgstr ""
"迄今為止，我們只涵蓋了正規表示式部分功能。在本節中，我們將介紹一些新的元字符"
"和如何使用群組檢索匹配文本的部分。"

#: ../../howto/regex.rst:683
#, fuzzy
msgid "More Metacharacters"
msgstr "更多元字符"

#: ../../howto/regex.rst:685
#, fuzzy
msgid ""
"There are some metacharacters that we haven't covered yet.  Most of them "
"will be covered in this section."
msgstr "本節將介紹一些我們還沒有涉及的元字符。其中大部分會在本節中詳加說明。"

#: ../../howto/regex.rst:688
#, fuzzy
msgid ""
"Some of the remaining metacharacters to be discussed are :dfn:`zero-width "
"assertions`.  They don't cause the engine to advance through the string; "
"instead, they consume no characters at all, and simply succeed or fail.  For "
"example, ``\\b`` is an assertion that the current position is located at a "
"word boundary; the position isn't changed by the ``\\b`` at all.  This means "
"that zero-width assertions should never be repeated, because if they match "
"once at a given location, they can obviously be matched an infinite number "
"of times."
msgstr ""
"還有一些其它的元字符待討論，稱為「零寬斷言(zero-width assertions)」。它們並不"
"會使引擎在字串中前進；取而代之的是，它們根本沒有消耗任何字元，僅是成功或失"
"敗。例如，``\\b`` 表示當前位置位於單詞邊界上；該位置完全未被 ``\\b`` 所改變。"
"因此，絕不能重複使用零寬斷言，因為如果在某個位置匹配一次，顯然可以無限次地匹"
"配。"

#: ../../howto/regex.rst:696
msgid "``|``"
msgstr "``|``"

#: ../../howto/regex.rst:697
#, fuzzy
msgid ""
"Alternation, or the \"or\" operator.   If *A* and *B* are regular "
"expressions, ``A|B`` will match any string that matches either *A* or *B*. "
"``|`` has very low precedence in order to make it work reasonably when "
"you're alternating multi-character strings. ``Crow|Servo`` will match either "
"``'Crow'`` or ``'Servo'``, not ``'Cro'``, a ``'w'`` or an ``'S'``, and "
"``'ervo'``."
msgstr ""
"交替，或 \"or\" 運算子。如果 *A* 和 *B* 是正規表示式，則 ``A|B`` 將符合任何"
"與 *A* 或 *B* 相符的字串。``|`` 的優先順序非常低，以便在交替多字元字串時使其"
"正常工作。``Crow|Servo`` 將匹配 ``'Crow'`` 或 ``'Servo'``，而不是 ``'Cro'``、"
"``'w'`` 或 ``'S'`` 和 ``'ervo'``。"

#: ../../howto/regex.rst:703
#, fuzzy
msgid ""
"To match a literal ``'|'``, use ``\\|``, or enclose it inside a character "
"class, as in ``[|]``."
msgstr ""
"要匹配文字中的 ``'|'``，可以使用反斜線加上符號 ``\\|``，或是將它放入字元組"
"中，例如 ``[|]``。"

#: ../../howto/regex.rst:706
msgid "``^``"
msgstr "``^``"

#: ../../howto/regex.rst:707
#, fuzzy
msgid ""
"Matches at the beginning of lines.  Unless the :const:`MULTILINE` flag has "
"been set, this will only match at the beginning of the string.  In :const:"
"`MULTILINE` mode, this also matches immediately after each newline within "
"the string."
msgstr ""
"從每一行的開頭開始找尋符合的內容。除非設定了 :const:`MULTILINE` 旗標，否則只"
"會在字串開頭進行匹配。在 :const:`MULTILINE` 狀態下，也會立即經過字串中每個換"
"行符號後進行匹配。"

#: ../../howto/regex.rst:711
#, fuzzy
msgid ""
"For example, if you wish to match the word ``From`` only at the beginning of "
"a line, the RE to use is ``^From``. ::"
msgstr ""
"例如，如果你希望只在行首匹配單詞 ``From``，要使用的正則表達式是 "
"``^From``。 ::"

#: ../../howto/regex.rst:714
msgid ""
">>> print(re.search('^From', 'From Here to Eternity'))  \n"
"<re.Match object; span=(0, 4), match='From'>\n"
">>> print(re.search('^From', 'Reciting From Memory'))\n"
"None"
msgstr ""
">>> print(re.search('^From', 'From Here to Eternity'))  \n"
"<re.Match object; span=(0, 4), match='From'>\n"
">>> print(re.search('^From', 'Reciting From Memory'))\n"
"None"

#: ../../howto/regex.rst:719
#, fuzzy
msgid "To match a literal ``'^'``, use ``\\^``."
msgstr "為了符合文字字面上的 ``'^'``，使用反斜線來表示，因此表達成 ``\\^``。"

#: ../../howto/regex.rst:721
msgid "``$``"
msgstr "``$``"

#: ../../howto/regex.rst:722
#, fuzzy
msgid ""
"Matches at the end of a line, which is defined as either the end of the "
"string, or any location followed by a newline character.     ::"
msgstr ""
"與一行的結尾匹配，其定義為字串的結尾或是接在換行符號之後的任何位置。(注意：句"
"中符號應保留 rst 格式)。 ::"

#: ../../howto/regex.rst:725
msgid ""
">>> print(re.search('}$', '{block}'))  \n"
"<re.Match object; span=(6, 7), match='}'>\n"
">>> print(re.search('}$', '{block} '))\n"
"None\n"
">>> print(re.search('}$', '{block}\\n'))  \n"
"<re.Match object; span=(6, 7), match='}'>"
msgstr ""
">>> print(re.search('}$', '{block}'))  \n"
"<re.Match object; span=(6, 7), match='}'>\n"
">>> print(re.search('}$', '{block} '))\n"
"None\n"
">>> print(re.search('}$', '{block}\\n'))  \n"
"<re.Match object; span=(6, 7), match='}'>"

#: ../../howto/regex.rst:732
#, fuzzy
msgid ""
"To match a literal ``'$'``, use ``\\$`` or enclose it inside a character "
"class, as in  ``[$]``."
msgstr ""
"為了匹配字面上的 ``'$'``，請使用 ``\\$`` 或將其包含在字符類中，例如 ``[$]``。"

#: ../../howto/regex.rst:735
msgid "``\\A``"
msgstr "``\\A``"

#: ../../howto/regex.rst:736
#, fuzzy
msgid ""
"Matches only at the start of the string.  When not in :const:`MULTILINE` "
"mode, ``\\A`` and ``^`` are effectively the same.  In :const:`MULTILINE` "
"mode, they're different: ``\\A`` still matches only at the beginning of the "
"string, but ``^`` may match at any location inside the string that follows a "
"newline character."
msgstr ""
"僅能在字串的開頭進行匹配。若未啟用 :const:`MULTILINE` 模式，``\\A`` 與 ``^`` "
"其實表示相同意義；然而，在 :const:`MULTILINE` 模式下，它們有所不同：``\\A`` "
"仍舊只會匹配到字串的起始位置，但是 ``^`` 則可以透過換行符後面的任何位置進行匹"
"配。"

#: ../../howto/regex.rst:741
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../howto/regex.rst:742
#, fuzzy
msgid "Matches only at the end of the string."
msgstr "僅在字串結尾進行匹配。"

#: ../../howto/regex.rst:744
msgid "``\\b``"
msgstr "``\\b``"

#: ../../howto/regex.rst:745
#, fuzzy
msgid ""
"Word boundary.  This is a zero-width assertion that matches only at the "
"beginning or end of a word.  A word is defined as a sequence of alphanumeric "
"characters, so the end of a word is indicated by whitespace or a non-"
"alphanumeric character."
msgstr ""
"單字邊界，是一個零寬度的斷言，只會在單詞的開頭或結尾符合。單字指由英文字母和"
"阿拉伯數字所構成的序列，因此單詞的結尾必定以空格或非英數字符號來表示。"

#: ../../howto/regex.rst:750
#, fuzzy
msgid ""
"The following example matches ``class`` only when it's a complete word; it "
"won't match when it's contained inside another word. ::"
msgstr ""
"以下範例只會比對 ``class`` 是否為一個完整的單字，當它包含在其他單字中時則不會"
"比對到。 ::"

#: ../../howto/regex.rst:753
msgid ""
">>> p = re.compile(r'\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"<re.Match object; span=(3, 8), match='class'>\n"
">>> print(p.search('the declassified algorithm'))\n"
"None\n"
">>> print(p.search('one subclass is'))\n"
"None"
msgstr ""
">>> p = re.compile(r'\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"<re.Match object; span=(3, 8), match='class'>\n"
">>> print(p.search('the declassified algorithm'))\n"
"None\n"
">>> print(p.search('one subclass is'))\n"
"None"

#: ../../howto/regex.rst:761
#, fuzzy
msgid ""
"There are two subtleties you should remember when using this special "
"sequence. First, this is the worst collision between Python's string "
"literals and regular expression sequences.  In Python's string literals, "
"``\\b`` is the backspace character, ASCII value 8.  If you're not using raw "
"strings, then Python will convert the ``\\b`` to a backspace, and your RE "
"won't match as you expect it to. The following example looks the same as our "
"previous RE, but omits the ``'r'`` in front of the RE string. ::"
msgstr ""
"當你使用這個特殊序列時，請注意兩點細節。首先，這是 Python 字符串字面值和正則"
"表達式序列之間最嚴重的衝突。在 Python 字符串字面值中，``\\b`` 是回退字符"
"（ASCII 值為 8）。如果你沒有使用原始字符串，那麼 Python 會將 ``\\b`` 轉換為回"
"退鍵，而你的正則表達式不會按預期匹配。以下實例看起來與我們之前的 RE 相同，但"
"省略了 RE 字符串前面的 ``'r'``。 ::"

#: ../../howto/regex.rst:769
msgid ""
">>> p = re.compile('\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"None\n"
">>> print(p.search('\\b' + 'class' + '\\b'))\n"
"<re.Match object; span=(0, 7), match='\\x08class\\x08'>"
msgstr ""
">>> p = re.compile('\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"None\n"
">>> print(p.search('\\b' + 'class' + '\\b'))\n"
"<re.Match object; span=(0, 7), match='\\x08class\\x08'>"

#: ../../howto/regex.rst:775
#, fuzzy
msgid ""
"Second, inside a character class, where there's no use for this assertion, "
"``\\b`` represents the backspace character, for compatibility with Python's "
"string literals."
msgstr ""
"第二點，在字元類別中，如果不需要這個斷言，``\\b`` 代表的是消除符號"
"（backspace），為了與 Python 的字串表示法相容。"

#: ../../howto/regex.rst:779
msgid "``\\B``"
msgstr "``\\B``"

#: ../../howto/regex.rst:780
#, fuzzy
msgid ""
"Another zero-width assertion, this is the opposite of ``\\b``, only matching "
"when the current position is not at a word boundary."
msgstr ""
"另一個零寬斷言，這是 ``\\b`` 的相反，僅在當前位置不位於單字邊界時匹配。"

#: ../../howto/regex.rst:785
#, fuzzy
msgid "Grouping"
msgstr "群組化"

#: ../../howto/regex.rst:787
#, fuzzy
msgid ""
"Frequently you need to obtain more information than just whether the RE "
"matched or not.  Regular expressions are often used to dissect strings by "
"writing a RE divided into several subgroups which match different components "
"of interest. For example, an RFC-822 header line is divided into a header "
"name and a value, separated by a ``':'``, like this:"
msgstr ""
"常常需要取得比僅僅判斷正規表示式是否符合的更多資訊。經常用來剖析字串的方式是"
"撰寫一個正規表示式，其中包含許多子組，可以匹配各種不同的所需元素。例如，"
"RFC-822 標頭行可分成一個標頭名稱和一個值，由冒號 ``':'`` 分隔開來︰"

#: ../../howto/regex.rst:793
msgid ""
"From: author@example.com\n"
"User-Agent: Thunderbird 1.5.0.9 (X11/20061227)\n"
"MIME-Version: 1.0\n"
"To: editor@example.com"
msgstr ""
"From: author@example.com\n"
"User-Agent: Thunderbird 1.5.0.9 (X11/20061227)\n"
"MIME-Version: 1.0\n"
"To: editor@example.com"

#: ../../howto/regex.rst:800
#, fuzzy
msgid ""
"This can be handled by writing a regular expression which matches an entire "
"header line, and has one group which matches the header name, and another "
"group which matches the header's value."
msgstr ""
"這可以透過匹配整個標頭行的正規表示式來處理，其中有一個群組匹配標頭名稱，另一"
"個群組匹配標頭值。"

#: ../../howto/regex.rst:804
#, fuzzy
msgid ""
"Groups are marked by the ``'('``, ``')'`` metacharacters. ``'('`` and "
"``')'`` have much the same meaning as they do in mathematical expressions; "
"they group together the expressions contained inside them, and you can "
"repeat the contents of a group with a quantifier, such as ``*``, ``+``, ``?"
"``, or ``{m,n}``.  For example, ``(ab)*`` will match zero or more "
"repetitions of ``ab``. ::"
msgstr ""
"群組由 ``'('`` 和 ``')'`` 元字符標記。在數學表達式中，``'('`` 和 ``')'`` 具有"
"大致相同的含義； 它們將其中包含的表達式分組在一起，可以使用量詞（如 ``*``, "
"``+``, ``?`` 或 ``{m,n}``\\ ）重複群組內容。例如，``(ab)*`` 可以匹配零個或多"
"個 ``ab``。 ::"

#: ../../howto/regex.rst:811
msgid ""
">>> p = re.compile('(ab)*')\n"
">>> print(p.match('ababababab').span())\n"
"(0, 10)"
msgstr ""
">>> p = re.compile('(ab)*')\n"
">>> print(p.match('ababababab').span())\n"
"(0, 10)"

#: ../../howto/regex.rst:815
#, fuzzy
msgid ""
"Groups indicated with ``'('``, ``')'`` also capture the starting and ending "
"index of the text that they match; this can be retrieved by passing an "
"argument to :meth:`~re.Match.group`, :meth:`~re.Match.start`, :meth:`~re."
"Match.end`, and :meth:`~re.Match.span`.  Groups are numbered starting with "
"0.  Group 0 is always present; it's the whole RE, so :ref:`match object "
"<match-objects>` methods all have group 0 as their default argument.  Later "
"we'll see how to express groups that don't capture the span of text that "
"they match. ::"
msgstr ""
"有括弧主分組 ``'('``, ``')'`` 捕捉了匹配文本的開始與結束索引，可透過向 :meth:"
"`~re.Match.group`、:meth:`~re.Match.start`、:meth:`~re.Match.end` 和:meth:"
"`~re.Match.span` 中傳入參數獲取此訊息。主分組以 0 開始編號，因此第一個是 0，"
"代表整個正規表示式(RE)，所以當透過 :ref:`match object <match-objects>` 方法時"
"預設值皆會回傳主分組 0。後續我們也會看到如何表示不包含其匹配範圍但需要群聚化"
"的案例。 ::"

#: ../../howto/regex.rst:824
msgid ""
">>> p = re.compile('(a)b')\n"
">>> m = p.match('ab')\n"
">>> m.group()\n"
"'ab'\n"
">>> m.group(0)\n"
"'ab'"
msgstr ""
">>> p = re.compile('(a)b')\n"
">>> m = p.match('ab')\n"
">>> m.group()\n"
"'ab'\n"
">>> m.group(0)\n"
"'ab'"

#: ../../howto/regex.rst:831
#, fuzzy
msgid ""
"Subgroups are numbered from left to right, from 1 upward.  Groups can be "
"nested; to determine the number, just count the opening parenthesis "
"characters, going from left to right. ::"
msgstr ""
"子群組自左而右，由1開始進行編號。此外，群組還可以嵌套；想要確定嵌套數量時，只"
"需要從左至右計算開啟括號的個數即可。 ::"

#: ../../howto/regex.rst:835
msgid ""
">>> p = re.compile('(a(b)c)d')\n"
">>> m = p.match('abcd')\n"
">>> m.group(0)\n"
"'abcd'\n"
">>> m.group(1)\n"
"'abc'\n"
">>> m.group(2)\n"
"'b'"
msgstr ""
">>> p = re.compile('(a(b)c)d')\n"
">>> m = p.match('abcd')\n"
">>> m.group(0)\n"
"'abcd'\n"
">>> m.group(1)\n"
"'abc'\n"
">>> m.group(2)\n"
"'b'"

#: ../../howto/regex.rst:844
#, fuzzy
msgid ""
":meth:`~re.Match.group` can be passed multiple group numbers at a time, in "
"which case it will return a tuple containing the corresponding values for "
"those groups. ::"
msgstr ""
":meth:`~re.Match.group` 可以同時傳入多個群組編號，這樣它會回傳包含這些群組對"
"應數值的元组。 ::"

#: ../../howto/regex.rst:847
msgid ""
">>> m.group(2,1,2)\n"
"('b', 'abc', 'b')"
msgstr ""
">>> m.group(2,1,2)\n"
"('b', 'abc', 'b')"

#: ../../howto/regex.rst:850
#, fuzzy
msgid ""
"The :meth:`~re.Match.groups` method returns a tuple containing the strings "
"for all the subgroups, from 1 up to however many there are. ::"
msgstr ""
":meth:`~re.Match.groups` 方法會回傳一個元組（tuple），裡面包含所有子群組"
"（subgroups）所對應的字串，從 1 到數量上限不等。 ::"

#: ../../howto/regex.rst:853
msgid ""
">>> m.groups()\n"
"('abc', 'b')"
msgstr ""
">>> m.groups()\n"
"('abc', 'b')"

#: ../../howto/regex.rst:856
#, fuzzy
msgid ""
"Backreferences in a pattern allow you to specify that the contents of an "
"earlier capturing group must also be found at the current location in the "
"string.  For example, ``\\1`` will succeed if the exact contents of group 1 "
"can be found at the current position, and fails otherwise.  Remember that "
"Python's string literals also use a backslash followed by numbers to allow "
"including arbitrary characters in a string, so be sure to use a raw string "
"when incorporating backreferences in a RE."
msgstr ""
"在模式中使用回溯參照可讓你指定早期捕獲組的內容必須在字串的當前位置也存在。例"
"如，若精確內容與第一個群組相符合，則 ``\\1`` 將會成功；反之失敗。請記得 "
"Python 字串面值也使用反斜槓後接數字來包含任意字元，因此在正規表示式 (RE) 中嵌"
"入回溯參照時要用原始字串表達法（raw string）。"

#: ../../howto/regex.rst:864
#, fuzzy
msgid "For example, the following RE detects doubled words in a string. ::"
msgstr "例如，以下的正規表示式可以在一個字串中偵測出重複的單詞。 ::"

#: ../../howto/regex.rst:866
msgid ""
">>> p = re.compile(r'\\b(\\w+)\\s+\\1\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"
msgstr ""
">>> p = re.compile(r'\\b(\\w+)\\s+\\1\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"

#: ../../howto/regex.rst:870
#, fuzzy
msgid ""
"Backreferences like this aren't often useful for just searching through a "
"string --- there are few text formats which repeat data in this way --- but "
"you'll soon find out that they're *very* useful when performing string "
"substitutions."
msgstr ""
"像這樣的反向參照通常對於只是搜尋字串來說並不常用 --- 很少有文字格式會以此方式"
"重複數據 --- 但當你執行字串取代時，就很快發現它們*非常*有用。"

#: ../../howto/regex.rst:876
#, fuzzy
msgid "Non-capturing and Named Groups"
msgstr "非捕獲和命名群組"

#: ../../howto/regex.rst:878
#, fuzzy
msgid ""
"Elaborate REs may use many groups, both to capture substrings of interest, "
"and to group and structure the RE itself.  In complex REs, it becomes "
"difficult to keep track of the group numbers.  There are two features which "
"help with this problem.  Both of them use a common syntax for regular "
"expression extensions, so we'll look at that first."
msgstr ""
"複雜的正規表示式（RE）可能會使用許多群組，既用於捕獲感興趣的子串，又用於分組"
"和結構化 RE 本身。在複雜的 RE 中，很難跟踪群號碼。有兩個功能可以幫助解決這個"
"問題。它們都使用常見的正則表達式擴展語法來實現，因此我們首先看一下這種形式。"

#: ../../howto/regex.rst:884
#, fuzzy
msgid ""
"Perl 5 is well known for its powerful additions to standard regular "
"expressions. For these new features the Perl developers couldn't choose new "
"single-keystroke metacharacters or new special sequences beginning with "
"``\\`` without making Perl's regular expressions confusingly different from "
"standard REs.  If they chose ``&`` as a new metacharacter, for example, old "
"expressions would be assuming that ``&`` was a regular character and "
"wouldn't have escaped it by writing ``\\&`` or ``[&]``."
msgstr ""
"Perl 5 因其對於常規表示式（regular expressions）的強大增強而聞名。為了支援這"
"些新特性，Perl 的開發者不能選擇使用單一的按鍵元字符或以 ``\\`` 開頭的新特殊序"
"列，否則會使 Perl 的正規表示式與標準 REs 形成混亂不同之處。例如他們若選擇 & "
"作為一個新元字符，老表達式就可能誤以為 & 是正常字元並沒有透過組合 ``\\&`` 或 "
"``[&]`` 來跳脫它。"

#: ../../howto/regex.rst:891
#, fuzzy
msgid ""
"The solution chosen by the Perl developers was to use ``(?...)`` as the "
"extension syntax.  ``?`` immediately after a parenthesis was a syntax error "
"because the ``?`` would have nothing to repeat, so this didn't introduce any "
"compatibility problems.  The characters immediately after the ``?``  "
"indicate what extension is being used, so ``(?=foo)`` is one thing (a "
"positive lookahead assertion) and ``(?:foo)`` is something else (a non-"
"capturing group containing the subexpression ``foo``)."
msgstr ""
"Perl 開發人員所選擇的方法是使用 ``(?...)`` 作為擴展語法，直接在括號後面加上 "
"``?`` 是語法錯誤，因為 ``?`` 無事可做，故此不會引入任何相容性問題。而 ``?`` "
"後面的字元指出正使用何種擴充功能，因此 ``(?=foo)`` 是一種東西（肯定先行斷"
"言），而 ``(?:foo)`` 則是另一種東西（非捕獲式群組中包含子表達式「foo」）。"

#: ../../howto/regex.rst:899
#, fuzzy
msgid ""
"Python supports several of Perl's extensions and adds an extension syntax to "
"Perl's extension syntax.  If the first character after the question mark is "
"a ``P``, you know that it's an extension that's specific to Python."
msgstr ""
"Python 支援 Perl 的數個擴展，並在其基礎上加入了一種撰寫擴展的語法。如果問號後"
"的首字為 ``P``，表示它是 Python 專屬的擴展。"

#: ../../howto/regex.rst:904
#, fuzzy
msgid ""
"Now that we've looked at the general extension syntax, we can return to the "
"features that simplify working with groups in complex REs."
msgstr ""
"現在我們已經看過一般擴展語法，接著可以回到簡化處理包含多個群組的正規表示式所"
"需特性。"

#: ../../howto/regex.rst:907
#, fuzzy
msgid ""
"Sometimes you'll want to use a group to denote a part of a regular "
"expression, but aren't interested in retrieving the group's contents. You "
"can make this fact explicit by using a non-capturing group: ``(?:...)``, "
"where you can replace the ``...`` with any other regular expression. ::"
msgstr ""
"有時你會想用群組來表達正規表示式的一部分，但卻不需要加以擷取。你可以使用非捕"
"獲性群組 ``(?:...)``，在其中可填上任何其他的正規表示式。 ::"

#: ../../howto/regex.rst:912
msgid ""
">>> m = re.match(\"([abc])+\", \"abc\")\n"
">>> m.groups()\n"
"('c',)\n"
">>> m = re.match(\"(?:[abc])+\", \"abc\")\n"
">>> m.groups()\n"
"()"
msgstr ""
">>> m = re.match(\"([abc])+\", \"abc\")\n"
">>> m.groups()\n"
"('c',)\n"
">>> m = re.match(\"(?:[abc])+\", \"abc\")\n"
">>> m.groups()\n"
"()"

#: ../../howto/regex.rst:919
#, fuzzy
msgid ""
"Except for the fact that you can't retrieve the contents of what the group "
"matched, a non-capturing group behaves exactly the same as a capturing "
"group; you can put anything inside it, repeat it with a repetition "
"metacharacter such as ``*``, and nest it within other groups (capturing or "
"non-capturing). ``(?:...)`` is particularly useful when modifying an "
"existing pattern, since you can add new groups without changing how all the "
"other groups are numbered.  It should be mentioned that there's no "
"performance difference in searching between capturing and non-capturing "
"groups; neither form is any faster than the other."
msgstr ""
"除了無法檢索群組匹配的內容之外，非捕獲組的行為與捕獲組完全相同；你可以在其中"
"放入任何內容，使用重複元字元（例如 ``*``）重複它，並將其嵌套在其他組中（捕獲"
"或非捕獲）。``(?:...)`` 在修改現有模式時特別有用，因為你可以新增群組而無需更"
"改所有其他群組的編號方式。值得一提的是，捕獲組和非捕獲組之間的搜尋表現沒有差"
"異；這兩種形式都不比另一種更快。"

#: ../../howto/regex.rst:928
#, fuzzy
msgid ""
"A more significant feature is named groups: instead of referring to them by "
"numbers, groups can be referenced by a name."
msgstr ""
"一個更重要的功能是命名 group：而不是用數字來引用它們，可以透過名稱來引用群"
"組。"

#: ../../howto/regex.rst:931
#, fuzzy
msgid ""
"The syntax for a named group is one of the Python-specific extensions: ``(?"
"P<name>...)``.  *name* is, obviously, the name of the group.  Named groups "
"behave exactly like capturing groups, and additionally associate a name with "
"a group.  The :ref:`match object <match-objects>` methods that deal with "
"capturing groups all accept either integers that refer to the group by "
"number or strings that contain the desired group's name.  Named groups are "
"still given numbers, so you can retrieve information about a group in two "
"ways::"
msgstr ""
"命名群組的語法是 Python 特定的擴充功能：``(?P<name>...)``。*name* 顯然是群組"
"的名稱。命名群組表現與捕獲群組相同，此外還能將一個名字賦予該群組作為其識別。"
"處理有關捕獲群組的 :ref:`match object <match-objects>` 方法接受由數字引用之表"
"示欲選取特定群组或以含所需之特定命名之字符串當作輸入替代的方式去透過這些方法"
"操作命名控制算式咧！雖然每个给定单元只会有一个编号但它也可以由名称调用从而看"
"到编号： ::"

#: ../../howto/regex.rst:939
msgid ""
">>> p = re.compile(r'(?P<word>\\b\\w+\\b)')\n"
">>> m = p.search( '(((( Lots of punctuation )))' )\n"
">>> m.group('word')\n"
"'Lots'\n"
">>> m.group(1)\n"
"'Lots'"
msgstr ""
">>> p = re.compile(r'(?P<word>\\b\\w+\\b)')\n"
">>> m = p.search( '(((( Lots of punctuation )))' )\n"
">>> m.group('word')\n"
"'Lots'\n"
">>> m.group(1)\n"
"'Lots'"

#: ../../howto/regex.rst:946
#, fuzzy
msgid ""
"Additionally, you can retrieve named groups as a dictionary with :meth:`~re."
"Match.groupdict`::"
msgstr ""
"此外，你可以使用 :meth:`~re.Match.groupdict` 方法將命名群組作為字典檢索： ::"

#: ../../howto/regex.rst:949
msgid ""
">>> m = re.match(r'(?P<first>\\w+) (?P<last>\\w+)', 'Jane Doe')\n"
">>> m.groupdict()\n"
"{'first': 'Jane', 'last': 'Doe'}"
msgstr ""
">>> m = re.match(r'(?P<first>\\w+) (?P<last>\\w+)', 'Jane Doe')\n"
">>> m.groupdict()\n"
"{'first': 'Jane', 'last': 'Doe'}"

#: ../../howto/regex.rst:953
#, fuzzy
msgid ""
"Named groups are handy because they let you use easily remembered names, "
"instead of having to remember numbers.  Here's an example RE from the :mod:"
"`imaplib` module::"
msgstr ""
"命名群組是很方便的，因為它們讓你使用容易記住的名稱，而不是要記住數字。這裡有"
"一個 :mod:`imaplib` 模組中的正則表示式範例： ::"

#: ../../howto/regex.rst:957
msgid ""
"InternalDate = re.compile(r'INTERNALDATE \"'\n"
"        r'(?P<day>[ 123][0-9])-(?P<mon>[A-Z][a-z][a-z])-'\n"
"        r'(?P<year>[0-9][0-9][0-9][0-9])'\n"
"        r' (?P<hour>[0-9][0-9]):(?P<min>[0-9][0-9]):(?P<sec>[0-9][0-9])'\n"
"        r' (?P<zonen>[-+])(?P<zoneh>[0-9][0-9])(?P<zonem>[0-9][0-9])'\n"
"        r'\"')"
msgstr ""
"InternalDate = re.compile(r'INTERNALDATE \"'\n"
"        r'(?P<day>[ 123][0-9])-(?P<mon>[A-Z][a-z][a-z])-'\n"
"        r'(?P<year>[0-9][0-9][0-9][0-9])'\n"
"        r' (?P<hour>[0-9][0-9]):(?P<min>[0-9][0-9]):(?P<sec>[0-9][0-9])'\n"
"        r' (?P<zonen>[-+])(?P<zoneh>[0-9][0-9])(?P<zonem>[0-9][0-9])'\n"
"        r'\"')"

#: ../../howto/regex.rst:964
#, fuzzy
msgid ""
"It's obviously much easier to retrieve ``m.group('zonem')``, instead of "
"having to remember to retrieve group 9."
msgstr "很明顯，取回 ``m.group('zonem')`` 比記住要取得第 9 組方便多了。"

#: ../../howto/regex.rst:967
#, fuzzy
msgid ""
"The syntax for backreferences in an expression such as ``(...)\\1`` refers "
"to the number of the group.  There's naturally a variant that uses the group "
"name instead of the number. This is another Python extension: ``(?P=name)`` "
"indicates that the contents of the group called *name* should again be "
"matched at the current point.  The regular expression for finding doubled "
"words, ``\\b(\\w+)\\s+\\1\\b`` can also be written as ``\\b(?"
"P<word>\\w+)\\s+(?P=word)\\b``::"
msgstr ""
"在 ``(...)\\1`` 這樣的表達中，用於反向引用的數字代表著此群組（group）所在位"
"置；同樣地也有另一種使用名稱而非數字來表示群組的 Python 擴展：``(?P=...)``。"
"當運算式掃描到此時，等號右邊被指定名稱的群組其內容就會重新被掃描和比對。利用 "
"``\\b(\\w+)\\s+\\1\\b`` 可以找出重複單詞，這個正規表示式亦可改寫成 ``\\b(?"
"P<word>\\w+)\\s+(?P=word)\\b``： ::"

#: ../../howto/regex.rst:974
msgid ""
">>> p = re.compile(r'\\b(?P<word>\\w+)\\s+(?P=word)\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"
msgstr ""
">>> p = re.compile(r'\\b(?P<word>\\w+)\\s+(?P=word)\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"

#: ../../howto/regex.rst:980
#, fuzzy
msgid "Lookahead Assertions"
msgstr "先行斷言"

#: ../../howto/regex.rst:982
#, fuzzy
msgid ""
"Another zero-width assertion is the lookahead assertion.  Lookahead "
"assertions are available in both positive and negative form, and  look like "
"this:"
msgstr ""
"另一種零寬度斷言是「先行斷言」（lookahead assertion）。先行斷言分為肯定和否定"
"兩種形式，符號如下："

#: ../../howto/regex.rst:985
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../howto/regex.rst:986
#, fuzzy
msgid ""
"Positive lookahead assertion.  This succeeds if the contained regular "
"expression, represented here by ``...``, successfully matches at the current "
"location, and fails otherwise. But, once the contained expression has been "
"tried, the matching engine doesn't advance at all; the rest of the pattern "
"is tried right where the assertion started."
msgstr ""
"正向先行斷言。如果包含在此處的正規表示式被成功匹配到當前位置，則此項目 "
"succeeds；否則失敗。但一旦已嘗試了所包含的表達式，配對引擎就不再往下移動，在"
"斷言開始的地方嘗試模式中其餘部分。"

#: ../../howto/regex.rst:992
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../howto/regex.rst:993
#, fuzzy
msgid ""
"Negative lookahead assertion.  This is the opposite of the positive "
"assertion; it succeeds if the contained expression *doesn't* match at the "
"current position in the string."
msgstr ""
"負向先行斷言。這與肯定先行斷言相反；它在當前位置的字串不符合包含表達式時才會"
"成功。"

#: ../../howto/regex.rst:997
#, fuzzy
msgid ""
"To make this concrete, let's look at a case where a lookahead is useful. "
"Consider a simple pattern to match a filename and split it apart into a base "
"name and an extension, separated by a ``.``.  For example, in ``news.rc``, "
"``news`` is the base name, and ``rc`` is the filename's extension."
msgstr ""
"為了讓這個概念更明確，讓我們來看一個使用向前搜尋的案例。考慮一個簡單的模式來"
"匹配文件名並將其拆分成基本名稱和擴展名，以「.」隔開。例如，在「news.rc」中，"
"「news」是基本名稱，而「rc」是文件的副檔名。"

#: ../../howto/regex.rst:1002
#, fuzzy
msgid "The pattern to match this is quite simple:"
msgstr "符合此模式的正則表示式相當簡單："

#: ../../howto/regex.rst:1004
msgid "``.*[.].*$``"
msgstr "``.*[.].*$``"

#: ../../howto/regex.rst:1006
#, fuzzy
msgid ""
"Notice that the ``.`` needs to be treated specially because it's a "
"metacharacter, so it's inside a character class to only match that specific "
"character.  Also notice the trailing ``$``; this is added to ensure that all "
"the rest of the string must be included in the extension.  This regular "
"expression matches ``foo.bar`` and ``autoexec.bat`` and ``sendmail.cf`` and "
"``printers.conf``."
msgstr ""
"請注意 ``.`` 需要特殊處理，因為它是一個元字符，所以必須在字元類中使用才能匹配"
"該特定字符。同時請注意尾隨的 `$` 符號; 這是為了確保擴展名中包含所有其餘部分。"
"此正規表示式匹配 `foo.bar`、 `autoexec.bat`、 `sendmail.cf`和 `printers."
"conf` 等檔案名稱。"

#: ../../howto/regex.rst:1013
#, fuzzy
msgid ""
"Now, consider complicating the problem a bit; what if you want to match "
"filenames where the extension is not ``bat``? Some incorrect attempts:"
msgstr ""
"現在，考慮再複雜化問題；如果你想要匹配副檔名不是「bat」的文件名呢？以下是一些"
"錯誤嘗試："

#: ../../howto/regex.rst:1016
#, fuzzy
msgid ""
"``.*[.][^b].*$``  The first attempt above tries to exclude ``bat`` by "
"requiring that the first character of the extension is not a ``b``.  This is "
"wrong, because the pattern also doesn't match ``foo.bar``."
msgstr ""
"``.*[.][^b].*$`` 上述的第一個嘗試是試圖透過要求擴展名的第一個字符不是 ``b``，"
"來排除 ``bat``。這是錯誤的，因為此模式也無法匹配“foo.bar”。"

#: ../../howto/regex.rst:1020
msgid "``.*[.]([^b]..|.[^a].|..[^t])$``"
msgstr "``.*[.]([^b]..|.[^a].|..[^t])$``"

#: ../../howto/regex.rst:1022
#, fuzzy
msgid ""
"The expression gets messier when you try to patch up the first solution by "
"requiring one of the following cases to match: the first character of the "
"extension isn't ``b``; the second character isn't ``a``; or the third "
"character isn't ``t``.  This accepts ``foo.bar`` and rejects ``autoexec."
"bat``, but it requires a three-letter extension and won't accept a filename "
"with a two-letter extension such as ``sendmail.cf``.  We'll complicate the "
"pattern again in an effort to fix it."
msgstr ""
"當我們嘗試透過要求以下情況中的一種匹配以修補第一個解決方案時，表達式變得更加"
"混亂：擴展名的第一個字元不是「b」 ; 第二个字符不是「a」; 或者第三个字符不是"
"「t」。这將接受 \"foo.bar\" 和拒絕 \"autoexec.bat\" ，但它需要一个三字母擴展"
"名，并且将无法接受具有两字母擴展名（例如“sendmail.cf”）的文件名。我们將再次混"
"合模式，试图进行修复。"

#: ../../howto/regex.rst:1030
msgid "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"
msgstr "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"

#: ../../howto/regex.rst:1032
#, fuzzy
msgid ""
"In the third attempt, the second and third letters are all made optional in "
"order to allow matching extensions shorter than three characters, such as "
"``sendmail.cf``."
msgstr ""
"在第三次嘗試中，第二個和第三個字母均為可選項以便匹配短於三個字符的擴展名，例"
"如“sendmail.cf”。"

#: ../../howto/regex.rst:1036
#, fuzzy
msgid ""
"The pattern's getting really complicated now, which makes it hard to read "
"and understand.  Worse, if the problem changes and you want to exclude both "
"``bat`` and ``exe`` as extensions, the pattern would get even more "
"complicated and confusing."
msgstr ""
"現在這個樣式變得非常複雜，這使得它很難閱讀和理解。更糟的是，如果問題發生改"
"變，並且你要排除``bat``和 ``exe`` 作為副檔名，那麼該模式就會變得更加複雜和混"
"亂。"

#: ../../howto/regex.rst:1041
#, fuzzy
msgid "A negative lookahead cuts through all this confusion:"
msgstr "一個負向前瞻可以解決所有這些困惑："

#: ../../howto/regex.rst:1043
#, fuzzy
msgid ""
"``.*[.](?!bat$)[^.]*$``  The negative lookahead means: if the expression "
"``bat`` doesn't match at this point, try the rest of the pattern; if "
"``bat$`` does match, the whole pattern will fail.  The trailing ``$`` is "
"required to ensure that something like ``sample.batch``, where the extension "
"only starts with ``bat``, will be allowed.  The ``[^.]*`` makes sure that "
"the pattern works when there are multiple dots in the filename."
msgstr ""
"``.*[.](?!bat$)[^.]*$``這個表達式中負向前瞻的意思是：如果現在此處的表達式"
"「bat」不符合，則嘗試模式其餘部分；如果「bat$」能夠匹配成功，則整個模式將失"
"敗。必須使用結尾的「$」來確保類似於`sample.batch` 的文件名(其中擴展名僅以 "
"`bat` 開頭)也可以被接受。「[^.] *」則確保了當文件名中存在多個點時，該模式仍然"
"有效。"

#: ../../howto/regex.rst:1050
#, fuzzy
msgid ""
"Excluding another filename extension is now easy; simply add it as an "
"alternative inside the assertion.  The following pattern excludes filenames "
"that end in either ``bat`` or ``exe``:"
msgstr ""
"排除其他檔案副檔名現在很容易；只要在斷言中加入它作為替代方案即可。下列模式可"
"以排除以``bat``或``exe``結尾的檔案："

#: ../../howto/regex.rst:1054
msgid "``.*[.](?!bat$|exe$)[^.]*$``"
msgstr "``.*[.](?!bat$|exe$)[^.]*$``"

#: ../../howto/regex.rst:1058
#, fuzzy
msgid "Modifying Strings"
msgstr "修改字串"

#: ../../howto/regex.rst:1060
#, fuzzy
msgid ""
"Up to this point, we've simply performed searches against a static string. "
"Regular expressions are also commonly used to modify strings in various "
"ways, using the following pattern methods:"
msgstr ""
"到目前為止，我們僅對一個靜態字符串執行了搜尋。正規表示式也常被用來以不同方式"
"修改字串，使用下列模式方法："

#: ../../howto/regex.rst:1067
msgid "``split()``"
msgstr "``split()``"

#: ../../howto/regex.rst:1067
#, fuzzy
msgid "Split the string into a list, splitting it wherever the RE matches"
msgstr "將字串拆分成一個列表，在與正規表示式(RE)相符處進行拆分"

#: ../../howto/regex.rst:1070
msgid "``sub()``"
msgstr "``sub()``"

#: ../../howto/regex.rst:1070
#, fuzzy
msgid ""
"Find all substrings where the RE matches, and replace them with a different "
"string"
msgstr "尋找所有正規表示式所匹配到的子字串，並將其替換為不同的字串。"

#: ../../howto/regex.rst:1073
msgid "``subn()``"
msgstr "``subn()``"

#: ../../howto/regex.rst:1073
#, fuzzy
msgid ""
"Does the same thing as :meth:`!sub`,  but returns the new string and the "
"number of replacements"
msgstr "跟 `sub()` 方法一樣，但回傳值是所產生的新字串以及替換發生的次數"

#: ../../howto/regex.rst:1080
#, fuzzy
msgid "Splitting Strings"
msgstr "分割字串"

#: ../../howto/regex.rst:1082
#, fuzzy
msgid ""
"The :meth:`~re.Pattern.split` method of a pattern splits a string apart "
"wherever the RE matches, returning a list of the pieces. It's similar to "
"the :meth:`~str.split` method of strings but provides much more generality "
"in the delimiters that you can split by; string :meth:`!split` only supports "
"splitting by whitespace or by a fixed string.  As you'd expect, there's a "
"module-level :func:`re.split` function, too."
msgstr ""
"模式的 :meth:`~re.Pattern.split` 方法將字符串拆分為正則表達式匹配到的位置，返"
"回一個列表。它類似於字串的 :meth:`!split` 方法，但在可分隔符號方面提供更多通"
"用性；字串 :meth:`!split` 只支援按空格或固定字元進行拆分 。預期中也有模組級別"
"的函式：:func:`re.split`。"

#: ../../howto/regex.rst:1093
#, fuzzy
msgid ""
"Split *string* by the matches of the regular expression.  If capturing "
"parentheses are used in the RE, then their contents will also be returned as "
"part of the resulting list.  If *maxsplit* is nonzero, at most *maxsplit* "
"splits are performed."
msgstr ""
"拆分*string*，以正則表達式作匹配。若RE使用捕獲括號，將其內容也一同回傳為結果"
"列表的元素。當*maxsplit*非零時，最多執行 *maxsplit* 次拆分。"

#: ../../howto/regex.rst:1098
#, fuzzy
msgid ""
"You can limit the number of splits made, by passing a value for *maxsplit*. "
"When *maxsplit* is nonzero, at most *maxsplit* splits will be made, and the "
"remainder of the string is returned as the final element of the list.  In "
"the following example, the delimiter is any sequence of non-alphanumeric "
"characters. ::"
msgstr ""
"你可以透過設定 *maxsplit* 參數來限制分割次數，當 *maxsplit* 值不是零時，最多"
"分割此數量並將字串剩餘部份作為清單的最終元素回傳。在下面的範例中，以非英文字"
"母和數字為區隔符號。 ::"

#: ../../howto/regex.rst:1104
msgid ""
">>> p = re.compile(r'\\W+')\n"
">>> p.split('This is a test, short and sweet, of split().')\n"
"['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']\n"
">>> p.split('This is a test, short and sweet, of split().', 3)\n"
"['This', 'is', 'a', 'test, short and sweet, of split().']"
msgstr ""
">>> p = re.compile(r'\\W+')\n"
">>> p.split('This is a test, short and sweet, of split().')\n"
"['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']\n"
">>> p.split('This is a test, short and sweet, of split().', 3)\n"
"['This', 'is', 'a', 'test, short and sweet, of split().']"

#: ../../howto/regex.rst:1110
#, fuzzy
msgid ""
"Sometimes you're not only interested in what the text between delimiters is, "
"but also need to know what the delimiter was.  If capturing parentheses are "
"used in the RE, then their values are also returned as part of the list.  "
"Compare the following calls::"
msgstr ""
"有時你不僅對分隔符之間的文本有興趣，也需要知道該分隔符是什麼。如果在正規表示"
"式（RE）中使用捕獲括號，那麼它們的值也作為列表的一部分回傳。比較以下調用： ::"

#: ../../howto/regex.rst:1115
msgid ""
">>> p = re.compile(r'\\W+')\n"
">>> p2 = re.compile(r'(\\W+)')\n"
">>> p.split('This... is a test.')\n"
"['This', 'is', 'a', 'test', '']\n"
">>> p2.split('This... is a test.')\n"
"['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']"
msgstr ""
">>> p = re.compile(r'\\W+')\n"
">>> p2 = re.compile(r'(\\W+)')\n"
">>> p.split('This... is a test.')\n"
"['This', 'is', 'a', 'test', '']\n"
">>> p2.split('This... is a test.')\n"
"['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']"

#: ../../howto/regex.rst:1122
#, fuzzy
msgid ""
"The module-level function :func:`re.split` adds the RE to be used as the "
"first argument, but is otherwise the same.   ::"
msgstr ""
"模組層級函式 :func:`re.split` 新增一個參數，作為被用來作為第一個引數的正規表"
"示式，但除此之外功能和原本相同。 ::"

#: ../../howto/regex.rst:1125
msgid ""
">>> re.split(r'[\\W]+', 'Words, words, words.')\n"
"['Words', 'words', 'words', '']\n"
">>> re.split(r'([\\W]+)', 'Words, words, words.')\n"
"['Words', ', ', 'words', ', ', 'words', '.', '']\n"
">>> re.split(r'[\\W]+', 'Words, words, words.', 1)\n"
"['Words', 'words, words.']"
msgstr ""
">>> re.split(r'[\\W]+', 'Words, words, words.')\n"
"['Words', 'words', 'words', '']\n"
">>> re.split(r'([\\W]+)', 'Words, words, words.')\n"
"['Words', ', ', 'words', ', ', 'words', '.', '']\n"
">>> re.split(r'[\\W]+', 'Words, words, words.', 1)\n"
"['Words', 'words, words.']"

#: ../../howto/regex.rst:1134
#, fuzzy
msgid "Search and Replace"
msgstr "搜尋和取代"

#: ../../howto/regex.rst:1136
#, fuzzy
msgid ""
"Another common task is to find all the matches for a pattern, and replace "
"them with a different string.  The :meth:`~re.Pattern.sub` method takes a "
"replacement value, which can be either a string or a function, and the "
"string to be processed."
msgstr ""
"另一個常見的任務是找到符合某個模式的所有匹配項，並用不同的字串取代它們。:"
"meth:`~re.Pattern.sub` 方法需要傳入替換值，可以是字串或函式，以及要處理的字"
"串。"

#: ../../howto/regex.rst:1143
#, fuzzy
msgid ""
"Returns the string obtained by replacing the leftmost non-overlapping "
"occurrences of the RE in *string* by the replacement *replacement*.  If the "
"pattern isn't found, *string* is returned unchanged."
msgstr ""
"回傳字串，此字串經取代來源字串 *string* 中最左邊且沒重複的區段符合所提供的正"
"規表示式 RE 所產生之符合 REPLACEMENT 的內容。若未找到該模式，則回傳原始 "
"*string* 字串。"

#: ../../howto/regex.rst:1147
#, fuzzy
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  The default value "
"of 0 means to replace all occurrences."
msgstr ""
"選擇性的參數 *count* 是最大替換次數；*count* 必須是一個非負整數。預設值為0，"
"表示取代所有出現次數。"

#: ../../howto/regex.rst:1151
#, fuzzy
msgid ""
"Here's a simple example of using the :meth:`~re.Pattern.sub` method.  It "
"replaces colour names with the word ``colour``::"
msgstr ""
"以下是使用 ``sub`` 方法的一個簡單範例。它會將顏色名稱替換為「color」： ::"

#: ../../howto/regex.rst:1154
msgid ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.sub('colour', 'blue socks and red shoes')\n"
"'colour socks and colour shoes'\n"
">>> p.sub('colour', 'blue socks and red shoes', count=1)\n"
"'colour socks and red shoes'"
msgstr ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.sub('colour', 'blue socks and red shoes')\n"
"'colour socks and colour shoes'\n"
">>> p.sub('colour', 'blue socks and red shoes', count=1)\n"
"'colour socks and red shoes'"

#: ../../howto/regex.rst:1160
#, fuzzy
msgid ""
"The :meth:`~re.Pattern.subn` method does the same work, but returns a 2-"
"tuple containing the new string value and the number of replacements  that "
"were performed::"
msgstr ""
":meth:`~re.Pattern.subn` 方法與 :meth:`~re.SubPattern.sub` 相同，但其回傳值為"
"一個包含新字串和替換次數共兩個元素的二元組(tuple)： ::"

#: ../../howto/regex.rst:1163
msgid ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.subn('colour', 'blue socks and red shoes')\n"
"('colour socks and colour shoes', 2)\n"
">>> p.subn('colour', 'no colours at all')\n"
"('no colours at all', 0)"
msgstr ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.subn('colour', 'blue socks and red shoes')\n"
"('colour socks and colour shoes', 2)\n"
">>> p.subn('colour', 'no colours at all')\n"
"('no colours at all', 0)"

#: ../../howto/regex.rst:1169
#, fuzzy
msgid ""
"Empty matches are replaced only when they're not adjacent to a previous "
"empty match. ::"
msgstr "只有當一個空匹配不相鄰於先前的空匹配時，才會替換空匹配。 ::"

#: ../../howto/regex.rst:1172
msgid ""
">>> p = re.compile('x*')\n"
">>> p.sub('-', 'abxd')\n"
"'-a-b--d-'"
msgstr ""
">>> p = re.compile('x*')\n"
">>> p.sub('-', 'abxd')\n"
"'-a-b--d-'"

#: ../../howto/regex.rst:1176
#, fuzzy
msgid ""
"If *replacement* is a string, any backslash escapes in it are processed.  "
"That is, ``\\n`` is converted to a single newline character, ``\\r`` is "
"converted to a carriage return, and so forth. Unknown escapes such as "
"``\\&`` are left alone. Backreferences, such as ``\\6``, are replaced with "
"the substring matched by the corresponding group in the RE.  This lets you "
"incorporate portions of the original text in the resulting replacement "
"string."
msgstr ""
"如果 *replacement* 是一個字串，其中的反斜線會被處理。也就是 `\\n` 會轉換成新"
"行符號，`\\r` 會轉換成回車鍵等等。未知的轉義符如 `\\&` 則不變留作原樣。可替代"
"參照（backreferences），例如 `\\6`，將會被正則表達式中相對應組別所匹配到的子"
"字串取代掉，因此可以在替換字串中加上原始訊息文字部分"

#: ../../howto/regex.rst:1183
#, fuzzy
msgid ""
"This example matches the word ``section`` followed by a string enclosed in "
"``{``, ``}``, and changes ``section`` to ``subsection``::"
msgstr ""
"本例尋找單字 ``section`` 後，接著一串以大括號包覆的字詞，並將 ``section`` 替"
"換為 ``subsection``。即： ::"

#: ../../howto/regex.rst:1186
msgid ""
">>> p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First} section{second}')\n"
"'subsection{First} subsection{second}'"
msgstr ""
">>> p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First} section{second}')\n"
"'subsection{First} subsection{second}'"

#: ../../howto/regex.rst:1190
#, fuzzy
msgid ""
"There's also a syntax for referring to named groups as defined by the ``(?"
"P<name>...)`` syntax.  ``\\g<name>`` will use the substring matched by the "
"group named ``name``, and  ``\\g<number>``  uses the corresponding group "
"number. ``\\g<2>`` is therefore equivalent to ``\\2``,  but isn't ambiguous "
"in a replacement string such as ``\\g<2>0``.  (``\\20`` would be interpreted "
"as a reference to group 20, not a reference to group 2 followed by the "
"literal character ``'0'``.)  The following substitutions are all equivalent, "
"but use all three variations of the replacement string. ::"
msgstr ""
"還有一種用來引用由 ``(?P<name>...)`` 語法定義的命名群組的語法。``\\g<name>`` "
"將使用名為 ``name`` 的群組相符的子字串，而 ``\\g<number>`` 使用對應的群組編"
"號。因此，``\\g<2>`` 等價於 ``\\2``，但在替換字串（例如 ``\\g<2>0``）中不會產"
"生歧義。 （``\\20`` 將解釋為對組 20 的引用，而不是對組 2 的引用，後跟文字字"
"元 ``'0'``。）以下替換都是等效的，但使用替換字串。 ::"

#: ../../howto/regex.rst:1199
msgid ""
">>> p = re.compile('section{ (?P<name> [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<1>}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<name>}','section{First}')\n"
"'subsection{First}'"
msgstr ""
">>> p = re.compile('section{ (?P<name> [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<1>}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<name>}','section{First}')\n"
"'subsection{First}'"

#: ../../howto/regex.rst:1207
#, fuzzy
msgid ""
"*replacement* can also be a function, which gives you even more control.  If "
"*replacement* is a function, the function is called for every non-"
"overlapping occurrence of *pattern*.  On each call, the function is passed "
"a :ref:`match object <match-objects>` argument for the match and can use "
"this information to compute the desired replacement string and return it."
msgstr ""
"*replacement* （替換物）也可以是一個函式，這樣就能讓你得到更多的控制。如果 "
"*replacement* 是一個函式，則在每次非重疊出現 *pattern* 的地方都會呼叫該函式。"
"在每次呼叫中，將傳遞給該函式 :ref:`match object <match-objects>` 參數以供與匹"
"配相關的替換操作並將其回傳。"

#: ../../howto/regex.rst:1213
#, fuzzy
msgid ""
"In the following example, the replacement function translates decimals into "
"hexadecimal::"
msgstr "以下是範例，此替換函式可將十進制轉譯成十六進制： ::"

#: ../../howto/regex.rst:1216
msgid ""
">>> def hexrepl(match):\n"
"...     \"Return the hex string for a decimal number\"\n"
"...     value = int(match.group())\n"
"...     return hex(value)\n"
"...\n"
">>> p = re.compile(r'\\d+')\n"
">>> p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')\n"
"'Call 0xffd2 for printing, 0xc000 for user code.'"
msgstr ""

#: ../../howto/regex.rst:1225
#, fuzzy
msgid ""
"When using the module-level :func:`re.sub` function, the pattern is passed "
"as the first argument.  The pattern may be provided as an object or as a "
"string; if you need to specify regular expression flags, you must either use "
"a pattern object as the first parameter, or use embedded modifiers in the "
"pattern string, e.g. ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` returns ``'x "
"x'``."
msgstr ""
"當使用模組層級的 :func:`re.sub` 函式時，模式會傳遞為第一個引數。模式可以提供"
"為物件或字串; 如果你需要指定正規表示式旗標，必須將模式物件用作第一個參數，或"
"在模式字串中使用內置修改器，例如 ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` 就"
"會回傳 ``'x x'``"

#: ../../howto/regex.rst:1233
msgid "Common Problems"
msgstr "常見問題"

#: ../../howto/regex.rst:1235
#, fuzzy
msgid ""
"Regular expressions are a powerful tool for some applications, but in some "
"ways their behaviour isn't intuitive and at times they don't behave the way "
"you may expect them to.  This section will point out some of the most common "
"pitfalls."
msgstr ""
"正規表示式是某些情況下強大的工具，但有時其行為並不直觀，而且偶爾會表現出你未"
"曾預期的結果。本節將指出其中一些最常見的陷阱。"

#: ../../howto/regex.rst:1241
msgid "Use String Methods"
msgstr "使用字串方法"

#: ../../howto/regex.rst:1243
#, fuzzy
msgid ""
"Sometimes using the :mod:`re` module is a mistake.  If you're matching a "
"fixed string, or a single character class, and you're not using any :mod:"
"`re` features such as the :const:`~re.IGNORECASE` flag, then the full power "
"of regular expressions may not be required. Strings have several methods for "
"performing operations with fixed strings and they're usually much faster, "
"because the implementation is a single small C loop that's been optimized "
"for the purpose, instead of the large, more generalized regular expression "
"engine."
msgstr ""
"有時候使用 :mod:`re` 模組會是一個錯誤。如果你只是匹配固定字串或單一字符類，並"
"且不使用任何: const:`~re.IGNORECASE` 等模組功能，则可能不需要完整的正規表示式"
"的功能。相對地, 字符串有好幾種方法來執行操作以查找固定字符串，而這些方法通常"
"更快，因為其實現是一個被優化、小型 C loop 而已，而非大型、更廣泛的正則引擎"

#: ../../howto/regex.rst:1251
#, fuzzy
msgid ""
"One example might be replacing a single fixed string with another one; for "
"example, you might replace ``word`` with ``deed``.  :func:`re.sub` seems "
"like the function to use for this, but consider the :meth:`~str.replace` "
"method.  Note that :meth:`!replace` will also replace ``word`` inside words, "
"turning ``swordfish`` into ``sdeedfish``, but the  naive RE ``word`` would "
"have done that, too.  (To avoid performing the substitution on parts of "
"words, the pattern would have to be ``\\bword\\b``, in order to require that "
"``word`` have a word boundary on either side.  This takes the job beyond  :"
"meth:`!replace`'s abilities.)"
msgstr ""
"一個例子可能是將一個固定字串替換為另一個固定字串；例如，你可以將“word”替換"
"為“deed”。 :func:`re.sub` 似乎是用於此目的的函式，但請考慮 :meth:`~str."
"replace` 方法。請注意， :meth:`!replace` 也會取代單字中的 ``word`` ，將 "
"``swordfish`` 變成 ``sdeedfish`` ，但天真的 RE ``word`` 也會這樣做。 （為了避"
"免對部分單字執行替換，模式必須是 ``\\bword\\b``，以便要求 ``word`` 在兩側都有"
"單字邊界。這使工作超出了： meth:`!replace`的能力。）"

#: ../../howto/regex.rst:1260
#, fuzzy
msgid ""
"Another common task is deleting every occurrence of a single character from "
"a string or replacing it with another single character.  You might do this "
"with something like ``re.sub('\\n', ' ', S)``, but :meth:`~str.translate` is "
"capable of doing both tasks and will be faster than any regular expression "
"operation can be."
msgstr ""
"另一個常見的任務是從字串中刪除某個特定字元的所有出現，或以另一個單一字元取代"
"它。你可能會透過類似這樣的指令實現：``re.sub('\\n', ' ', S)``，但 :meth:"
"`~str.translate` 可同時做到這兩件事情且速度比正規表示式操作更快。"

#: ../../howto/regex.rst:1266
#, fuzzy
msgid ""
"In short, before turning to the :mod:`re` module, consider whether your "
"problem can be solved with a faster and simpler string method."
msgstr ""
"簡而言之，在使用 :mod:`re` 模組之前，請考慮是否可以使用更快且更簡單的字串方法"
"來解決你的問題。"

#: ../../howto/regex.rst:1271
msgid "match() versus search()"
msgstr "match() 與 search() 的差別"

#: ../../howto/regex.rst:1273
#, fuzzy
msgid ""
"The :func:`~re.match` function only checks if the RE matches at the "
"beginning of the string while :func:`~re.search` will scan forward through "
"the string for a match. It's important to keep this distinction in mind.  "
"Remember,  :func:`!match` will only report a successful match which will "
"start at 0; if the match wouldn't start at zero,  :func:`!match` will *not* "
"report it. ::"
msgstr ""
":func:`~re.match` 函式只會檢查 RE 是否與字串開頭匹配，而 :func:`~re.search` "
"則會透過掃描字串尋找匹配。重要的是要注意這個差別，請記得：只有當一個匹配成功"
"且從 0 開始才會報告 :func:`!match` 的掃描結果；否則就不會報告該結果。 ::"

#: ../../howto/regex.rst:1279
msgid ""
">>> print(re.match('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.match('super', 'insuperable'))\n"
"None"
msgstr ""
">>> print(re.match('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.match('super', 'insuperable'))\n"
"None"

#: ../../howto/regex.rst:1284
#, fuzzy
msgid ""
"On the other hand, :func:`~re.search` will scan forward through the string, "
"reporting the first match it finds. ::"
msgstr ""
"另一方面，:func:`~re.search` 會從字符串前向掃描，報告它發現的第一個匹配。 ::"

#: ../../howto/regex.rst:1287
msgid ""
">>> print(re.search('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.search('super', 'insuperable').span())\n"
"(2, 7)"
msgstr ""
">>> print(re.search('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.search('super', 'insuperable').span())\n"
"(2, 7)"

#: ../../howto/regex.rst:1292
#, fuzzy
msgid ""
"Sometimes you'll be tempted to keep using :func:`re.match`, and just add ``."
"*`` to the front of your RE.  Resist this temptation and use :func:`re."
"search` instead.  The regular expression compiler does some analysis of REs "
"in order to speed up the process of looking for a match.  One such analysis "
"figures out what the first character of a match must be; for example, a "
"pattern starting with ``Crow`` must match starting with a ``'C'``.  The "
"analysis lets the engine quickly scan through the string looking for the "
"starting character, only trying the full match if a ``'C'`` is found."
msgstr ""
"有時你會想繼續使用 :func:`re.match`，只需在正則式上方加上 ``.*``。但最好抵制"
"這種誘惑，改用 :func:`re.search`。因為正則表達式的編譯器會分析它以加速查找匹"
"配的流程。其中一項分析是確定匹配首字元；例如，以 \"Crow\" 開始的模式必須與"
"「C」開頭相符。此分析讓引擎快速掃描字串尋找起始字符，在發現「C」時才嘗試完整"
"匹配。"

#: ../../howto/regex.rst:1301
#, fuzzy
msgid ""
"Adding ``.*`` defeats this optimization, requiring scanning to the end of "
"the string and then backtracking to find a match for the rest of the RE.  "
"Use :func:`re.search` instead."
msgstr ""
"將 ``.*`` 加入正規表示式會使此優化失效，需要掃描整個字串，接著回溯尋找 RE 的"
"其他匹配項。建議使用 :func:`re.search` 代替。"

#: ../../howto/regex.rst:1307
#, fuzzy
msgid "Greedy versus Non-Greedy"
msgstr "貪婪模式與非貪婪模式"

#: ../../howto/regex.rst:1309
#, fuzzy
msgid ""
"When repeating a regular expression, as in ``a*``, the resulting action is "
"to consume as much of the pattern as possible.  This fact often bites you "
"when you're trying to match a pair of balanced delimiters, such as the angle "
"brackets surrounding an HTML tag.  The naive pattern for matching a single "
"HTML tag doesn't work because of the greedy nature of ``.*``. ::"
msgstr ""
"當重複一個正規表示式，例如 ``a*``，結果會儘可能多的消耗範圍內的模式。當你試圖"
"匹配成對的平衡分隔符號時，這個特性經常會出現問題，例如用於 HTML 標記周圍小於"
"與大於括號（angle brackets）。由於 ``.*`` 貪心的本質, 難以使用單一HTML標籤匹"
"配模式解決困境。 ::"

#: ../../howto/regex.rst:1315
msgid ""
">>> s = '<html><head><title>Title</title>'\n"
">>> len(s)\n"
"32\n"
">>> print(re.match('<.*>', s).span())\n"
"(0, 32)\n"
">>> print(re.match('<.*>', s).group())\n"
"<html><head><title>Title</title>"
msgstr ""
">>> s = '<html><head><title>Title</title>'\n"
">>> len(s)\n"
"32\n"
">>> print(re.match('<.*>', s).span())\n"
"(0, 32)\n"
">>> print(re.match('<.*>', s).group())\n"
"<html><head><title>Title</title>"

#: ../../howto/regex.rst:1323
#, fuzzy
msgid ""
"The RE matches the ``'<'`` in ``'<html>'``, and the ``.*`` consumes the rest "
"of the string.  There's still more left in the RE, though, and the ``>`` "
"can't match at the end of the string, so the regular expression engine has "
"to backtrack character by character until it finds a match for the ``>``.   "
"The final match extends from the ``'<'`` in ``'<html>'`` to the ``'>'`` in "
"``'</title>'``, which isn't what you want."
msgstr ""
"RE（正規表示式）匹配 ``'<html>'`` 中的 ``'<'``, 然後使用 ``.*`` 消耗掉其餘部"
"分的字串。雖然 RE 仍有更多內容，但是 ``>`` 無法在字符串末尾匹配，因此正規表示"
"式引擎必須逐字符回溯直到找到 ``>`` 的匹配為止。最終匹配從 ``'<html>'`` 中的“ "
"<”一直延伸到 `` '</ title>'``的“>”，這不是你想要的。"

#: ../../howto/regex.rst:1330
#, fuzzy
msgid ""
"In this case, the solution is to use the non-greedy quantifiers ``*?``, ``+?"
"``, ``??``, or ``{m,n}?``, which match as *little* text as possible.  In the "
"above example, the ``'>'`` is tried immediately after the first ``'<'`` "
"matches, and when it fails, the engine advances a character at a time, "
"retrying the ``'>'`` at every step.  This produces just the right result::"
msgstr ""
"在這個情況下，解決方法是使用 non-greedy quantifiers ``*?``, ``+?``, ``??``, "
"或 ``{m,n}?``。它會匹配最少的文字。在上面的範例中，當第一個``'<'``被匹配後就"
"立即嘗試 ``'>'``，如果失敗則引擎每次向前移動一個字符並重新嘗試匹配到此為止。"
"這樣可以得到正確的結果： ::"

#: ../../howto/regex.rst:1336
msgid ""
">>> print(re.match('<.*?>', s).group())\n"
"<html>"
msgstr ""
">>> print(re.match('<.*?>', s).group())\n"
"<html>"

#: ../../howto/regex.rst:1339
#, fuzzy
msgid ""
"(Note that parsing HTML or XML with regular expressions is painful. Quick-"
"and-dirty patterns will handle common cases, but HTML and XML have special "
"cases that will break the obvious regular expression; by the time you've "
"written a regular expression that handles all of the possible cases, the "
"patterns will be *very* complicated.  Use an HTML or XML parser module for "
"such tasks.)"
msgstr ""
"（注意，使用正規表示式解析 HTML 或 XML 是非常困難的。簡單而粗略的樣式能處理常"
"見情況，但是 HTML 和 XML 有特別情況會打壞明顯正規表示示；當你寫下一個講解所有"
"可能性的原則時，樣式將變得*非常*複雜。對於這些任務使用 HTML 或 XML 解析器模"
"組）"

#: ../../howto/regex.rst:1347
msgid "Using re.VERBOSE"
msgstr "使用 re.VERBOSE"

#: ../../howto/regex.rst:1349
msgid ""
"By now you've probably noticed that regular expressions are a very compact "
"notation, but they're not terribly readable.  REs of moderate complexity can "
"become lengthy collections of backslashes, parentheses, and metacharacters, "
"making them difficult to read and understand."
msgstr ""
"現在你可能已經注意到正規表示式是一種非常緊湊的標示方法 (notion)，但並不容易閱"
"讀。中等複雜度的正規表示式可能會變成斜線、括號和元字元的冗長集合，使其很難理"
"解和閱讀。"

#: ../../howto/regex.rst:1354
#, fuzzy
msgid ""
"For such REs, specifying the :const:`re.VERBOSE` flag when compiling the "
"regular expression can be helpful, because it allows you to format the "
"regular expression more clearly."
msgstr ""
"對於這樣的正規表示式，在編譯時指定 :const:`re.VERBOSE` 旗標可以很有幫助，因為"
"它允許你更清晰地格式化正則表達式。"

#: ../../howto/regex.rst:1358
#, fuzzy
msgid ""
"The ``re.VERBOSE`` flag has several effects.  Whitespace in the regular "
"expression that *isn't* inside a character class is ignored.  This means "
"that an expression such as ``dog | cat`` is equivalent to the less readable "
"``dog|cat``, but ``[a b]`` will still match the characters ``'a'``, ``'b'``, "
"or a space.  In addition, you can also put comments inside a RE; comments "
"extend from a ``#`` character to the next newline.  When used with triple-"
"quoted strings, this enables REs to be formatted more neatly::"
msgstr ""
"``re.VERBOSE`` 旗標有多種功能。正規表示式中\\ *不*\\ 位於字元類別中的空格將被"
"忽略。這意味著諸如 ``dog | cat`` 之類的表達式相當於可讀性較差的 ``dog|cat``，"
"但 ``[a b]`` 仍會匹配字元 ``'a'``、``'b'`` 或空格。此外，你也可以在 RE 中新增"
"註解；註解從 ``#`` 字元延伸到下一個換行符號。當與三引號字串一起使用時，這使"
"得 RE 的格式更加整齊："

#: ../../howto/regex.rst:1366
msgid ""
"pat = re.compile(r\"\"\"\n"
" \\s*                 # Skip leading whitespace\n"
" (?P<header>[^:]+)   # Header name\n"
" \\s* :               # Whitespace, and a colon\n"
" (?P<value>.*?)      # The header's value -- *? used to\n"
"                     # lose the following trailing whitespace\n"
" \\s*$                # Trailing whitespace to end-of-line\n"
"\"\"\", re.VERBOSE)"
msgstr ""

#: ../../howto/regex.rst:1375
msgid "This is far more readable than::"
msgstr "這遠比以下方式容易閱讀： ::"

#: ../../howto/regex.rst:1377
msgid "pat = re.compile(r\"\\s*(?P<header>[^:]+)\\s*:(?P<value>.*?)\\s*$\")"
msgstr "pat = re.compile(r\"\\s*(?P<header>[^:]+)\\s*:(?P<value>.*?)\\s*$\")"

#: ../../howto/regex.rst:1381
#, fuzzy
msgid "Feedback"
msgstr "回饋"

#: ../../howto/regex.rst:1383
#, fuzzy
msgid ""
"Regular expressions are a complicated topic.  Did this document help you "
"understand them?  Were there parts that were unclear, or Problems you "
"encountered that weren't covered here?  If so, please send suggestions for "
"improvements to the author."
msgstr ""
"正規表示式是一個複雜的主題。這份文件有幫助你了解嗎？ 是否有部分不清楚或未涵蓋"
"到問題？ 如果有，請將改進建議發送給作者。"

#: ../../howto/regex.rst:1388
#, fuzzy
msgid ""
"The most complete book on regular expressions is almost certainly Jeffrey "
"Friedl's Mastering Regular Expressions, published by O'Reilly.  "
"Unfortunately, it exclusively concentrates on Perl and Java's flavours of "
"regular expressions, and doesn't contain any Python material at all, so it "
"won't be useful as a reference for programming in Python.  (The first "
"edition covered Python's now-removed :mod:`!regex` module, which won't help "
"you much.)  Consider checking it out from your library."
msgstr ""
"關於正規表示式，最完整的參考書籍很可能是 Jeffrey Friedl 的《Mastering "
"Regular Expressions》，由 O'Reilly 出版。但很遺憾地，它只著重在 Perl 和 Java "
"的正規表示式版本上，沒有包含任何 Python 內容，因此對於使用 Python 程式設計來"
"說甚至可能不太實用。（第一版涵蓋了現今已移除的 :mod:`!regex` 模組）建議你從圖"
"書館借閱該書。"
