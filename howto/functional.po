# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Leon H., 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-23 07:52+0800\n"
"PO-Revision-Date: 2023-03-26 18:25+0000\n"
"Last-Translator: CTHua <illiew2470+pythonTW@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/functional.rst:5 ../../howto/functional.rst:3
msgid "Functional Programming HOWTO"
msgstr "如何撰寫函式程式設計 (Functional Programming)"

#: ../../howto/functional.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/functional.rst:7 ../../howto/functional.rst:5
msgid "A. M. Kuchling"
msgstr "A. M. Kuchling"

#: ../../howto/functional.rst:0
msgid "Release"
msgstr "發佈版本"

#: ../../howto/functional.rst:8 ../../howto/functional.rst:6
msgid "0.32"
msgstr "0.32"

#: ../../howto/functional.rst:10 ../../howto/functional.rst:8
#, fuzzy
msgid ""
"In this document, we'll take a tour of Python's features suitable for "
"implementing programs in a functional style.  After an introduction to the "
"concepts of functional programming, we'll look at language features such as :"
"term:`iterator`\\s and :term:`generator`\\s and relevant library modules "
"such as :mod:`itertools` and :mod:`functools`."
msgstr ""
"在本文件中，我們將介紹適合以函式風格實作程式的 Python 功能。在介紹了函式式程"
"式設計的概念之後，我們將了解諸如 :term:`iterator` 和 :term:`generator` 等語言"
"特性以及相關的函式庫模組，例如 :mod:`itertools` 和 :mod:`functools`。"

#: ../../howto/functional.rst:18 ../../howto/functional.rst:16
msgid "Introduction"
msgstr "簡介"

#: ../../howto/functional.rst:20 ../../howto/functional.rst:18
#, fuzzy
msgid ""
"This section explains the basic concept of functional programming; if you're "
"just interested in learning about Python language features, skip to the next "
"section on :ref:`functional-howto-iterators`."
msgstr ""
"本節說明函式程式設計的基本概念；如果你只想學習有關 Python 語言功能，請跳至下"
"一節 :ref:`functional-howto-iterators`。"

#: ../../howto/functional.rst:24 ../../howto/functional.rst:22
msgid ""
"Programming languages support decomposing problems in several different ways:"
msgstr "程式語言支援多種不同的方式來拆解問題："

#: ../../howto/functional.rst:26 ../../howto/functional.rst:24
#, fuzzy
msgid ""
"Most programming languages are **procedural**: programs are lists of "
"instructions that tell the computer what to do with the program's input.  C, "
"Pascal, and even Unix shells are procedural languages."
msgstr ""
"大部分的程式語言都是\\ **程序式**的：程式是由一連串指令所組成，這些指令告訴電"
"腦要如何處理程式的輸入。C、Pascal 以及甚至 UNIX shells 都屬於程序式語言。"

#: ../../howto/functional.rst:30 ../../howto/functional.rst:28
#, fuzzy
msgid ""
"In **declarative** languages, you write a specification that describes the "
"problem to be solved, and the language implementation figures out how to "
"perform the computation efficiently.  SQL is the declarative language you're "
"most likely to be familiar with; a SQL query describes the data set you want "
"to retrieve, and the SQL engine decides whether to scan tables or use "
"indexes, which subclauses should be performed first, etc."
msgstr ""
"在\\ **宣告式 (declarative)** 語言中，你所撰寫的規範描述問題與計算目標，而程"
"式會決定如何高效地執行運算。SQL是你最可能熟悉的宣告式語言；一個 SQL 查詢描述"
"了你要檢索的資料集，然後由 SQL 引擎決定是否掃描表或使用索引、哪些副子句首先執"
"行等等。"

#: ../../howto/functional.rst:37 ../../howto/functional.rst:35
#, fuzzy
msgid ""
"**Object-oriented** programs manipulate collections of objects.  Objects "
"have internal state and support methods that query or modify this internal "
"state in some way. Smalltalk and Java are object-oriented languages.  C++ "
"and Python are languages that support object-oriented programming, but don't "
"force the use of object-oriented features."
msgstr ""
"面向物件程式設計（Object-oriented programming）是一種以對象作為基本單位進行運"
"算的程式設計方法。每個對象都擁有內在狀態，並支援可以查詢或修改此內部狀態的方"
"法。Smalltalk 和 Java 是面向物件語言，而C++和Python 雖然可以支援面向物件程式"
"設計但不強制使用這些特性。"

#: ../../howto/functional.rst:43 ../../howto/functional.rst:41
#, fuzzy
msgid ""
"**Functional** programming decomposes a problem into a set of functions. "
"Ideally, functions only take inputs and produce outputs, and don't have any "
"internal state that affects the output produced for a given input.  Well-"
"known functional languages include the ML family (Standard ML, OCaml, and "
"other variants) and Haskell."
msgstr ""
"**函式程式設計 (Functional programming)** 將問題分解為一組函式。理想情況下，"
"函式只接收輸入並產生輸出，且不具備任何內部狀態會影響特定輸入的輸出結果。知名"
"的函式程式語言包括 ML 系列 (Standard ML、OCaml 和其他變種) 和 Haskell."

#: ../../howto/functional.rst:49 ../../howto/functional.rst:47
#, fuzzy
msgid ""
"The designers of some computer languages choose to emphasize one particular "
"approach to programming.  This often makes it difficult to write programs "
"that use a different approach.  Other languages are multi-paradigm languages "
"that support several different approaches. Lisp, C++, and Python are multi-"
"paradigm; you can write programs or libraries that are largely procedural, "
"object-oriented, or functional in all of these languages.  In a large "
"program, different sections might be written using different approaches; the "
"GUI might be object-oriented while the processing logic is procedural or "
"functional, for example."
msgstr ""
"某些電腦語言的設計者選擇強調特定的程式編寫方法，因此製作不同編寫方式的程式會"
"變得很困難。其他則是支援數種程式編寫方法 (multi-paradigm) 的多范型 (multi-"
"paradigm) 語言。像是 Lisp、C++ 和 Python 都是多范型語言，你可以使用不同的編寫"
"方式在這幾種語言中撰寫主要以 procedural(程序化)、object-oriented（物件導向）"
"或 functional（函式導向）等三大方式；當你在開發一個龐大的程式時，不同區塊可能"
"採用不同的策略(e.g. GUI 物件導向，而 logic 部分則結合 procedural 或 "
"functional)，依情況而定。"

#: ../../howto/functional.rst:60 ../../howto/functional.rst:58
#, fuzzy
msgid ""
"In a functional program, input flows through a set of functions. Each "
"function operates on its input and produces some output.  Functional style "
"discourages functions with side effects that modify internal state or make "
"other changes that aren't visible in the function's return value.  Functions "
"that have no side effects at all are called **purely functional**.  Avoiding "
"side effects means not using data structures that get updated as a program "
"runs; every function's output must only depend on its input."
msgstr ""
"在函式程式中，輸入會流經一組函式。每個函式都會操作輸入並生成某些輸出。函式式"
"風格不鼓勵有副作用的函式，即修改內部狀態或做出其他在回傳值中看不到變化的更"
"改。沒有任何副作用的功能稱為\\ **純粹函式**。避免使用隨程序運行而更新的資料結"
"構，每個函式的輸出必須僅依賴其輸入。"

#: ../../howto/functional.rst:68 ../../howto/functional.rst:66
#, fuzzy
msgid ""
"Some languages are very strict about purity and don't even have assignment "
"statements such as ``a=3`` or ``c = a + b``, but it's difficult to avoid all "
"side effects, such as printing to the screen or writing to a disk file. "
"Another example is a call to the :func:`print` or :func:`time.sleep` "
"function, neither of which returns a useful value. Both are called only for "
"their side effects of sending some text to the screen or pausing execution "
"for a second."
msgstr ""
"一些程式語言非常嚴格，對於純淨度要求很高，甚至沒有賦值陳述句（例如 ``a=3`` "
"或 ``c = a + b``），但很難避免所有副作用，例如向螢幕列印或寫入磁碟檔案。另一"
"個例子是呼叫 :func:`print` 或 :func:`time.sleep` 函式，這兩者都沒有回傳一個有"
"用的值。它們只會因其副作用而被調用，如向螢幕發送一些文字或暫停執行 1 秒鐘。"

#: ../../howto/functional.rst:75 ../../howto/functional.rst:73
#, fuzzy
msgid ""
"Python programs written in functional style usually won't go to the extreme "
"of avoiding all I/O or all assignments; instead, they'll provide a "
"functional-appearing interface but will use non-functional features "
"internally. For example, the implementation of a function will still use "
"assignments to local variables, but won't modify global variables or have "
"other side effects."
msgstr ""
"用函式風格撰寫的 Python 程序通常不會極端地避免所有 I/O 或所有賦值。相反，它們"
"會提供一個看起來很「函式」 的介面，但在內部仍然使用非函式特性。例如，函数的实"
"现仍会使用賦值给本地變量，但不會修改全局变量或产生其它副作用。"

#: ../../howto/functional.rst:81 ../../howto/functional.rst:79
#, fuzzy
msgid ""
"Functional programming can be considered the opposite of object-oriented "
"programming.  Objects are little capsules containing some internal state "
"along with a collection of method calls that let you modify this state, and "
"programs consist of making the right set of state changes.  Functional "
"programming wants to avoid state changes as much as possible and works with "
"data flowing between functions.  In Python you might combine the two "
"approaches by writing functions that take and return instances representing "
"objects in your application (e-mail messages, transactions, etc.)."
msgstr ""
"函式程式設計可視為物件導向程式設計的相反。物件是一些小膠囊，含有內部狀態和一"
"組方法調用，讓你可以修改此狀態，而程序則包括進行正確的設定更改。函式程式設計"
"希望盡可能避免更改硬體裝置，并且利用在函式之間流動的資料來進行運作。在Python"
"中，你可以透過撰寫接受並回傳屬於應用程式中去展現物件(例如電子郵件消息、交易"
"等) 的實例 函式來結合這兩種方法。"

#: ../../howto/functional.rst:90 ../../howto/functional.rst:88
#, fuzzy
msgid ""
"Functional design may seem like an odd constraint to work under.  Why should "
"you avoid objects and side effects?  There are theoretical and practical "
"advantages to the functional style:"
msgstr ""
"函式設計看似是一個奇怪的限制，為什麼要避免使用物件和副作用呢？但實踐中與理論"
"上都有函式風格的好處："

#: ../../howto/functional.rst:94 ../../howto/functional.rst:92
#, fuzzy
msgid "Formal provability."
msgstr "正式可證明性。"

#: ../../howto/functional.rst:95 ../../howto/functional.rst:93
msgid "Modularity."
msgstr "模組化。"

#: ../../howto/functional.rst:96 ../../howto/functional.rst:94
msgid "Composability."
msgstr "組合性。"

#: ../../howto/functional.rst:97 ../../howto/functional.rst:95
msgid "Ease of debugging and testing."
msgstr "除錯和測試的便利性。"

#: ../../howto/functional.rst:101 ../../howto/functional.rst:99
#, fuzzy
msgid "Formal provability"
msgstr "正式可證明性"

#: ../../howto/functional.rst:103 ../../howto/functional.rst:101
#, fuzzy
msgid ""
"A theoretical benefit is that it's easier to construct a mathematical proof "
"that a functional program is correct."
msgstr "一個理論上的好處是，構建數學證明能更容易地確認函式程式是否正確。"

#: ../../howto/functional.rst:106 ../../howto/functional.rst:104
#, fuzzy
msgid ""
"For a long time researchers have been interested in finding ways to "
"mathematically prove programs correct.  This is different from testing a "
"program on numerous inputs and concluding that its output is usually "
"correct, or reading a program's source code and concluding that the code "
"looks right; the goal is instead a rigorous proof that a program produces "
"the right result for all possible inputs."
msgstr ""
"許多研究者長期以來一直致力於找尋數學上證明程式正確性的方法。這和在大量輸入中"
"測試程式、並得出其輸出通常是正確的結果，或閱讀程式原始碼、並得出該程式碼看起"
"來沒有問題不同；此處的目標是嚴格地證明：對於所有可能的輸入，該程序都能產生正"
"確的結果。"

#: ../../howto/functional.rst:113 ../../howto/functional.rst:111
#, fuzzy
msgid ""
"The technique used to prove programs correct is to write down "
"**invariants**, properties of the input data and of the program's variables "
"that are always true.  For each line of code, you then show that if "
"invariants X and Y are true **before** the line is executed, the slightly "
"different invariants X' and Y' are true **after** the line is executed.  "
"This continues until you reach the end of the program, at which point the "
"invariants should match the desired conditions on the program's output."
msgstr ""
"證明程式的正確性技術是撰寫\\ **不變式 (invariants)**，這些不變式會反映輸入資"
"料和程式變數的屬性，而且總是成立。對於每行程式碼，在執行之前如果有不變式X與Y"
"成立，就必須證明在執行後相似但略為不同的 X' 與 Y' 也需成立。重複此程序直到結"
"束整段程式碼時，應該符合期望產生程式的輸出條件。"

#: ../../howto/functional.rst:121 ../../howto/functional.rst:119
#, fuzzy
msgid ""
"Functional programming's avoidance of assignments arose because assignments "
"are difficult to handle with this technique; assignments can break "
"invariants that were true before the assignment without producing any new "
"invariants that can be propagated onward."
msgstr ""
"函式程式設計不使用賦值是由於這種技術對處理賦值有困難。賦值會破壞先前的不變"
"量，且未產生可往後傳遞的新不變量。"

#: ../../howto/functional.rst:126 ../../howto/functional.rst:124
#, fuzzy
msgid ""
"Unfortunately, proving programs correct is largely impractical and not "
"relevant to Python software. Even trivial programs require proofs that are "
"several pages long; the proof of correctness for a moderately complicated "
"program would be enormous, and few or none of the programs you use daily "
"(the Python interpreter, your XML parser, your web browser) could be proven "
"correct.  Even if you wrote down or generated a proof, there would then be "
"the question of verifying the proof; maybe there's an error in it, and you "
"wrongly believe you've proved the program correct."
msgstr ""
"很不幸地，證明程式的正確性在實務上是不切實際且與 Python 軟體無關。即使是極簡"
"單的程式，其正確性的證明需要數頁才能完成；對於中等複雜度的程式來說，進行正確"
"性證明會非常龐大，在你日常使用的許多程式（例如 Python 直譯器、XML 解析器或瀏"
"覽器）當中只有少數甚至可能沒有被驗證過它們是否正確。即使你擁有或產生了一份可"
"用作該程序之正確性證明文件，仍需考量如何驗証該文件本身；也許裡面存在錯誤、而"
"你卻錯誤地相信你已經成功地予以變更完畢並儲存該結果。"

#: ../../howto/functional.rst:137 ../../howto/functional.rst:135
msgid "Modularity"
msgstr "模組化"

#: ../../howto/functional.rst:139 ../../howto/functional.rst:137
#, fuzzy
msgid ""
"A more practical benefit of functional programming is that it forces you to "
"break apart your problem into small pieces.  Programs are more modular as a "
"result.  It's easier to specify and write a small function that does one "
"thing than a large function that performs a complicated transformation.  "
"Small functions are also easier to read and to check for errors."
msgstr ""
"函式程式設計更切實的優點是它強迫你將問題分解成一個個小部分，程式因此變得更有"
"模組化。寫出只處理單一事項的小函式比較龐大且進行複雜轉換的大函式還要容易。另"
"外，促使拆分出多個小函式也可以增加易讀性和錯誤檢查效率。"

#: ../../howto/functional.rst:147 ../../howto/functional.rst:145
msgid "Ease of debugging and testing"
msgstr "除錯和測試的便利性"

#: ../../howto/functional.rst:149 ../../howto/functional.rst:147
#, fuzzy
msgid "Testing and debugging a functional-style program is easier."
msgstr "測試和除錯功能風格的程式比較容易。"

#: ../../howto/functional.rst:151 ../../howto/functional.rst:149
#, fuzzy
msgid ""
"Debugging is simplified because functions are generally small and clearly "
"specified.  When a program doesn't work, each function is an interface point "
"where you can check that the data are correct.  You can look at the "
"intermediate inputs and outputs to quickly isolate the function that's "
"responsible for a bug."
msgstr ""
"偵錯變得簡單，因為函式通常都很小又清楚明確。當程式出現問題時，每個函式都是一"
"個介面點，在那裡你可以檢查資料是否正確。你可以查看中間輸入和輸出來迅速分離負"
"責漏洞的函式。"

#: ../../howto/functional.rst:156 ../../howto/functional.rst:154
#, fuzzy
msgid ""
"Testing is easier because each function is a potential subject for a unit "
"test. Functions don't depend on system state that needs to be replicated "
"before running a test; instead you only have to synthesize the right input "
"and then check that the output matches expectations."
msgstr ""
"測試更簡單了，因為每個函式都可以成為單元測試的潛在對象。函式不依賴於需要複製"
"系統狀態以運行測試的系統狀態；相反，你只需合成正確的輸入，然後檢查輸出是否符"
"合預期。"

#: ../../howto/functional.rst:163 ../../howto/functional.rst:161
msgid "Composability"
msgstr "組合性"

#: ../../howto/functional.rst:165 ../../howto/functional.rst:163
#, fuzzy
msgid ""
"As you work on a functional-style program, you'll write a number of "
"functions with varying inputs and outputs.  Some of these functions will be "
"unavoidably specialized to a particular application, but others will be "
"useful in a wide variety of programs.  For example, a function that takes a "
"directory path and returns all the XML files in the directory, or a function "
"that takes a filename and returns its contents, can be applied to many "
"different situations."
msgstr ""
"當你在開發函式風格的程式時，會撰寫多個具有不同輸入和輸出的函式。一些函式會無"
"法避免地針對特定應用進行專門化設計，但其他部分則可以在許多不同類型 的程式中使"
"用。例如，一個接受目錄路徑並回傳該目錄中所有XML文件的函式，或者一個接受文件名"
"稱並回傳其內容的函式，在許多不同情況下都是非常實 用的。"

#: ../../howto/functional.rst:172 ../../howto/functional.rst:170
#, fuzzy
msgid ""
"Over time you'll form a personal library of utilities.  Often you'll "
"assemble new programs by arranging existing functions in a new configuration "
"and writing a few functions specialized for the current task."
msgstr ""
"隨著時間過去，你會建立一個個人函式庫 (library)。你常常只需要在排列現有的型別 "
"(type) 中加入一些引數 (argument) 與參數 (parameter)，並編寫幾個針對目前任務特"
"化的函式即可組裝新程式。"

#: ../../howto/functional.rst:180 ../../howto/functional.rst:178
msgid "Iterators"
msgstr "疊代器"

#: ../../howto/functional.rst:182 ../../howto/functional.rst:180
#, fuzzy
msgid ""
"I'll start by looking at a Python language feature that's an important "
"foundation for writing functional-style programs: iterators."
msgstr ""
"我會從一個對於撰寫函式程式非常重要的 Python 語言特性開始，那就是「疊代器」。"

#: ../../howto/functional.rst:185 ../../howto/functional.rst:183
#, fuzzy
msgid ""
"An iterator is an object representing a stream of data; this object returns "
"the data one element at a time.  A Python iterator must support a method "
"called :meth:`~iterator.__next__` that takes no arguments and always returns "
"the next element of the stream.  If there are no more elements in the "
"stream, :meth:`~iterator.__next__` must raise the :exc:`StopIteration` "
"exception. Iterators don't have to be finite, though; it's perfectly "
"reasonable to write an iterator that produces an infinite stream of data."
msgstr ""
"一個疊代器 (iterator) 是代表資料串流的物件；這個物件會一次回傳一個元素。在 "
"Python 中，疊代器必須支援名為 :meth:`~iterator.__next__` 的方法，不需接受任何"
"引數且永遠回傳串流中下一個元素。若串流中沒有更多元素則 :meth:`~iterator."
"__next__` 必須引發 :exc:`StopIteration` 例外。雖然疊代器可以是非有限的，在程"
"式中撰寫可產生無限資料串流的疊代器也完全合理。"

#: ../../howto/functional.rst:193 ../../howto/functional.rst:191
#, fuzzy
msgid ""
"The built-in :func:`iter` function takes an arbitrary object and tries to "
"return an iterator that will return the object's contents or elements, "
"raising :exc:`TypeError` if the object doesn't support iteration.  Several "
"of Python's built-in data types support iteration, the most common being "
"lists and dictionaries.  An object is called :term:`iterable` if you can get "
"an iterator for it."
msgstr ""
"內建的 :func:`iter` 函式可以接受任意物件，並嘗試回傳一個疊代器以回傳物件的內"
"容或元素，若該物件不支援疊代則會產生 :exc:`TypeError`。Python 的多數內建資料"
"型別支援疊代，最常見的是串列和字典。當你能夠取得一個疊代器來處理某個物件時，"
"這個物件就稱作是 :term:`可疊代物件 (iterable) <iterable>`。"

#: ../../howto/functional.rst:200 ../../howto/functional.rst:198
msgid "You can experiment with the iteration interface manually:"
msgstr "你可以手動實驗疊代介面："

#: ../../howto/functional.rst:218 ../../howto/functional.rst:216
#, fuzzy
msgid ""
"Python expects iterable objects in several different contexts, the most "
"important being the :keyword:`for` statement.  In the statement ``for X in "
"Y``, Y must be an iterator or some object for which :func:`iter` can create "
"an iterator.  These two statements are equivalent::"
msgstr ""
"Python 在多種情況下會期待可疊代物件，其中最主要的情況是在 :keyword:`for` 陳述"
"式中。在 ``for X in Y`` 的陳述式當中，變數 Y 必須為一個疊代器(iterator)或可使"
"用 :func:`iter` 建立出疊代器的物件(object)。以下兩個陳述式亦具相同解釋： ::"

#: ../../howto/functional.rst:224
msgid ""
"for i in iter(obj):\n"
"    print(i)\n"
"\n"
"for i in obj:\n"
"    print(i)"
msgstr ""
"for i in iter(obj):\n"
"    print(i)\n"
"\n"
"for i in obj:\n"
"    print(i)"

#: ../../howto/functional.rst:230 ../../howto/functional.rst:228
msgid ""
"Iterators can be materialized as lists or tuples by using the :func:`list` "
"or :func:`tuple` constructor functions:"
msgstr ""
"使用 :func:`list` 或 :func:`tuple` 建構函式可以將疊代器具現為串列或元組："

#: ../../howto/functional.rst:239 ../../howto/functional.rst:237
msgid ""
"Sequence unpacking also supports iterators: if you know an iterator will "
"return N elements, you can unpack them into an N-tuple:"
msgstr ""
"序列解包 (Sequence unpacking) 也支援疊代器：如果你知道一個疊代器會回傳 N 個元"
"素，你可以將它們解包成一個 N-tuple："

#: ../../howto/functional.rst:248 ../../howto/functional.rst:246
#, fuzzy
msgid ""
"Built-in functions such as :func:`max` and :func:`min` can take a single "
"iterator argument and will return the largest or smallest element.  The "
"``\"in\"`` and ``\"not in\"`` operators also support iterators: ``X in "
"iterator`` is true if X is found in the stream returned by the iterator.  "
"You'll run into obvious problems if the iterator is infinite; :func:`max`, :"
"func:`min` will never return, and if the element X never appears in the "
"stream, the ``\"in\"`` and ``\"not in\"`` operators won't return either."
msgstr ""
"Python 中的內建函式（如：:func:`max`、:func:`min`）可以接受單一的疊代器引數，"
"並回傳該疊代器中最大或最小的元素。而 ``\"in\"`` 和 ``\"not in\"`` 運算子也支"
"援疊代器：當 X 在該疊代器回傳之串流中被找到時，``X in iterator`` 會為真。如果"
"所提供的疊代器是無限大的，你將會遇到明顯問題；:func:`max` 或 :func:`min` 永不"
"結束，若元素 X 未出現於串流中, ``\"in\"`` 和 ``\"not in\"`` 運算子將同時失"
"效。"

#: ../../howto/functional.rst:256 ../../howto/functional.rst:254
#, fuzzy
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it.  Iterator "
"objects can optionally provide these additional capabilities, but the "
"iterator protocol only specifies the :meth:`~iterator.__next__` method.  "
"Functions may therefore consume all of the iterator's output, and if you "
"need to do something different with the same stream, you'll have to create a "
"new iterator."
msgstr ""
"注意，你只能在疊代器中向前移動；沒有辦法獲取先前的元素、重置疊代器或複製它。"
"疊代器物件可以選擇提供這些額外功能，但是疊代協議僅指定了:meth:`~iterator."
"__next__` 方法。因此函式可能會消耗所有疊代器的輸出，如果你需要使用相同的流做"
"一些不同的事情，則必須建立新的疊代器。"

#: ../../howto/functional.rst:266 ../../howto/functional.rst:264
msgid "Data Types That Support Iterators"
msgstr "支援疊代器的資料型別"

#: ../../howto/functional.rst:268 ../../howto/functional.rst:266
msgid ""
"We've already seen how lists and tuples support iterators.  In fact, any "
"Python sequence type, such as strings, will automatically support creation "
"of an iterator."
msgstr ""
"我們已經看過了串列和元組如何支援疊代器。事實上，任何 Python 序列型別（例如字"
"串）都會自動支援建立疊代器。"

#: ../../howto/functional.rst:272 ../../howto/functional.rst:270
#, fuzzy
msgid ""
"Calling :func:`iter` on a dictionary returns an iterator that will loop over "
"the dictionary's keys::"
msgstr "呼叫 `iter` 函式處理字典會回傳一個疊代器，可循環取得該字典的鍵： ::"

#: ../../howto/functional.rst:275
msgid ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}\n"
">>> for key in m:\n"
"...     print(key, m[key])\n"
"Jan 1\n"
"Feb 2\n"
"Mar 3\n"
"Apr 4\n"
"May 5\n"
"Jun 6\n"
"Jul 7\n"
"Aug 8\n"
"Sep 9\n"
"Oct 10\n"
"Nov 11\n"
"Dec 12"
msgstr ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}\n"
">>> for key in m:\n"
"...     print(key, m[key])\n"
"Jan 1\n"
"Feb 2\n"
"Mar 3\n"
"Apr 4\n"
"May 5\n"
"Jun 6\n"
"Jul 7\n"
"Aug 8\n"
"Sep 9\n"
"Oct 10\n"
"Nov 11\n"
"Dec 12"

#: ../../howto/functional.rst:292 ../../howto/functional.rst:290
#, fuzzy
msgid ""
"Note that starting with Python 3.7, dictionary iteration order is guaranteed "
"to be the same as the insertion order. In earlier versions, the behaviour "
"was unspecified and could vary between implementations."
msgstr ""
"注意，在 Python 3.7 版本後，字典的疊代順序保證與插入順序相同。在較早的版本"
"中，此行為未定義且可能因實作而異。"

#: ../../howto/functional.rst:296 ../../howto/functional.rst:294
#, fuzzy
msgid ""
"Applying :func:`iter` to a dictionary always loops over the keys, but "
"dictionaries have methods that return other iterators.  If you want to "
"iterate over values or key/value pairs, you can explicitly call the :meth:"
"`~dict.values` or :meth:`~dict.items` methods to get an appropriate iterator."
msgstr ""
"將 :func:`iter` 應用於字典時，會一直遍歷鍵 (key)，但是字典有其它回傳疊代器的"
"方法。因此如果你想要對值 (value) 或鍵/值 (key/value) 進行疊代操作，可以明確呼"
"叫 :meth:`~dict.values` 或 :meth:`~dict.items` 方法取得相應的疊代器。"

#: ../../howto/functional.rst:302 ../../howto/functional.rst:300
msgid ""
"The :func:`dict` constructor can accept an iterator that returns a finite "
"stream of ``(key, value)`` tuples:"
msgstr ""
":func:`dict` 建構式可接受回傳有限 ``(key, value)`` 元組之串流的疊代器："

#: ../../howto/functional.rst:309 ../../howto/functional.rst:307
msgid ""
"Files also support iteration by calling the :meth:`~io.TextIOBase.readline` "
"method until there are no more lines in the file.  This means you can read "
"each line of a file like this::"
msgstr ""
"檔案還支援疊代，我們可以呼叫 :meth:`~io.TextIOBase.readline` 方法來逐行讀取檔"
"案，直到檔案結束為止。也就是說，我們可以透過以下方式來逐一讀取檔案中的每一"
"行： ::"

#: ../../howto/functional.rst:313
msgid ""
"for line in file:\n"
"    # do something for each line\n"
"    ..."
msgstr ""
"for line in file:\n"
"    # 為每一列都做某些事情\n"
"    ..."

#: ../../howto/functional.rst:317 ../../howto/functional.rst:315
#, fuzzy
msgid ""
"Sets can take their contents from an iterable and let you iterate over the "
"set's elements::"
msgstr ""
"set 型別可以由 iterable 取得其內容，並且讓你能夠疊代(set iteration)所有的元"
"素： ::"

#: ../../howto/functional.rst:320
msgid ""
">>> S = {2, 3, 5, 7, 11, 13}\n"
">>> for i in S:\n"
"...     print(i)\n"
"2\n"
"3\n"
"5\n"
"7\n"
"11\n"
"13"
msgstr ""
">>> S = {2, 3, 5, 7, 11, 13}\n"
">>> for i in S:\n"
"...     print(i)\n"
"2\n"
"3\n"
"5\n"
"7\n"
"11\n"
"13"

#: ../../howto/functional.rst:333 ../../howto/functional.rst:331
msgid "Generator expressions and list comprehensions"
msgstr "產生器運算式與串列綜合運算"

#: ../../howto/functional.rst:335 ../../howto/functional.rst:333
#, fuzzy
msgid ""
"Two common operations on an iterator's output are 1) performing some "
"operation for every element, 2) selecting a subset of elements that meet "
"some condition. For example, given a list of strings, you might want to "
"strip off trailing whitespace from each line or extract all the strings "
"containing a given substring."
msgstr ""
"疊代器的輸出上，兩個常見操作為 1) 對每個元素進行某些操作、2) 選擇符合特定條件"
"的元素子集。例如，給定一個字串串列，你可能希望從每行中去除尾部空格或提取所有"
"包含特定子字串的字串。"

#: ../../howto/functional.rst:341 ../../howto/functional.rst:339
msgid ""
"List comprehensions and generator expressions (short form: \"listcomps\" and "
"\"genexps\") are a concise notation for such operations, borrowed from the "
"functional programming language Haskell (https://www.haskell.org/).  You can "
"strip all the whitespace from a stream of strings with the following code::"
msgstr ""
"串列綜合運算和產生器運算式（list comprehensions 與 generator expressions，簡"
"稱 \"listcomps\" 和 \"genexps\"）是對於這類操作的一個簡潔的表示法，為借用自函"
"式程式語言 Haskell (https://www.haskell.org/)。你可以使用以下程式碼從字串串流"
"中刪除所有空格： ::"

#: ../../howto/functional.rst:346
msgid ""
">>> line_list = ['  line 1\\n', 'line 2  \\n', ' \\n', '']\n"
"\n"
">>> # Generator expression -- returns iterator\n"
">>> stripped_iter = (line.strip() for line in line_list)\n"
"\n"
">>> # List comprehension -- returns list\n"
">>> stripped_list = [line.strip() for line in line_list]"
msgstr ""
">>> line_list = ['  line 1\\n', 'line 2  \\n', ' \\n', '']\n"
"\n"
">>> # 產生器運算式 -- 回傳疊代器\n"
">>> stripped_iter = (line.strip() for line in line_list)\n"
"\n"
">>> # 串列綜合運算 -- 回傳串列\n"
">>> stripped_list = [line.strip() for line in line_list]"

#: ../../howto/functional.rst:354 ../../howto/functional.rst:352
msgid ""
"You can select only certain elements by adding an ``\"if\"`` condition::"
msgstr "你可以透過加入 ``\"if\"`` 條件來只選擇出特定的元素： ::"

#: ../../howto/functional.rst:356
msgid ""
">>> stripped_list = [line.strip() for line in line_list\n"
"...                  if line != \"\"]"
msgstr ""
">>> stripped_list = [line.strip() for line in line_list\n"
"...                  if line != \"\"]"

#: ../../howto/functional.rst:359 ../../howto/functional.rst:357
#, fuzzy
msgid ""
"With a list comprehension, you get back a Python list; ``stripped_list`` is "
"a list containing the resulting lines, not an iterator.  Generator "
"expressions return an iterator that computes the values as necessary, not "
"needing to materialize all the values at once.  This means that list "
"comprehensions aren't useful if you're working with iterators that return an "
"infinite stream or a very large amount of data.  Generator expressions are "
"preferable in these situations."
msgstr ""
"使用串列綜合運算，可以得到一個 Python 串列；`stripped_list` 是包含結果行的串"
"列，而不是疊代器。產生器運算式回傳會根據需要計算值的疊代器，它不需要一次性將"
"所有值都實現。這意味著如果你正在使用回傳無限流或大量資料的遠程執行引數時，列"
"表推導可能並不好用。在這些情況下更適合使用產生器運算式。"

#: ../../howto/functional.rst:366 ../../howto/functional.rst:364
#, fuzzy
msgid ""
"Generator expressions are surrounded by parentheses (\"()\") and list "
"comprehensions are surrounded by square brackets (\"[]\").  Generator "
"expressions have the form::"
msgstr ""
"產生器運算式被圓括號（\"()\"）包圍，而串列綜合運算則被方括號(\"[]\")包圍。產"
"生器運算式的形式為： ::"

#: ../../howto/functional.rst:370
msgid ""
"( expression for expr in sequence1\n"
"             if condition1\n"
"             for expr2 in sequence2\n"
"             if condition2\n"
"             for expr3 in sequence3\n"
"             ...\n"
"             if condition3\n"
"             for exprN in sequenceN\n"
"             if conditionN )"
msgstr ""
"( expression for expr in sequence1\n"
"             if condition1\n"
"             for expr2 in sequence2\n"
"             if condition2\n"
"             for expr3 in sequence3\n"
"             ...\n"
"             if condition3\n"
"             for exprN in sequenceN\n"
"             if conditionN )"

#: ../../howto/functional.rst:380 ../../howto/functional.rst:378
msgid ""
"Again, for a list comprehension only the outside brackets are different "
"(square brackets instead of parentheses)."
msgstr ""
"再次提醒，串列綜合運算只有外層括號不同（使用方括號 (square brackets) 而非小括"
"號 (parentheses)）。"

#: ../../howto/functional.rst:383 ../../howto/functional.rst:381
#, fuzzy
msgid ""
"The elements of the generated output will be the successive values of "
"``expression``.  The ``if`` clauses are all optional; if present, "
"``expression`` is only evaluated and added to the result when ``condition`` "
"is true."
msgstr ""
"生成的輸出元素將是 ``expression`` 連續的值。如果有，``if`` 子句都是可選的；如"
"果存在，只有當條件為 true 時才會評估並添加 ``expression`` 到結果中。"

#: ../../howto/functional.rst:387 ../../howto/functional.rst:385
#, fuzzy
msgid ""
"Generator expressions always have to be written inside parentheses, but the "
"parentheses signalling a function call also count.  If you want to create an "
"iterator that will be immediately passed to a function you can write::"
msgstr ""
"產生器運算式總是必須寫在括號內，但用於函式呼叫的括號也被視為一種。如果想要創"
"建一個立即傳入函式中的疊代器，可寫成： ::"

#: ../../howto/functional.rst:391
msgid "obj_total = sum(obj.count for obj in list_all_objects())"
msgstr "obj_total = sum(obj.count for obj in list_all_objects())"

#: ../../howto/functional.rst:393 ../../howto/functional.rst:391
#, fuzzy
msgid ""
"The ``for...in`` clauses contain the sequences to be iterated over.  The "
"sequences do not have to be the same length, because they are iterated over "
"from left to right, **not** in parallel.  For each element in ``sequence1``, "
"``sequence2`` is looped over from the beginning.  ``sequence3`` is then "
"looped over for each resulting pair of elements from ``sequence1`` and "
"``sequence2``."
msgstr ""
"``for...in`` 子句包含要疊代的序列。序列的長度不必相同，因為它們是從左到右疊代"
"的，**不是**並行的。對於「sequence1」中的每個元素，「sequence2」從頭開始循"
"環。然後，對來自“sequence1”和“sequence2”的每個結果元素對“sequence3”進行循環。"

#: ../../howto/functional.rst:399 ../../howto/functional.rst:397
#, fuzzy
msgid ""
"To put it another way, a list comprehension or generator expression is "
"equivalent to the following Python code::"
msgstr "換句話說，串列綜合運算或產生器運算式相當於以下 Python 程式碼： ::"

#: ../../howto/functional.rst:402
msgid ""
"for expr1 in sequence1:\n"
"    if not (condition1):\n"
"        continue   # Skip this element\n"
"    for expr2 in sequence2:\n"
"        if not (condition2):\n"
"            continue   # Skip this element\n"
"        ...\n"
"        for exprN in sequenceN:\n"
"            if not (conditionN):\n"
"                continue   # Skip this element\n"
"\n"
"            # Output the value of\n"
"            # the expression."
msgstr ""

#: ../../howto/functional.rst:416 ../../howto/functional.rst:414
#, fuzzy
msgid ""
"This means that when there are multiple ``for...in`` clauses but no ``if`` "
"clauses, the length of the resulting output will be equal to the product of "
"the lengths of all the sequences.  If you have two lists of length 3, the "
"output list is 9 elements long:"
msgstr ""
"這表示當有多個 ``for ... in`` 子句但沒有 ``if`` 子句時，輸出的長度會等於所有"
"序列長度的乘積。如果你有兩個長度為 3 的串列，則輸出串列將包含 9 個元素："

#: ../../howto/functional.rst:428 ../../howto/functional.rst:426
#, fuzzy
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if ``expression`` "
"is creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"為避免 Python 語法產生歧義，在建立元組時必須使用括號將「expression」包圍。第"
"一個串列綜合運算是語法錯誤，而第二個則正確： ::"

#: ../../howto/functional.rst:432
msgid ""
"# Syntax error\n"
"[x, y for x in seq1 for y in seq2]\n"
"# Correct\n"
"[(x, y) for x in seq1 for y in seq2]"
msgstr ""
"# 語法錯誤\n"
"[x, y for x in seq1 for y in seq2]\n"
"# 正確\n"
"[(x, y) for x in seq1 for y in seq2]"

#: ../../howto/functional.rst:439 ../../howto/functional.rst:437
#, fuzzy
msgid "Generators"
msgstr "產生器"

#: ../../howto/functional.rst:441 ../../howto/functional.rst:439
#, fuzzy
msgid ""
"Generators are a special class of functions that simplify the task of "
"writing iterators.  Regular functions compute a value and return it, but "
"generators return an iterator that returns a stream of values."
msgstr ""
"產生器是一種特殊類型的函式，可簡化疊代器撰寫任務。通常函式運算並且回傳值，但"
"產生器回傳一個可提供一系列值得疊代物件。"

#: ../../howto/functional.rst:445 ../../howto/functional.rst:443
#, fuzzy
msgid ""
"You're doubtless familiar with how regular function calls work in Python or "
"C. When you call a function, it gets a private namespace where its local "
"variables are created.  When the function reaches a ``return`` statement, "
"the local variables are destroyed and the value is returned to the caller.  "
"A later call to the same function creates a new private namespace and a "
"fresh set of local variables. But, what if the local variables weren't "
"thrown away on exiting a function?  What if you could later resume the "
"function where it left off?  This is what generators provide; they can be "
"thought of as resumable functions."
msgstr ""
"你應該對在 Python 或 C 中如何呼叫常規函式很熟悉。當你呼叫一個函式時，它會得到"
"一個私用的命名空間以建立其本地變量。當函式達到`return`語句時，這些本地變量就"
"被銷毀並回傳值給呼叫者。後續對相同函式的調用會建立新的私有命名空間和全新集合"
"的本地變數。但是，如果退出函数时不要丟棄本地变量怎么办？ 如果你可以稍后恢复该"
"函数从离开点处继续执行会怎样？这就是產生器提供了什么；它们可以视为可恢复功能"

#: ../../howto/functional.rst:454 ../../howto/functional.rst:452
#, fuzzy
msgid "Here's the simplest example of a generator function:"
msgstr "以下是 generator function 最簡單的範例:"

#: ../../howto/functional.rst:460 ../../howto/functional.rst:458
#, fuzzy
msgid ""
"Any function containing a :keyword:`yield` keyword is a generator function; "
"this is detected by Python's :term:`bytecode` compiler which compiles the "
"function specially as a result."
msgstr ""
"任何包含 :keyword:`yield` 關鍵字的函式都是產生器(generator) 函式；Python 的 "
"**字節碼（bytecode）** 編譯器會特別地編譯這種函式。"

#: ../../howto/functional.rst:464 ../../howto/functional.rst:462
#, fuzzy
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the ``yield`` expression, the generator outputs the value of "
"``i``, similar to a ``return`` statement.  The big difference between "
"``yield`` and a ``return`` statement is that on reaching a ``yield`` the "
"generator's state of execution is suspended and local variables are "
"preserved.  On the next call to the generator's :meth:`~generator.__next__` "
"method, the function will resume executing."
msgstr ""
"當你調用 generator function 時，它並不會回傳單一的值；而是回傳支援疊代器協定"
"(iterator protocol) 的 generator 物件。當執行到 ``yield`` 運算式時，程式將輸"
"出變數 i 的值，就像使用 ``return`` 陳述句時一樣。``yield`` 與 ``return`` 陳述"
"句間的差別在於，在達成「yield」後，generator 程序被暫停並保留當下本地變數"
"(local variables) 後往下執行。接下來再次呼叫該generator物件之 :meth:"
"`~generator.__next__` 方法時，此函式將繼續執行。"

#: ../../howto/functional.rst:473 ../../howto/functional.rst:471
#, fuzzy
msgid "Here's a sample usage of the ``generate_ints()`` generator:"
msgstr "以下是 ``generate_ints()`` 產生器的一個範例使用："

#: ../../howto/functional.rst:490 ../../howto/functional.rst:488
#, fuzzy
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a, b, c = "
"generate_ints(3)``."
msgstr ""
"你可以同樣寫為 ``for i in generate_ints(5)``，或者是 ``a, b, c = "
"generate_ints(3)``。"

#: ../../howto/functional.rst:493 ../../howto/functional.rst:491
#, fuzzy
msgid ""
"Inside a generator function, ``return value`` causes "
"``StopIteration(value)`` to be raised from the :meth:`~generator.__next__` "
"method.  Once this happens, or the bottom of the function is reached, the "
"procession of values ends and the generator cannot yield any further values."
msgstr ""
"在產生器函式中，使用 ``return value`` 會導致從 :meth:`~generator.__next__` 方"
"法中拋出 ``StopIteration(value)``。一旦此情況發生或函式已執行到最深層，數值序"
"列即停止進展且該產生器函式無法再繼續或提供後續之值。"

#: ../../howto/functional.rst:498 ../../howto/functional.rst:496
#, fuzzy
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`~iterator.__next__` "
"method increment ``self.count`` and return it. However, for a moderately "
"complicated generator, writing a corresponding class can be much messier."
msgstr ""
"你可以透過手動編寫類別，並將所有產生器的區域變數存儲為實例變數感受到產生器效"
"果。例如，回傳一個整數串列可透過設置「self.count」為0，並在: meth：`〜"
"iterator. __ next__`方法中增加「self.count」並回傳它來完成。但是，對於中等程"
"度複雜的產生器 ，編寫相應的類可能會更加混亂。"

#: ../../howto/functional.rst:506 ../../howto/functional.rst:504
#, fuzzy
msgid ""
"The test suite included with Python's library, :source:`Lib/test/"
"test_generators.py`, contains a number of more interesting examples.  Here's "
"one generator that implements an in-order traversal of a tree using "
"generators recursively. ::"
msgstr ""
"Python 函式庫內所附的測試套件 :source:`Lib/test/test_generators.py` 包含許多"
"有趣的範例。以下是一個使用遞迴單元產生器實作樹之中序走訪程式範例。 ::"

#: ../../howto/functional.rst:511
msgid ""
"# A recursive generator that generates Tree leaves in in-order.\n"
"def inorder(t):\n"
"    if t:\n"
"        for x in inorder(t.left):\n"
"            yield x\n"
"\n"
"        yield t.label\n"
"\n"
"        for x in inorder(t.right):\n"
"            yield x"
msgstr ""

#: ../../howto/functional.rst:522 ../../howto/functional.rst:520
#, fuzzy
msgid ""
"Two other examples in ``test_generators.py`` produce solutions for the N-"
"Queens problem (placing N queens on an NxN chess board so that no queen "
"threatens another) and the Knight's Tour (finding a route that takes a "
"knight to every square of an NxN chessboard without visiting any square "
"twice)."
msgstr ""
"在 ``test_generators.py`` 中有另外兩個例子解決 N 皇后問題 （在 NxN 的象棋盤上"
"放置 N 個皇后，使得每個皇后不互相威脅）以及騎士巡迴（找到一條路徑讓騎士遍歷 "
"NxN 的棋盤且不重複造訪任何一格）。"

#: ../../howto/functional.rst:530 ../../howto/functional.rst:528
#, fuzzy
msgid "Passing values into a generator"
msgstr "傳遞參數至產生器"

#: ../../howto/functional.rst:532 ../../howto/functional.rst:530
#, fuzzy
msgid ""
"In Python 2.4 and earlier, generators only produced output.  Once a "
"generator's code was invoked to create an iterator, there was no way to pass "
"any new information into the function when its execution is resumed.  You "
"could hack together this ability by making the generator look at a global "
"variable or by passing in some mutable object that callers then modify, but "
"these approaches are messy."
msgstr ""
"在 Python 2.4 及之前的版本中，產生器只能產生輸出。一旦啟動產生器程式碼以建立"
"疊代器，當其執行被恢復時就無法傳遞任何新信息進入函式中。你可以透過使產生器查"
"看全局變數或傳入某些可變對象然後由調用者修改來編寫此功能，但這種方法很麻煩。"

#: ../../howto/functional.rst:539 ../../howto/functional.rst:537
#, fuzzy
msgid ""
"In Python 2.5 there's a simple way to pass values into a generator. :keyword:"
"`yield` became an expression, returning a value that can be assigned to a "
"variable or otherwise operated on::"
msgstr ""
"在Python 2.5中，有一種簡單的方法可以將值傳遞給產生器。``yield`` 成為一個表達"
"式，會回傳可指派給變數或進行其他操作的值： ::"

#: ../../howto/functional.rst:543
msgid "val = (yield i)"
msgstr "val = (yield i)"

#: ../../howto/functional.rst:545 ../../howto/functional.rst:543
#, fuzzy
msgid ""
"I recommend that you **always** put parentheses around a ``yield`` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"建議當處理 ``yield`` 回傳的值時，請**總是**加上括號，如前述範例所示。這樣做並"
"非必要，但如果一直加上括號會比記得何時需要更容易。"

#: ../../howto/functional.rst:550 ../../howto/functional.rst:548
#, fuzzy
msgid ""
"(:pep:`342` explains the exact rules, which are that a ``yield``-expression "
"must always be parenthesized except when it occurs at the top-level "
"expression on the right-hand side of an assignment.  This means you can "
"write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(:pep:`342` 指出準確的規則，即必須為 ``yield``-expression 加入括號，除非它出"
"現在指派運算式右側的最上層運算式。這意味著如果有運算，你需要使用括號，例如: "
"``val = (yield i) + 12``，但是你也可以直接寫成 ``val = yield i`` 避免使用括號"
"以作為最上層運算式。)"

#: ../../howto/functional.rst:556 ../../howto/functional.rst:554
#, fuzzy
msgid ""
"Values are sent into a generator by calling its :meth:`send(value) "
"<generator.send>` method.  This method resumes the generator's code and the "
"``yield`` expression returns the specified value.  If the regular :meth:"
"`~generator.__next__` method is called, the ``yield`` returns ``None``."
msgstr ""
"透過呼叫產生器的 :meth:`send(value) <generator.send>` 方法，可以將值送入產生"
"器。此方法重新啟動產生器執行程式並回傳指定的值，若是以一般 :meth:`~generator."
"__next__` 方法呼叫時，則會回傳 `None`。"

#: ../../howto/functional.rst:561 ../../howto/functional.rst:559
#, fuzzy
msgid ""
"Here's a simple counter that increments by 1 and allows changing the value "
"of the internal counter."
msgstr "這裡有一個簡單的計數器，可以使內部變數增量1並允許改變其值。"

#: ../../howto/functional.rst:564
msgid ""
"def counter(maximum):\n"
"    i = 0\n"
"    while i < maximum:\n"
"        val = (yield i)\n"
"        # If value provided, change counter\n"
"        if val is not None:\n"
"            i = val\n"
"        else:\n"
"            i += 1"
msgstr ""

#: ../../howto/functional.rst:576 ../../howto/functional.rst:574
#, fuzzy
msgid "And here's an example of changing the counter:"
msgstr "下面是更改計數器的範例:"

#: ../../howto/functional.rst:593 ../../howto/functional.rst:591
#, fuzzy
msgid ""
"Because ``yield`` will often be returning ``None``, you should always check "
"for this case.  Don't just use its value in expressions unless you're sure "
"that the :meth:`~generator.send` method will be the only method used to "
"resume your generator function."
msgstr ""
"因為 ``yield`` 非常容易回傳成 `None`，所以你必須特別留意這種情況。除非你確定"
"只會使用 :meth:`~generator.send` 來重新啟動產生器函式，否則不要直接在運算中使"
"用其的回傳值。"

#: ../../howto/functional.rst:598 ../../howto/functional.rst:596
#, fuzzy
msgid ""
"In addition to :meth:`~generator.send`, there are two other methods on "
"generators:"
msgstr "除了 ``generator.send`` 方法之外，產生器還有另外兩種方法："

#: ../../howto/functional.rst:601 ../../howto/functional.rst:599
#, fuzzy
msgid ""
":meth:`throw(value) <generator.throw>` is used to raise an exception inside "
"the generator; the exception is raised by the ``yield`` expression where the "
"generator's execution is paused."
msgstr ""
":meth:`throw(value) <generator.throw>` 用於在產生器內部引發異常；該異常由暫停"
"產生器執行的 ``yield`` 運算式引發。"

#: ../../howto/functional.rst:605 ../../howto/functional.rst:603
#, fuzzy
msgid ""
":meth:`~generator.close` raises a :exc:`GeneratorExit` exception inside the "
"generator to terminate the iteration.  On receiving this exception, the "
"generator's code must either raise :exc:`GeneratorExit` or :exc:"
"`StopIteration`; catching the exception and doing anything else is illegal "
"and will trigger a :exc:`RuntimeError`.  :meth:`~generator.close` will also "
"be called by Python's garbage collector when the generator is garbage-"
"collected."
msgstr ""
":meth:`~generator.close()` 會在產生器(iterator)中丟出 :exc:`GeneratorExit`例"
"外來終止疊代。當接收到此例外時，產生器的程式碼必須將其拋出 :exc:"
"`GeneratorExit` 或是 :exc:`StopIteration`; 接住這個例外做任何其他事情都是不合"
"法的，而且會觸發一個 :exc:`RuntimeError`。當垃圾回收系統處理釋放記憶體回收"
"(generator物件)，也會呼叫:meth:`~generator.close()`。"

#: ../../howto/functional.rst:613 ../../howto/functional.rst:611
#, fuzzy
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of catching :exc:"
"`GeneratorExit`."
msgstr ""
"如果你需要在 :exc:`GeneratorExit` 發生時運行清理程式，我建議使用 ``try: ... "
"finally:`` 套件區塊替代捕獲 :exc:`GeneratorExit`。"

#: ../../howto/functional.rst:616 ../../howto/functional.rst:614
#, fuzzy
msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr ""
"這些變更的累積效應是，將產生資訊的單向產生器轉換為同時兼具生成及消費能力。"

#: ../../howto/functional.rst:619 ../../howto/functional.rst:617
#, fuzzy
msgid ""
"Generators also become **coroutines**, a more generalized form of "
"subroutines. Subroutines are entered at one point and exited at another "
"point (the top of the function, and a ``return`` statement), but coroutines "
"can be entered, exited, and resumed at many different points (the ``yield`` "
"statements)."
msgstr ""
"產生器也可以變成 **協程(coroutine)** ，一種更廣義的子程序(subroutine)形式。子"
"程序從一個點進入並在另一個點退出(函式頂部和“return”語句)，但是協程可以在許多"
"不同的點中被進入、退出和恢復（``yield`` 語句）。"

#: ../../howto/functional.rst:626 ../../howto/functional.rst:624
msgid "Built-in functions"
msgstr "內建函式"

#: ../../howto/functional.rst:628 ../../howto/functional.rst:626
#, fuzzy
msgid ""
"Let's look in more detail at built-in functions often used with iterators."
msgstr "讓我們更詳細地看一下與疊代器經常使用的內建函式。"

#: ../../howto/functional.rst:630 ../../howto/functional.rst:628
#, fuzzy
msgid ""
"Two of Python's built-in functions, :func:`map` and :func:`filter` duplicate "
"the features of generator expressions:"
msgstr ""
"Python 內建函式 :func:`map` 和 :func:`filter` 兩個函式，都有產生器運算 expr "
"的功能。"

#: ../../howto/functional.rst:633 ../../howto/functional.rst:640
#, fuzzy
msgid ""
":func:`map(f, iterA, iterB, ...) <map>` returns an iterator over the sequence"
msgstr ""
":func:`map(f, iterA, iterB...) <map>` 回傳一個疊代器，此疊代器針對序列進行映"
"射。"

#: ../../howto/functional.rst:634 ../../howto/functional.rst:632
#, fuzzy
msgid ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."
msgstr ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2])...``。"
"（註解：這個是用在 Python 中「將若干個 iterable 作為參數餵給一個函式」的快速"
"寫法，`zip` 在這種情況下表現得特別優秀。）"

#: ../../howto/functional.rst:644 ../../howto/functional.rst:642
#, fuzzy
msgid "You can of course achieve the same effect with a list comprehension."
msgstr "你當然可以使用串列綜合運算來達到相同的效果。"

#: ../../howto/functional.rst:646 ../../howto/functional.rst:644
#, fuzzy
msgid ""
":func:`filter(predicate, iter) <filter>` returns an iterator over all the "
"sequence elements that meet a certain condition, and is similarly duplicated "
"by list comprehensions.  A **predicate** is a function that returns the "
"truth value of some condition; for use with :func:`filter`, the predicate "
"must take a single value."
msgstr ""
":func:`filter(predicate, iter) <filter>` 會回傳一個疊代器，其中包含符合特定條"
"件的所有序列元素。此功能與串列綜合運算類似地運作。**predicate（謂詞）** 是一"
"種函式，用於回傳某些情況下的真實值；對於 :func:`filter` 的使用，謂詞必須接受"
"單個值作為引數。"

#: ../../howto/functional.rst:659 ../../howto/functional.rst:657
#, fuzzy
msgid "This can also be written as a list comprehension:"
msgstr "這個也可以被形式化為串列綜合運算："

#: ../../howto/functional.rst:665 ../../howto/functional.rst:663
#, fuzzy
msgid ""
":func:`enumerate(iter, start=0) <enumerate>` counts off the elements in the "
"iterable returning 2-tuples containing the count (from *start*) and each "
"element. ::"
msgstr ""
":func:`enumerate(iter, start=0) <enumerate>` 函数可用来枚举 iterable 中元素的"
"序号并回傳一个二元组，包含了序号（从 *start* 开始）以及每个元素。 ::"

#: ../../howto/functional.rst:669
msgid ""
">>> for item in enumerate(['subject', 'verb', 'object']):\n"
"...     print(item)\n"
"(0, 'subject')\n"
"(1, 'verb')\n"
"(2, 'object')"
msgstr ""
">>> for item in enumerate(['subject', 'verb', 'object']):\n"
"...     print(item)\n"
"(0, 'subject')\n"
"(1, 'verb')\n"
"(2, 'object')"

#: ../../howto/functional.rst:675 ../../howto/functional.rst:673
#, fuzzy
msgid ""
":func:`enumerate` is often used when looping through a list and recording "
"the indexes at which certain conditions are met::"
msgstr ""
"在遍歷串列並記錄符合特定條件的索引時，常使用 :func:`enumerate` 函式： ::"

#: ../../howto/functional.rst:678
msgid ""
"f = open('data.txt', 'r')\n"
"for i, line in enumerate(f):\n"
"    if line.strip() == '':\n"
"        print('Blank line at line #%i' % i)"
msgstr ""
"f = open('data.txt', 'r')\n"
"for i, line in enumerate(f):\n"
"    if line.strip() == '':\n"
"        print('Blank line at line #%i' % i)"

#: ../../howto/functional.rst:683 ../../howto/functional.rst:681
#, fuzzy
msgid ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` collects all the "
"elements of the iterable into a list, sorts the list, and returns the sorted "
"result.  The *key* and *reverse* arguments are passed through to the "
"constructed list's :meth:`~list.sort` method. ::"
msgstr ""
":func:`sorted(iterable, key=None, reverse=False) <排序>` 會將可疊代的 "
"iterable 內容放到一個串列中，再依照順序進行排序並回傳。*key* 和 *reverse* 引"
"數也會被傳遞給建立的串列物件使用 :meth:`~list.sort` 方法。 ::"

#: ../../howto/functional.rst:688
msgid ""
">>> import random\n"
">>> # Generate 8 random numbers between [0, 10000)\n"
">>> rand_list = random.sample(range(10000), 8)\n"
">>> rand_list  \n"
"[769, 7953, 9828, 6431, 8442, 9878, 6213, 2207]\n"
">>> sorted(rand_list)  \n"
"[769, 2207, 6213, 6431, 7953, 8442, 9828, 9878]\n"
">>> sorted(rand_list, reverse=True)  \n"
"[9878, 9828, 8442, 7953, 6431, 6213, 2207, 769]"
msgstr ""

#: ../../howto/functional.rst:698 ../../howto/functional.rst:696
#, fuzzy
msgid ""
"(For a more detailed discussion of sorting, see the :ref:`sortinghowto`.)"
msgstr "（關於排序的更詳細討論，請參閱 :ref:`sortinghowto`。）"

#: ../../howto/functional.rst:701 ../../howto/functional.rst:699
#, fuzzy
msgid ""
"The :func:`any(iter) <any>` and :func:`all(iter) <all>` built-ins look at "
"the truth values of an iterable's contents.  :func:`any` returns ``True`` if "
"any element in the iterable is a true value, and :func:`all` returns "
"``True`` if all of the elements are true values:"
msgstr ""
"`:func:`any(iter) <any>` 與 :func:`all(iter) <all>` 是內建函式，用於檢查可疊"
"代物件的真實值。:func:`any` 會在可疊代物件中任意一個元素為真時回傳``True``；"
"而 :func:`all` 則會在所有元素都為真時回傳``True``："

#: ../../howto/functional.rst:720 ../../howto/functional.rst:718
#, fuzzy
msgid ""
":func:`zip(iterA, iterB, ...) <zip>` takes one element from each iterable "
"and returns them in a tuple::"
msgstr ""
":func:`zip(iterA, iterB, ...) <zip>` 針對每個可疊代物件取出一個元素，並以 "
"tuple 的形式回傳： ::"

#: ../../howto/functional.rst:723
msgid ""
"zip(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2), ('c', 3)"
msgstr ""
"zip(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2), ('c', 3)"

#: ../../howto/functional.rst:726 ../../howto/functional.rst:724
#, fuzzy
msgid ""
"It doesn't construct an in-memory list and exhaust all the input iterators "
"before returning; instead tuples are constructed and returned only if "
"they're requested.  (The technical term for this behaviour is `lazy "
"evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"
msgstr ""
"它並未構建一個記憶體串列而在回傳前耗盡所有輸入的疊代器；若要求時，它只有構建"
"元組才會回傳。(這種行為的技術名詞是「`惰性計算 <https://zh.wikipedia.org/"
"wiki/%E6%87%92%E5%BA%A6%E8%AF%84%E4%BC%B0>`__。)"

#: ../../howto/functional.rst:731 ../../howto/functional.rst:729
#, fuzzy
msgid ""
"This iterator is intended to be used with iterables that are all of the same "
"length.  If the iterables are of different lengths, the resulting stream "
"will be the same length as the shortest iterable. ::"
msgstr ""
"此疊代器適用於長度相同的可疊代物件。如果這些可疊代物件的長度不同，則結果將與"
"最短可疊代物件一樣長。 ::"

#: ../../howto/functional.rst:735
msgid ""
"zip(['a', 'b'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2)"
msgstr ""
"zip(['a', 'b'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2)"

#: ../../howto/functional.rst:738 ../../howto/functional.rst:736
#, fuzzy
msgid ""
"You should avoid doing this, though, because an element may be taken from "
"the longer iterators and discarded.  This means you can't go on to use the "
"iterators further because you risk skipping a discarded element."
msgstr ""
"你應避免這樣做，因為可能從較長的疊代器中取出元素並將其丟棄。這意味著你不能再"
"延續使用此疊代器，否則會有被跳過的舊元素風險。"

#: ../../howto/functional.rst:744 ../../howto/functional.rst:742
#, fuzzy
msgid "The itertools module"
msgstr "Python 模組 itertools"

#: ../../howto/functional.rst:746 ../../howto/functional.rst:744
#, fuzzy
msgid ""
"The :mod:`itertools` module contains a number of commonly used iterators as "
"well as functions for combining several iterators.  This section will "
"introduce the module's contents by showing small examples."
msgstr ""
"``itertools`` (疊代工具) 模組包含許多常用的疊代器，以及合併數個疊代器的函式。"
"本節會透過一些小例子來介紹模組內容。"

#: ../../howto/functional.rst:750 ../../howto/functional.rst:748
#, fuzzy
msgid "The module's functions fall into a few broad classes:"
msgstr "這個模組的函式可以分為幾個廣泛的類別："

#: ../../howto/functional.rst:752 ../../howto/functional.rst:750
#, fuzzy
msgid "Functions that create a new iterator based on an existing iterator."
msgstr "基於現有的iterator建立新的遍歷器函式。"

#: ../../howto/functional.rst:753 ../../howto/functional.rst:751
#, fuzzy
msgid "Functions for treating an iterator's elements as function arguments."
msgstr "將疊代器的元素當作函式引數來處理的函式。"

#: ../../howto/functional.rst:754 ../../howto/functional.rst:752
#, fuzzy
msgid "Functions for selecting portions of an iterator's output."
msgstr "選取疊代器輸出的某些部分的函式。"

#: ../../howto/functional.rst:755 ../../howto/functional.rst:753
#, fuzzy
msgid "A function for grouping an iterator's output."
msgstr "一個用於將疊代器輸出分組的函式。"

#: ../../howto/functional.rst:758 ../../howto/functional.rst:756
#, fuzzy
msgid "Creating new iterators"
msgstr "建立新的疊代器"

#: ../../howto/functional.rst:760 ../../howto/functional.rst:758
#, fuzzy
msgid ""
":func:`itertools.count(start, step) <itertools.count>` returns an infinite "
"stream of evenly spaced values.  You can optionally supply the starting "
"number, which defaults to 0, and the interval between numbers, which "
"defaults to 1::"
msgstr ""
":func:`itertools.count(start, step) <itertools.count>` 回傳一個無限的序列，其"
"中包含均勻分佈的值。你可以選擇提供起始數字（預設為 0）和數字間隔時間（預設為 "
"1）： ::"

#: ../../howto/functional.rst:764
msgid ""
"itertools.count() =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"itertools.count(10) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"itertools.count(10, 5) =>\n"
"  10, 15, 20, 25, 30, 35, 40, 45, 50, 55, ..."
msgstr ""
"itertools.count() =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"itertools.count(10) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"itertools.count(10, 5) =>\n"
"  10, 15, 20, 25, 30, 35, 40, 45, 50, 55, ..."

#: ../../howto/functional.rst:771 ../../howto/functional.rst:769
#, fuzzy
msgid ""
":func:`itertools.cycle(iter) <itertools.cycle>` saves a copy of the contents "
"of a provided iterable and returns a new iterator that returns its elements "
"from first to last.  The new iterator will repeat these elements "
"infinitely. ::"
msgstr ""
":func:`itertools.cycle(iter) <itertools.cycle>` 會儲存提供的可疊代物件之內容"
"並回傳一個新型別 `iterator`，該 `iterator` 將從頭到尾依序回傳它所儲存的元素。"
"新的 `iterator` 會無限次數重複這些元素。 ::"

#: ../../howto/functional.rst:775
msgid ""
"itertools.cycle([1, 2, 3, 4, 5]) =>\n"
"  1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ..."
msgstr ""
"itertools.cycle([1, 2, 3, 4, 5]) =>\n"
"  1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ..."

#: ../../howto/functional.rst:778 ../../howto/functional.rst:776
#, fuzzy
msgid ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` returns the provided "
"element *n* times, or returns the element endlessly if *n* is not "
"provided. ::"
msgstr ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` 回傳提供的元素 *n* "
"次，若未提供 *n* 值就無限次回傳此元素。 ::"

#: ../../howto/functional.rst:781
msgid ""
"itertools.repeat('abc') =>\n"
"  abc, abc, abc, abc, abc, abc, abc, abc, abc, abc, ...\n"
"itertools.repeat('abc', 5) =>\n"
"  abc, abc, abc, abc, abc"
msgstr ""
"itertools.repeat('abc') =>\n"
"  abc, abc, abc, abc, abc, abc, abc, abc, abc, abc, ...\n"
"itertools.repeat('abc', 5) =>\n"
"  abc, abc, abc, abc, abc"

#: ../../howto/functional.rst:786 ../../howto/functional.rst:784
#, fuzzy
msgid ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` takes an "
"arbitrary number of iterables as input, and returns all the elements of the "
"first iterator, then all the elements of the second, and so on, until all of "
"the iterables have been exhausted. ::"
msgstr ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` 會以多個疊代器為"
"輸入，回傳第一個疊代器中的所有元素，然後是第二個疊代器的所有元素以此類推直到"
"每個疊代器都已被耗盡。 ::"

#: ../../howto/functional.rst:791
msgid ""
"itertools.chain(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  a, b, c, 1, 2, 3"
msgstr ""
"itertools.chain(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  a, b, c, 1, 2, 3"

#: ../../howto/functional.rst:794 ../../howto/functional.rst:792
#, fuzzy
msgid ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"returns a stream that's a slice of the iterator.  With a single *stop* "
"argument, it will return the first *stop* elements.  If you supply a "
"starting index, you'll get *stop-start* elements, and if you supply a value "
"for *step*, elements will be skipped accordingly.  Unlike Python's string "
"and list slicing, you can't use negative values for *start*, *stop*, or "
"*step*. ::"
msgstr ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` 會回"
"傳一個疊代器的子序列 (slice)。只有一個 *stop* 參數時，會回傳前面的第 *stop* "
"個元素。如果你提供起始索引(start)，會取得你想要的區間長度 *stop-start* 內元"
"素；同理，若你提供步距(step)參數值，將被省略指定元素格數後, 回傳接續該點剩下"
"满足长宽要求之子序列內容物件。請注意與 Python 的字串及清單$subscript$方式"
"(slicing)不同，在此無法使用負數來定義 $start$、$stop$ 或 $step$。 ::"

#: ../../howto/functional.rst:801
msgid ""
"itertools.islice(range(10), 8) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7\n"
"itertools.islice(range(10), 2, 8) =>\n"
"  2, 3, 4, 5, 6, 7\n"
"itertools.islice(range(10), 2, 8, 2) =>\n"
"  2, 4, 6"
msgstr ""
"itertools.islice(range(10), 8) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7\n"
"itertools.islice(range(10), 2, 8) =>\n"
"  2, 3, 4, 5, 6, 7\n"
"itertools.islice(range(10), 2, 8, 2) =>\n"
"  2, 4, 6"

#: ../../howto/functional.rst:808 ../../howto/functional.rst:806
#, fuzzy
msgid ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replicates an iterator; it "
"returns *n* independent iterators that will all return the contents of the "
"source iterator. If you don't supply a value for *n*, the default is 2.  "
"Replicating iterators requires saving some of the contents of the source "
"iterator, so this can consume significant memory if the iterator is large "
"and one of the new iterators is consumed more than the others. ::"
msgstr ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` 複製一個疊代器；它會回傳 "
"*n* 個互相獨立的疊代器，這些新的疊代器都會回傳源頭(iter)的內容。如果你對於 "
"*n* 沒有給定值，那麼預設值就是2。複製一個疊代器需要保存源頭(iter)部分內容，所"
"以如果其中一個新的iterator被 more than the others 消耗掉比其他 iterators多很"
"多時，此操作可能會消耗大量記憶體。 ::"

#: ../../howto/functional.rst:816
msgid ""
"itertools.tee( itertools.count() ) =>\n"
"   iterA, iterB\n"
"\n"
"where iterA ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"\n"
"and   iterB ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ..."
msgstr ""
"itertools.tee( itertools.count() ) =>\n"
"   iterA, iterB\n"
"\n"
"where iterA ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"\n"
"and   iterB ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ..."

#: ../../howto/functional.rst:827 ../../howto/functional.rst:825
#, fuzzy
msgid "Calling functions on elements"
msgstr "對元素呼叫函式"

#: ../../howto/functional.rst:829 ../../howto/functional.rst:827
#, fuzzy
msgid ""
"The :mod:`operator` module contains a set of functions corresponding to "
"Python's operators.  Some examples are :func:`operator.add(a, b) <operator."
"add>` (adds two values), :func:`operator.ne(a, b)  <operator.ne>` (same as "
"``a != b``), and :func:`operator.attrgetter('id') <operator.attrgetter>` "
"(returns a callable that fetches the ``.id`` attribute)."
msgstr ""
"``:mod:`operator` 模組包含一系列對應於 Python 運算子的函式。其中有些例子如下:"
"func:`operator.add(a, b) <operator.add>` (adds two values), :func:`operator."
"ne(a, b)  <operator.ne>`\\ （與 ``a != b`` 相同）和 :func:`operator."
"attrgetter('id') <operator.attrgetter>`\\ （回傳會取得 ``.id`` 屬性的可呼叫物"
"件 (callable)）。"

#: ../../howto/functional.rst:835 ../../howto/functional.rst:833
#, fuzzy
msgid ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` assumes that the "
"iterable will return a stream of tuples, and calls *func* using these tuples "
"as the arguments::"
msgstr ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` 假設可疊代物件會回"
"傳元組的串流，並使用這些元組當作引數呼叫 *func*： ::"

#: ../../howto/functional.rst:839
msgid ""
"itertools.starmap(os.path.join,\n"
"                  [('/bin', 'python'), ('/usr', 'bin', 'java'),\n"
"                   ('/usr', 'bin', 'perl'), ('/usr', 'bin', 'ruby')])\n"
"=>\n"
"  /bin/python, /usr/bin/java, /usr/bin/perl, /usr/bin/ruby"
msgstr ""
"itertools.starmap(os.path.join,\n"
"                  [('/bin', 'python'), ('/usr', 'bin', 'java'),\n"
"                   ('/usr', 'bin', 'perl'), ('/usr', 'bin', 'ruby')])\n"
"=>\n"
"  /bin/python, /usr/bin/java, /usr/bin/perl, /usr/bin/ruby"

#: ../../howto/functional.rst:847 ../../howto/functional.rst:845
msgid "Selecting elements"
msgstr "選取元素"

#: ../../howto/functional.rst:849 ../../howto/functional.rst:847
#, fuzzy
msgid ""
"Another group of functions chooses a subset of an iterator's elements based "
"on a predicate."
msgstr "另一組函式是利用預定條件篩選出疊代器中的元素子集。"

#: ../../howto/functional.rst:852 ../../howto/functional.rst:850
#, fuzzy
msgid ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` is "
"the opposite of :func:`filter`, returning all elements for which the "
"predicate returns false::"
msgstr ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` 是 :"
"func:`filter` 的相反，會回傳所有於述詞函式中回傳「False」的元素： ::"

#: ../../howto/functional.rst:856
msgid ""
"itertools.filterfalse(is_even, itertools.count()) =>\n"
"  1, 3, 5, 7, 9, 11, 13, 15, ..."
msgstr ""
"itertools.filterfalse(is_even, itertools.count()) =>\n"
"  1, 3, 5, 7, 9, 11, 13, 15, ..."

#: ../../howto/functional.rst:859 ../../howto/functional.rst:857
#, fuzzy
msgid ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` returns "
"elements for as long as the predicate returns true.  Once the predicate "
"returns false, the iterator will signal the end of its results. ::"
msgstr ""
"`itertools.takewhile(predicate, iter) <itertools.takewhile>`函式會回傳一直到"
"斷言條件返 回 False 為止的元素。一旦是因為斷言條件回傳了 False 而停止，該遍歷"
"器就會回報內容的結束。 ::"

#: ../../howto/functional.rst:863
msgid ""
"def less_than_10(x):\n"
"    return x < 10\n"
"\n"
"itertools.takewhile(less_than_10, itertools.count()) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n"
"\n"
"itertools.takewhile(is_even, itertools.count()) =>\n"
"  0"
msgstr ""
"def less_than_10(x):\n"
"    return x < 10\n"
"\n"
"itertools.takewhile(less_than_10, itertools.count()) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n"
"\n"
"itertools.takewhile(is_even, itertools.count()) =>\n"
"  0"

#: ../../howto/functional.rst:872 ../../howto/functional.rst:870
#, fuzzy
msgid ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` discards "
"elements while the predicate returns true, and then returns the rest of the "
"iterable's results. ::"
msgstr ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` 會在 "
"predicate 回傳 True 時，捨棄元素，一直到 predicate 回傳 False 為止再回傳 "
"iterable 中剩下的結果。 ::"

#: ../../howto/functional.rst:876
msgid ""
"itertools.dropwhile(less_than_10, itertools.count()) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"\n"
"itertools.dropwhile(is_even, itertools.count()) =>\n"
"  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ..."
msgstr ""
"itertools.dropwhile(less_than_10, itertools.count()) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"\n"
"itertools.dropwhile(is_even, itertools.count()) =>\n"
"  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ..."

#: ../../howto/functional.rst:882 ../../howto/functional.rst:880
#, fuzzy
msgid ""
":func:`itertools.compress(data, selectors) <itertools.compress>` takes two "
"iterators and returns only those elements of *data* for which the "
"corresponding element of *selectors* is true, stopping whenever either one "
"is exhausted::"
msgstr ""
":func:`itertools.compress(data, selectors) <itertools.compress>` 函式需要兩個"
"疊代器，並回傳當 *selectors* 中對應的元素為 true 時 *data* 對應的元素。若其中"
"一個疊代器耗盡，該函式也會停止運行： ::"

#: ../../howto/functional.rst:886
msgid ""
"itertools.compress([1, 2, 3, 4, 5], [True, True, False, False, True]) =>\n"
"   1, 2, 5"
msgstr ""
"itertools.compress([1, 2, 3, 4, 5], [True, True, False, False, True]) =>\n"
"   1, 2, 5"

#: ../../howto/functional.rst:891 ../../howto/functional.rst:889
msgid "Combinatoric functions"
msgstr "組合函式"

#: ../../howto/functional.rst:893 ../../howto/functional.rst:891
#, fuzzy
msgid ""
"The :func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"returns an iterator giving all possible *r*-tuple combinations of the "
"elements contained in *iterable*.  ::"
msgstr ""
":func:`itertools.combinations(iterable, r) <itertools.combinations>` 函式會回"
"傳一個疊代器物件，其中包含從 *iterable* 物件中選擇出所有可能的長度為 *r* 的元"
"素並組合成 tuple 所形成之疊代器。 ::"

#: ../../howto/functional.rst:897
msgid ""
"itertools.combinations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 3), (2, 4), (2, 5),\n"
"  (3, 4), (3, 5),\n"
"  (4, 5)\n"
"\n"
"itertools.combinations([1, 2, 3, 4, 5], 3) =>\n"
"  (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5),\n"
"  (2, 3, 4), (2, 3, 5), (2, 4, 5),\n"
"  (3, 4, 5)"
msgstr ""
"itertools.combinations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 3), (2, 4), (2, 5),\n"
"  (3, 4), (3, 5),\n"
"  (4, 5)\n"
"\n"
"itertools.combinations([1, 2, 3, 4, 5], 3) =>\n"
"  (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5),\n"
"  (2, 3, 4), (2, 3, 5), (2, 4, 5),\n"
"  (3, 4, 5)"

#: ../../howto/functional.rst:908 ../../howto/functional.rst:906
#, fuzzy
msgid ""
"The elements within each tuple remain in the same order as *iterable* "
"returned them.  For example, the number 1 is always before 2, 3, 4, or 5 in "
"the examples above.  A similar function, :func:`itertools."
"permutations(iterable, r=None) <itertools.permutations>`, removes this "
"constraint on the order, returning all possible arrangements of length *r*::"
msgstr ""
"每個 tuple 內的元素順序與 *iterable* 回傳時相同。例如，上述範例中數字 1 總是"
"在 2、3、4 或 5 的前面。一個類似的函式 :func:`itertools."
"permutations(iterable, r=None) <itertools.permutations>` 移除了此限制，並回傳"
"所有長度為 *r* 的可能排列： ::"

#: ../../howto/functional.rst:915
msgid ""
"itertools.permutations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 1), (2, 3), (2, 4), (2, 5),\n"
"  (3, 1), (3, 2), (3, 4), (3, 5),\n"
"  (4, 1), (4, 2), (4, 3), (4, 5),\n"
"  (5, 1), (5, 2), (5, 3), (5, 4)\n"
"\n"
"itertools.permutations([1, 2, 3, 4, 5]) =>\n"
"  (1, 2, 3, 4, 5), (1, 2, 3, 5, 4), (1, 2, 4, 3, 5),\n"
"  ...\n"
"  (5, 4, 3, 2, 1)"
msgstr ""
"itertools.permutations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 1), (2, 3), (2, 4), (2, 5),\n"
"  (3, 1), (3, 2), (3, 4), (3, 5),\n"
"  (4, 1), (4, 2), (4, 3), (4, 5),\n"
"  (5, 1), (5, 2), (5, 3), (5, 4)\n"
"\n"
"itertools.permutations([1, 2, 3, 4, 5]) =>\n"
"  (1, 2, 3, 4, 5), (1, 2, 3, 5, 4), (1, 2, 4, 3, 5),\n"
"  ...\n"
"  (5, 4, 3, 2, 1)"

#: ../../howto/functional.rst:927 ../../howto/functional.rst:925
#, fuzzy
msgid ""
"If you don't supply a value for *r* the length of the iterable is used, "
"meaning that all the elements are permuted."
msgstr ""
"如果你不提供 *r* 的值，將使用可疊代物件的長度來進行排列，也就是說所有元素都會"
"被重組。"

#: ../../howto/functional.rst:930 ../../howto/functional.rst:928
#, fuzzy
msgid ""
"Note that these functions produce all of the possible combinations by "
"position and don't require that the contents of *iterable* are unique::"
msgstr ""
"請注意，這些函式按位置產生所有可能的組合，不需要 *iterable* 的內容是唯一"
"的： ::"

#: ../../howto/functional.rst:933
msgid ""
"itertools.permutations('aba', 3) =>\n"
"  ('a', 'b', 'a'), ('a', 'a', 'b'), ('b', 'a', 'a'),\n"
"  ('b', 'a', 'a'), ('a', 'a', 'b'), ('a', 'b', 'a')"
msgstr ""
"itertools.permutations('aba', 3) =>\n"
"  ('a', 'b', 'a'), ('a', 'a', 'b'), ('b', 'a', 'a'),\n"
"  ('b', 'a', 'a'), ('a', 'a', 'b'), ('a', 'b', 'a')"

#: ../../howto/functional.rst:937 ../../howto/functional.rst:935
msgid ""
"The identical tuple ``('a', 'a', 'b')`` occurs twice, but the two 'a' "
"strings came from different positions."
msgstr ""
"相同的元組 ``('a', 'a', 'b')`` 出現了兩次，但是兩個 'a' 是來自不同的位置。"

#: ../../howto/functional.rst:940 ../../howto/functional.rst:938
#, fuzzy
msgid ""
"The :func:`itertools.combinations_with_replacement(iterable, r) <itertools."
"combinations_with_replacement>` function relaxes a different constraint: "
"elements can be repeated within a single tuple.  Conceptually an element is "
"selected for the first position of each tuple and then is replaced before "
"the second element is selected.  ::"
msgstr ""
"該函式 :func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` 可以放寬限制，讓相同的元素可以在同"
"一個 tuple 內重覆出現。此函式是先選擇第一個位置的元素，接著再更換該元素單打才"
"繼續選取下一個；如此類推，直到組合成完整的 tuple。 ::"

#: ../../howto/functional.rst:946
msgid ""
"itertools.combinations_with_replacement([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 1), (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 2), (2, 3), (2, 4), (2, 5),\n"
"  (3, 3), (3, 4), (3, 5),\n"
"  (4, 4), (4, 5),\n"
"  (5, 5)"
msgstr ""
"itertools.combinations_with_replacement([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 1), (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 2), (2, 3), (2, 4), (2, 5),\n"
"  (3, 3), (3, 4), (3, 5),\n"
"  (4, 4), (4, 5),\n"
"  (5, 5)"

#: ../../howto/functional.rst:955 ../../howto/functional.rst:953
msgid "Grouping elements"
msgstr "將元素分組"

#: ../../howto/functional.rst:957 ../../howto/functional.rst:955
#, fuzzy
msgid ""
"The last function I'll discuss, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, is the most complicated.  "
"``key_func(elem)`` is a function that can compute a key value for each "
"element returned by the iterable.  If you don't supply a key function, the "
"key is simply each element itself."
msgstr ""
"最後一個要談的函式是 :func:`itertools.groupby(iter, key_func=None) "
"<itertools.groupby>`。它是最複雜的之一，``key_func(elem)`` 是用來計算可疊代物"
"件中每個元素的關鍵值（key value） 的函式。如果沒有提供關鍵字 (Key function)，"
"則以各個元素本身當作其鍵（key）。"

#: ../../howto/functional.rst:962 ../../howto/functional.rst:960
#, fuzzy
msgid ""
":func:`~itertools.groupby` collects all the consecutive elements from the "
"underlying iterable that have the same key value, and returns a stream of 2-"
"tuples containing a key value and an iterator for the elements with that key."
msgstr ""
":func:`~itertools.groupby` 會將具有相同鍵值的連續元素從底層可疊代物件中收集起"
"來，並回傳包含鍵值和該鍵下元素的疊代器2個項目的流程。"

#: ../../howto/functional.rst:968
msgid ""
"city_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'),\n"
"             ('Anchorage', 'AK'), ('Nome', 'AK'),\n"
"             ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'),\n"
"             ...\n"
"            ]\n"
"\n"
"def get_state(city_state):\n"
"    return city_state[1]\n"
"\n"
"itertools.groupby(city_list, get_state) =>\n"
"  ('AL', iterator-1),\n"
"  ('AK', iterator-2),\n"
"  ('AZ', iterator-3), ...\n"
"\n"
"where\n"
"iterator-1 =>\n"
"  ('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL')\n"
"iterator-2 =>\n"
"  ('Anchorage', 'AK'), ('Nome', 'AK')\n"
"iterator-3 =>\n"
"  ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ')"
msgstr ""
"city_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'),\n"
"             ('Anchorage', 'AK'), ('Nome', 'AK'),\n"
"             ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'),\n"
"             ...\n"
"            ]\n"
"\n"
"def get_state(city_state):\n"
"    return city_state[1]\n"
"\n"
"itertools.groupby(city_list, get_state) =>\n"
"  ('AL', iterator-1),\n"
"  ('AK', iterator-2),\n"
"  ('AZ', iterator-3), ...\n"
"\n"
"where\n"
"iterator-1 =>\n"
"  ('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL')\n"
"iterator-2 =>\n"
"  ('Anchorage', 'AK'), ('Nome', 'AK')\n"
"iterator-3 =>\n"
"  ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ')"

#: ../../howto/functional.rst:990 ../../howto/functional.rst:988
#, fuzzy
msgid ""
":func:`~itertools.groupby` assumes that the underlying iterable's contents "
"will already be sorted based on the key.  Note that the returned iterators "
"also use the underlying iterable, so you have to consume the results of "
"iterator-1 before requesting iterator-2 and its corresponding key."
msgstr ""
":func:`~itertools.groupby` 假設底層的可疊代物件已基於鍵值排序。需要注意的是，"
"所回傳之 iterators 也使用了原始的可疊代物件，因此必須先消耗掉 iterator-1 的結"
"果，再取用 iterator-2 及其對應鍵值。"

#: ../../howto/functional.rst:997 ../../howto/functional.rst:995
msgid "The functools module"
msgstr "functools 模組"

#: ../../howto/functional.rst:999 ../../howto/functional.rst:997
#, fuzzy
msgid ""
"The :mod:`functools` module contains some higher-order functions. A **higher-"
"order function** takes one or more functions as input and returns a new "
"function.  The most useful tool in this module is the :func:`functools."
"partial` function."
msgstr ""
"Python 中 :mod:`functools` 模組包含了一些高階函式。**高階函式** 可以接受一個"
"或多個函式作為輸入並回傳新的函式。這個模組中最有用的工具是 :func:`functools."
"partial` 函式。"

#: ../../howto/functional.rst:1004 ../../howto/functional.rst:1002
#, fuzzy
msgid ""
"For programs written in a functional style, you'll sometimes want to "
"construct variants of existing functions that have some of the parameters "
"filled in. Consider a Python function ``f(a, b, c)``; you may wish to create "
"a new function ``g(b, c)`` that's equivalent to ``f(1, b, c)``; you're "
"filling in a value for one of ``f()``'s parameters.  This is called "
"\"partial function application\"."
msgstr ""
"對於以函式風格撰寫的程式，有時你可能想要建立現有函式的變體，其中填入某些引"
"數。考慮一個 Python 函式 ``f(a, b, c)``；你可以希望建立一個新函式 ``g(b, "
"c)``，它等效於 ``f(1, b, c)``；這相當於為 ``f()`` 的一個參數填寫了值。這稱為"
"「部分函式應用」（\"partial function application\"）。"

#: ../../howto/functional.rst:1010 ../../howto/functional.rst:1008
#, fuzzy
msgid ""
"The constructor for :func:`~functools.partial` takes the arguments "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``.  The "
"resulting object is callable, so you can just call it to invoke ``function`` "
"with the filled-in arguments."
msgstr ""
"`:func:`~functools.partial` 的建構子接受 ``(function, arg1, arg2, ..., "
"kwarg1=value1, kwarg2=value2)`` 引數。該物件是可呼叫的(callable)，因此你只需"
"呼叫該物件以填入引數，然後調用 ``function``。"

#: ../../howto/functional.rst:1015 ../../howto/functional.rst:1013
msgid "Here's a small but realistic example::"
msgstr "以下是個很小但實際的範例： ::"

#: ../../howto/functional.rst:1017
msgid ""
"import functools\n"
"\n"
"def log(message, subsystem):\n"
"    \"\"\"Write the contents of 'message' to the specified subsystem.\"\"\"\n"
"    print('%s: %s' % (subsystem, message))\n"
"    ...\n"
"\n"
"server_log = functools.partial(log, subsystem='server')\n"
"server_log('Unable to open socket')"
msgstr ""

#: ../../howto/functional.rst:1027 ../../howto/functional.rst:1025
#, fuzzy
msgid ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"cumulatively performs an operation on all the iterable's elements and, "
"therefore, can't be applied to infinite iterables. *func* must be a function "
"that takes two elements and returns a single value.  :func:`functools."
"reduce` takes the first two elements A and B returned by the iterator and "
"calculates ``func(A, B)``.  It then requests the third element, C, "
"calculates ``func(func(A, B), C)``, combines this result with the fourth "
"element returned, and continues until the iterable is exhausted.  If the "
"iterable returns no values at all, a :exc:`TypeError` exception is raised.  "
"If the initial value is supplied, it's used as a starting point and "
"``func(initial_value, A)`` is the first calculation. ::"
msgstr ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` 會對"
"可疊代的所有元素施行運算，因此無法應用在無限的可疊代物件上。*func* 必須是一個"
"接受兩個元素並回傳單一值的函式。:func:`functools.reduce` 取得由疊代器回傳的第"
"一個和第二個元素 A 和 B，並計算 ``func(A,B)``。然後請求第三個元素 C ，計算 "
"``func(func(A,B),C)``，結合此結果和回傳之第四個物件持續進行直到耗盡該疊代器。"
"如果沒有任何回傳值將引發 :exc:`TypeError` 錯誤。如果提供了起始值，則使用它做"
"為起點並進行「初始」處理，在首次遠算時會呼叫 `` func(initial_value,A)``。 ::"

#: ../../howto/functional.rst:1039
msgid ""
">>> import operator, functools\n"
">>> functools.reduce(operator.concat, ['A', 'BB', 'C'])\n"
"'ABBC'\n"
">>> functools.reduce(operator.concat, [])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: reduce() of empty sequence with no initial value\n"
">>> functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"6\n"
">>> functools.reduce(operator.mul, [], 1)\n"
"1"
msgstr ""
">>> import operator, functools\n"
">>> functools.reduce(operator.concat, ['A', 'BB', 'C'])\n"
"'ABBC'\n"
">>> functools.reduce(operator.concat, [])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: reduce() of empty sequence with no initial value\n"
">>> functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"6\n"
">>> functools.reduce(operator.mul, [], 1)\n"
"1"

#: ../../howto/functional.rst:1051 ../../howto/functional.rst:1049
#, fuzzy
msgid ""
"If you use :func:`operator.add` with :func:`functools.reduce`, you'll add up "
"all the elements of the iterable.  This case is so common that there's a "
"special built-in called :func:`sum` to compute it:"
msgstr ""
"如果你在 :func:`functools.reduce` 中使用 :func:`operator.add`，它將會加總可疊"
"代物件中的所有元素。這個情況非常常見，因此 Python 已內建一個名為 :func:`sum` "
"的函式用來計算："

#: ../../howto/functional.rst:1063 ../../howto/functional.rst:1061
#, fuzzy
msgid ""
"For many uses of :func:`functools.reduce`, though, it can be clearer to just "
"write the obvious :keyword:`for` loop::"
msgstr ""
"很多時候，在使用 :func:`functools.reduce` 時，只要寫一個明顯的 :keyword:"
"`for` 迴圈可能會更清楚易懂： ::"

#: ../../howto/functional.rst:1066
msgid ""
"import functools\n"
"# Instead of:\n"
"product = functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"\n"
"# You can write:\n"
"product = 1\n"
"for i in [1, 2, 3]:\n"
"    product *= i"
msgstr ""
"import functools\n"
"# 這樣：\n"
"product = functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"\n"
"# 你可改寫成：\n"
"product = 1\n"
"for i in [1, 2, 3]:\n"
"    product *= i"

#: ../../howto/functional.rst:1075 ../../howto/functional.rst:1073
#, fuzzy
msgid ""
"A related function is :func:`itertools.accumulate(iterable, func=operator."
"add) <itertools.accumulate>`.  It performs the same calculation, but instead "
"of returning only the final result, :func:`~itertools.accumulate` returns an "
"iterator that also yields each partial result::"
msgstr ""
"一個相關的函式是 :func:`itertools.accumulate(iterable, func=operator.add) "
"<itertools.accumulate>`。它執行相同的計算，但不僅會回傳最終結果，也會產生每個"
"部分結果的疊代器： ::"

#: ../../howto/functional.rst:1080
msgid ""
"itertools.accumulate([1, 2, 3, 4, 5]) =>\n"
"  1, 3, 6, 10, 15\n"
"\n"
"itertools.accumulate([1, 2, 3, 4, 5], operator.mul) =>\n"
"  1, 2, 6, 24, 120"
msgstr ""
"itertools.accumulate([1, 2, 3, 4, 5]) =>\n"
"  1, 3, 6, 10, 15\n"
"\n"
"itertools.accumulate([1, 2, 3, 4, 5], operator.mul) =>\n"
"  1, 2, 6, 24, 120"

#: ../../howto/functional.rst:1088 ../../howto/functional.rst:1086
msgid "The operator module"
msgstr "operator 模組"

#: ../../howto/functional.rst:1090 ../../howto/functional.rst:1088
#, fuzzy
msgid ""
"The :mod:`operator` module was mentioned earlier.  It contains a set of "
"functions corresponding to Python's operators.  These functions are often "
"useful in functional-style code because they save you from writing trivial "
"functions that perform a single operation."
msgstr ""
"之前有提到 :mod:`operator` 模組，它包含一些對應 Python 運算子的函式。這些函式"
"常用於函式風格的程式碼中，因為可以省去寫只完成單一運算子操作的瑣碎函式。"

#: ../../howto/functional.rst:1095 ../../howto/functional.rst:1093
#, fuzzy
msgid "Some of the functions in this module are:"
msgstr "本模組中的一些函式包括："

#: ../../howto/functional.rst:1097 ../../howto/functional.rst:1095
msgid ""
"Math operations: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."
msgstr ""
"數學運算：``add()``、 ``sub()``、``mul()``、``floordiv()``、``abs()`` 等等。"

#: ../../howto/functional.rst:1098 ../../howto/functional.rst:1096
#, fuzzy
msgid "Logical operations: ``not_()``, ``truth()``."
msgstr "邏輯運算：``not_()``（非運算）、 ``truth()``（真值判斷）."

#: ../../howto/functional.rst:1099 ../../howto/functional.rst:1097
#, fuzzy
msgid "Bitwise operations: ``and_()``, ``or_()``, ``invert()``."
msgstr "位元運算：``and_()``, ``or_()``, ``invert()``。"

#: ../../howto/functional.rst:1100 ../../howto/functional.rst:1098
#, fuzzy
msgid ""
"Comparisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, and ``ge()``."
msgstr "比較：``eq()``、``ne()``, ``lt()``, ``le()``, ``gt()`` 和 ``ge()``。"

#: ../../howto/functional.rst:1101 ../../howto/functional.rst:1099
#, fuzzy
msgid "Object identity: ``is_()``, ``is_not()``."
msgstr "物件識別：``is_()``，``is_not()``。"

#: ../../howto/functional.rst:1103 ../../howto/functional.rst:1101
#, fuzzy
msgid "Consult the operator module's documentation for a complete list."
msgstr "請參考 operator 模組的說明文件以取得完整清單"

#: ../../howto/functional.rst:1107 ../../howto/functional.rst:1105
#, fuzzy
msgid "Small functions and the lambda expression"
msgstr "小型函式和 lambda 運算式"

#: ../../howto/functional.rst:1109 ../../howto/functional.rst:1107
#, fuzzy
msgid ""
"When writing functional-style programs, you'll often need little functions "
"that act as predicates or that combine elements in some way."
msgstr ""
"在編寫函式程式時，你通常會需要一些小型的函式來作為斷言（predicate）或以某種方"
"式組合元素之用。"

#: ../../howto/functional.rst:1112 ../../howto/functional.rst:1110
#, fuzzy
msgid ""
"If there's a Python built-in or a module function that's suitable, you don't "
"need to define a new function at all::"
msgstr "如果有適合的 Python 內建函式或模組函式，你完全不需要定義新的函式： ::"

#: ../../howto/functional.rst:1115
msgid ""
"stripped_lines = [line.strip() for line in lines]\n"
"existing_files = filter(os.path.exists, file_list)"
msgstr ""
"stripped_lines = [line.strip() for line in lines]\n"
"existing_files = filter(os.path.exists, file_list)"

#: ../../howto/functional.rst:1118 ../../howto/functional.rst:1116
#, fuzzy
msgid ""
"If the function you need doesn't exist, you need to write it.  One way to "
"write small functions is to use the :keyword:`lambda` expression.  "
"``lambda`` takes a number of parameters and an expression combining these "
"parameters, and creates an anonymous function that returns the value of the "
"expression::"
msgstr ""
"如果你需要的函式不存在，就需要自行撰寫。編寫小型函式的其中一種方法是使用"
"「lambda」運算式。「lambda」接受任意數量的引數及結合這些引數的運算，並建立一"
"個匿名函式以回傳運算值:"

#: ../../howto/functional.rst:1123
msgid ""
"adder = lambda x, y: x+y\n"
"\n"
"print_assign = lambda name, value: name + '=' + str(value)"
msgstr ""
"adder = lambda x, y: x+y\n"
"\n"
"print_assign = lambda name, value: name + '=' + str(value)"

#: ../../howto/functional.rst:1127 ../../howto/functional.rst:1125
#, fuzzy
msgid ""
"An alternative is to just use the ``def`` statement and define a function in "
"the usual way::"
msgstr "另一種方法是只需使用「def」陳述式，以通常的方式定義函式： ::"

#: ../../howto/functional.rst:1130
msgid ""
"def adder(x, y):\n"
"    return x + y\n"
"\n"
"def print_assign(name, value):\n"
"    return name + '=' + str(value)"
msgstr ""
"def adder(x, y):\n"
"    return x + y\n"
"\n"
"def print_assign(name, value):\n"
"    return name + '=' + str(value)"

#: ../../howto/functional.rst:1136 ../../howto/functional.rst:1134
#, fuzzy
msgid ""
"Which alternative is preferable?  That's a style question; my usual course "
"is to avoid using ``lambda``."
msgstr "哪種方式比較好呢？這是個風格問題。我通常不使用「lambda」函式庫。"

#: ../../howto/functional.rst:1139 ../../howto/functional.rst:1137
#, fuzzy
msgid ""
"One reason for my preference is that ``lambda`` is quite limited in the "
"functions it can define.  The result has to be computable as a single "
"expression, which means you can't have multiway ``if... elif... else`` "
"comparisons or ``try... except`` statements.  If you try to do too much in a "
"``lambda`` statement, you'll end up with an overly complicated expression "
"that's hard to read.  Quick, what's the following code doing? ::"
msgstr ""
"我偏好使用lambda的原因之一是它定義函式時所能表達的範圍相對有限。lambda 的結果"
"必須以單一運算式計算，這意味著你無法使用多路 ``if... elif... else`` 比較或"
"``try…except`` 語句。如果你在 ``lambda`` 陳述式中嘗試完成太多工作，最終會得到"
"一個非常複雜且難以閱讀的 expression。你快速看懂以下 code 做些什麼了嗎？ ::"

#: ../../howto/functional.rst:1146
msgid ""
"import functools\n"
"total = functools.reduce(lambda a, b: (0, a[1] + b[1]), items)[1]"
msgstr ""
"import functools\n"
"total = functools.reduce(lambda a, b: (0, a[1] + b[1]), items)[1]"

#: ../../howto/functional.rst:1149 ../../howto/functional.rst:1147
#, fuzzy
msgid ""
"You can figure it out, but it takes time to disentangle the expression to "
"figure out what's going on.  Using a short nested ``def`` statements makes "
"things a little bit better::"
msgstr ""
"你可以自己解讀，但需要花點時間拆解這個運算式才能看懂。使用短的巢狀``def``陳述"
"句會使事情稍微好一些： ::"

#: ../../howto/functional.rst:1153
msgid ""
"import functools\n"
"def combine(a, b):\n"
"    return 0, a[1] + b[1]\n"
"\n"
"total = functools.reduce(combine, items)[1]"
msgstr ""
"import functools\n"
"def combine(a, b):\n"
"    return 0, a[1] + b[1]\n"
"\n"
"total = functools.reduce(combine, items)[1]"

#: ../../howto/functional.rst:1159 ../../howto/functional.rst:1157
#, fuzzy
msgid "But it would be best of all if I had simply used a ``for`` loop::"
msgstr "但最好的方式還是我直接使用``for``迴圈： ::"

#: ../../howto/functional.rst:1161
msgid ""
"total = 0\n"
"for a, b in items:\n"
"    total += b"
msgstr ""
"total = 0\n"
"for a, b in items:\n"
"    total += b"

#: ../../howto/functional.rst:1165 ../../howto/functional.rst:1163
#, fuzzy
msgid "Or the :func:`sum` built-in and a generator expression::"
msgstr "或使用內建的 :func:`sum` 函式與產生器運算式： ::"

#: ../../howto/functional.rst:1167
msgid "total = sum(b for a, b in items)"
msgstr "total = sum(b for a, b in items)"

#: ../../howto/functional.rst:1169 ../../howto/functional.rst:1167
#, fuzzy
msgid ""
"Many uses of :func:`functools.reduce` are clearer when written as ``for`` "
"loops."
msgstr ""
"很多使用 :func:`functools.reduce` 的情況，如果改以 ``for`` 迴圈來表達會更清"
"楚。"

#: ../../howto/functional.rst:1171 ../../howto/functional.rst:1169
#, fuzzy
msgid ""
"Fredrik Lundh once suggested the following set of rules for refactoring uses "
"of ``lambda``:"
msgstr "Fredrik Lundh 曾建議以下重構 ``lambda`` 使用時應遵循的一些規則："

#: ../../howto/functional.rst:1174 ../../howto/functional.rst:1172
msgid "Write a lambda function."
msgstr "撰寫一個 lambda 函式。"

#: ../../howto/functional.rst:1175 ../../howto/functional.rst:1173
#, fuzzy
msgid "Write a comment explaining what the heck that lambda does."
msgstr "寫一個註解來解釋這個 lambda 到底在幹嘛。"

#: ../../howto/functional.rst:1176 ../../howto/functional.rst:1174
#, fuzzy
msgid ""
"Study the comment for a while, and think of a name that captures the essence "
"of the comment."
msgstr "仔細閱讀註解一會兒，思考出一個能夠涵蓋該註解核心的名稱。"

#: ../../howto/functional.rst:1178 ../../howto/functional.rst:1176
msgid "Convert the lambda to a def statement, using that name."
msgstr "將 lambda 轉換成 def 陳述式，並使用該名稱。"

#: ../../howto/functional.rst:1179 ../../howto/functional.rst:1177
msgid "Remove the comment."
msgstr "移除註解。"

#: ../../howto/functional.rst:1181 ../../howto/functional.rst:1179
#, fuzzy
msgid ""
"I really like these rules, but you're free to disagree about whether this "
"lambda-free style is better."
msgstr "我真的很喜歡這些規則，但如果你贊成不使用 lambda 的風格也可以。"

#: ../../howto/functional.rst:1186 ../../howto/functional.rst:1184
msgid "Revision History and Acknowledgements"
msgstr "修訂歷史與致謝"

#: ../../howto/functional.rst:1188 ../../howto/functional.rst:1186
#, fuzzy
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, Mike "
"Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake Winton."
msgstr ""
"作者想感謝以下人士對本文各版本提供意見、修正和協助，包括：Ian Bicking、Nick "
"Coghlan、Nick Efford、Raymond Hettinger、Jim Jewett、Mike Krell、Leandro "
"Lameiro、Jussi Salmela Collin Winter 和 Blake Winton。"

#: ../../howto/functional.rst:1193 ../../howto/functional.rst:1191
msgid "Version 0.1: posted June 30 2006."
msgstr "0.1 版本：於 2006 年 6 月 30 日張貼。"

#: ../../howto/functional.rst:1195 ../../howto/functional.rst:1193
msgid "Version 0.11: posted July 1 2006.  Typo fixes."
msgstr "0.11 版本：於 2006 年 7 月 1 日發佈。修正文字錯誤。"

#: ../../howto/functional.rst:1197 ../../howto/functional.rst:1195
#, fuzzy
msgid ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections into "
"one. Typo fixes."
msgstr ""
"0.2 版本：於 2006 年 7 月 10 日張貼。將產生器運算式和串列綜合運算的部分合併為"
"一個部分。修正了錯誤拼字。"

#: ../../howto/functional.rst:1200 ../../howto/functional.rst:1198
#, fuzzy
msgid ""
"Version 0.21: Added more references suggested on the tutor mailing list."
msgstr "0.21 版本：新增了於 tutor 郵件列表建議的更多參考資料。"

#: ../../howto/functional.rst:1202 ../../howto/functional.rst:1200
#, fuzzy
msgid ""
"Version 0.30: Adds a section on the ``functional`` module written by Collin "
"Winter; adds short section on the operator module; a few other edits."
msgstr ""
"版本 0.30：新增了一個由 Collin Winter 編寫的「函式」模組部分；加入了有關"
"「operator」模組的簡短介紹；做了幾處其他修訂。"

#: ../../howto/functional.rst:1207 ../../howto/functional.rst:1205
#, fuzzy
msgid "References"
msgstr "參考文獻"

#: ../../howto/functional.rst:1210 ../../howto/functional.rst:1208
#, fuzzy
msgid "General"
msgstr "總則"

#: ../../howto/functional.rst:1212 ../../howto/functional.rst:1210
#, fuzzy
msgid ""
"**Structure and Interpretation of Computer Programs**, by Harold Abelson and "
"Gerald Jay Sussman with Julie Sussman.  The book can be found at https://"
"mitpress.mit.edu/sicp.  In this classic textbook of computer science, "
"chapters 2 and 3 discuss the use of sequences and streams to organize the "
"data flow inside a program.  The book uses Scheme for its examples, but many "
"of the design approaches described in these chapters are applicable to "
"functional-style Python code."
msgstr ""
"《計算機程序的結構和解釋》（Structure and Interpretation of Computer "
"Programs）是 Harold Abelson 和 Gerald Jay Sussman 與 Julie Sussman 的經典電腦"
"科學教材。該書第 2 章和第 3 章探討了使用序列和流在程式中組織資料流的方法。該"
"書範例以 Scheme 程式語言呈現，但這些章節描述的設計方法對於函式風格 Python 的"
"程式碼也很有適用性。完整文本可以在 https://mitpress.mit.edu/sicp/ 找到。"

#: ../../howto/functional.rst:1220 ../../howto/functional.rst:1218
#, fuzzy
msgid ""
"https://www.defmacro.org/ramblings/fp.html: A general introduction to "
"functional programming that uses Java examples and has a lengthy historical "
"introduction."
msgstr ""
"這是一篇介紹函式程式設計的文章，以 Java 程式碼作為示範，並附上相當冗長的歷史"
"背景介紹。原文連結為 https://www.defmacro.org/ramblings/fp.html"

#: ../../howto/functional.rst:1223 ../../howto/functional.rst:1221
msgid ""
"https://en.wikipedia.org/wiki/Functional_programming: General Wikipedia "
"entry describing functional programming."
msgstr ""
"https://en.wikipedia.org/wiki/Functional_programming: 這是維基百科上介紹函式"
"程式設計的條目。"

#: ../../howto/functional.rst:1226 ../../howto/functional.rst:1224
msgid "https://en.wikipedia.org/wiki/Coroutine: Entry for coroutines."
msgstr "https://en.wikipedia.org/wiki/Coroutine: 協程 (coroutines) 的條目。"

#: ../../howto/functional.rst:1228 ../../howto/functional.rst:1226
msgid ""
"https://en.wikipedia.org/wiki/Partial_application: Entry for the concept of "
"partial function application."
msgstr ""
"https://en.wikipedia.org/wiki/Partial_application: 偏函式 (partial "
"application) 概念的條目。"

#: ../../howto/functional.rst:1230 ../../howto/functional.rst:1228
msgid ""
"https://en.wikipedia.org/wiki/Currying: Entry for the concept of currying."
msgstr "https://en.wikipedia.org/wiki/Currying: currying 概念的條目。"

#: ../../howto/functional.rst:1233 ../../howto/functional.rst:1231
msgid "Python-specific"
msgstr "Python 特有"

#: ../../howto/functional.rst:1235 ../../howto/functional.rst:1233
#, fuzzy
msgid ""
"https://gnosis.cx/TPiP/: The first chapter of David Mertz's book :title-"
"reference:`Text Processing in Python` discusses functional programming for "
"text processing, in the section titled \"Utilizing Higher-Order Functions in "
"Text Processing\"."
msgstr ""
"https://gnosis.cx/TPiP/: David Mertz 的書 :title-reference:`Python 文字處理` "
"第一章，討論利用高階函式在文字處理上的功能程式設計。"

#: ../../howto/functional.rst:1240 ../../howto/functional.rst:1238
msgid ""
"Mertz also wrote a 3-part series of articles on functional programming for "
"IBM's DeveloperWorks site; see `part 1 <https://developer.ibm.com/articles/l-"
"prog/>`__, `part 2 <https://developer.ibm.com/tutorials/l-prog2/>`__, and "
"`part 3 <https://developer.ibm.com/tutorials/l-prog3/>`__,"
msgstr ""
"Mertz 在 IBM 的 DeveloperWorks 上撰寫了分三部分的函式程式設計相關系列文章；請"
"查閱\\ `第一部分 <https://developer.ibm.com/articles/l-prog/>`__、`第二部分 "
"<https://developer.ibm.com/tutorials/l-prog2/>`__\\ 和\\ `第三部分 <https://"
"developer.ibm.com/tutorials/l-prog3/>`__。"

#: ../../howto/functional.rst:1248 ../../howto/functional.rst:1246
msgid "Python documentation"
msgstr "Python 說明文件"

#: ../../howto/functional.rst:1250 ../../howto/functional.rst:1248
msgid "Documentation for the :mod:`itertools` module."
msgstr ":mod:`itertools` 模組的說明文件。"

#: ../../howto/functional.rst:1252 ../../howto/functional.rst:1250
msgid "Documentation for the :mod:`functools` module."
msgstr ":mod:`functools` 模組的說明文件。"

#: ../../howto/functional.rst:1254 ../../howto/functional.rst:1252
msgid "Documentation for the :mod:`operator` module."
msgstr ":mod:`operator` 模組的說明文件。"

#: ../../howto/functional.rst:1256 ../../howto/functional.rst:1254
msgid ":pep:`289`: \"Generator Expressions\""
msgstr ":pep:`289`：「產生器運算式 (Generator Expressions)」"

#: ../../howto/functional.rst:1258 ../../howto/functional.rst:1256
msgid ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
msgstr ""
":pep:`342`：「利用強化型產生器達成協同程式設計」描述的是 Python 2.5 中新增的"
"產生器功能。"
