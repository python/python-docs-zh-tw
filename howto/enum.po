# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# CTHua <illiew2470+pythonTW@gmail.com>, 2023
# Matt Wang <mattwang44@gmail.com>, 2024
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-24 16:01+0800\n"
"PO-Revision-Date: 2024-05-13 19:30+0000\n"
"Last-Translator: Matt Wang <mattwang44@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"

#: ../../howto/enum.rst:3
msgid "Enum HOWTO"
msgstr "如何使用列舉 (Enum)"

#: ../../howto/enum.rst:9
#, fuzzy
msgid ""
"An :class:`Enum` is a set of symbolic names bound to unique values.  They "
"are similar to global variables, but they offer a more useful :func:"
"`repr()`, grouping, type-safety, and a few other features."
msgstr ""
":class:`Enum` 是一組綁定唯一值的符號名稱集合。與全域變數類似，但提供更有用"
"的 :func:`repr()`、分組功能、型別安全以及其他若干特殊功能。"

#: ../../howto/enum.rst:13
#, fuzzy
msgid ""
"They are most useful when you have a variable that can take one of a limited "
"selection of values.  For example, the days of the week::"
msgstr ""
"當你有一個變數可以取值為限定的一部分時，最有用。例如：一周中的日期： ::"

#: ../../howto/enum.rst:26
msgid "Or perhaps the RGB primary colors::"
msgstr "或許是 RGB 主要色彩： ::"

#: ../../howto/enum.rst:34
#, fuzzy
msgid ""
"As you can see, creating an :class:`Enum` is as simple as writing a class "
"that inherits from :class:`Enum` itself."
msgstr ""
"你可以看出來，建立一個:class:`Enum`就像編寫一個從自身繼承的:class:`Enum`類"
"別。"

#: ../../howto/enum.rst:37
msgid "Case of Enum Members"
msgstr "列舉成員的情況"

#: ../../howto/enum.rst:39
#, fuzzy
msgid ""
"Because Enums are used to represent constants, and to help avoid issues with "
"name clashes between mixin-class methods/attributes and enum names, we "
"strongly recommend using UPPER_CASE names for members, and will be using "
"that style in our examples."
msgstr ""
"由於列舉用於表示常數，我們建議使用大寫命名法，以此命名成員。在我們的範例中也"
"會採用這種風格。"

#: ../../howto/enum.rst:44
#, fuzzy
msgid ""
"Depending on the nature of the enum a member's value may or may not be "
"important, but either way that value can be used to get the corresponding "
"member::"
msgstr ""
"根據 enum 的性質，成員的值可能很重要，也可能不太重要，但無論如何這個值都可以"
"用來取得對應的成員： ::"

#: ../../howto/enum.rst:51
#, fuzzy
msgid ""
"As you can see, the ``repr()`` of a member shows the enum name, the member "
"name, and the value.  The ``str()`` of a member shows only the enum name and "
"member name::"
msgstr ""
"你可以看到，一個成員的 ``repr()`` 會顯示列舉名稱、成員名稱和值。而該成員的 "
"``str()`` 僅會顯示列舉名稱和成員名稱： ::"

#: ../../howto/enum.rst:58
#, fuzzy
msgid "The *type* of an enumeration member is the enum it belongs to::"
msgstr "列舉成員的 *型別* 即其所屬的列舉：注意：保留 rst 格式符號： ::"

#: ../../howto/enum.rst:65
msgid "Enum members have an attribute that contains just their :attr:`name`::"
msgstr "列舉成員具有一個屬性，其中僅包含它們的 :attr:`name`： ::"

#: ../../howto/enum.rst:70
#, fuzzy
msgid "Likewise, they have an attribute for their :attr:`value`::"
msgstr "同樣地，它們具有一個屬性用於它們的 :attr:`value` 值： ::"

#: ../../howto/enum.rst:76
#, fuzzy
msgid ""
"Unlike many languages that treat enumerations solely as name/value pairs, "
"Python Enums can have behavior added.  For example, :class:`datetime.date` "
"has two methods for returning the weekday: :meth:`weekday` and :meth:"
"`isoweekday`. The difference is that one of them counts from 0-6 and the "
"other from 1-7. Rather than keep track of that ourselves we can add a method "
"to the :class:`Weekday` enum to extract the day from the :class:`date` "
"instance and return the matching enum member::"
msgstr ""
"與其他把列舉視為純名稱/值對的語言不同，Python 的 Enums 可添加行為。例如，:"
"class:`datetime.date` 有兩個回傳週幾星期幾的方法：:meth:`weekday` 和 :meth:"
"`isoweekday`。差異在於一個從0-6算起，另一個從1-7算起。我們可以新增一個方法到:"
"class:`Weekday` 列舉中 ，以提取日期實例的天數並回傳相應的列舉成員來追蹤它自 "
"己： ::"

#: ../../howto/enum.rst:88
msgid "The complete :class:`Weekday` enum now looks like this::"
msgstr "完整的 :class:`Weekday` 列舉現在看起來像是這樣： ::"

#: ../../howto/enum.rst:103
msgid "Now we can find out what today is!  Observe::"
msgstr "現在我們可以找出今天是哪一天了！請觀察： ::"

#: ../../howto/enum.rst:109
#, fuzzy
msgid ""
"Of course, if you're reading this on some other day, you'll see that day "
"instead."
msgstr "當然，如果你是在其他日期閱讀這篇文章，你會看到該天的日期。"

#: ../../howto/enum.rst:111
#, fuzzy
msgid ""
"This :class:`Weekday` enum is great if our variable only needs one day, but "
"what if we need several?  Maybe we're writing a function to plot chores "
"during a week, and don't want to use a :class:`list` -- we could use a "
"different type of :class:`Enum`::"
msgstr ""
"這個 :class:`Weekday` 列舉型別對於只需要一天的變數很方便，但如果我們需要多天"
"呢？也許我們正在撰寫一個函式，要在整週繪製家務事項，而不想使用 :class:`list` "
"-- 我們可以使用另一種 :class:`Enum` 型別： ::"

#: ../../howto/enum.rst:126
#, fuzzy
msgid ""
"We've changed two things: we're inherited from :class:`Flag`, and the values "
"are all powers of 2."
msgstr "我們做了兩件事：一是繼承 :class:`Flag` 類別，二是所有的值都是2的乘方。"

#: ../../howto/enum.rst:129
msgid ""
"Just like the original :class:`Weekday` enum above, we can have a single "
"selection::"
msgstr "就像原本的 :class:`Weekday` 列舉一樣，我們可以進行單一選擇： ::"

#: ../../howto/enum.rst:135
msgid ""
"But :class:`Flag` also allows us to combine several members into a single "
"variable::"
msgstr "但是 :class:`Flag` 也允許我們將數個成員結合為一個變數： ::"

#: ../../howto/enum.rst:142
msgid "You can even iterate over a :class:`Flag` variable::"
msgstr "你甚至可以疊代一個 :class:`Flag` 變數： ::"

#: ../../howto/enum.rst:149
msgid "Okay, let's get some chores set up::"
msgstr "好的，讓我們進行一些設定： ::"

#: ../../howto/enum.rst:157
#, fuzzy
msgid "And a function to display the chores for a given day::"
msgstr "以下是給定一個日期的家務事項顯示函式： ::"

#: ../../howto/enum.rst:167
#, fuzzy
msgid ""
"In cases where the actual values of the members do not matter, you can save "
"yourself some work and use :func:`auto()` for the values::"
msgstr ""
"如果成員的實際值不重要，你可以省去一些工作，並使用 :func:`auto()` 替代數"
"值： ::"

#: ../../howto/enum.rst:186
msgid "Programmatic access to enumeration members and their attributes"
msgstr "可以用程式化的方式存取列舉成員及其屬性"

#: ../../howto/enum.rst:188
#, fuzzy
msgid ""
"Sometimes it's useful to access members in enumerations programmatically (i."
"e. situations where ``Color.RED`` won't do because the exact color is not "
"known at program-writing time).  ``Enum`` allows such access::"
msgstr ""
"有時候，以程式方式存取列舉中的成員是很有用且必要的（例如在編寫程式時無法確定"
"正確顏色，因此使用 ``Color.RED`` 就不合適）。在這種情況下，可以利用 ``Enum`` "
"來存取： ::"

#: ../../howto/enum.rst:197
msgid "If you want to access enum members by *name*, use item access::"
msgstr "如果你想要透過 *name* 存取列舉成員，請使用項目來存取： ::"

#: ../../howto/enum.rst:204
#, fuzzy
msgid "If you have an enum member and need its :attr:`name` or :attr:`value`::"
msgstr ""
"如果你有一個列舉的成員，並需要獲取其 :attr:`name` 或 :attr:`value`屬性： ::"

#: ../../howto/enum.rst:214
msgid "Duplicating enum members and values"
msgstr "複製列舉成員和值"

#: ../../howto/enum.rst:216
msgid "Having two enum members with the same name is invalid::"
msgstr "擁有兩個同名的列舉成員是無效的： ::"

#: ../../howto/enum.rst:226
#, fuzzy
msgid ""
"However, an enum member can have other names associated with it.  Given two "
"entries ``A`` and ``B`` with the same value (and ``A`` defined first), ``B`` "
"is an alias for the member ``A``.  By-value lookup of the value of ``A`` "
"will return the member ``A``.  By-name lookup of ``A`` will return the "
"member ``A``. By-name lookup of ``B`` will also return the member ``A``::"
msgstr ""
"然而，列舉成員可以有其它名稱與之相關聯。假設有兩個項目 ``A`` 與 ``B``，且其值"
"相同 (且``A``定義在前面)，則 ``B`` 是成員 ``A`` 的別名。透過取得 \"by-"
"value\"屬性來查找 \"A\"的值會回傳成員\"A\"； 透過 \"by-name\"方式查找\"A\"也"
"會回傳成員\"A\"；透過 \"by-name\" 方式查找\"B\"，同樣也會回傳 成員 ``A``： ::"

#: ../../howto/enum.rst:247
#, fuzzy
msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr ""
"嘗試建立一個與已定義的屬性（另一個成員、方法等）同名的成員，或者嘗試建立一個"
"與成 員同名的屬性是不被允許的。"

#: ../../howto/enum.rst:253
msgid "Ensuring unique enumeration values"
msgstr "確保列舉值唯一"

#: ../../howto/enum.rst:255
#, fuzzy
msgid ""
"By default, enumerations allow multiple names as aliases for the same value. "
"When this behavior isn't desired, you can use the :func:`unique` decorator::"
msgstr ""
"預設情況下，列舉型別允許使用多個名稱作為相同值的別名。當不希望這種行為時，可"
"以使用 :func:`unique` 裝飾器： ::"

#: ../../howto/enum.rst:272
msgid "Using automatic values"
msgstr "使用自動產生的值"

#: ../../howto/enum.rst:274
#, fuzzy
msgid "If the exact value is unimportant you can use :class:`auto`::"
msgstr "如果精確值不重要，可以使用 :class:`auto`： ::"

#: ../../howto/enum.rst:285
#, fuzzy
msgid ""
"The values are chosen by :func:`_generate_next_value_`, which can be "
"overridden::"
msgstr "值是由 :func:`_generate_next_value_` 決定的，可以被覆寫： ::"

#: ../../howto/enum.rst:304
#, fuzzy
msgid ""
"The :meth:`_generate_next_value_` method must be defined before any members."
msgstr "在任何成員之前都必須先定義 :meth:`_generate_next_value_` 方法。"

#: ../../howto/enum.rst:307
msgid "Iteration"
msgstr "疊代"

#: ../../howto/enum.rst:309
#, fuzzy
msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr "逐一列舉列舉型別的成員時不提供其別名： ::"

#: ../../howto/enum.rst:316
#, fuzzy
msgid ""
"Note that the aliases ``Shape.ALIAS_FOR_SQUARE`` and ``Weekday.WEEKEND`` "
"aren't shown."
msgstr ""
"注意：別名 ``Shape.ALIAS_FOR_SQUARE`` 和 ``Weekday.WEEKEND`` 沒有顯示。"

#: ../../howto/enum.rst:318
#, fuzzy
msgid ""
"The special attribute ``__members__`` is a read-only ordered mapping of "
"names to members.  It includes all names defined in the enumeration, "
"including the aliases::"
msgstr ""
"特殊屬性 ``__members__`` 是一個只能讀取的有序映射，從名稱到成員。它包括了列舉"
"中定義的所有名稱，包括別名： ::"

#: ../../howto/enum.rst:330
#, fuzzy
msgid ""
"The ``__members__`` attribute can be used for detailed programmatic access "
"to the enumeration members.  For example, finding all the aliases::"
msgstr ""
"``__members__`` 屬性可用於對列舉成員進行詳細的程式設計訪問。例如，查找所有別"
"名： ::"

#: ../../howto/enum.rst:338
#, fuzzy
msgid ""
"Aliases for flags include values with multiple flags set, such as ``3``, and "
"no flags set, i.e. ``0``."
msgstr ""
"輸入參數的別名可以使用在有多個指令旗標時，例如 `3`；也可用於無任何指令旗標"
"時，即 `0`。"

#: ../../howto/enum.rst:343
msgid "Comparisons"
msgstr "比較"

#: ../../howto/enum.rst:345
#, fuzzy
msgid "Enumeration members are compared by identity::"
msgstr "列舉成員按識別性進行比較： ::"

#: ../../howto/enum.rst:354
#, fuzzy
msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum "
"members are not integers (but see `IntEnum`_ below)::"
msgstr ""
"不支援列舉值之間的排序比較。列舉成員並非整數（但下方可參考 `IntEnum`_）： ::"

#: ../../howto/enum.rst:362
#, fuzzy
msgid "Equality comparisons are defined though::"
msgstr "等式比較是透過以下定義： ::"

#: ../../howto/enum.rst:371
#, fuzzy
msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, see "
"below)::"
msgstr ""
"對不包含列舉值的比較總是會得到「不相等」（再一次地，:class:`IntEnum` 是有特別"
"定義的行為，詳情見下文）： ::"

#: ../../howto/enum.rst:380
#, fuzzy
msgid ""
"It is possible to reload modules -- if a reloaded module contains enums, "
"they will be recreated, and the new members may not compare identical/equal "
"to the original members."
msgstr ""
"可以重新加載模組——如果重新加載的模組包含列舉，它們將被重新建立，並且新成員可"
"能不會與原始成員相同/相等。"

#: ../../howto/enum.rst:385
msgid "Allowed members and attributes of enumerations"
msgstr "列舉型別中的允許成員和屬性"

#: ../../howto/enum.rst:387
#, fuzzy
msgid ""
"Most of the examples above use integers for enumeration values.  Using "
"integers is short and handy (and provided by default by the `Functional "
"API`_), but not strictly enforced.  In the vast majority of use-cases, one "
"doesn't care what the actual value of an enumeration is.  But if the value "
"*is* important, enumerations can have arbitrary values."
msgstr ""
"大部分上面的範例都使用整數來作為列舉值。使用整數即方便又快速（而且Functional "
"API預設也會支援），但不是強制性的做法。在極大多數情況下，一個資料列舉實際所代"
"表的值不重要。但如果該值很重要，你仍可以隨意指定任何需求所涵蓋到之列舉值。"

#: ../../howto/enum.rst:393
#, fuzzy
msgid ""
"Enumerations are Python classes, and can have methods and special methods as "
"usual.  If we have this enumeration::"
msgstr ""
"列舉是 Python 中的一種類別，可像慣例中的其他類別一樣，具有方法和特殊方法。若"
"我們定義以下列舉： ::"

#: ../../howto/enum.rst:413
msgid "Then::"
msgstr "接著是： ::"

#: ../../howto/enum.rst:422
#, fuzzy
msgid ""
"The rules for what is allowed are as follows: names that start and end with "
"a single underscore are reserved by enum and cannot be used; all other "
"attributes defined within an enumeration will become members of this "
"enumeration, with the exception of special methods (:meth:`__str__`, :meth:"
"`__add__`, etc.), descriptors (methods are also descriptors), and variable "
"names listed in :attr:`_ignore_`."
msgstr ""
"定義列舉時，需注意以下規則：命名以一個底線開頭和結尾的名稱保留給 enum ，不能"
"使用；除了特殊方法（例如: :meth:`__str__`, :meth:`__add__` 等）、描述符 (方法"
"也是描述符) 以及在 :attr:`_ignore_` 中列出的變數名之外，定義於列舉內部的所有"
"屬性都會成為此列舉類別的成員。"

#: ../../howto/enum.rst:429
#, fuzzy
msgid ""
"Note:  if your enumeration defines :meth:`__new__` and/or :meth:`__init__`, "
"any value(s) given to the enum member will be passed into those methods. See "
"`Planet`_ for an example."
msgstr ""
"請注意：如果你的列舉定義了 ``__new__`` 和/或 ``__init__`` 方法，則任何指定給"
"該列舉成員的值都將傳遞到這些方法中。請參考 `Planet`_ 的範例。"

#: ../../howto/enum.rst:435
#, fuzzy
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members.  See :ref:`new-vs-init` for "
"more details."
msgstr ""
"__new__` 方法（如果定義）將在建立 Enum 成員期間使用；然後它被 Enum 的 "
"__new__` 替換，該 __new__` 在類別建立後用於尋找現有成員。有關更多詳細資訊，請"
"參閱：ref:`new-vs-init`。"

#: ../../howto/enum.rst:442
msgid "Restricted Enum subclassing"
msgstr "受限列舉子類別化"

#: ../../howto/enum.rst:444
#, fuzzy
msgid ""
"A new :class:`Enum` class must have one base enum class, up to one concrete "
"data type, and as many :class:`object`-based mixin classes as needed.  The "
"order of these base classes is::"
msgstr ""
"一個新的 :class:`Enum` 類別必須擁有一個基礎列舉(enum)類別、不超過一種具體的資"
"料型別(data type)，以及所需的任意數量使用 :class:`object` 為基礎(mixin) 的混"
"合類別。這些基礎類別(base classes)之間的順序為： ::"

#: ../../howto/enum.rst:451
#, fuzzy
msgid ""
"Also, subclassing an enumeration is allowed only if the enumeration does not "
"define any members.  So this is forbidden::"
msgstr ""
"同時，只有在列舉型別未定義任何成員時才允許子類化enumeration。因此，這是被禁止"
"的： ::"

#: ../../howto/enum.rst:461
msgid "But this is allowed::"
msgstr "但這是允許的： ::"

#: ../../howto/enum.rst:472
#, fuzzy
msgid ""
"Allowing subclassing of enums that define members would lead to a violation "
"of some important invariants of types and instances.  On the other hand, it "
"makes sense to allow sharing some common behavior between a group of "
"enumerations. (See `OrderedEnum`_ for an example.)"
msgstr ""
"允許定義成員的列舉型別可以被繼承，但這也會違反一些重要的類型和實例不變數。然"
"而，在一組列舉中，允許共享某些通用的行為是有道理的。(例如參考 `OrderedEnum`_ "
"之範例) 。"

#: ../../howto/enum.rst:481
#, fuzzy
msgid "Dataclass support"
msgstr "資料類支援"

#: ../../howto/enum.rst:483
#, fuzzy
msgid ""
"When inheriting from a :class:`~dataclasses.dataclass`, the :meth:`~Enum."
"__repr__` omits the inherited class' name.  For example::"
msgstr ""
"當從:class:`~dataclasses.dataclass` 繼承時，:meth:`~Enum.__repr__` 會省略繼承"
"的類別的名稱。例如：："

#: ../../howto/enum.rst:500
#, fuzzy
msgid ""
"Use the :func:`!dataclass` argument ``repr=False`` to use the standard :func:"
"`repr`."
msgstr "使用 :func:`!dataclass` 參數 ``repr=False`` 來使用標準 :func:`repr`。"

#: ../../howto/enum.rst:503
#, fuzzy
msgid ""
"Only the dataclass fields are shown in the value area, not the dataclass' "
"name."
msgstr "值區域中僅顯示資料類欄位，而不顯示資料類名稱。"

#: ../../howto/enum.rst:509
msgid "Pickling"
msgstr "Pickling"

#: ../../howto/enum.rst:511
msgid "Enumerations can be pickled and unpickled::"
msgstr "列舉可以被 pickle 和 unpickle： ::"

#: ../../howto/enum.rst:518
#, fuzzy
msgid ""
"The usual restrictions for pickling apply: picklable enums must be defined "
"in the top level of a module, since unpickling requires them to be "
"importable from that module."
msgstr ""
"通常對於 pickling 有一些限制：可 pickle 的列舉型別必須在模組的最上層定義，因"
"為反序列化需要它們從該模組中 importable。"

#: ../../howto/enum.rst:524
#, fuzzy
msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums nested "
"in other classes."
msgstr ""
"從 pickle 協議版本 4 開始，嵌套在其他類別內的 enums 可以方便地進行序列化"
"（pickle）。"

#: ../../howto/enum.rst:527
#, fuzzy
msgid ""
"It is possible to modify how enum members are pickled/unpickled by defining :"
"meth:`__reduce_ex__` in the enumeration class.  The default method is by-"
"value, but enums with complicated values may want to use by-name::"
msgstr ""
"可以透過在列舉類別中定義 :meth:`__reduce_ex__` 來修改列舉成員的取捨（pickled/"
"unpickled）方式： ::"

#: ../../howto/enum.rst:537
#, fuzzy
msgid ""
"Using by-name for flags is not recommended, as unnamed aliases will not "
"unpickle."
msgstr "不建議旗標使用依名稱，因為未命名的別名不會被 unpickle。"

#: ../../howto/enum.rst:542
msgid "Functional API"
msgstr "功能性 API"

#: ../../howto/enum.rst:544
msgid ""
"The :class:`Enum` class is callable, providing the following functional API::"
msgstr ":class:`Enum` 類別是可呼叫物件，並提供以下功能性 API： ::"

#: ../../howto/enum.rst:554
#, fuzzy
msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the enumeration."
msgstr ""
"這個 API 的語義類似 :class:`~collections.namedtuple`。叫用 :class:`Enum` 的第"
"一個引數是列舉型別的名稱。"

#: ../../howto/enum.rst:557
#, fuzzy
msgid ""
"The second argument is the *source* of enumeration member names.  It can be "
"a whitespace-separated string of names, a sequence of names, a sequence of 2-"
"tuples with key/value pairs, or a mapping (e.g. dictionary) of names to "
"values.  The last two options enable assigning arbitrary values to "
"enumerations; the others auto-assign increasing integers starting with 1 "
"(use the ``start`` parameter to specify a different starting value).  A new "
"class derived from :class:`Enum` is returned.  In other words, the above "
"assignment to :class:`Animal` is equivalent to::"
msgstr ""
"第二個參數是列舉成員名稱的「來源」。它可以是由空格分隔的字串、一系列名稱、具"
"有鍵值對的 2 元序列，或者映射(例如字典)，其中包含了名稱和相應值。最後兩個選項"
"使得能夠將任意值指定給列舉；其他則自動分配從 1 開始增加的整數 (使用 "
"``start`` 參數可指定不同的起始值) 。回傳一個衍生自 :class:`Enum` 的新類別。換"
"句話說，上面賦予 :class:`Animal` 的功能等價於： ::"

#: ../../howto/enum.rst:573
#, fuzzy
msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` is "
"that ``0`` is ``False`` in a boolean sense, but by default enum members all "
"evaluate to ``True``."
msgstr ""
"預設將起始數字設為 ``1`` 而非 ``0`` 的原因是，布林運算中 ``0`` 為 ``False``, "
"但列舉型別中成員的預設值皆為真（evaluate to True）。"

#: ../../howto/enum.rst:577
#, fuzzy
msgid ""
"Pickling enums created with the functional API can be tricky as frame stack "
"implementation details are used to try and figure out which module the "
"enumeration is being created in (e.g. it will fail if you use a utility "
"function in a separate module, and also may not work on IronPython or "
"Jython). The solution is to specify the module name explicitly as follows::"
msgstr ""
"使用函式 API 建立的列舉型別可能會比較棘手，因為框架堆疊實現細節被用來嘗試找出"
"建立列舉型別的模組（例如，如果在另一個模組中使用實用工具函式則失敗，在 "
"IronPython 或 Jython 上也可能無法正常運作）。解決方案是明確指定模組名稱，如下"
"所示： ::"

#: ../../howto/enum.rst:587
#, fuzzy
msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the new "
"Enum members will not be unpicklable; to keep errors closer to the source, "
"pickling will be disabled."
msgstr ""
"如果未提供``module``，且Enum不能確定它是什麼，新的Enum成員將無法進行反序列"
"化; 為了讓錯誤更接近源頭，pickling會被禁用。"

#: ../../howto/enum.rst:591
#, fuzzy
msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on :attr:"
"`~definition.__qualname__` being set to the location where pickle will be "
"able to find the class.  For example, if the class was made available in "
"class SomeData in the global scope::"
msgstr ""
"新的 pickle 協議 4 在某些情況下還依賴於 :attr:``~definition.__qualname__`` 設"
"置為 pickle 能找到該類別位置的屬性。舉例而言，如果在全域範圍內建立了一個名為 "
"SomeData 的類別： ::"

#: ../../howto/enum.rst:598
msgid "The complete signature is::"
msgstr "完整的函式為： ::"

#: ../../howto/enum.rst:610
msgid "*value*: What the new enum class will record as its name."
msgstr "*value*：新列舉類別將記錄為其名稱。"

#: ../../howto/enum.rst:612
#, fuzzy
msgid ""
"*names*: The enum members.  This can be a whitespace- or comma-separated "
"string (values will start at 1 unless otherwise specified)::"
msgstr ""
"*names*：列出 enum 的成員，這應為一個換行或以逗號分隔的字串（否則值將從 1 開"
"始）： ::"

#: ../../howto/enum.rst:617
msgid "or an iterator of names::"
msgstr "或一個名稱的疊代器： ::"

#: ../../howto/enum.rst:621
msgid "or an iterator of (name, value) pairs::"
msgstr "或是一個 (name, value) 對的疊代器： ::"

#: ../../howto/enum.rst:625
msgid "or a mapping::"
msgstr "或是一個對映： ::"

#: ../../howto/enum.rst:629
#, fuzzy
msgid "*module*: name of module where new enum class can be found."
msgstr "*module*：可以找到新列舉類別的模組的名稱。"

#: ../../howto/enum.rst:631
#, fuzzy
msgid "*qualname*: where in module new enum class can be found."
msgstr "*qualname*：在模組中可以找到新列舉類別的位置。"

#: ../../howto/enum.rst:633
msgid "*type*: type to mix in to new enum class."
msgstr "*type*：混合到新列舉類別中的型別。"

#: ../../howto/enum.rst:635
msgid "*start*: number to start counting at if only names are passed in."
msgstr "*start*：如果僅傳入名稱，則從該數字開始計數。"

#: ../../howto/enum.rst:637
msgid "The *start* parameter was added."
msgstr "新增了 *start* 參數。"

#: ../../howto/enum.rst:642
msgid "Derived Enumerations"
msgstr "衍生列舉"

#: ../../howto/enum.rst:645
msgid "IntEnum"
msgstr "IntEnum"

#: ../../howto/enum.rst:647
#, fuzzy
msgid ""
"The first variation of :class:`Enum` that is provided is also a subclass of :"
"class:`int`.  Members of an :class:`IntEnum` can be compared to integers; by "
"extension, integer enumerations of different types can also be compared to "
"each other::"
msgstr ""
"提供的第一種:class:`Enum`變異體也是 :class:`int` 的子類別。:class:`IntEnum` "
"成員可與整數進行比較；由此，不同型別的整數列舉也可以相互比較： ::"

#: ../../howto/enum.rst:668
msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr "然而，它們仍無法與標準的 :class:`Enum` 型別相比較： ::"

#: ../../howto/enum.rst:681
msgid ""
":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr ":class:`IntEnum` 型別的值在其他方面的行為就像你所預期的整數一樣： ::"

#: ../../howto/enum.rst:692
msgid "StrEnum"
msgstr "StrEnum"

#: ../../howto/enum.rst:694
#, fuzzy
msgid ""
"The second variation of :class:`Enum` that is provided is also a subclass "
"of :class:`str`.  Members of a :class:`StrEnum` can be compared to strings; "
"by extension, string enumerations of different types can also be compared to "
"each other."
msgstr ""
"提供第二種 :class:`Enum` 變型的子類別 :class:`StrEnum`。:class:`StrEnum` 的成"
"員可與字串比較；因此，不同型態的字串列舉也可以彼此比較。"

#: ../../howto/enum.rst:703
msgid "IntFlag"
msgstr "IntFlag"

#: ../../howto/enum.rst:705
#, fuzzy
msgid ""
"The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
"based on :class:`int`.  The difference being :class:`IntFlag` members can be "
"combined using the bitwise operators (&, \\|, ^, ~) and the result is still "
"an :class:`IntFlag` member, if possible.  Like :class:`IntEnum`, :class:"
"`IntFlag` members are also integers and can be used wherever an :class:`int` "
"is used."
msgstr ""
"提供的 Enum 的下一個變體 IntFlag 也基於 int。差別在於 IntFlag 成員可以使用位"
"元運算子（&、\\|、^、~）進行組合，如果可能的話，結果仍然是 IntFlag 成員。與 "
"IntEnum 一樣，IntFlag 成員也是整數，並且可以在使用 int 的任何地方使用。"

#: ../../howto/enum.rst:713
#, fuzzy
msgid ""
"Any operation on an :class:`IntFlag` member besides the bit-wise operations "
"will lose the :class:`IntFlag` membership."
msgstr ""
"除了以位元運算的方式操作 :class:`IntFlag` 成員之外，其他任何操作都會使這個成"
"員失去屬於 :class:`IntFlag` 的身份。"

#: ../../howto/enum.rst:716
#, fuzzy
msgid ""
"Bit-wise operations that result in invalid :class:`IntFlag` values will lose "
"the :class:`IntFlag` membership.  See :class:`FlagBoundary` for details."
msgstr ""
"進行位元運算，若導致 :class:`IntFlag` 值無效，就會失去 :class:`IntFlag` 成員"
"資格。詳細資訊請參考 :class:`FlagBoundary`。"

#: ../../howto/enum.rst:723
msgid "Sample :class:`IntFlag` class::"
msgstr "範例 :class:`IntFlag` 類別： ::"

#: ../../howto/enum.rst:739
msgid "It is also possible to name the combinations::"
msgstr "可以為這些組合命名： ::"

#: ../../howto/enum.rst:756
#, fuzzy
msgid ""
"Named combinations are considered aliases.  Aliases do not show up during "
"iteration, but can be returned from by-value lookups."
msgstr ""
"已命名的組合被視為別名。\"Aliases\" 在疊代時不會顯示，但可以從按值查找中回"
"傳。"

#: ../../howto/enum.rst:761
#, fuzzy
msgid ""
"Another important difference between :class:`IntFlag` and :class:`Enum` is "
"that if no flags are set (the value is 0), its boolean evaluation is :data:"
"`False`::"
msgstr ""
":class:`IntFlag` 和 :class:`Enum` 之間的另一個重要差異是，如果沒有設定旗標"
"（值為0），那麼它的布林估值就是 :data:`False`： ::"

#: ../../howto/enum.rst:769
#, fuzzy
msgid ""
"Because :class:`IntFlag` members are also subclasses of :class:`int` they "
"can be combined with them (but may lose :class:`IntFlag` membership::"
msgstr ""
"由於 :class:`IntFlag` 成員也是 :class:`int` 的子類別，因此它們可以與這些數值"
"結合使用 (但其可能失去 :class:`IntFlag` 的成員身份) ： ::"

#: ../../howto/enum.rst:780
#, fuzzy
msgid ""
"The negation operator, ``~``, always returns an :class:`IntFlag` member with "
"a positive value::"
msgstr ""
"否定運算子 ``~``，總是會回傳一個 :class:`IntFlag` 成員，其值為正數： ::"

#: ../../howto/enum.rst:786
msgid ":class:`IntFlag` members can also be iterated over::"
msgstr ":class:`IntFlag` 的成員也可以進行疊代： ::"

#: ../../howto/enum.rst:795
msgid "Flag"
msgstr "Flag"

#: ../../howto/enum.rst:797
#, fuzzy
msgid ""
"The last variation is :class:`Flag`.  Like :class:`IntFlag`, :class:`Flag` "
"members can be combined using the bitwise operators (&, \\|, ^, ~).  Unlike :"
"class:`IntFlag`, they cannot be combined with, nor compared against, any "
"other :class:`Flag` enumeration, nor :class:`int`.  While it is possible to "
"specify the values directly it is recommended to use :class:`auto` as the "
"value and let :class:`Flag` select an appropriate value."
msgstr ""
"最後一個變體是 Flag。與 IntFlag 一樣，Flag 成員可以使用位元運算子（&、\\|、"
"^、~）進行組合。與 IntFlag 不同，它們不能與任何其他 Flag 列舉或 int 組合或比"
"較。雖然可以直接指定值，但建議使用 auto 作為值，並讓 Flag 選擇適當的值。"

#: ../../howto/enum.rst:806
#, fuzzy
msgid ""
"Like :class:`IntFlag`, if a combination of :class:`Flag` members results in "
"no flags being set, the boolean evaluation is :data:`False`::"
msgstr ""
"類似 :class:`IntFlag` 的作法，如果一組 :class:`Flag` 類別的成員結果沒有任何旗"
"標被設定，那麼布林式評估會是 :data:`False`： ::"

#: ../../howto/enum.rst:820
#, fuzzy
msgid ""
"Individual flags should have values that are powers of two (1, 2, 4, "
"8, ...), while combinations of flags will not::"
msgstr ""
"個別的旗標 (flag) 應該具有 2 的次方數值 (1, 2, 4, 8...)，而旗標組合則不"
"會： ::"

#: ../../howto/enum.rst:832
#, fuzzy
msgid ""
"Giving a name to the \"no flags set\" condition does not change its boolean "
"value::"
msgstr "將「無旗標設置」狀況命名並不會改變其布林值："

#: ../../howto/enum.rst:846
msgid ":class:`Flag` members can also be iterated over::"
msgstr ":class:`Flag` 成員也可以被疊代： ::"

#: ../../howto/enum.rst:856
#, fuzzy
msgid ""
"For the majority of new code, :class:`Enum` and :class:`Flag` are strongly "
"recommended, since :class:`IntEnum` and :class:`IntFlag` break some semantic "
"promises of an enumeration (by being comparable to integers, and thus by "
"transitivity to other unrelated enumerations).  :class:`IntEnum` and :class:"
"`IntFlag` should be used only in cases where :class:`Enum` and :class:`Flag` "
"will not do; for example, when integer constants are replaced with "
"enumerations, or for interoperability with other systems."
msgstr ""
"對於大部分的新程式碼，強烈建議使用 :class:`Enum` 和 :class:`Flag`, 因為 :"
"class:`IntEnum` 和 :class:`IntFlag` 違反了列舉型別的一些語意承諾(可比較整數，"
"因此也可適用於其他無關聯的列舉型別)。只有在不具備:class: `Enum`和:class: "
"`Flag` 的功能時方才應使用:class: ` IntEnum`與： class：``IntDate``；例如當整"
"數常量被替換成列舉常量或需要互通性質上其他系統時。"

#: ../../howto/enum.rst:866
msgid "Others"
msgstr "其他"

#: ../../howto/enum.rst:868
#, fuzzy
msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be very "
"simple to implement independently::"
msgstr ""
"雖然 :class:`IntEnum` 是 :mod:`enum` 模組的一部分，但獨立實現也非常簡單： ::"

#: ../../howto/enum.rst:874
#, fuzzy
msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`FloatEnum` that mixes in :class:`float` instead of :class:"
"`int`."
msgstr ""
"這展示了多種派生列舉定義相似之處；例如，一個以浮點型別（``float``）混入代替整"
"數（``int``）的 ``FloatEnum`` 類別。"

#: ../../howto/enum.rst:877
msgid "Some rules:"
msgstr "一些規則："

#: ../../howto/enum.rst:879
#, fuzzy
msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before :class:"
"`Enum` itself in the sequence of bases, as in the :class:`IntEnum` example "
"above."
msgstr ""
"當子類別化 :class:`Enum` 時，mix-in 的型別必須在 :class:`Enum` 本身之前出現於"
"基礎序列中，就像先前舉的 :class:`IntEnum` 範例。"

#: ../../howto/enum.rst:882
#, fuzzy
msgid ""
"Mix-in types must be subclassable. For example, :class:`bool` and :class:"
"`range` are not subclassable and will throw an error during Enum creation if "
"used as the mix-in type."
msgstr ""
"混入類別必須是可被繼承的。例如 :class:`bool` 和 :class:`range` 並非可被子類化"
"的，如果用於作為混入類型則會在建立列舉時拋出錯誤訊息。"

#: ../../howto/enum.rst:885
#, fuzzy
msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. :class:"
"`int` above.  This restriction does not apply to mix-ins which only add "
"methods and don't specify another type."
msgstr ""
"雖然:class:`Enum`可以包含任何型別的成員，但是一旦混合了其他型別，所有的成員都"
"必須具有該型別的值，例如上面提到的 :class:`int`。這個限制不適用於僅添加方法而"
"未指定另一種類型的 mixin。"

#: ../../howto/enum.rst:889
#, fuzzy
msgid ""
"When another data type is mixed in, the :attr:`value` attribute is *not the "
"same* as the enum member itself, although it is equivalent and will compare "
"equal."
msgstr ""
"當enum與其他型別混在一起時，即使他們是相等的且具有可比性，該列舉成員本身和屬"
"性 :attr:`value` *不會完全相同*。"

#: ../../howto/enum.rst:892
#, fuzzy
msgid ""
"A ``data type`` is a mixin that defines :meth:`__new__`, or a :class:"
"`~dataclasses.dataclass`"
msgstr ""
"``data type`` 是定義 :meth:`__new__` 或 :class:`~dataclasses.dataclass` 的 "
"mixin"

#: ../../howto/enum.rst:894
#, fuzzy
msgid ""
"%-style formatting:  ``%s`` and ``%r`` call the :class:`Enum` class's :meth:"
"`__str__` and :meth:`__repr__` respectively; other codes (such as ``%i`` or "
"``%h`` for IntEnum) treat the enum member as its mixed-in type."
msgstr ""
"% 風格的格式化：使用 ``%s`` 和 ``%r``，分別會呼叫 :class:`Enum` 類別的 :meth:"
"`__str__` 和 :meth:`__repr__`；其它格式符號（例如：IntEnum 的 ``%i`` 或 "
"``%h``）則將列舉成員視為其混入型別。"

#: ../../howto/enum.rst:897
msgid ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and :func:"
"`format` will use the enum's :meth:`__str__` method."
msgstr ""
":ref:`格式化字串文本 <f-strings>`、:meth:`str.format` 和 :func:`format` 會使"
"用列舉的 :meth:`__str__` 方法。"

#: ../../howto/enum.rst:902
#, fuzzy
msgid ""
"Because :class:`IntEnum`, :class:`IntFlag`, and :class:`StrEnum` are "
"designed to be drop-in replacements for existing constants, their :meth:"
"`__str__` method has been reset to their data types' :meth:`__str__` method."
msgstr ""
"由於 :class:`IntEnum`、:class:`IntFlag` 和 :class:`StrEnum` 被設計為現有常數"
"的即插即用替代品，因此它們的 :meth:`__str__` 方法已被重置為其資料類型的 :"
"meth:`__str__` 方法。"

#: ../../howto/enum.rst:910
msgid "When to use :meth:`__new__` vs. :meth:`__init__`"
msgstr "何時使用 :meth:`__new__` 而不是 :meth:`__init__`"

#: ../../howto/enum.rst:912
#, fuzzy
msgid ""
":meth:`__new__` must be used whenever you want to customize the actual value "
"of the :class:`Enum` member.  Any other modifications may go in either :meth:"
"`__new__` or :meth:`__init__`, with :meth:`__init__` being preferred."
msgstr ""
"當你想客製化 :class:`Enum` 成員的實際值時，必須使用 :meth:`__new__`。任何其他"
"修改可以放在 :meth:`__new_` 或是 :meth:`__init__` 中，而優先選擇使用 :meth:"
"`__init__ ` 進行修改。"

#: ../../howto/enum.rst:916
#, fuzzy
msgid ""
"For example, if you want to pass several items to the constructor, but only "
"want one of them to be the value::"
msgstr "例如，如果你想傳遞幾個項目給構造函式，但只想其中一個是值： ::"

#: ../../howto/enum.rst:943
#, fuzzy
msgid ""
"*Do not* call ``super().__new__()``, as the lookup-only ``__new__`` is the "
"one that is found; instead, use the data type directly."
msgstr ""
"*不要*呼叫 ``super().__new__()``，因為只查找 ``__new__`` 是找到的；相反，直接"
"使用資料型態。"

#: ../../howto/enum.rst:948
#, fuzzy
msgid "Finer Points"
msgstr "微妙之處"

#: ../../howto/enum.rst:951
msgid "Supported ``__dunder__`` names"
msgstr "有支援的 ``__dunder_ _`` 命名"

#: ../../howto/enum.rst:953
#, fuzzy
msgid ""
":attr:`__members__` is a read-only ordered mapping of ``member_name``:"
"``member`` items.  It is only available on the class."
msgstr ""
":attr:`__members__` 是一個唯讀的有序映射，包含了 ``member_name``:``member`` "
"項目，在類別中才能使用。"

#: ../../howto/enum.rst:956
#, fuzzy
msgid ""
":meth:`__new__`, if specified, must create and return the enum members; it "
"is also a very good idea to set the member's :attr:`_value_` appropriately.  "
"Once all the members are created it is no longer used."
msgstr ""
"如果指定了 `:meth:`__new__`` 則必須建立並回傳列舉成員；同時，為其 :attr:"
"`_value_` 正確設值是一個非常好的選擇。當所有成員都建立完成後，此方法將不再使"
"用。"

#: ../../howto/enum.rst:962
msgid "Supported ``_sunder_`` names"
msgstr "有支援的 ``_sunder_`` 命名"

#: ../../howto/enum.rst:964
msgid "``_name_`` -- name of the member"
msgstr "``_name_`` -- 成員的名稱"

#: ../../howto/enum.rst:965
msgid ""
"``_value_`` -- value of the member; can be set / modified in ``__new__``"
msgstr "``_value_`` -- 成員的值；可在 ``__new__`` 中設定/修改"

#: ../../howto/enum.rst:967
msgid ""
"``_missing_`` -- a lookup function used when a value is not found; may be "
"overridden"
msgstr "``_missing_`` -- 當找不到值時使用的查詢函式；可以被覆寫"

#: ../../howto/enum.rst:969
#, fuzzy
msgid ""
"``_ignore_`` -- a list of names, either as a :class:`list` or a :class:"
"`str`, that will not be transformed into members, and will be removed from "
"the final class"
msgstr ""
"``_ignore_`` -- 包含不需要作為類別成員的名稱的列表，必須是 :class:`list` 或 :"
"class:`str` 類型，這些名稱將不會轉換為類別成員且將從最終所建立的類別中移除"

#: ../../howto/enum.rst:972
#, fuzzy
msgid ""
"``_order_`` -- used in Python 2/3 code to ensure member order is consistent "
"(class attribute, removed during class creation)"
msgstr ""
"``_order_`` -- 在 Python 2/3 程式碼中使用以確保成員順序一致（類屬性，在類建立"
"期間刪除）"

#: ../../howto/enum.rst:974
#, fuzzy
msgid ""
"``_generate_next_value_`` -- used by the `Functional API`_ and by :class:"
"`auto` to get an appropriate value for an enum member; may be overridden"
msgstr ""
"``_generate_next_value_`` 是供 `Functional API`_ 和 :class:`auto` 使用的方"
"法，以便取得適當的列舉成員值；可被覆寫。"

#: ../../howto/enum.rst:980
msgid ""
"For standard :class:`Enum` classes the next value chosen is the last value "
"seen incremented by one."
msgstr "對於標準的 :class:`Enum` 類別，下一個選擇的值是最後看到的值加一。"

#: ../../howto/enum.rst:983
#, fuzzy
msgid ""
"For :class:`Flag` classes the next value chosen will be the next highest "
"power-of-two, regardless of the last value seen."
msgstr ""
"對於 :class:`Flag` 類別，下一個被選擇的值是接下來最高的二次冪，無論上一個值是"
"否見過。"

#: ../../howto/enum.rst:986
msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``、``_order_``、``_generate_next_value_``"

#: ../../howto/enum.rst:987
msgid "``_ignore_``"
msgstr "``_ignore_``"

#: ../../howto/enum.rst:989
#, fuzzy
msgid ""
"To help keep Python 2 / Python 3 code in sync an :attr:`_order_` attribute "
"can be provided.  It will be checked against the actual order of the "
"enumeration and raise an error if the two do not match::"
msgstr ""
"為了協助保持 Python 2 / Python 3 的程式碼同步，可以提供一個 :attr:`_order_` "
"屬性。它將與列舉的實際順序進行檢查，如果不符則會引發錯誤： ::"

#: ../../howto/enum.rst:1007
msgid ""
"In Python 2 code the :attr:`_order_` attribute is necessary as definition "
"order is lost before it can be recorded."
msgstr ""
"在 Python 2 的程式中，:attr:`_order_` 屬性是必要的，因為定義順序在記錄之前就"
"已遺失。"

#: ../../howto/enum.rst:1012
msgid "_Private__names"
msgstr "_Private__names"

#: ../../howto/enum.rst:1014
#, fuzzy
msgid ""
":ref:`Private names <private-name-mangling>` are not converted to enum "
"members, but remain normal attributes."
msgstr ""
"私有名稱（即雙下劃線開頭的屬性或方法）不會轉換成列舉成員，而是保持正常屬性。"
"請參見 :ref:`Private names <private-name-mangling>`。"

#: ../../howto/enum.rst:1021
msgid "``Enum`` member type"
msgstr "``Enum`` 成員型別"

#: ../../howto/enum.rst:1023
#, fuzzy
msgid ""
"Enum members are instances of their enum class, and are normally accessed as "
"``EnumClass.member``.  In certain situations, such as writing custom enum "
"behavior, being able to access one member directly from another is useful, "
"and is supported; however, in order to avoid name clashes between member "
"names and attributes/methods from mixed-in classes, upper-case names are "
"strongly recommended."
msgstr ""
"列舉成員是其列舉類別的實例，通常會以 ``EnumClass.member`` 來存取。在某些情況"
"下，例如編寫自訂列舉行為，能夠直接從另一個成員存取一個成員是有用的，並且受到"
"支援；但是，為了避免混合類別中的成員名稱和屬性/方法之間的名稱衝突，強烈建議使"
"用大寫名稱。"

#: ../../howto/enum.rst:1034
msgid "Creating members that are mixed with other data types"
msgstr "建立和其他資料型別混合的成員"

#: ../../howto/enum.rst:1036
#, fuzzy
msgid ""
"When subclassing other data types, such as :class:`int` or :class:`str`, "
"with an :class:`Enum`, all values after the ``=`` are passed to that data "
"type's constructor.  For example::"
msgstr ""
"當需要對其他數據類型（例如 :class:`int` 或 :class:`str`）進行父類別派生並使用"
"到:class:`Enum`時，屬於 `=` 之後的所有值都會傳遞給該數據類型的建構函式。例"
"如： ::"

#: ../../howto/enum.rst:1048
msgid "Boolean value of ``Enum`` classes and members"
msgstr "``Enum`` 類別和成員的布林值"

#: ../../howto/enum.rst:1050
#, fuzzy
msgid ""
"Enum classes that are mixed with non-:class:`Enum` types (such as :class:"
"`int`, :class:`str`, etc.) are evaluated according to the mixed-in type's "
"rules; otherwise, all members evaluate as :data:`True`.  To make your own "
"enum's boolean evaluation depend on the member's value add the following to "
"your class::"
msgstr ""
"混合了非 :class:`Enum` 型別（例如:class:`int`、:class:`str`等）的列舉類型，會"
"依據混入型別所規定的規則進行評估；否則，所有成員均評估為:data: `True`. 要讓你"
"自己的enum布林求值取決於成員值時，在你的類中添加以下內容： ::"

#: ../../howto/enum.rst:1059
msgid "Plain :class:`Enum` classes always evaluate as :data:`True`."
msgstr "通常 :class:`Enum` 類別的值會被計算為 :data:`True`。"

#: ../../howto/enum.rst:1063
msgid "``Enum`` classes with methods"
msgstr "具有方法的 ``Enum`` 類別"

#: ../../howto/enum.rst:1065
#, fuzzy
msgid ""
"If you give your enum subclass extra methods, like the `Planet`_ class "
"below, those methods will show up in a :func:`dir` of the member, but not of "
"the class::"
msgstr ""
"如果你給你的列舉子類別新增了一些方法，就像下面這個 `Planet`_ 類別，那這些方法"
"會出現在成員的 :func:`dir`，但不會出現在列舉本身的 :func:`dir` 裡： ::"

#: ../../howto/enum.rst:1076
msgid "Combining members of ``Flag``"
msgstr "合併 ``Flag`` 的成員"

#: ../../howto/enum.rst:1078
#, fuzzy
msgid ""
"Iterating over a combination of :class:`Flag` members will only return the "
"members that are comprised of a single bit::"
msgstr "疊代 :class:`Flag` 成員的組合將只會回傳由單一位元所構成的成員： ::"

#: ../../howto/enum.rst:1096
#, fuzzy
msgid "``Flag`` and ``IntFlag`` minutia"
msgstr "``Flag`` 和 ``IntFlag`` 細節部份"

#: ../../howto/enum.rst:1098
msgid "Using the following snippet for our examples::"
msgstr "我們將運用下列程式碼片段作為範例： ::"

#: ../../howto/enum.rst:1109
msgid "the following are true:"
msgstr "以下敘述為真："

#: ../../howto/enum.rst:1111
#, fuzzy
msgid "single-bit flags are canonical"
msgstr "單位元旗標是規範的"

#: ../../howto/enum.rst:1112
msgid "multi-bit and zero-bit flags are aliases"
msgstr "多位元旗標和零位元旗標是別名"

#: ../../howto/enum.rst:1113
#, fuzzy
msgid "only canonical flags are returned during iteration::"
msgstr "疊代時只回傳正規旗標 (canonical flags)： ::"

#: ../../howto/enum.rst:1118
#, fuzzy
msgid ""
"negating a flag or flag set returns a new flag/flag set with the "
"corresponding positive integer value::"
msgstr "否定一個旗標或旗標集會回傳對應的正整數值： ::"

#: ../../howto/enum.rst:1127
#, fuzzy
msgid "names of pseudo-flags are constructed from their members' names::"
msgstr "偽旗標的名稱是由其成員名稱建構而成的： ::"

#: ../../howto/enum.rst:1132
msgid "multi-bit flags, aka aliases, can be returned from operations::"
msgstr "多位元旗標，也就是別名，可以從操作中回傳： ::"

#: ../../howto/enum.rst:1143
#, fuzzy
msgid ""
"membership / containment checking: zero-valued flags are always considered "
"to be contained::"
msgstr "成員 / 包含測試：零值旗標始終被認為是包含的： ::"

#: ../../howto/enum.rst:1149
#, fuzzy
msgid ""
"otherwise, only if all bits of one flag are in the other flag will True be "
"returned::"
msgstr "否則，只有當一個旗標的所有位都在另一個旗標中時，才會回傳 True： ::"

#: ../../howto/enum.rst:1158
#, fuzzy
msgid ""
"There is a new boundary mechanism that controls how out-of-range / invalid "
"bits are handled: ``STRICT``, ``CONFORM``, ``EJECT``, and ``KEEP``:"
msgstr ""
"有一個新的邊界機制控制超出範圍或無效位元的處理方式: ``STRICT``（嚴格）、"
"``CONFORM``（遵從）、``EJECT``（彈出）和 ``KEEP``（保留）："

#: ../../howto/enum.rst:1161
#, fuzzy
msgid "STRICT --> raises an exception when presented with invalid values"
msgstr "在遇到無效數值時，STRICT（嚴格模式）會引發一個異常。"

#: ../../howto/enum.rst:1162
msgid "CONFORM --> discards any invalid bits"
msgstr "CONFORM --> 丟棄任何無效的位元"

#: ../../howto/enum.rst:1163
#, fuzzy
msgid "EJECT --> lose Flag status and become a normal int with the given value"
msgstr "EJECT --> 失去旗標狀態，並成為一個具有給定值的普通整數"

#: ../../howto/enum.rst:1164
msgid "KEEP --> keep the extra bits"
msgstr "KEEP --> 保留額外的位元"

#: ../../howto/enum.rst:1166
msgid "keeps Flag status and extra bits"
msgstr "保留旗標狀態和額外位元"

#: ../../howto/enum.rst:1167
msgid "extra bits do not show up in iteration"
msgstr "額外位元在疊代時不會出現"

#: ../../howto/enum.rst:1168
msgid "extra bits do show up in repr() and str()"
msgstr "在 repr() 和 str() 也會顯示額外的位元"

#: ../../howto/enum.rst:1170
#, fuzzy
msgid ""
"The default for Flag is ``STRICT``, the default for ``IntFlag`` is "
"``EJECT``, and the default for ``_convert_`` is ``KEEP`` (see ``ssl."
"Options`` for an example of when ``KEEP`` is needed)."
msgstr ""
"標記的預設值為「嚴格」(``STRICT``)，IntFlag 的預設值為「拋出異常」"
"(``EJECT``)，而 _convert_ 的預設值則是「保持現況」(``KEEP``) (請參考 ``ssl."
"Options`` 中需要使用 ``KEEP`` 的範例）。"

#: ../../howto/enum.rst:1178
msgid "How are Enums and Flags different?"
msgstr "列舉和旗標有何不同？"

#: ../../howto/enum.rst:1180
#, fuzzy
msgid ""
"Enums have a custom metaclass that affects many aspects of both derived :"
"class:`Enum` classes and their instances (members)."
msgstr ""
"限定列舉 (Enums) 有一個獨特的元類，會影響到所有衍生 :class:`Enum` 類別及其實"
"例（成員）的許多屬性。"

#: ../../howto/enum.rst:1185
msgid "Enum Classes"
msgstr "列舉類別"

#: ../../howto/enum.rst:1187
#, fuzzy
msgid ""
"The :class:`EnumType` metaclass is responsible for providing the :meth:"
"`__contains__`, :meth:`__dir__`, :meth:`__iter__` and other methods that "
"allow one to do things with an :class:`Enum` class that fail on a typical "
"class, such as ``list(Color)`` or ``some_enum_var in Color``.  :class:"
"`EnumType` is responsible for ensuring that various other methods on the "
"final :class:`Enum` class are correct (such as :meth:`__new__`, :meth:"
"`__getnewargs__`, :meth:`__str__` and :meth:`__repr__`)."
msgstr ""
":class:`EnumType`(列舉型別) 元類別(meta-class) 負責提供 `__contains__`、 "
"`__dir__`、 `__iter__` 以及其他方法，允許開發人員使用像是 ``list(Color)`` 或"
"是 ``some_enum_var in Color`` 的方式對一個 :class:`Enum`(列舉類別)進行操作，"
"而通常類別則無法進行。:class:`EnumType`維護被命名的常數(names constants)，例"
"如 :meth:`__new__.`, :meth:`__getnewargs__.`, :meth:`__str__.`, 和:meth: "
"'__repr__',並確保最終的:class'Enum'(列舉class)符合指定格式。"

#: ../../howto/enum.rst:1196
msgid "Flag Classes"
msgstr "旗標類別"

#: ../../howto/enum.rst:1198
#, fuzzy
msgid ""
"Flags have an expanded view of aliasing: to be canonical, the value of a "
"flag needs to be a power-of-two value, and not a duplicate name.  So, in "
"addition to the :class:`Enum` definition of alias, a flag with no value (a.k."
"a. ``0``) or with more than one power-of-two value (e.g. ``3``) is "
"considered an alias."
msgstr ""
"旗標有一個更廣泛的別名觀點：為了符合規範，旗標的值需要是二次冪的值，而不是重"
"複的名稱。因此除了使用 :class:`Enum` 別名定義之外，沒有值（a.k.a. `0`)或多於"
"一個二次冪數（例如 `3`）的旗幟也被視為別名。"

#: ../../howto/enum.rst:1204
msgid "Enum Members (aka instances)"
msgstr "列舉成員（又稱為實例）"

#: ../../howto/enum.rst:1206
#, fuzzy
msgid ""
"The most interesting thing about enum members is that they are singletons. :"
"class:`EnumType` creates them all while it is creating the enum class "
"itself, and then puts a custom :meth:`__new__` in place to ensure that no "
"new ones are ever instantiated by returning only the existing member "
"instances."
msgstr ""
"enum 成員最有趣的地方在於它們是單例 (singletons)。當 :class:`EnumType` 建立列"
"舉類別本身時，就會一併建立這些成員，並提供自訂的 :meth:`__new__` 方法來確保只"
"回傳現有的成員實例，而不會再被實體化出新的。"

#: ../../howto/enum.rst:1212
msgid "Flag Members"
msgstr "旗標成員"

#: ../../howto/enum.rst:1214
#, fuzzy
msgid ""
"Flag members can be iterated over just like the :class:`Flag` class, and "
"only the canonical members will be returned.  For example::"
msgstr ""
"旗標成員可像 :class:`Flag` 類別一樣被疊代，只有典型成員會被回傳。舉例而"
"言： ::"

#: ../../howto/enum.rst:1220
msgid "(Note that ``BLACK``, ``PURPLE``, and ``WHITE`` do not show up.)"
msgstr "（請注意，``BLACK``、``PURPLE`` 和 ``WHITE`` 不會出現）"

#: ../../howto/enum.rst:1222
msgid ""
"Inverting a flag member returns the corresponding positive value, rather "
"than a negative value --- for example::"
msgstr "反轉旗標成員會回傳相應的正值，而不是負值 --- 例如： ::"

#: ../../howto/enum.rst:1228
#, fuzzy
msgid ""
"Flag members have a length corresponding to the number of power-of-two "
"values they contain.  For example::"
msgstr "旗標成員的長度與他們包含的二次冥值相對應。例如： ::"

#: ../../howto/enum.rst:1238
msgid "Enum Cookbook"
msgstr "列舉參考手冊"

#: ../../howto/enum.rst:1241
#, fuzzy
msgid ""
"While :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag`, and :"
"class:`IntFlag` are expected to cover the majority of use-cases, they cannot "
"cover them all.  Here are recipes for some different types of enumerations "
"that can be used directly, or as examples for creating one's own."
msgstr "雖然我們期望 :class:`Enum`、:cl"

#: ../../howto/enum.rst:1248
msgid "Omitting values"
msgstr "省略值"

#: ../../howto/enum.rst:1250
msgid ""
"In many use-cases, one doesn't care what the actual value of an enumeration "
"is. There are several ways to define this type of simple enumeration:"
msgstr "很多時候，我們不在意列舉的實際值。定義這種簡單的列舉有幾種方式："

#: ../../howto/enum.rst:1253
msgid "use instances of :class:`auto` for the value"
msgstr "使用 :class:`auto` 的實例當作值"

#: ../../howto/enum.rst:1254
msgid "use instances of :class:`object` as the value"
msgstr "使用 :class:`object` 的實例作為值。"

#: ../../howto/enum.rst:1255
msgid "use a descriptive string as the value"
msgstr "使用描述性的字串作為值"

#: ../../howto/enum.rst:1256
#, fuzzy
msgid ""
"use a tuple as the value and a custom :meth:`__new__` to replace the tuple "
"with an :class:`int` value"
msgstr ""
"使用元組作為值，再加上自定義的 :meth:`__new__` 函式來將該元組替換成 :class:"
"`int` 型別的值"

#: ../../howto/enum.rst:1259
#, fuzzy
msgid ""
"Using any of these methods signifies to the user that these values are not "
"important, and also enables one to add, remove, or reorder members without "
"having to renumber the remaining members."
msgstr ""
"使用這些方法之一，向使用者傳達數值不重要的意涵，也能讓你加入、移除或重新排序"
"成員而不必重新編號其他成員。"

#: ../../howto/enum.rst:1265
msgid "Using :class:`auto`"
msgstr "使用 :class:`auto`"

#: ../../howto/enum.rst:1267
msgid "Using :class:`auto` would look like::"
msgstr "使用 :class:`auto` 看起來會像這樣： ::"

#: ../../howto/enum.rst:1279
msgid "Using :class:`object`"
msgstr "使用 :class:`object`"

#: ../../howto/enum.rst:1281
msgid "Using :class:`object` would look like::"
msgstr "使用 :class:`object` 看起來會像這樣： ::"

#: ../../howto/enum.rst:1291
msgid ""
"This is also a good example of why you might want to write your own :meth:"
"`__repr__`::"
msgstr "這也是為何你有可能會想要撰寫你自己的 :meth:`__repr__` 的好範例： ::"

#: ../../howto/enum.rst:1307
msgid "Using a descriptive string"
msgstr "使用一個描述性字串"

#: ../../howto/enum.rst:1309
msgid "Using a string as the value would look like::"
msgstr "將字串作為值會看起來像這樣： ::"

#: ../../howto/enum.rst:1321
msgid "Using a custom :meth:`__new__`"
msgstr "使用自訂的 :meth:`__new__`"

#: ../../howto/enum.rst:1323
msgid "Using an auto-numbering :meth:`__new__` would look like::"
msgstr "使用自動編號的 :meth:`__new__` 看起來會像這樣： ::"

#: ../../howto/enum.rst:1340
#, fuzzy
msgid ""
"To make a more general purpose ``AutoNumber``, add ``*args`` to the "
"signature::"
msgstr ""
"為了讓``AutoNumber``成為更多用途的程式，請在函式签名中新增 ``*args``： ::"

#: ../../howto/enum.rst:1350
msgid ""
"Then when you inherit from ``AutoNumber`` you can write your own "
"``__init__`` to handle any extra arguments::"
msgstr ""
"當你從 ``AutoNumber`` 繼承時，可以撰寫自己的 ``__init__`` 來處理任何額外引"
"數： ::"

#: ../../howto/enum.rst:1369
#, fuzzy
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members."
msgstr ""
":meth:`__new__` 方法（如有定義）將在建立列舉成員期間使用；然後它被列舉的 :"
"meth:`__new__` 替換，該 :meth:`__new__` 在類別建立後用於尋找現有成員。"

#: ../../howto/enum.rst:1375
#, fuzzy
msgid ""
"*Do not* call ``super().__new__()``, as the lookup-only ``__new__`` is the "
"one that is found; instead, use the data type directly -- e.g.::"
msgstr ""
"*不要*\\ 呼叫 ``super().__new__()``，因為只查找 ``__new__`` 是找到的；相反，"
"直接使用資料型別—例如::"

#: ../../howto/enum.rst:1382
msgid "OrderedEnum"
msgstr "OrderedEnum"

#: ../../howto/enum.rst:1384
#, fuzzy
msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being comparable "
"to other enumerations)::"
msgstr ""
"一個有序的列舉，它不依據 :class:`IntEnum` 類別而是遵循正常的 :class:`Enum` 不"
"變量 （例如不能與其他列舉進行比較）： ::"

#: ../../howto/enum.rst:1418
msgid "DuplicateFreeEnum"
msgstr "DuplicateFreeEnum"

#: ../../howto/enum.rst:1420
#, fuzzy
msgid ""
"Raises an error if a duplicate member value is found instead of creating an "
"alias::"
msgstr "如果出現重複的成員值而不是建立別名，則會引發錯誤： ::"

#: ../../howto/enum.rst:1445
#, fuzzy
msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr ""
"這是一個有用的範例，可以透過繼承 Enum 來添加或修改其他行為以及禁止別名。如果"
"唯一需要的更改是禁止使用別名，那麼可以使用 :func:`unique` 裝飾器。"

#: ../../howto/enum.rst:1451
msgid "Planet"
msgstr "Planet"

#: ../../howto/enum.rst:1453
#, fuzzy
msgid ""
"If :meth:`__new__` or :meth:`__init__` is defined, the value of the enum "
"member will be passed to those methods::"
msgstr ""
"如果定義了 :meth:`__new__` 或是 :meth:`__init__`，將會把該列舉成員的值傳遞給"
"這些方法： ::"

#: ../../howto/enum.rst:1482
msgid "TimePeriod"
msgstr "TimePeriod"

#: ../../howto/enum.rst:1484
msgid "An example to show the :attr:`_ignore_` attribute in use::"
msgstr "一個展示使用 :attr:`_ignore_` 屬性的範例： ::"

#: ../../howto/enum.rst:1503
msgid "Subclassing EnumType"
msgstr "子類別化 EnumType"

#: ../../howto/enum.rst:1505
#, fuzzy
msgid ""
"While most enum needs can be met by customizing :class:`Enum` subclasses, "
"either with class decorators or custom functions, :class:`EnumType` can be "
"subclassed to provide a different Enum experience."
msgstr ""
"雖然大部分的列舉需求可以透過客製化 :class:`Enum` subclasses，藉由使用類別裝飾"
"器或是自定義的函式來應付，在創造另一種不同的列舉體驗時，可以建立 :class:"
"`EnumType` 子類別。"
