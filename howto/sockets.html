<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Socket 程式設計指南 &#8212; Python 3.12.4 說明文件</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=41b4f12d" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=b20cc3f5" />
    
    <script src="../_static/documentation_options.js?v=6bff4b4f"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f1e884e3"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.12.4 說明文件 中搜尋"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="關於這些文件" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="copyright" title="版權" href="../copyright.html" />
    <link rel="next" title="排序技法" href="sorting.html" />
    <link rel="prev" title="如何使用正規表達式" href="regex.html" />
    
    <link rel="canonical" href="https://docs.python.org/3/howto/sockets.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" />
                <input type="submit" value="前往"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目錄</a></h3>
    <ul>
<li><a class="reference internal" href="#">Socket 程式設計指南</a><ul>
<li><a class="reference internal" href="#sockets">Sockets</a><ul>
<li><a class="reference internal" href="#history">歷史</a></li>
</ul>
</li>
<li><a class="reference internal" href="#creating-a-socket">建立一個 Socket</a><ul>
<li><a class="reference internal" href="#ipc">IPC</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-a-socket">使用一個 Socket</a><ul>
<li><a class="reference internal" href="#binary-data">二進位資料</a></li>
</ul>
</li>
<li><a class="reference internal" href="#disconnecting">結束連線</a><ul>
<li><a class="reference internal" href="#when-sockets-die">Sockets 何時銷毀</a></li>
</ul>
</li>
<li><a class="reference internal" href="#non-blocking-sockets">非阻塞的 Sockets</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="regex.html"
                          title="上一章">如何使用正規表達式</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="sorting.html"
                          title="下一章">排序技法</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/howto/sockets.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="sorting.html" title="排序技法"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="regex.html" title="如何使用正規表達式"
             accesskey="P">上一頁</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 如何達成任務</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Socket 程式設計指南</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" id="search-box" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="socket-programming-howto">
<span id="socket-howto"></span><h1>Socket 程式設計指南<a class="headerlink" href="#socket-programming-howto" title="連結到這個標頭">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">作者<span class="colon">:</span></dt>
<dd class="field-odd"><p>Gordon McMillan</p>
</dd>
</dl>
<aside class="topic">
<p class="topic-title">摘要</p>
<p>Sockets 在各處都被廣泛使用，但卻是一項被誤解最嚴重的技術之一。這是一篇對 sockets 的概論介紹。這並不是一個完整的教學指南 - 你還需要做許多準備才能讓 sockets 正常運作。這篇文章也沒有包含細節（其中有非常多的細節），但我希望這篇文章能夠讓你有足夠的背景知識，以便開始正確的使用 sockets 程式設計。</p>
</aside>
<section id="sockets">
<h2>Sockets<a class="headerlink" href="#sockets" title="連結到這個標頭">¶</a></h2>
<p>我只會討論關於 INET（例如：IPv4）的 sockets，但它們涵蓋了幾乎 99% 的 sockets 使用場景。而我也將僅討論關於 STREAM（比如：TCP）類型的 sockets - 除非你真的知道你在做什麼（在這種情況下，這份指南可能不適合你），使用 STREAM 類型的 socket 會獲得比其他 sockets 類型更好的表現和性能。我將會嘗試解釋 socket 是什麼，以及如何使用阻塞 (blocking) 和非阻塞 (non-blocking) sockets 的一些建議。但首先我會先談論阻塞 sockets。在處理非阻塞 sockets 之前，你需要了解它們的工作原理。</p>
<p>要理解這些東西的困難點之一在於 &quot;scoket&quot; 可以代表多種具有些微差異的東西，這主要取決於上下文。所以首先，讓我們先區分「用戶端 (client)」socket 和「伺服器端 (server)」socket 的差別，「用戶端」socket 表示通訊的一端，「伺服器端」socket 更像是一個電話總機接線員。用戶端應用程式（例如：你的瀏覽器）只能使用「用戶端」socket; 它所連接的網路伺服器則同時使用「伺服器端」socket 和 「用戶端」socket 來進行通訊。</p>
<section id="history">
<h3>歷史<a class="headerlink" href="#history" title="連結到這個標頭">¶</a></h3>
<p>在各種形式的 <abbr title="Inter Process Communication">IPC</abbr> 中，sockets 是最受歡迎的。在任何特定的平台上，可能會存在其他更快速的 IPC 形式，但對於跨平台通訊來說，sockets 是唯一的選擇。</p>
<p>Sockets 作為 Unix 的 BSD 分支的一部分在 Berkeley 被發明出來。它們隨著網際網路的普及而迅速蔓延開來。這是有很好的理由 — sockets 和 INET 的結合讓世界各地任何的機器之間的通訊變得非常簡單（至少與其它方案相比是如此）。</p>
</section>
</section>
<section id="creating-a-socket">
<h2>建立一個 Socket<a class="headerlink" href="#creating-a-socket" title="連結到這個標頭">¶</a></h2>
<p>大致上來說，當你點擊了帶你來到這個頁面的連結時，你的瀏覽器做了以下的操作：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># create an INET, STREAMing socket</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="c1"># now connect to the web server on port 80 - the normal http port</span>
<span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s2">&quot;www.python.org&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
</pre></div>
</div>
<p>當 <code class="docutils literal notranslate"><span class="pre">connect</span></code> 完成時，這個 socket <code class="docutils literal notranslate"><span class="pre">s</span></code> 可以用來發送請求來取得頁面的文本。同一個 socket 也會讀取回傳值，然後再被銷毀。是的，會被銷毀。用戶端 socket 通常只用來做一次交換（或是一小組連續交換）。</p>
<p>網路伺服器 (web server) 的運作就稍微複雜一點。首先，網路伺服器會建立一個「伺服器端 socket」：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># create an INET, STREAMing socket</span>
<span class="n">serversocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="c1"># bind the socket to a public host, and a well-known port</span>
<span class="n">serversocket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">(),</span> <span class="mi">80</span><span class="p">))</span>
<span class="c1"># become a server socket</span>
<span class="n">serversocket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>有幾件事需要注意：我們使用了 <code class="docutils literal notranslate"><span class="pre">socket.gethostname()</span></code>，這樣 socket 才能對外部網路可見。如果我們使用了 <code class="docutils literal notranslate"><span class="pre">s.bind(('localhost',</span> <span class="pre">80))</span></code> 或 <code class="docutils literal notranslate"><span class="pre">s.bind(('127.0.0.1',</span> <span class="pre">80))</span></code>，我們會得到一個「伺服器端」socket，但是只能在同一台機器內可見。<code class="docutils literal notranslate"><span class="pre">s.bind(('',</span> <span class="pre">80))</span></code> 指定 socket 可以透過機器的任何地址存取。</p>
<p>第二個要注意的是：數字小的連接埠 (port) 通常保留給「廣為人知的」服務（HTTP、SNMP等）。如果你只是想執行程式，可以使用一個數字較大的連接埠（4 位數字）。</p>
<p>最後，<code class="docutils literal notranslate"><span class="pre">listen</span></code> 引數告訴 socket 函式庫 (library)，我們希望在佇列 (queue) 中累積達 5 個（正常的最大值）連線請求後再拒絕外部連線。如果其餘的程式碼編寫正確，這應該足夠了。</p>
<p>現在我們有一個監聽 80 連接埠的「伺服器端」socket 了，我們可以進入網路伺服器的主迴圈了：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="c1"># accept connections from outside</span>
    <span class="p">(</span><span class="n">clientsocket</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="o">=</span> <span class="n">serversocket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="c1"># now do something with the clientsocket</span>
    <span class="c1"># in this case, we&#39;ll pretend this is a threaded server</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">client_thread</span><span class="p">(</span><span class="n">clientsocket</span><span class="p">)</span>
    <span class="n">ct</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>事實上，有三種方法可以讓這個迴圈運作 - 分配一個執行緒 (thread) 來處理 <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code> 、建立一個新行程 (process) 來處理 <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code>，或者將這個程式重新改寫成使用非阻塞 socket，並使用 <code class="docutils literal notranslate"><span class="pre">select</span></code> 在我們的「伺服器端」socket 和任何有效的 <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code> 之間進行多工處理。稍後將會更詳細的介紹。現在最重要的是理解：這就是「伺服器端」socket 做的<em>所有</em> 事情。它不會發送任何資料、也不接收任何資料，它只會建立「伺服器端」socket。每個 <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code> 都是為了回應某些<em>其他</em> <code class="docutils literal notranslate"><span class="pre">connect()</span></code> 到我們綁定的主機上的「用戶端」socket。一但 <code class="docutils literal notranslate"><span class="pre">clientsocket</span></code> 建立完成，就會繼續監聽更多的連線請求。兩個「用戶端」可以隨意的通訊 - 它們使用的是一些動態分配的連接埠，會在通訊結束的時候被回收並重新利用。</p>
<section id="ipc">
<h3>IPC<a class="headerlink" href="#ipc" title="連結到這個標頭">¶</a></h3>
<p>如果你需要在一台機器上的兩個行程間進行快速的行程間通訊 (IPC)，你應該考慮使用管道 (pipes) 或共享記憶體 (shared memory)。如果你確定要使用 AF_INET sockets，請將「伺服器端」socket 綁定到 <code class="docutils literal notranslate"><span class="pre">'localhost'</span></code>。在大多數平台上，這樣將會繞過幾個網路程式碼層，並且速度會更快一些。</p>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p><a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 將跨平台行程間通訊整合到更高層的 API 中。</p>
</div>
</section>
</section>
<section id="using-a-socket">
<h2>使用一個 Socket<a class="headerlink" href="#using-a-socket" title="連結到這個標頭">¶</a></h2>
<p>首先需要注意，網頁瀏覽器的「用戶端」socket 和網路伺服器的「用戶端」socket 是非常類似的。也就是說，這是一個「點對點 (peer to peer)」的通訊方式，或者也可以說<em>作為設計者，你必須決定通訊的規則</em>。通常情況下，<code class="docutils literal notranslate"><span class="pre">connect</span></code> 的 socket 會通過發送一個請求或者信號來開始一次通訊。但這屬於設計決策，而不是 socket 的規則。</p>
<p>現在有兩組可供通訊使用的動詞。你可以使用 <code class="docutils literal notranslate"><span class="pre">send</span></code> 和 <code class="docutils literal notranslate"><span class="pre">recv</span></code>，或者可以將用戶端 socket 轉換成類似檔案的形式，並使用 <code class="docutils literal notranslate"><span class="pre">read</span></code> 和 <code class="docutils literal notranslate"><span class="pre">write</span></code>。後者是 Java 中呈現 socket 的方式。我不打算在這裡討論它，只是提醒你需要在 socket 上使用 <code class="docutils literal notranslate"><span class="pre">flush</span></code>。這些是緩衝的「檔案」，一個常見的錯誤是使用 <code class="docutils literal notranslate"><span class="pre">write</span></code> 寫入某些內容，然後直接 <code class="docutils literal notranslate"><span class="pre">read</span></code> 回覆。如果不使用 <code class="docutils literal notranslate"><span class="pre">flush</span></code>，你可能會一直等待這個回覆，因為請求可能還在你的輸出緩衝中。</p>
<p>現在我們來到 sockets 的主要障礙 - <code class="docutils literal notranslate"><span class="pre">send</span></code> 和 <code class="docutils literal notranslate"><span class="pre">recv</span></code> 操作的是網路緩衝區。他們不一定會處理你提供給它們的所有位元組（或者是你期望它處理的位元組），因為它們主要的重點是處理網路緩衝區。一般來說，它們會在關聯的網路衝區已滿 (<code class="docutils literal notranslate"><span class="pre">send</span></code>) 或已清空 (<code class="docutils literal notranslate"><span class="pre">recv</span></code>) 時回傳，然後告訴你它們處理了多少位元組。<em>你</em> 的責任是一直呼叫它們直到你所有的訊息處理完成。</p>
<p>當 <code class="docutils literal notranslate"><span class="pre">recv</span></code> 回傳「零位元組 (0 bytes)」時，就表示另一端已經關閉（或著正在關閉）連線。你再也不能從這個連線上取得任何資料了。你可能還是可以成功發送資料；我稍後會對此進行更詳細的解釋。</p>
<p>像 HTTP 這樣的協議只使用一個 socket 進行一次傳輸，用戶端發送一個請求，然後讀取一個回覆。就這樣，然後這個 socket 就會被銷毀。這表示者用戶端可以通過接收「零位元組」來檢測回覆的結束。</p>
<p>但是如果你打算在之後的傳輸中重新利用 socket 的話，你需要明白<em>socket 中是不存在</em> <abbr>EOT （傳輸結束）</abbr>。重申一次：如果一個 socket 的 <code class="docutils literal notranslate"><span class="pre">send</span></code> 或 <code class="docutils literal notranslate"><span class="pre">recv</span></code> 處理了「零位元組」後回傳，表示連線已經斷開。如果連線<em>沒有</em> 斷開，你可能會永遠處於等待 <code class="docutils literal notranslate"><span class="pre">recv</span></code> 的狀態，因為（就目前來說）socket <em>不會</em> 告訴你沒有更多資料可以讀取了。現在，如果你稍微思考一下，你就會意識到 socket 的一個基本事實：<em>訊息要麼是一個固定的長度（不好的做法），要麼是可以被分隔的（普通的做法），要麼是指定其長度（更好地做法），要麼通過關閉連線來結束。</em>完全由你來決定要使用哪種方式（但有些方法比其他方法來的更好）。</p>
<p>假設你不想結束連線，最簡單的方式就是使用固定長度的訊息：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MySocket</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;demonstration class only</span>
<span class="sd">      - coded for clarity, not efficiency</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span>
                            <span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">mysend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="n">totalsent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">totalsent</span> <span class="o">&lt;</span> <span class="n">MSGLEN</span><span class="p">:</span>
            <span class="n">sent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="n">totalsent</span><span class="p">:])</span>
            <span class="k">if</span> <span class="n">sent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;socket connection broken&quot;</span><span class="p">)</span>
            <span class="n">totalsent</span> <span class="o">=</span> <span class="n">totalsent</span> <span class="o">+</span> <span class="n">sent</span>

    <span class="k">def</span> <span class="nf">myreceive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bytes_recd</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">bytes_recd</span> <span class="o">&lt;</span> <span class="n">MSGLEN</span><span class="p">:</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">MSGLEN</span> <span class="o">-</span> <span class="n">bytes_recd</span><span class="p">,</span> <span class="mi">2048</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">chunk</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;socket connection broken&quot;</span><span class="p">)</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
            <span class="n">bytes_recd</span> <span class="o">=</span> <span class="n">bytes_recd</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
</pre></div>
</div>
<p>發送部分的程式碼幾乎可用於任何訊息的傳送方式 - 在 Python 中你發送一個字串，可以用 <code class="docutils literal notranslate"><span class="pre">len()</span></code> 來確認他的長度（即使字串包含了 <code class="docutils literal notranslate"><span class="pre">\0</span></code> 字元）。在這裡，主要是接收的程式碼變得更複雜一些。（在 C 語言中，情況沒有變得更糟，只是如果訊息中包含了 <code class="docutils literal notranslate"><span class="pre">\0</span></code> 字元，你就不能使用 <code class="docutils literal notranslate"><span class="pre">strlen</span></code> 函式。）</p>
<p>最簡單的改進方法是將訊息的第一個字元表示訊息的類型，並根據訊息的類型來決定訊息的長度。現在你需要使用兩次 <code class="docutils literal notranslate"><span class="pre">recv</span></code> - 第一次用於接收（至少）第一個字元來得知長度，第二次用於在迴圈中接收剩下的訊息。如果你決定使用分隔符號的方式，你將會以某個任意的區塊大小進行接收（4096 或 8192 通常是網路緩衝區大小的良好選擇），並在收到的內容中掃描分隔符號。</p>
<p>需要注意的一個複雜情況是，如果你的通訊協議允許連續發送多個訊息（沒有任何回應），並且你傳遞給 <code class="docutils literal notranslate"><span class="pre">recv</span></code> 函式一個任意的區塊大小，最後有可能讀取到下一條訊息的開頭。你需要將其放在一旁並保留下來，直到需要使用的時候。</p>
<p>使用長度作為訊息的前綴（例如，使用 5 個數字字元表示）會變得更複雜，因為（信不信由你）你可能無法在一次 <code class="docutils literal notranslate"><span class="pre">recv</span></code> 中獲得所有 5 個字元。在一般使用下，可能不會有這個狀況，但在高負載的網路下，除非使用兩個 <code class="docutils literal notranslate"><span class="pre">recv</span></code> （第一個用於確定長度，第二個用於取得訊息的資料部分），否則你的程式碼很快就會出現錯誤。這令人非常頭痛。同樣的情況也會讓你發現 <code class="docutils literal notranslate"><span class="pre">send</span></code> 並不總能在一次傳輸中完全清除所有內容。儘管已經閱讀了這篇文章，但最終還是無法解決！</p>
<p>為了節省篇幅、培養你的技能（並保持我的競爭優勢），這些改進方法留給讀者自行練習。現在讓我們開始進行清理工作。</p>
<section id="binary-data">
<h3>二進位資料<a class="headerlink" href="#binary-data" title="連結到這個標頭">¶</a></h3>
<p>使用 socket 傳輸二進位資料完全是可行的。最主要的問題在於不同機器使用不同的二進位資料格式。例如，<a class="reference external" href="https://en.wikipedia.org/wiki/Endianness#Networking">網路二進位順序</a> 採用的是「大端序 big-endian」，所以一個值為 <code class="docutils literal notranslate"><span class="pre">1</span></code> 的 16 位元整數會表示成兩個 16 進位的位元組 <code class="docutils literal notranslate"><span class="pre">00</span> <span class="pre">01</span></code>。然而大多數常見的處理器 (x86/AMD64，ARM，RISC-V) 採用的是「小端序 little-endian」，所以相同的 <code class="docutils literal notranslate"><span class="pre">1</span></code> 會被表示成 <code class="docutils literal notranslate"><span class="pre">01</span> <span class="pre">00</span></code>。（譯者注：將一個多位數的低位放在較小的位址處，高位放在較大的位址處，則稱小端序；反之則稱大端序。）</p>
<p>Socket 函式庫提供了用於轉換 16 位元和 32 位元整數的函式 - <code class="docutils literal notranslate"><span class="pre">ntohl,</span> <span class="pre">htonl,</span> <span class="pre">ntohs,</span> <span class="pre">htons</span></code>，其中 &quot;n&quot; 表示 <em>network</em>，&quot;h&quot; 表示 <em>host</em>，&quot;s&quot; 表示 <em>short</em>，&quot;l&quot; 表示 <em>long</em>。當網路的位元組順序和主機位元組順序相同時，這些函式不會做任何操作，但當主機的位元組順序相反時，這些函式會適當的交換位元組順序。</p>
<p>在現今的 64 位元機器中，二進位資料的 ASCII 表示通常會比二進位表示要小，這是因為在很多情況下，大多數整數的值為 0 或者 1。例如，字串形式的 <code class="docutils literal notranslate"><span class="pre">&quot;0&quot;</span></code> 是兩個位元組，而完整的 64 位元整數則是 8 個位元組。當然，這對固定長度的訊息來說不太適合，需要自行決定。</p>
</section>
</section>
<section id="disconnecting">
<h2>結束連線<a class="headerlink" href="#disconnecting" title="連結到這個標頭">¶</a></h2>
<p>嚴格來說，在關閉 socket 前，你應該使用 <code class="docutils literal notranslate"><span class="pre">shutdown</span></code> 函式。<code class="docutils literal notranslate"><span class="pre">shutdown</span></code> 函式是發送給 socket 另一端的一個提醒。根據你傳遞的引數，它可以表示「我不會再發送任何訊息了，但我仍然會持續監聽」，或者是「我不會再繼續監聽了，真讚！」。然而，大多數的 socket 函式庫或程式設計師都習慣忽略這種禮節，因為通常情況下 <code class="docutils literal notranslate"><span class="pre">close</span></code> 跟 <code class="docutils literal notranslate"><span class="pre">shutdown();</span> <span class="pre">close()</span></code> 是一樣的。所以在大多數情況下，不需要再特地使用 <code class="docutils literal notranslate"><span class="pre">shutdown</span></code> 了。</p>
<p>有效使用 <code class="docutils literal notranslate"><span class="pre">shutdown</span></code> 的一種方式是在類似 HTTP 的交換中，用戶端發送請求後，然後使用 <code class="docutils literal notranslate"><span class="pre">shutdown(1)</span></code>。這告訴伺服器「這個用戶端已經發送完成，但仍可以接收」。伺服器可以通過接收「零位元組」來檢測 &quot;EOF&quot;。這樣它就可以確定已經接收到完整的請求。伺服器發送回覆，如果 <code class="docutils literal notranslate"><span class="pre">send</span></code> 成功完成，那麼用戶端確實在持續接收。</p>
<p>Python 更進一步地採取自動關閉的步驟，並且當 socket 被垃圾回收機制回收時，如果需要的話，他會自動執行 <code class="docutils literal notranslate"><span class="pre">close</span></code>。但依賴這個機制是一個非常不好的習慣，如果你的 socket 在沒有 <code class="docutils literal notranslate"><span class="pre">close</span></code> 的情況下消失了，那麼另一端的 socket 可能會認為你只是慢了一步，而無期限的等待。<em>請務必</em> 在使用完畢後使用 <code class="docutils literal notranslate"><span class="pre">close</span></code> 關閉你的 sockets。</p>
<section id="when-sockets-die">
<h3>Sockets 何時銷毀<a class="headerlink" href="#when-sockets-die" title="連結到這個標頭">¶</a></h3>
<p>使用阻塞式 socket 最糟糕的地方可能是在另一端突然強制關閉（未執行 <code class="docutils literal notranslate"><span class="pre">close</span></code>）的情況下會發生什麼？你的 socket 很可能會處於阻塞狀態。TCP 是一種可靠的協議，它在放棄連線之前會等待很長很長的時間。如果你正在使用執行緒，整個執行緒基本上已經無法使用。在這方面，你無法做太多事情。只要你不做一些愚蠢的事情，比如在執行阻塞式讀取時持有一個鎖，那麼執行緒並不會消耗太多資源。<em>不要</em>試圖終止執行緒 - 執行緒比行程更有效的部分原因是它們避免了與自動回收資源相關的開銷。換句話說，如果你確實設法終止了執行緒，整個行程可能會出現問題。</p>
</section>
</section>
<section id="non-blocking-sockets">
<h2>非阻塞的 Sockets<a class="headerlink" href="#non-blocking-sockets" title="連結到這個標頭">¶</a></h2>
<p>如果你已經理解了前面的內容，你已經知道了大部分關於使用 sockets 的機制的所需知識，你仍然會以非常相似的方式使用相同的函式。就這樣而已，如果你做的對，你的程式就會是近乎完美的。</p>
<p>在 Python 中可以使用 <code class="docutils literal notranslate"><span class="pre">socket.setblocking(False)</span></code> 來設定為非阻塞。在 C 的作法更為複雜（例如，你需要在 BSD 風格的 <code class="docutils literal notranslate"><span class="pre">O_NONBLOCK</span></code> 和幾乎沒有區別的 POSIX 風格的 <code class="docutils literal notranslate"><span class="pre">O_NDELAY</span></code> 之間做出選擇，這與 <code class="docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code> 完全不同），但基本思想是一樣的，你要在建立 socket 後但在使用它之前執行此操作。（實際上，如果你願意的話，你甚至可以來回切換。）</p>
<p>主要的機制差異在於 <code class="docutils literal notranslate"><span class="pre">send</span></code>、<code class="docutils literal notranslate"><span class="pre">recv</span></code>、<code class="docutils literal notranslate"><span class="pre">connect</span></code> 和 <code class="docutils literal notranslate"><span class="pre">accept</span></code> 可能在沒有執行任何操作的情況下就回傳了。你當然有多種選擇。你可以檢查回傳值和錯誤代碼，但這些操作通常會讓自己抓狂。如果你不相信我，不妨試試看。你的應用程式會變得臃腫、錯誤百出，並且占用 CPU。所以，讓我們跳過無腦的解決方案，使用正確的方式。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">select</span></code>。</p>
<p>在 C 中，編寫 <code class="docutils literal notranslate"><span class="pre">select</span></code> 是非常複雜的，但在 Python 中，這很簡單，並與 C 的版本非常類似，如果你理解了 Python 中的 <code class="docutils literal notranslate"><span class="pre">select</span></code>，在 C 中處理它時也不會有太大的困難：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ready_to_read</span><span class="p">,</span> <span class="n">ready_to_write</span><span class="p">,</span> <span class="n">in_error</span> <span class="o">=</span> \
               <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                  <span class="n">potential_readers</span><span class="p">,</span>
                  <span class="n">potential_writers</span><span class="p">,</span>
                  <span class="n">potential_errs</span><span class="p">,</span>
                  <span class="n">timeout</span><span class="p">)</span>
</pre></div>
</div>
<p>你傳遞給 <code class="docutils literal notranslate"><span class="pre">select</span></code> 三個列表：第一個列表包含你可能想要嘗試讀取的所有 sockets；第二個包含所有你可能想要嘗試寫入的 sockets，最後一個（通常為空）包含你想要檢查錯誤的 sockets。你應該注意，一個 socket 可以同時存在於多個列表中。<code class="docutils literal notranslate"><span class="pre">select</span></code> 呼叫是阻塞的，但你可以設置超時。通常這是一個明智的做法 - 除非有充分的理由，否則給它一個很長的超時（比如一分鐘）。</p>
<p>作為回傳，你將獲得三個列表。它們包含實際上可讀取、可寫入和出錯的 sockets。這些列表中的每一個都是你傳入的相應列表的子集（可能為空）。</p>
<p>如果一個 socket 在輸出的可讀列表中，你可以幾乎確定，在這個業務中我們能夠得到的最接近確定的事情是，對該 socket 的 <code class="docutils literal notranslate"><span class="pre">recv</span></code> 呼叫將會回傳一些<em>內容</em>。對於可寫列表，也是同樣的想法。你將能夠發送一些 <em>內容</em>。也許不是全部，但<em>一些內容</em>總比什麼都沒有好。（實際上，任何比較正常的 socket 都會以可寫的方式回傳 - 這只是意味者「外送網路 (outbound network)」的緩衝空間是可用的。）</p>
<p>如果你有一個「伺服器端」socket，請將其放在 potential_readers 列表中，如果它在可讀列表中出現，你的 <code class="docutils literal notranslate"><span class="pre">accept</span></code> 呼叫（幾乎可以確定）會成功。如果你建立了一個新的 socket 去 <code class="docutils literal notranslate"><span class="pre">connect</span></code> 到其他地方，請將它放在 potential_writers 列表中，如果它在可寫列表中出現，那麼他有可能已經連接上了。</p>
<p>實際上，即使是使用阻塞式 socket 的情況下，<code class="docutils literal notranslate"><span class="pre">select</span></code> 也很方便。這是一種判斷是否會被阻塞的方法之一 - 當緩衝區中有某些內容時， socket 會回傳為可讀。然而，這仍然無法解決判斷另一端是否完成，或者只是忙於其他事情的問題。</p>
<p><strong>可移植性警告</strong>：在 Unix 上，<code class="docutils literal notranslate"><span class="pre">select</span></code> 同時適用於 sockets 和文件。但請不要在 Windows 上嘗試這麼做，在 Windows 上，<code class="docutils literal notranslate"><span class="pre">select</span></code> 只適用於 sockets。同時，請注意，在 C 語言中，許多更進階的 socket 選項在 Windows 上有不同的實現方式。實際上，在 Windows 上，我通常會使用執行緒（這非常，非常有效）與我的 sockets 一起使用。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目錄</a></h3>
    <ul>
<li><a class="reference internal" href="#">Socket 程式設計指南</a><ul>
<li><a class="reference internal" href="#sockets">Sockets</a><ul>
<li><a class="reference internal" href="#history">歷史</a></li>
</ul>
</li>
<li><a class="reference internal" href="#creating-a-socket">建立一個 Socket</a><ul>
<li><a class="reference internal" href="#ipc">IPC</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-a-socket">使用一個 Socket</a><ul>
<li><a class="reference internal" href="#binary-data">二進位資料</a></li>
</ul>
</li>
<li><a class="reference internal" href="#disconnecting">結束連線</a><ul>
<li><a class="reference internal" href="#when-sockets-die">Sockets 何時銷毀</a></li>
</ul>
</li>
<li><a class="reference internal" href="#non-blocking-sockets">非阻塞的 Sockets</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="regex.html"
                          title="上一章">如何使用正規表達式</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="sorting.html"
                          title="下一章">排序技法</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/howto/sockets.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="收合側邊欄">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="sorting.html" title="排序技法"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="regex.html" title="如何使用正規表達式"
             >上一頁</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 如何達成任務</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Socket 程式設計指南</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" id="search-box" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    版權
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最後更新於 Jul 20, 2024 (06:30 UTC)。
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    使用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.6 建立。
    </div>

  </body>
</html>