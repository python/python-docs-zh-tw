<!DOCTYPE html>

<html lang="zh-TW" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>術語表 &#8212; Python 3.12.4 說明文件</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="_static/pydoctheme.css?v=41b4f12d" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="_static/pygments_dark.css?v=b20cc3f5" />
    
    <script src="_static/documentation_options.js?v=6bff4b4f"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=f1e884e3"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.12.4 說明文件 中搜尋"
          href="_static/opensearch.xml"/>
    <link rel="author" title="關於這些文件" href="about.html" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜尋" href="search.html" />
    <link rel="copyright" title="版權" href="copyright.html" />
    <link rel="next" title="關於這些說明文件" href="about.html" />
    <link rel="prev" title="「為什麼 Python 被安裝在我的機器上？」常見問答集" href="faq/installed.html" />
    
    <link rel="canonical" href="https://docs.python.org/3/glossary.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="_static/py.svg" />
            <script type="text/javascript" src="_static/copybutton.js"></script>
            <script type="text/javascript" src="_static/menu.js"></script>
            <script type="text/javascript" src="_static/search-focus.js"></script>
            <script type="text/javascript" src="_static/themetoggle.js"></script> 
            <script type="text/javascript" src="_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" />
                <input type="submit" value="前往"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="faq/installed.html"
                          title="上一章">「為什麼 Python 被安裝在我的機器上？」常見問答集</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="about.html"
                          title="下一章">關於這些說明文件</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/glossary.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="about.html" title="關於這些說明文件"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="「為什麼 Python 被安裝在我的機器上？」常見問答集"
             accesskey="P">上一頁</a> |</li>

          <li><img src="_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.12.4 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">術語表</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" id="search-box" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="glossary">
<span id="id1"></span><h1>術語表<a class="headerlink" href="#glossary" title="連結到這個標頭">¶</a></h1>
<dl class="glossary">
<dt id="term-0"><code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code><a class="headerlink" href="#term-0" title="連結到這個項目">¶</a></dt><dd><p>互動式 shell 的預設 Python 提示字元。常見於能在直譯器中以互動方式被執行的程式碼範例。</p>
</dd>
<dt id="term-..."><code class="docutils literal notranslate"><span class="pre">...</span></code><a class="headerlink" href="#term-..." title="連結到這個項目">¶</a></dt><dd><p>可以表示：</p>
<ul class="simple">
<li><p>在一個被縮排的程式碼區塊、在一對匹配的左右定界符（delimiter，例如括號、方括號、花括號或三引號）內部，或是在指定一個裝飾器 (decorator) 之後，要輸入程式碼時，互動式 shell 顯示的預設 Python 提示字元。</p></li>
<li><p>內建常數 <a class="reference internal" href="library/constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal notranslate"><span class="pre">Ellipsis</span></code></a>。</p></li>
</ul>
</dd>
<dt id="term-2to3">2to3<a class="headerlink" href="#term-2to3" title="連結到這個項目">¶</a></dt><dd><p>一個試著將 Python 2.x 程式碼轉換為 Python 3.x 程式碼的工具，它是透過處理大部分的不相容性來達成此目的，而這些不相容性能夠透過剖析原始碼和遍歷剖析樹而被檢測出來。</p>
<p>2to3 在可以標準函式庫中以 <a class="reference internal" href="library/2to3.html#module-lib2to3" title="lib2to3: The 2to3 library"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lib2to3</span></code></a> 被使用；它提供了一個獨立的入口點，在 <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/2to3</span></code>。請參閱 <a class="reference internal" href="library/2to3.html#to3-reference"><span class="std std-ref">2to3 --- 自動將 Python 2的程式碼轉成 Python 3</span></a>。</p>
</dd>
<dt id="term-abstract-base-class">abstract base class（抽象基底類別）<a class="headerlink" href="#term-abstract-base-class" title="連結到這個項目">¶</a></dt><dd><p>抽象基底類別（又稱為 ABC）提供了一種定義介面的方法，作為 <a class="reference internal" href="#term-duck-typing"><span class="xref std std-term">duck-typing</span></a>（鴨子型別）的補充。其他類似的技術，像是 <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a>，則顯得笨拙或是帶有細微的錯誤（例如使用<a class="reference internal" href="reference/datamodel.html#special-lookup"><span class="std std-ref">魔術方法 (magic method)</span></a>）。ABC 採用虛擬的 subclass（子類別），它們並不繼承自另一個 class（類別），但仍可被 <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 及 <a class="reference internal" href="library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 辨識；請參閱 <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> 模組的說明文件。Python 有許多內建的 ABC，用於資料結構（在 <a class="reference internal" href="library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 模組）、數字（在 <a class="reference internal" href="library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">numbers</span></code></a> 模組）、串流（在 <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 模組）及 import 尋檢器和載入器（在 <a class="reference internal" href="library/importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> 模組）。你可以使用 <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> 模組建立自己的 ABC。</p>
</dd>
<dt id="term-annotation">annotation（註釋）<a class="headerlink" href="#term-annotation" title="連結到這個項目">¶</a></dt><dd><p>一個與變數、class 屬性、函式的參數或回傳值相關聯的標籤。照慣例，它被用來作為 <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hint</span></a>（型別提示）。</p>
<p>在執行環境 (runtime)，區域變數的註釋無法被存取，但全域變數、class 屬性和函式的註解，會分別被儲存在模組、class 和函式的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 特殊屬性中。</p>
<p>請參閱 <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">variable annotation</span></a>、<a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">function annotation</span></a>、<span class="target" id="index-71"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 和 <span class="target" id="index-72"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>，這些章節皆有此功能的說明。關於註釋的最佳實踐方法也請參閱 <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">註釋 (annotation) 最佳實踐</span></a>。</p>
</dd>
<dt id="term-argument">argument（引數）<a class="headerlink" href="#term-argument" title="連結到這個項目">¶</a></dt><dd><p>呼叫函式時被傳遞給 <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a>（或 <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a>）的值。引數有兩種：</p>
<ul>
<li><p><em class="dfn">關鍵字引數 (keyword argument)</em>：在函式呼叫中，以識別字（identifier，例如 <code class="docutils literal notranslate"><span class="pre">name=</span></code>）開頭的引數，或是以 <code class="docutils literal notranslate"><span class="pre">**</span></code> 後面 dictionary（字典）內的值被傳遞的引數。例如，<code class="docutils literal notranslate"><span class="pre">3</span></code> 和 <code class="docutils literal notranslate"><span class="pre">5</span></code> 都是以下 <a class="reference internal" href="library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> 呼叫中的關鍵字引數：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="n">real</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;real&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">位置引數 (positional argument)</em>：不是關鍵字引數的引數。位置引數可在一個引數列表的起始處出現，和（或）作為 <code class="docutils literal notranslate"><span class="pre">*</span></code> 之後的 <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterable</span></a>（可疊代物件）中的元素被傳遞。例如，<code class="docutils literal notranslate"><span class="pre">3</span></code> 和 <code class="docutils literal notranslate"><span class="pre">5</span></code> 都是以下呼叫中的位置引數：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<p>引數會被指定給函式主體中的附名區域變數。關於支配這個指定過程的規則，請參閱<a class="reference internal" href="reference/expressions.html#calls"><span class="std std-ref">Calls</span></a>章節。在語法上，任何運算式都可以被用來表示一個引數；其評估值會被指定給區域變數。</p>
<p>另請參閱術語表的 <a class="reference internal" href="#term-parameter"><span class="xref std std-term">parameter</span></a>（參數）條目、常見問題中的<a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">引數和參數之間的差異</span></a>，以及 <span class="target" id="index-73"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a>。</p>
</dd>
<dt id="term-asynchronous-context-manager">asynchronous context manager（非同步情境管理器）<a class="headerlink" href="#term-asynchronous-context-manager" title="連結到這個項目">¶</a></dt><dd><p>一個可以控制 <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 陳述式中所見環境的物件，而它是透過定義 <a class="reference internal" href="reference/datamodel.html#object.__aenter__" title="object.__aenter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code></a> 和 <a class="reference internal" href="reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a> method（方法）來控制的。由 <span class="target" id="index-74"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> 引入。</p>
</dd>
<dt id="term-asynchronous-generator">asynchronous generator（非同步產生器）<a class="headerlink" href="#term-asynchronous-generator" title="連結到這個項目">¶</a></dt><dd><p>一個會回傳 <a class="reference internal" href="#term-asynchronous-generator-iterator"><span class="xref std std-term">asynchronous generator iterator</span></a>（非同步產生器疊代器）的函式。它看起來像一個以 <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 定義的協程函式 (coroutine function)，但不同的是它包含了 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 運算式，能生成一系列可用於 <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 迴圈的值。</p>
<p>這個術語通常用來表示一個非同步產生器函式，但在某些情境中，也可能是表示<em>非同步產生器疊代器 (asynchronous generator iterator)</em>。萬一想表達的意思不夠清楚，那就使用完整的術語，以避免歧義。</p>
<p>一個非同步產生器函式可能包含 <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 運算式，以及 <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 和 <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 陳述式。</p>
</dd>
<dt id="term-asynchronous-generator-iterator">asynchronous generator iterator（非同步產生器疊代器）<a class="headerlink" href="#term-asynchronous-generator-iterator" title="連結到這個項目">¶</a></dt><dd><p>一個由 <a class="reference internal" href="#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a>（非同步產生器）函式所建立的物件。</p>
<p>這是一個 <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>（非同步疊代器），當它以 <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> method 被呼叫時，會回傳一個可等待物件 (awaitable object)，該物件將執行非同步產生器的函式主體，直到遇到下一個 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 運算式。</p>
<p>每個 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 會暫停處理程序，並記住位置執行狀態（包括區域變數及擱置中的 try 陳述式）。當<em>非同步產生器疊代器</em>以另一個被 <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 回傳的可等待物件有效地回復時，它會從停止的地方繼續執行。請參閱 <span class="target" id="index-75"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> 和 <span class="target" id="index-76"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a>。</p>
</dd>
<dt id="term-asynchronous-iterable">asynchronous iterable（非同步可疊代物件）<a class="headerlink" href="#term-asynchronous-iterable" title="連結到這個項目">¶</a></dt><dd><p>一個物件，它可以在 <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 陳述式中被使用。必須從它的 <a class="reference internal" href="reference/datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> method 回傳一個 <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>（非同步疊代器）。由 <span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> 引入。</p>
</dd>
<dt id="term-asynchronous-iterator">asynchronous iterator（非同步疊代器）<a class="headerlink" href="#term-asynchronous-iterator" title="連結到這個項目">¶</a></dt><dd><p>一個實作 <a class="reference internal" href="reference/datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> 和 <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> method 的物件。<a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 必須回傳一個 <a class="reference internal" href="#term-awaitable"><span class="xref std std-term">awaitable</span></a>（可等待物件）。<a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 會解析非同步疊代器的 <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> method 所回傳的可等待物件，直到它引發 <a class="reference internal" href="library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 例外。由 <span class="target" id="index-78"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> 引入。</p>
</dd>
<dt id="term-attribute">attribute（屬性）<a class="headerlink" href="#term-attribute" title="連結到這個項目">¶</a></dt><dd><p>一個與某物件相關聯的值，該值大多能透過使用點分隔運算式 (dotted expression) 的名稱被參照。例如，如果物件 <em>o</em> 有一個屬性 <em>a</em>，則該屬性能以 <em>o.a</em> 被參照。</p>
<p>如果一個物件允許，給予該物件一個名稱不是由<a class="reference internal" href="reference/lexical_analysis.html#identifiers"><span class="std std-ref">Identifiers and keywords</span></a>所定義之識別符 (identifier) 的屬性是有可能的，例如使用 <a class="reference internal" href="library/functions.html#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a>。像這樣的屬性將無法使用點分隔運算式來存取，而是需要使用 <a class="reference internal" href="library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 來取得它。</p>
</dd>
<dt id="term-awaitable">awaitable（可等待物件）<a class="headerlink" href="#term-awaitable" title="連結到這個項目">¶</a></dt><dd><p>一個可以在 <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 運算式中被使用的物件。它可以是一個 <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">coroutine</span></a>（協程），或是一個有 <a class="reference internal" href="reference/datamodel.html#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> method 的物件。另請參閱 <span class="target" id="index-79"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>。</p>
</dd>
<dt id="term-BDFL">BDFL<a class="headerlink" href="#term-BDFL" title="連結到這個項目">¶</a></dt><dd><p>Benevolent Dictator For Life（終身仁慈獨裁者），又名 <a class="reference external" href="https://gvanrossum.github.io/">Guido van Rossum</a>，Python 的創造者。</p>
</dd>
<dt id="term-binary-file">binary file（二進位檔案）<a class="headerlink" href="#term-binary-file" title="連結到這個項目">¶</a></dt><dd><p>一個能夠讀取和寫入 <a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>（類位元組串物件）的 <a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a>（檔案物件）。二進位檔案的例子有：以二進位模式（<code class="docutils literal notranslate"><span class="pre">'rb'</span></code>、<code class="docutils literal notranslate"><span class="pre">'wb'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'rb+'</span></code>）開啟的檔案、<a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin.buffer</span></code></a>、<a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout.buffer</span></code></a>，以及 <a class="reference internal" href="library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> 和 <a class="reference internal" href="library/gzip.html#gzip.GzipFile" title="gzip.GzipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">gzip.GzipFile</span></code></a> 實例。</p>
<p>另請參閱 <a class="reference internal" href="#term-text-file"><span class="xref std std-term">text file</span></a>（文字檔案），它是一個能夠讀取和寫入 <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 物件的檔案物件。</p>
</dd>
<dt id="term-borrowed-reference">borrowed reference（借用參照）<a class="headerlink" href="#term-borrowed-reference" title="連結到這個項目">¶</a></dt><dd><p>在 Python 的 C API 中，借用參照是一個對物件的參照，其中使用該物件的程式碼並不擁有這個參照。如果該物件被銷毀，它會成為一個迷途指標 (dangling pointer)。例如，一次垃圾回收 (garbage collection) 可以移除對物件的最後一個 <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">strong reference</span></a>（強參照），而將該物件銷毀。</p>
<p>對 <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a> 呼叫 <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> 以將它原地 (in-place) 轉換為 <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">strong reference</span></a> 是被建議的做法，除非該物件不能在最後一次使用借用參照之前被銷毀。<a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a> 函式可用於建立一個新的 <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">strong reference</span></a>。</p>
</dd>
<dt id="term-bytes-like-object">bytes-like object（類位元組串物件）<a class="headerlink" href="#term-bytes-like-object" title="連結到這個項目">¶</a></dt><dd><p>一個支援<a class="reference internal" href="c-api/buffer.html#bufferobjects"><span class="std std-ref">緩衝協定 (Buffer Protocol)</span></a>且能夠匯出 C-<a class="reference internal" href="#term-contiguous"><span class="xref std std-term">contiguous</span></a> 緩衝區的物件。這包括所有的 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>、<a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 和 <a class="reference internal" href="library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a> 物件，以及許多常見的 <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 物件。類位元組串物件可用於處理二進位資料的各種運算；這些運算包括壓縮、儲存至二進位檔案和透過 socket（插座）發送。</p>
<p>有些運算需要二進位資料是可變的。說明文件通常會將這些物件稱為「可讀寫的類位元組串物件」。可變緩衝區的物件包括 <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>，以及 <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 的 <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>。其他的運算需要讓二進位資料被儲存在不可變物件（「唯讀的類位元組串物件」）中；這些物件包括 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>，以及 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 物件的 <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>。</p>
</dd>
<dt id="term-bytecode">bytecode（位元組碼）<a class="headerlink" href="#term-bytecode" title="連結到這個項目">¶</a></dt><dd><p>Python 的原始碼會被編譯成位元組碼，它是 Python 程式在 CPython 直譯器中的內部表示法。該位元組碼也會被暫存在 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 檔案中，以便第二次執行同一個檔案時能夠更快速（可以不用從原始碼重新編譯為位元組碼）。這種「中間語言 (intermediate language)」據說是運行在一個 <a class="reference internal" href="#term-virtual-machine"><span class="xref std std-term">virtual machine</span></a>（虛擬機器）上，該虛擬機器會執行與每個位元組碼對應的機器碼 (machine code)。要注意的是，位元組碼理論上是無法在不同的 Python 虛擬機器之間運作的，也不能在不同版本的 Python 之間保持穩定。</p>
<p>位元組碼的指令列表可以在 <a class="reference internal" href="library/dis.html#bytecodes"><span class="std std-ref">dis 模組</span></a>的說明文件中找到。</p>
</dd>
<dt id="term-callable">callable（可呼叫物件）<a class="headerlink" href="#term-callable" title="連結到這個項目">¶</a></dt><dd><p>一個 callable 是可以被呼叫的物件，呼叫時可能以下列形式帶有一組引數（請見 <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">callable</span><span class="p">(</span><span class="n">argument1</span><span class="p">,</span> <span class="n">argument2</span><span class="p">,</span> <span class="n">argumentN</span><span class="p">)</span>
</pre></div>
</div>
<p>一個 <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> 與其延伸的 <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a> 都是 callable。一個有實作 <a class="reference internal" href="reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> 方法的 class 之實例也是個 callable。</p>
</dd>
<dt id="term-callback">callback（回呼）<a class="headerlink" href="#term-callback" title="連結到這個項目">¶</a></dt><dd><p>作為引數被傳遞的一個副程式 (subroutine) 函式，會在未來的某個時間點被執行。</p>
</dd>
<dt id="term-class">class（類別）<a class="headerlink" href="#term-class" title="連結到這個項目">¶</a></dt><dd><p>一個用於建立使用者定義物件的模板。Class 的定義通常會包含 method 的定義，這些 method 可以在 class 的實例上進行操作。</p>
</dd>
<dt id="term-class-variable">class variable（類別變數）<a class="headerlink" href="#term-class-variable" title="連結到這個項目">¶</a></dt><dd><p>一個在 class 中被定義，且應該只能在 class 層次（意即不是在 class 的實例中）被修改的變數。</p>
</dd>
<dt id="term-complex-number">complex number（複數）<a class="headerlink" href="#term-complex-number" title="連結到這個項目">¶</a></dt><dd><p>一個我們熟悉的實數系統的擴充，在此所有數字都會被表示為一個實部和一個虛部之和。虛數就是虛數單位（<code class="docutils literal notranslate"><span class="pre">-1</span></code> 的平方根）的實數倍，此單位通常在數學中被寫為 <code class="docutils literal notranslate"><span class="pre">i</span></code>，在工程學中被寫為 <code class="docutils literal notranslate"><span class="pre">j</span></code>。Python 內建了對複數的支援，它是用後者的記法來表示複數；虛部會帶著一個後綴的 <code class="docutils literal notranslate"><span class="pre">j</span></code> 被編寫，例如 <code class="docutils literal notranslate"><span class="pre">3+1j</span></code>。若要將 <a class="reference internal" href="library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 模組內的工具等效地用於複數，請使用 <a class="reference internal" href="library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a> 模組。複數的使用是一個相當進階的數學功能。如果你沒有察覺到對它們的需求，那麼幾乎能確定你可以安全地忽略它們。</p>
</dd>
<dt id="term-context-manager">context manager（情境管理器）<a class="headerlink" href="#term-context-manager" title="連結到這個項目">¶</a></dt><dd><p>一個可以控制 <a class="reference internal" href="reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 陳述式中所見環境的物件，而它是透過定義 <a class="reference internal" href="reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 和 <a class="reference internal" href="reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> method 來控制的。請參閱 <span class="target" id="index-80"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a>。</p>
</dd>
<dt id="term-context-variable">context variable（情境變數）<a class="headerlink" href="#term-context-variable" title="連結到這個項目">¶</a></dt><dd><p>一個變數，其值可以根據上下文的情境而有所不同。這類似執行緒區域儲存區 (Thread-Local Storage)，在其中，一個變數在每個執行緒可能具有不同的值。然而，關於情境變數，在一個執行緒中可能會有多個情境，而情境變數的主要用途，是在並行的非同步任務 (concurrent asynchronous task) 中，對於變數狀態的追蹤。請參閱 <a class="reference internal" href="library/contextvars.html#module-contextvars" title="contextvars: Context Variables"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>。</p>
</dd>
<dt id="term-contiguous">contiguous（連續的）<a class="headerlink" href="#term-contiguous" title="連結到這個項目">¶</a></dt><dd><p id="index-10">如果一個緩衝區是 <em>C-contiguous</em> 或是 <em>Fortran contiguous</em>，則它會確切地被視為是連續的。零維 (zero-dimensional) 的緩衝區都是 C 及 Fortran contiguous。在一維 (one-dimensional) 陣列中，各項目必須在記憶體中彼此相鄰地排列，而其索引順序是從零開始遞增。在多維的 (multidimensional) C-contiguous 陣列中，按記憶體位址的順序訪問各個項目時，最後一個索引的變化最快。然而，在 Fortran contiguous 陣列中，第一個索引的變化最快。</p>
</dd>
<dt id="term-coroutine">coroutine（協程）<a class="headerlink" href="#term-coroutine" title="連結到這個項目">¶</a></dt><dd><p>協程是副程式 (subroutine) 的一種更為廣義的形式。副程式是在某個時間點被進入並在另一個時間點被退出。協程可以在許多不同的時間點被進入、退出和回復。它們能夠以 <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 陳述式被實作。另請參閱 <span class="target" id="index-81"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>。</p>
</dd>
<dt id="term-coroutine-function">coroutine function（協程函式）<a class="headerlink" href="#term-coroutine-function" title="連結到這個項目">¶</a></dt><dd><p>一個回傳 <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">coroutine</span></a>（協程）物件的函式。一個協程函式能以 <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 陳述式被定義，並可能會包含 <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>、<a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 和 <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 關鍵字。這些關鍵字由 <span class="target" id="index-82"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> 引入。</p>
</dd>
<dt id="term-CPython">CPython<a class="headerlink" href="#term-CPython" title="連結到這個項目">¶</a></dt><dd><p>Python 程式語言的標準實作 (canonical implementation)，被發布在 <a class="reference external" href="https://www.python.org">python.org</a> 上。「CPython」這個術語在必要時被使用，以區分此實作與其它語言的實作，例如 Jython 或 IronPython。</p>
</dd>
<dt id="term-decorator">decorator（裝飾器）<a class="headerlink" href="#term-decorator" title="連結到這個項目">¶</a></dt><dd><p>一個函式，它會回傳另一個函式，通常它會使用 <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code> 語法，被應用為一種函式的變換 (function transformation)。裝飾器的常見範例是 <a class="reference internal" href="library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> 和 <a class="reference internal" href="library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>。</p>
<p>裝飾器語法只是語法糖。以下兩個函式定義在語義上是等效的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Class 也存在相同的概念，但在那裡比較不常用。關於裝飾器的更多內容，請參閱<a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">函式定義</span></a>和 <a class="reference internal" href="reference/compound_stmts.html#class"><span class="std std-ref">class 定義</span></a>的說明文件。</p>
</dd>
<dt id="term-descriptor">descriptor（描述器）<a class="headerlink" href="#term-descriptor" title="連結到這個項目">¶</a></dt><dd><p>任何定義了 <a class="reference internal" href="reference/datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>、<a class="reference internal" href="reference/datamodel.html#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> 或 <a class="reference internal" href="reference/datamodel.html#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> method 的物件。當一個 class 屬性是一個描述器時，它的特殊連結行為會在屬性查找時被觸發。通常，使用 <em>a.b</em> 來取得、設定或刪除某個屬性時，會在 <em>a</em> 的 class 字典中查找名稱為 <em>b</em> 的物件，但如果 <em>b</em> 是一個描述器，則相對應的描述器 method 會被呼叫。對描述器的理解是深入理解 Python 的關鍵，因為它們是許多功能的基礎，這些功能包括函式、method、屬性 (property)、class method、靜態 method，以及對 super class（父類別）的參照。</p>
<p>關於描述器 method 的更多資訊，請參閱<a class="reference internal" href="reference/datamodel.html#descriptors"><span class="std std-ref">Implementing Descriptors</span></a>或<a class="reference internal" href="howto/descriptor.html#descriptorhowto"><span class="std std-ref">描述器使用指南</span></a>。</p>
</dd>
<dt id="term-dictionary">dictionary（字典）<a class="headerlink" href="#term-dictionary" title="連結到這個項目">¶</a></dt><dd><p>一個關聯陣列 (associative array)，其中任意的鍵會被映射到值。鍵可以是任何帶有 <a class="reference internal" href="reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 和 <a class="reference internal" href="reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> method 的物件。在 Perl 中被稱為雜湊 (hash)。</p>
</dd>
<dt id="term-dictionary-comprehension">dictionary comprehension（字典綜合運算）<a class="headerlink" href="#term-dictionary-comprehension" title="連結到這個項目">¶</a></dt><dd><p>一種緊密的方法，用來處理一個可疊代物件中的全部或部分元素，並將處理結果以一個字典回傳。<code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{n:</span> <span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span> <span class="pre">for</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">range(10)}</span></code> 會產生一個字典，它包含了鍵 <code class="docutils literal notranslate"><span class="pre">n</span></code> 映射到值 <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span></code>。請參閱<a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">Displays for lists, sets and dictionaries</span></a>。</p>
</dd>
<dt id="term-dictionary-view">dictionary view（字典檢視）<a class="headerlink" href="#term-dictionary-view" title="連結到這個項目">¶</a></dt><dd><p>從 <a class="reference internal" href="library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.keys()</span></code></a>、<a class="reference internal" href="library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a> 及 <a class="reference internal" href="library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a> 回傳的物件被稱為字典檢視。它們提供了字典中項目的動態檢視，這表示當字典有變動時，該檢視會反映這些變動。若要強制將字典檢視轉為完整的 list（串列），須使用 <code class="docutils literal notranslate"><span class="pre">list(dictview)</span></code>。請參閱<a class="reference internal" href="library/stdtypes.html#dict-views"><span class="std std-ref">字典視圖物件</span></a>。</p>
</dd>
<dt id="term-docstring">docstring（說明字串）<a class="headerlink" href="#term-docstring" title="連結到這個項目">¶</a></dt><dd><p>一個在 class、函式或模組中，作為第一個運算式出現的字串文本。雖然它在套件執行時會被忽略，但它會被編譯器辨識，並被放入所屬 class、函式或模組的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 屬性中。由於說明字串可以透過內省 (introspection) 來瀏覽，因此它是物件的說明文件存放的標準位置。</p>
</dd>
<dt id="term-duck-typing">duck-typing（鴨子型別）<a class="headerlink" href="#term-duck-typing" title="連結到這個項目">¶</a></dt><dd><p>一種程式設計風格，它不是藉由檢查一個物件的型別來確定它是否具有正確的介面；取而代之的是，method 或屬性會單純地被呼叫或使用。（「如果它看起來像一隻鴨子而且叫起來像一隻鴨子，那麼它一定是一隻鴨子。」）因為強調介面而非特定型別，精心設計的程式碼能讓多形替代 (polymorphic substitution) 來增進它的靈活性。鴨子型別要避免使用 <a class="reference internal" href="library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 或 <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 進行測試。（但是請注意，鴨子型別可以用<a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">抽象基底類別 (abstract base class)</span></a> 來補充。）然而，它通常會採用 <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> 測試，或是 <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a> 程式設計風格。</p>
</dd>
<dt id="term-EAFP">EAFP<a class="headerlink" href="#term-EAFP" title="連結到這個項目">¶</a></dt><dd><p>Easier to ask for forgiveness than permission.（請求寬恕比請求許可更容易。）這種常見的 Python 編碼風格會先假設有效的鍵或屬性的存在，並在該假設被推翻時再捕獲例外。這種乾淨且快速的風格，其特色是存在許多的 <a class="reference internal" href="reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 和 <a class="reference internal" href="reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 陳述式。該技術與許多其他語言（例如 C）常見的 <a class="reference internal" href="#term-LBYL"><span class="xref std std-term">LBYL</span></a> 風格形成了對比。</p>
</dd>
<dt id="term-expression">expression（運算式）<a class="headerlink" href="#term-expression" title="連結到這個項目">¶</a></dt><dd><p>一段可以被評估並求值的語法。換句話說，一個運算式就是文字、名稱、屬性存取、運算子或函式呼叫等運算式元件的累積，而這些元件都能回傳一個值。與許多其他語言不同的是，並非所有的 Python 語言構造都是運算式。另外有一些 <a class="reference internal" href="#term-statement"><span class="xref std std-term">statement</span></a>（陳述式）不能被用作運算式，例如 <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a>。賦值 (assignment) 也是陳述式，而不是運算式。</p>
</dd>
<dt id="term-extension-module">extension module（擴充模組）<a class="headerlink" href="#term-extension-module" title="連結到這個項目">¶</a></dt><dd><p>一個以 C 或 C++ 編寫的模組，它使用 Python 的 C API 來與核心及使用者程式碼進行互動。</p>
</dd>
<dt id="term-f-string">f-string（f 字串）<a class="headerlink" href="#term-f-string" title="連結到這個項目">¶</a></dt><dd><p>以 <code class="docutils literal notranslate"><span class="pre">'f'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'F'</span></code> 為前綴的字串文本通常被稱為「f 字串」，它是<a class="reference internal" href="reference/lexical_analysis.html#f-strings"><span class="std std-ref">格式化的字串文本</span></a>的縮寫。另請參閱 <span class="target" id="index-83"></span><a class="pep reference external" href="https://peps.python.org/pep-0498/"><strong>PEP 498</strong></a>。</p>
</dd>
<dt id="term-file-object">file object（檔案物件）<a class="headerlink" href="#term-file-object" title="連結到這個項目">¶</a></dt><dd><p>一個讓使用者透過檔案導向 (file-oriented) API（如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> 或 <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> 等 method）來操作底層資源的物件。根據檔案物件被建立的方式，它能夠協調對真實磁碟檔案或是其他類型的儲存器或通訊裝置（例如標準輸入／輸出、記憶體內緩衝區、socket（插座）、管線 (pipe) 等）的存取。檔案物件也被稱為<em class="dfn">類檔案物件 (file-like object)</em> 或<em class="dfn">串流 (stream)</em>。</p>
<p>實際上，有三種檔案物件：原始的<a class="reference internal" href="#term-binary-file"><span class="xref std std-term">二進位檔案</span></a>、緩衝的<a class="reference internal" href="#term-binary-file"><span class="xref std std-term">二進位檔案</span></a>和<a class="reference internal" href="#term-text-file"><span class="xref std std-term">文字檔案</span></a>。它們的介面在 <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 模組中被定義。建立檔案物件的標準方法是使用 <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 函式。</p>
</dd>
<dt id="term-file-like-object">file-like object（類檔案物件）<a class="headerlink" href="#term-file-like-object" title="連結到這個項目">¶</a></dt><dd><p><a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a>（檔案物件）的同義字。</p>
</dd>
<dt id="term-filesystem-encoding-and-error-handler">filesystem encoding and error handler（檔案系統編碼和錯誤處理函式）<a class="headerlink" href="#term-filesystem-encoding-and-error-handler" title="連結到這個項目">¶</a></dt><dd><p>Python 所使用的一種編碼和錯誤處理函式，用來解碼來自作業系統的位元組，以及將 Unicode 編碼到作業系統。</p>
<p>檔案系統編碼必須保證能成功解碼所有小於 128 的位元組。如果檔案系統編碼無法提供此保證，則 API 函式會引發 <a class="reference internal" href="library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>。</p>
<p><a class="reference internal" href="library/sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code></a> 和 <a class="reference internal" href="library/sys.html#sys.getfilesystemencodeerrors" title="sys.getfilesystemencodeerrors"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencodeerrors()</span></code></a> 函式可用於取得檔案系統編碼和錯誤處理函式。</p>
<p><a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>（檔案系統編碼和錯誤處理函式）會在 Python 啟動時由 <a class="reference internal" href="c-api/init_config.html#c.PyConfig_Read" title="PyConfig_Read"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Read()</span></code></a> 函式來配置：請參閱 <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_encoding" title="PyConfig.filesystem_encoding"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_encoding</span></code></a>，以及 <a class="reference internal" href="c-api/init_config.html#c.PyConfig" title="PyConfig"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyConfig</span></code></a> 的成員 <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_errors" title="PyConfig.filesystem_errors"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_errors</span></code></a>。</p>
<p>另請參閱 <a class="reference internal" href="#term-locale-encoding"><span class="xref std std-term">locale encoding</span></a>（區域編碼）。</p>
</dd>
<dt id="term-finder">finder（尋檢器）<a class="headerlink" href="#term-finder" title="連結到這個項目">¶</a></dt><dd><p>一個物件，它會嘗試為正在被 import 的模組尋找 <a class="reference internal" href="#term-loader"><span class="xref std std-term">loader</span></a>（載入器）。</p>
<p>有兩種類型的尋檢器：<a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">元路徑尋檢器 (meta path finder)</span></a> 會使用 <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>，而<a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">路徑項目尋檢器 (path entry finder)</span></a> 會使用 <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>。</p>
<p>請參閱 <a class="reference internal" href="reference/import.html#importsystem"><span class="std std-ref">模組引入系統</span></a> 和 <a class="reference internal" href="library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 以了解更多細節。</p>
</dd>
<dt id="term-floor-division">floor division（向下取整除法）<a class="headerlink" href="#term-floor-division" title="連結到這個項目">¶</a></dt><dd><p>向下無條件捨去到最接近整數的數學除法。向下取整除法的運算子是 <code class="docutils literal notranslate"><span class="pre">//</span></code>。例如，運算式 <code class="docutils literal notranslate"><span class="pre">11</span> <span class="pre">//</span> <span class="pre">4</span></code> 的計算結果為 <code class="docutils literal notranslate"><span class="pre">2</span></code>，與 float（浮點數）真除法所回傳的 <code class="docutils literal notranslate"><span class="pre">2.75</span></code> 不同。請注意，<code class="docutils literal notranslate"><span class="pre">(-11)</span> <span class="pre">//</span> <span class="pre">4</span></code> 的結果是 <code class="docutils literal notranslate"><span class="pre">-3</span></code>，因為是 <code class="docutils literal notranslate"><span class="pre">-2.75</span></code> 被<em>向下</em>無條件捨去。請參閱 <span class="target" id="index-84"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a>。</p>
</dd>
<dt id="term-function">function（函式）<a class="headerlink" href="#term-function" title="連結到這個項目">¶</a></dt><dd><p>一連串的陳述式，它能夠向呼叫者回傳一些值。它也可以被傳遞零個或多個<a class="reference internal" href="#term-argument"><span class="xref std std-term">引數</span></a>，這些引數可被使用於函式本體的執行。另請參閱 <a class="reference internal" href="#term-parameter"><span class="xref std std-term">parameter</span></a>（參數）、<a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a>（方法），以及<a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">函式定義</span></a>章節。</p>
</dd>
<dt id="term-function-annotation">function annotation（函式註釋）<a class="headerlink" href="#term-function-annotation" title="連結到這個項目">¶</a></dt><dd><p>函式參數或回傳值的一個 <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a>（註釋）。</p>
<p>函式註釋通常被使用於<a class="reference internal" href="#term-type-hint"><span class="xref std std-term">型別提示</span></a>：例如，這個函式預期會得到兩個 <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 引數，並會有一個 <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 回傳值：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_two_numbers</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
   <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>函式註釋的語法在<a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">函式定義</span></a>章節有詳細解釋。</p>
<p>請參閱 <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">variable annotation</span></a> 和 <span class="target" id="index-85"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>，皆有此功能的描述。關於註釋的最佳實踐方法，另請參閱 <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">註釋 (annotation) 最佳實踐</span></a>。</p>
</dd>
<dt id="term-__future__">__future__<a class="headerlink" href="#term-__future__" title="連結到這個項目">¶</a></dt><dd><p><a class="reference internal" href="reference/simple_stmts.html#future"><span class="std std-ref">future 陳述式</span></a>：<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">&lt;feature&gt;</span></code>，會指示編譯器使用那些在 Python 未來的發布版本中將成為標準的語法或語義，來編譯當前的模組。而 <a class="reference internal" href="library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> 模組則記錄了 <em>feature（功能）</em>可能的值。透過 import 此模組並對其變數求值，你可以看見一個新的功能是何時首次被新增到此語言中，以及它何時將會（或已經）成為預設的功能：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">__future__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__future__</span><span class="o">.</span><span class="n">division</span>
<span class="go">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>
</pre></div>
</div>
</dd>
<dt id="term-garbage-collection">garbage collection（垃圾回收）<a class="headerlink" href="#term-garbage-collection" title="連結到這個項目">¶</a></dt><dd><p>當記憶體不再被使用時，將其釋放的過程。Python 執行垃圾回收，是透過參照計數 (reference counting)，以及一個能夠檢測和中斷參照循環 (reference cycle) 的循環垃圾回收器 (cyclic garbage collector) 來完成。垃圾回收器可以使用 <a class="reference internal" href="library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 模組對其進行控制。</p>
</dd>
<dt id="term-generator">generator（產生器）<a class="headerlink" href="#term-generator" title="連結到這個項目">¶</a></dt><dd><p>一個會回傳 <a class="reference internal" href="#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a>（產生器疊代器）的函式。它看起來像一個正常的函式，但不同的是它包含了 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 運算式，能產生一系列的值，這些值可用於 for 迴圈，或是以 <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 函式，每次檢索其中的一個值。</p>
<p>這個術語通常用來表示一個產生器函式，但在某些情境中，也可能是表示<em>產生器疊代器</em>。萬一想表達的意思不夠清楚，那就使用完整的術語，以避免歧義。</p>
</dd>
<dt id="term-generator-iterator">generator iterator（產生器疊代器）<a class="headerlink" href="#term-generator-iterator" title="連結到這個項目">¶</a></dt><dd><p>一個由 <a class="reference internal" href="#term-generator"><span class="xref std std-term">generator</span></a>（產生器）函式所建立的物件。</p>
<p>每個 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 會暫停處理程序，並記住位置執行狀態（包括區域變數及擱置中的 try 陳述式）。當<em>產生器疊代器</em>回復時，它會從停止的地方繼續執行（與那些每次調用時都要重新開始的函式有所不同）。</p>
</dd>
<dt id="term-generator-expression">generator expression（產生器運算式）<a class="headerlink" href="#term-generator-expression" title="連結到這個項目">¶</a></dt><dd><p>一個會回傳疊代器的運算式。它看起來像一個正常的運算式，後面接著一個 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 子句，該子句定義了迴圈變數、範圍以及一個選擇性的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> 子句。該組合運算式會為外層函式產生多個值：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>         <span class="c1"># sum of squares 0, 1, 4, ... 81</span>
<span class="go">285</span>
</pre></div>
</div>
</dd>
<dt id="term-generic-function">generic function（泛型函式）<a class="headerlink" href="#term-generic-function" title="連結到這個項目">¶</a></dt><dd><p>一個由多個函式組成的函式，該函式會對不同的型別實作相同的運算。呼叫期間應該使用哪種實作，是由調度演算法 (dispatch algorithm) 來決定。</p>
<p>另請參閱 <a class="reference internal" href="#term-single-dispatch"><span class="xref std std-term">single dispatch</span></a>（單一調度）術語表條目、<a class="reference internal" href="library/functools.html#functools.singledispatch" title="functools.singledispatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.singledispatch()</span></code></a> 裝飾器和 <span class="target" id="index-86"></span><a class="pep reference external" href="https://peps.python.org/pep-0443/"><strong>PEP 443</strong></a>。</p>
</dd>
<dt id="term-generic-type">generic type（泛型型別）<a class="headerlink" href="#term-generic-type" title="連結到這個項目">¶</a></dt><dd><p>一個能夠被參數化 (parameterized) 的 <a class="reference internal" href="#term-type"><span class="xref std std-term">type</span></a>（型別）；通常是一個 <a class="reference internal" href="reference/datamodel.html#sequence-types"><span class="std std-ref">容器型別</span></a>，像是 <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 和 <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>。它被用於<a class="reference internal" href="#term-type-hint"><span class="xref std std-term">型別提示</span></a>和<a class="reference internal" href="#term-annotation"><span class="xref std std-term">註釋</span></a>。</p>
<p>詳情請參閱<a class="reference internal" href="library/stdtypes.html#types-genericalias"><span class="std std-ref">泛型別名型別</span></a>、<span class="target" id="index-87"></span><a class="pep reference external" href="https://peps.python.org/pep-0483/"><strong>PEP 483</strong></a>、<span class="target" id="index-88"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>、<span class="target" id="index-89"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 模組。</p>
</dd>
<dt id="term-GIL">GIL<a class="headerlink" href="#term-GIL" title="連結到這個項目">¶</a></dt><dd><p>請參閱 <a class="reference internal" href="#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a>（全域直譯器鎖）。</p>
</dd>
<dt id="term-global-interpreter-lock">global interpreter lock（全域直譯器鎖）<a class="headerlink" href="#term-global-interpreter-lock" title="連結到這個項目">¶</a></dt><dd><p><a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> 直譯器所使用的機制，用以確保每次都只有一個執行緒能執行 Python 的 <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">bytecode</span></a>（位元組碼）。透過使物件模型（包括關鍵的內建型別，如 <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>）自動地避免並行存取 (concurrent access) 的危險，此機制可以簡化 CPython 的實作。鎖定整個直譯器，會使直譯器更容易成為多執行緒 (multi-threaded)，但代價是會犧牲掉多處理器的機器能夠提供的一大部分平行性 (parallelism)。</p>
<p>然而，有些擴充模組，無論是標準的或是第三方的，它們被設計成在執行壓縮或雜湊等計算密集 (computationally intensive) 的任務時，可以解除 GIL。另外，在執行 I/O 時，GIL 總是會被解除。</p>
<p>過去對於建立「無限制執行緒」直譯器（以更高的精細度鎖定共享資料的直譯器）的努力並未成功，因為在一般的單一處理器情況下，效能會有所損失。一般認為，若要克服這個效能問題，會使實作變得複雜許多，進而付出更高的維護成本。</p>
</dd>
<dt id="term-hash-based-pyc">hash-based pyc（雜湊架構的 pyc）<a class="headerlink" href="#term-hash-based-pyc" title="連結到這個項目">¶</a></dt><dd><p>一個位元組碼 (bytecode) 暫存檔，它使用雜湊值而不是對應原始檔案的最後修改時間，來確定其有效性。請參閱<a class="reference internal" href="reference/import.html#pyc-invalidation"><span class="std std-ref">Cached bytecode invalidation</span></a>。</p>
</dd>
<dt id="term-hashable">hashable（可雜湊的）<a class="headerlink" href="#term-hashable" title="連結到這個項目">¶</a></dt><dd><p>如果一個物件有一個雜湊值，該值在其生命週期中永不改變（它需要一個 <a class="reference internal" href="reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> method），且可與其他物件互相比較（它需要一個 <a class="reference internal" href="reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> method），那麼它就是一個<em>可雜湊</em>物件。比較結果為相等的多個可雜湊物件，它們必須擁有相同的雜湊值。</p>
<p>可雜湊性 (hashability) 使一個物件可用作 dictionary（字典）的鍵和 set（集合）的成員，因為這些資料結構都在其內部使用了雜湊值。</p>
<p>大多數的 Python 不可變內建物件都是可雜湊的；可變的容器（例如 list 或 dictionary）並不是；而不可變的容器（例如 tuple（元組）和 frozenset），只有當它們的元素是可雜湊的，它們本身才是可雜湊的。若物件是使用者自定 class 的實例，則這些物件會被預設為可雜湊的。它們在互相比較時都是不相等的（除非它們與自己比較），而它們的雜湊值則是衍生自它們的 <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>。</p>
</dd>
<dt id="term-IDLE">IDLE<a class="headerlink" href="#term-IDLE" title="連結到這個項目">¶</a></dt><dd><p>Python 的 Integrated Development and Learning Environment（整合開發與學習環境）。<a class="reference internal" href="library/idle.html#idle"><span class="std std-ref">IDLE</span></a> 是一個基本的編輯器和直譯器環境，它和 Python 的標準發行版本一起被提供。</p>
</dd>
<dt id="term-immutable">immutable（不可變物件）<a class="headerlink" href="#term-immutable" title="連結到這個項目">¶</a></dt><dd><p>一個具有固定值的物件。不可變物件包括數字、字串和 tuple（元組）。這類物件是不能被改變的。如果一個不同的值必須被儲存，則必須建立一個新的物件。它們在需要恆定雜湊值的地方，扮演重要的角色，例如 dictionary（字典）中的一個鍵。</p>
</dd>
<dt id="term-import-path">import path（引入路徑）<a class="headerlink" href="#term-import-path" title="連結到這個項目">¶</a></dt><dd><p>一個位置（或<a class="reference internal" href="#term-path-entry"><span class="xref std std-term">路徑項目</span></a>）的列表，而那些位置就是在 import 模組時，會被 <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">path based finder</span></a>（基於路徑的尋檢器）搜尋模組的位置。在 import 期間，此位置列表通常是來自 <a class="reference internal" href="library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>，但對於子套件 (subpackage) 而言，它也可能是來自父套件的 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 屬性。</p>
</dd>
<dt id="term-importing">importing（引入）<a class="headerlink" href="#term-importing" title="連結到這個項目">¶</a></dt><dd><p>一個過程。一個模組中的 Python 程式碼可以透過此過程，被另一個模組中的 Python 程式碼使用。</p>
</dd>
<dt id="term-importer">importer（引入器）<a class="headerlink" href="#term-importer" title="連結到這個項目">¶</a></dt><dd><p>一個能夠尋找及載入模組的物件；它既是 <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a>（尋檢器）也是 <a class="reference internal" href="#term-loader"><span class="xref std std-term">loader</span></a>（載入器）物件。</p>
</dd>
<dt id="term-interactive">interactive（互動的）<a class="headerlink" href="#term-interactive" title="連結到這個項目">¶</a></dt><dd><p>Python 有一個互動式直譯器，這表示你可以在直譯器的提示字元輸入陳述式和運算式，立即執行它們並且看到它們的結果。只要啟動 <code class="docutils literal notranslate"><span class="pre">python</span></code>，不需要任何引數（可能藉由從你的電腦的主選單選擇它）。這是測試新想法或檢查模塊和包的非常強大的方法（請記住help(x)）。</p>
</dd>
<dt id="term-interpreted">interpreted（直譯的）<a class="headerlink" href="#term-interpreted" title="連結到這個項目">¶</a></dt><dd><p>Python 是一種直譯語言，而不是編譯語言，不過這個區分可能有些模糊，因為有位元組碼 (bytecode) 編譯器的存在。這表示原始檔案可以直接被運行，而不需明確地建立另一個執行檔，然後再執行它。直譯語言通常比編譯語言有更短的開發／除錯週期，不過它們的程式通常也運行得較慢。另請參閱 <a class="reference internal" href="#term-interactive"><span class="xref std std-term">interactive</span></a>（互動的）。</p>
</dd>
<dt id="term-interpreter-shutdown">interpreter shutdown（直譯器關閉）<a class="headerlink" href="#term-interpreter-shutdown" title="連結到這個項目">¶</a></dt><dd><p>當 Python 直譯器被要求關閉時，它會進入一個特殊階段，在此它逐漸釋放所有被配置的資源，例如模組和各種關鍵內部結構。它也會多次呼叫<a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">垃圾回收器 (garbage collector)</span></a>。這能夠觸發使用者自定的解構函式 (destructor) 或弱引用的回呼 (weakref callback)，並執行其中的程式碼。在關閉階段被執行的程式碼會遇到各種例外，因為它所依賴的資源可能不再有作用了（常見的例子是函式庫模組或是警告機制）。</p>
<p>直譯器關閉的主要原因，是 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 模組或正被運行的腳本已經執行完成。</p>
</dd>
<dt id="term-iterable">iterable（可疊代物件）<a class="headerlink" href="#term-iterable" title="連結到這個項目">¶</a></dt><dd><p>一種能夠一次回傳一個其中成員的物件。可疊代物件的例子包括所有的序列型別（像是 <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>、<a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 和 <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>）和某些非序列型別，像是 <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>、<a class="reference internal" href="#term-file-object"><span class="xref std std-term">檔案物件</span></a>，以及你所定義的任何 class 物件，只要那些 class 有 <a class="reference internal" href="library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method 或是實作 <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>（序列）語意的 <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method，該物件就是可疊代物件。</p>
<p>可疊代物件可用於 <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 迴圈和許多其他需要一個序列的地方 (<a class="reference internal" href="library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a>、<a class="reference internal" href="library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a>...)。當一個可疊代物件作為引數被傳遞給內建函式 <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 時，它會為該物件回傳一個疊代器。此疊代器適用於針對一組值進行一遍 (one pass) 運算。使用疊代器時，通常不一定要呼叫 <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 或自行處理疊代器物件。<a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 陳述式會自動地為你處理這些事，它會建立一個暫時性的未命名變數，用於在迴圈期間保有該疊代器。另請參閱 <a class="reference internal" href="#term-iterator"><span class="xref std std-term">iterator</span></a>（疊代器）、<a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>（序列）和 <a class="reference internal" href="#term-generator"><span class="xref std std-term">generator</span></a>（產生器）。</p>
</dd>
<dt id="term-iterator">iterator（疊代器）<a class="headerlink" href="#term-iterator" title="連結到這個項目">¶</a></dt><dd><p>一個表示資料流的物件。重複地呼叫疊代器的 <a class="reference internal" href="library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> method（或是將它傳遞給內建函式 <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>）會依序回傳資料流中的各項目。當不再有資料時，則會引發 <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 例外。此時，該疊代器物件已被用盡，而任何對其 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code> method 的進一步呼叫，都只會再次引發 <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>。疊代器必須有一個 <a class="reference internal" href="library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method，它會回傳疊代器物件本身，所以每個疊代器也都是可疊代物件，且可以用於大多數適用其他可疊代物件的場合。一個明顯的例外，是嘗試多遍疊代 (multiple iteration passes) 的程式碼。一個容器物件（像是 <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>）在每次你將它傳遞給 <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 函式或在 <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 迴圈中使用它時，都會產生一個全新的疊代器。使用疊代器嘗試此事（多遍疊代）時，只會回傳在前一遍疊代中被用過的、同一個已被用盡的疊代器物件，使其看起來就像一個空的容器。</p>
<p>在<a class="reference internal" href="library/stdtypes.html#typeiter"><span class="std std-ref">疊代器型別</span></a>文中可以找到更多資訊。</p>
<div class="impl-detail compound">
<p><strong>CPython 實作細節：</strong> CPython 並不是始終如一地都會檢查「疊代器有定義 <a class="reference internal" href="library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>」這個規定。</p>
</div>
</dd>
<dt id="term-key-function">key function（鍵函式）<a class="headerlink" href="#term-key-function" title="連結到這個項目">¶</a></dt><dd><p>鍵函式或理序函式 (collation function) 是一個可呼叫 (callable) 函式，它會回傳一個用於排序 (sorting) 或定序 (ordering) 的值。例如，<a class="reference internal" href="library/locale.html#locale.strxfrm" title="locale.strxfrm"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.strxfrm()</span></code></a> 被用來產生一個了解區域特定排序慣例的排序鍵。</p>
<p>Python 中的許多工具，都接受以鍵函式來控制元素被定序或分組的方式。它們包括 <a class="reference internal" href="library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>、<a class="reference internal" href="library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>、<a class="reference internal" href="library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a>、<a class="reference internal" href="library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a>、<a class="reference internal" href="library/heapq.html#heapq.merge" title="heapq.merge"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.merge()</span></code></a>、<a class="reference internal" href="library/heapq.html#heapq.nsmallest" title="heapq.nsmallest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nsmallest()</span></code></a>、<a class="reference internal" href="library/heapq.html#heapq.nlargest" title="heapq.nlargest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nlargest()</span></code></a> 和 <a class="reference internal" href="library/itertools.html#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.groupby()</span></code></a>。</p>
<p>有幾種方法可以建立一個鍵函式。例如，<a class="reference internal" href="library/stdtypes.html#str.lower" title="str.lower"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.lower()</span></code></a> method 可以作為不分大小寫排序的鍵函式。或者，一個鍵函式也可以從 <a class="reference internal" href="reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 運算式被建造，例如 <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">r:</span> <span class="pre">(r[0],</span> <span class="pre">r[2])</span></code>。另外，<a class="reference internal" href="library/operator.html#operator.attrgetter" title="operator.attrgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.attrgetter()</span></code></a>、<a class="reference internal" href="library/operator.html#operator.itemgetter" title="operator.itemgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.itemgetter()</span></code></a> 和 <a class="reference internal" href="library/operator.html#operator.methodcaller" title="operator.methodcaller"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.methodcaller()</span></code></a> 為三個鍵函式的建構函式 (constructor)。關於如何建立和使用鍵函式的範例，請參閱<a class="reference internal" href="howto/sorting.html#sortinghowto"><span class="std std-ref">如何排序</span></a>。</p>
</dd>
<dt id="term-keyword-argument">keyword argument（關鍵字引數）<a class="headerlink" href="#term-keyword-argument" title="連結到這個項目">¶</a></dt><dd><p>請參閱 <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>（引數）。</p>
</dd>
<dt id="term-lambda">lambda<a class="headerlink" href="#term-lambda" title="連結到這個項目">¶</a></dt><dd><p>由單一 <a class="reference internal" href="#term-expression"><span class="xref std std-term">expression</span></a>（運算式）所組成的一個匿名行內函式 (inline function)，於該函式被呼叫時求值。建立 lambda 函式的語法是 <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">[parameters]:</span> <span class="pre">expression</span></code></p>
</dd>
<dt id="term-LBYL">LBYL<a class="headerlink" href="#term-LBYL" title="連結到這個項目">¶</a></dt><dd><p>Look before you leap.（三思而後行。）這種編碼風格會在進行呼叫或查找之前，明確地測試先決條件。這種風格與 <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a> 方式形成對比，且它的特色是會有許多 <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 陳述式的存在。</p>
<p>在一個多執行緒環境中，LBYL 方式有在「三思」和「後行」之間引入了競爭條件 (race condition) 的風險。例如以下程式碼 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">mapping:</span> <span class="pre">return</span> <span class="pre">mapping[key]</span></code>，如果另一個執行緒在測試之後但在查找之前，從 <em>mapping</em> 中移除了 <em>key</em>，則該程式碼就會失效。這個問題可以用鎖 (lock) 或使用 EAFP 編碼方式來解決。</p>
</dd>
<dt id="term-list">list（串列）<a class="headerlink" href="#term-list" title="連結到這個項目">¶</a></dt><dd><p>一個 Python 內建的 <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a> （序列）。儘管它的名字是 list，它其實更類似其他語言中的一個陣列 (array) 而較不像一個鏈結串列 (linked list)，因為存取元素的時間複雜度是 <em>O</em>(1)。</p>
</dd>
<dt id="term-list-comprehension">list comprehension（串列綜合運算）<a class="headerlink" href="#term-list-comprehension" title="連結到這個項目">¶</a></dt><dd><p>一種用來處理一個序列中的全部或部分元素，並將處理結果以一個 list 回傳的簡要方法。<code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">['{:#04x}'.format(x)</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(256)</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0]</span></code> 會產生一個字串 list，其中包含 0 到 255 範圍內，所有偶數的十六進位數 (0x..)。<a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 子句是選擇性的。如果省略它，則 <code class="docutils literal notranslate"><span class="pre">range(256)</span></code> 中的所有元素都會被處理。</p>
</dd>
<dt id="term-loader">loader（載入器）<a class="headerlink" href="#term-loader" title="連結到這個項目">¶</a></dt><dd><p>一個能夠載入模組的物件。它必須定義一個名為 <code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code> 的 method（方法）。載入器通常是被 <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a>（尋檢器）回傳。更多細節請參閱 <span class="target" id="index-90"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>，關於 <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>（抽象基底類別），請參閱 <a class="reference internal" href="library/importlib.html#importlib.abc.Loader" title="importlib.abc.Loader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.Loader</span></code></a>。</p>
</dd>
<dt id="term-locale-encoding">locale encoding（區域編碼）<a class="headerlink" href="#term-locale-encoding" title="連結到這個項目">¶</a></dt><dd><p>在 Unix 上，它是 LC_CTYPE 區域設定的編碼。它可以用 <a class="reference internal" href="library/locale.html#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.setlocale(locale.LC_CTYPE,</span> <span class="pre">new_locale)</span></code></a> 來設定。</p>
<p>在 Windows 上，它是 ANSI 代碼頁（code page，例如 <code class="docutils literal notranslate"><span class="pre">&quot;cp1252&quot;</span></code>）。</p>
<p>在 Android 和 VxWorks 上，Python 使用 <code class="docutils literal notranslate"><span class="pre">&quot;utf-8&quot;</span></code> 作為區域編碼。</p>
<p><a class="reference internal" href="library/locale.html#locale.getencoding" title="locale.getencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getencoding()</span></code></a> 可以用來取得區域編碼。</p>
<p>也請參考 <a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>。</p>
</dd>
<dt id="term-magic-method">magic method（魔術方法）<a class="headerlink" href="#term-magic-method" title="連結到這個項目">¶</a></dt><dd><p id="index-23"><a class="reference internal" href="#term-special-method"><span class="xref std std-term">special method</span></a>（特殊方法）的一個非正式同義詞。</p>
</dd>
<dt id="term-mapping">mapping（對映）<a class="headerlink" href="#term-mapping" title="連結到這個項目">¶</a></dt><dd><p>一個容器物件，它支援任意鍵的查找，且能實作 <a class="reference internal" href="library/collections.abc.html#collections-abstract-base-classes"><span class="std std-ref">abstract base classes（抽象基底類別）</span></a>中，<a class="reference internal" href="library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> 或 <a class="reference internal" href="library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a> 所指定的 method。範例包括 <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>、<a class="reference internal" href="library/collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>、<a class="reference internal" href="library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 和 <a class="reference internal" href="library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>。</p>
</dd>
<dt id="term-meta-path-finder">meta path finder（元路徑尋檢器）<a class="headerlink" href="#term-meta-path-finder" title="連結到這個項目">¶</a></dt><dd><p>一種經由搜尋 <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 而回傳的 <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a>（尋檢器）。元路徑尋檢器與<a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">路徑項目尋檢器 (path entry finder)</span></a> 相關但是不同。</p>
<p>關於元路徑尋檢器實作的 method，請參閱 <a class="reference internal" href="library/importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a>。</p>
</dd>
<dt id="term-metaclass">metaclass（元類別）<a class="headerlink" href="#term-metaclass" title="連結到這個項目">¶</a></dt><dd><p>一種 class 的 class。Class 定義過程會建立一個 class 名稱、一個 class dictionary（字典），以及一個 base class（基底類別）的列表。Metaclass 負責接受這三個引數，並建立該 class。大多數的物件導向程式語言會提供一個預設的實作。Python 的特別之處在於它能夠建立自訂的 metaclass。大部分的使用者從未需要此工具，但是當需要時，metaclass 可以提供強大且優雅的解決方案。它們已被用於記錄屬性存取、增加執行緒安全性、追蹤物件建立、實作單例模式 (singleton)，以及許多其他的任務。</p>
<p>更多資訊可以在<a class="reference internal" href="reference/datamodel.html#metaclasses"><span class="std std-ref">Metaclasses</span></a>章節中找到。</p>
</dd>
<dt id="term-method">method（方法）<a class="headerlink" href="#term-method" title="連結到這個項目">¶</a></dt><dd><p>一個在 class 本體內被定義的函式。如果 method 作為其 class 實例的一個屬性被呼叫，則它將會得到該實例物件成為它的第一個 <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>（引數）（此引數通常被稱為 <code class="docutils literal notranslate"><span class="pre">self</span></code>）。請參閱 <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a>（函式）和 <a class="reference internal" href="#term-nested-scope"><span class="xref std std-term">nested scope</span></a>（巢狀作用域）。</p>
</dd>
<dt id="term-method-resolution-order">method resolution order（方法解析順序）<a class="headerlink" href="#term-method-resolution-order" title="連結到這個項目">¶</a></dt><dd><p>方法解析順序是在查找某個成員的過程中，base class（基底類別）被搜尋的順序。關於 Python 自 2.3 版直譯器所使用的演算法細節，請參閱 <a class="reference internal" href="howto/mro.html#python-2-3-mro"><span class="std std-ref">The Python 2.3 Method Resolution Order</span></a>。</p>
</dd>
<dt id="term-module">module（模組）<a class="headerlink" href="#term-module" title="連結到這個項目">¶</a></dt><dd><p>一個擔任 Python 程式碼的組織單位 (organizational unit) 的物件。模組有一個命名空間，它包含任意的 Python 物件。模組是藉由 <a class="reference internal" href="#term-importing"><span class="xref std std-term">importing</span></a> 的過程，被載入至 Python。</p>
<p>另請參閱 <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a>（套件）。</p>
</dd>
<dt id="term-module-spec">module spec（模組規格）<a class="headerlink" href="#term-module-spec" title="連結到這個項目">¶</a></dt><dd><p>一個命名空間，它包含用於載入模組的 import 相關資訊。它是 <a class="reference internal" href="library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ModuleSpec</span></code></a> 的一個實例。</p>
</dd>
<dt id="term-MRO">MRO<a class="headerlink" href="#term-MRO" title="連結到這個項目">¶</a></dt><dd><p>請參閱 <a class="reference internal" href="#term-method-resolution-order"><span class="xref std std-term">method resolution order</span></a>（方法解析順序）。</p>
</dd>
<dt id="term-mutable">mutable（可變物件）<a class="headerlink" href="#term-mutable" title="連結到這個項目">¶</a></dt><dd><p>可變物件可以改變它們的值，但維持它們的 <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>。另請參閱 <a class="reference internal" href="#term-immutable"><span class="xref std std-term">immutable</span></a>（不可變物件）。</p>
</dd>
<dt id="term-named-tuple">named tuple（附名元組）<a class="headerlink" href="#term-named-tuple" title="連結到這個項目">¶</a></dt><dd><p>術語「named tuple（附名元組）」是指從 tuple 繼承的任何型別或 class，且它的可索引 (indexable) 元素也可以用附名屬性來存取。這些型別或 class 也可以具有其他的特性。</p>
<p>有些內建型別是 named tuple，包括由 <a class="reference internal" href="library/time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> 和 <a class="reference internal" href="library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a> 回傳的值。另一個例子是 <a class="reference internal" href="library/sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info</span></code></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>                   <span class="c1"># indexed access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max_exp</span>              <span class="c1"># named field access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>   <span class="c1"># kind of tuple</span>
<span class="go">True</span>
</pre></div>
</div>
<p>有些 named tuple 是內建型別（如上例）。或者，一個 named tuple 也可以從一個正規的 class 定義來建立，只要該 class 是繼承自 <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>，且定義了附名欄位 (named field) 即可。這類的 class 可以手工編寫、可以繼承自 <a class="reference internal" href="library/typing.html#typing.NamedTuple" title="typing.NamedTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.NamedTuple</span></code></a> 來建立，也可以使用工廠函式 (factory function) <a class="reference internal" href="library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a> 來建立。後者技術也增加了一些額外的 method，這些 method 可能是在手寫或內建的 named tuple 中，無法找到的。</p>
</dd>
<dt id="term-namespace">namespace（命名空間）<a class="headerlink" href="#term-namespace" title="連結到這個項目">¶</a></dt><dd><p>變數被儲存的地方。命名空間是以 dictionary（字典）被實作。有區域的、全域的及內建的命名空間，而在物件中（在 method 中）也有巢狀的命名空間。命名空間藉由防止命名衝突，來支援模組化。例如，函式 <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">builtins.open</span></code></a> 和 <a class="reference internal" href="library/os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> 是透過它們的命名空間來區分彼此。命名空間也藉由明確地區分是哪個模組在實作一個函式，來增進可讀性及可維護性。例如，寫出 <a class="reference internal" href="library/random.html#random.seed" title="random.seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">random.seed()</span></code></a> 或 <a class="reference internal" href="library/itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> 明確地表示，這些函式分別是由 <a class="reference internal" href="library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> 和 <a class="reference internal" href="library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> 模組在實作。</p>
</dd>
<dt id="term-namespace-package">namespace package（命名空間套件）<a class="headerlink" href="#term-namespace-package" title="連結到這個項目">¶</a></dt><dd><p>一個 <span class="target" id="index-91"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a>（套件），它只能作為子套件 (subpackage) 的一個容器。命名空間套件可能沒有實體的表示法，而且具體來說它們不像是一個 <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">regular package</span></a>（正規套件），因為它們並沒有 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 這個檔案。</p>
<p>另請參閱 <a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a>（模組）。</p>
</dd>
<dt id="term-nested-scope">nested scope（巢狀作用域）<a class="headerlink" href="#term-nested-scope" title="連結到這個項目">¶</a></dt><dd><p>能夠參照外層定義 (enclosing definition) 中的變數的能力。舉例來說，一個函式如果是在另一個函式中被定義，則它便能夠參照外層函式中的變數。請注意，在預設情況下，巢狀作用域僅適用於參照，而無法用於賦值。區域變數能在最內層作用域中讀取及寫入。同樣地，全域變數是在全域命名空間中讀取及寫入。<a class="reference internal" href="reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 容許對外層作用域進行寫入。</p>
</dd>
<dt id="term-new-style-class">new-style class（新式類別）<a class="headerlink" href="#term-new-style-class" title="連結到這個項目">¶</a></dt><dd><p>一個舊名，它是指現在所有的 class 物件所使用的 class 風格。在早期的 Python 版本中，只有新式 class 才能使用 Python 較新的、多樣的功能，像是 <a class="reference internal" href="reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>、描述器 (descriptor)、屬性 (property)、<a class="reference internal" href="reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a>、class method（類別方法）和 static method（靜態方法）。</p>
</dd>
<dt id="term-object">object（物件）<a class="headerlink" href="#term-object" title="連結到這個項目">¶</a></dt><dd><p>具有狀態（屬性或值）及被定義的行為（method）的任何資料。它也是任何 <a class="reference internal" href="#term-new-style-class"><span class="xref std std-term">new-style class</span></a>（新式類別）的最終 base class（基底類別）。</p>
</dd>
<dt id="term-package">package（套件）<a class="headerlink" href="#term-package" title="連結到這個項目">¶</a></dt><dd><p>一個 Python 的 <a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a>（模組），它可以包含子模組 (submodule) 或是遞迴的子套件 (subpackage)。技術上而言，套件就是具有 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 屬性的一個 Python 模組。</p>
<p>另請參閱 <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">regular package</span></a>（正規套件）和 <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">namespace package</span></a>（命名空間套件）。</p>
</dd>
<dt id="term-parameter">parameter（參數）<a class="headerlink" href="#term-parameter" title="連結到這個項目">¶</a></dt><dd><p>在 <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a>（函式）或 method 定義中的一個命名實體 (named entity)，它指明該函式能夠接受的一個 <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>（引數），或在某些情況下指示多個引數。共有有五種不同的參數類型：</p>
<ul>
<li><p><em class="dfn">positional-or-keyword</em>（位置或關鍵字）：指明一個可以<a class="reference internal" href="#term-argument"><span class="xref std std-term">按照位置</span></a>或是作為<a class="reference internal" href="#term-argument"><span class="xref std std-term">關鍵字引數</span></a>被傳遞的引數。這是參數的預設類型，例如以下的 <em>foo</em> 和 <em>bar</em>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="positional-only-parameter">
<li><p><em class="dfn">positional-only</em>（僅限位置）：指明一個只能按照位置被提供的引數。在函式定義的參數列表中包含一個 <code class="docutils literal notranslate"><span class="pre">/</span></code> 字元，就可以在該字元前面定義僅限位置參數，例如以下的 <em>posonly1</em> 和 <em>posonly2</em>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">posonly1</span><span class="p">,</span> <span class="n">posonly2</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">positional_or_keyword</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="keyword-only-parameter">
<li><p><em class="dfn">keyword-only</em>（僅限關鍵字）：指明一個只能以關鍵字被提供的引數。在函式定義的參數列表中，包含一個任意數量位置參數 (var-positional parameter) 或是單純的 <code class="docutils literal notranslate"><span class="pre">*</span></code> 字元，就可以在其後方定義僅限關鍵字參數，例如以下的 <em>kw_only1</em> 和 <em>kw_only2</em>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kw_only1</span><span class="p">,</span> <span class="n">kw_only2</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">var-positional</em>（任意數量位置）：指明一串能以任意序列被提供的位置引數（在已被其他參數接受的任何位置引數之外）。這類參數是透過在其參數名稱字首加上 <code class="docutils literal notranslate"><span class="pre">*</span></code> 來定義的，例如以下的 <em>args</em>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">var-keyword</em>（任意數量關鍵字）：指明可被提供的任意數量關鍵字引數（在已被其他參數接受的任何關鍵字引數之外）。這類參數是透過在其參數名稱字首加上 <code class="docutils literal notranslate"><span class="pre">**</span></code> 來定義的，例如上面範例中的 <em>kwargs</em>。</p></li>
</ul>
<p>參數可以指明引數是選擇性的或必需的，也可以為一些選擇性的引數指定預設值。</p>
<p>另請參閱術語表的 <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>（引數）條目、常見問題中的<a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">引數和參數之間的差異</span></a>、<a class="reference internal" href="library/inspect.html#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.Parameter</span></code></a> class、<a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">函式定義</span></a>章節，以及 <span class="target" id="index-92"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a>。</p>
</dd>
<dt id="term-path-entry">path entry（路徑項目）<a class="headerlink" href="#term-path-entry" title="連結到這個項目">¶</a></dt><dd><p>在 <a class="reference internal" href="#term-import-path"><span class="xref std std-term">import path</span></a>（引入路徑）中的一個位置，而 <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">path based finder</span></a> （基於路徑的尋檢器）會參考該位置來尋找要 import 的模組。</p>
</dd>
<dt id="term-path-entry-finder">path entry finder（路徑項目尋檢器）<a class="headerlink" href="#term-path-entry-finder" title="連結到這個項目">¶</a></dt><dd><p>被 <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 中的一個可呼叫物件 (callable)（意即一個 <a class="reference internal" href="#term-path-entry-hook"><span class="xref std std-term">path entry hook</span></a>）所回傳的一種 <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a>，它知道如何以一個 <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">path entry</span></a>定位模組。</p>
<p>關於路徑項目尋檢器實作的 method，請參閱 <a class="reference internal" href="library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a>。</p>
</dd>
<dt id="term-path-entry-hook">path entry hook（路徑項目鉤）<a class="headerlink" href="#term-path-entry-hook" title="連結到這個項目">¶</a></dt><dd><p>在 <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 列表中的一個可呼叫物件 (callable)，若它知道如何在一個特定的 <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">path entry</span></a> 中尋找模組，則會回傳一個 <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>（路徑項目尋檢器）。</p>
</dd>
<dt id="term-path-based-finder">path based finder（基於路徑的尋檢器）<a class="headerlink" href="#term-path-based-finder" title="連結到這個項目">¶</a></dt><dd><p>預設的<a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">元路徑尋檢器 (meta path finder)</span></a> 之一，它會在一個 <a class="reference internal" href="#term-import-path"><span class="xref std std-term">import path</span></a> 中搜尋模組。</p>
</dd>
<dt id="term-path-like-object">path-like object（類路徑物件）<a class="headerlink" href="#term-path-like-object" title="連結到這個項目">¶</a></dt><dd><p>一個表示檔案系統路徑的物件。類路徑物件可以是一個表示路徑的 <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 物件，或是一個實作 <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> 協定的物件。透過呼叫 <a class="reference internal" href="library/os.html#os.fspath" title="os.fspath"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fspath()</span></code></a> 函式，一個支援 <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> 協定的物件可以被轉換為 <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 檔案系統路徑；而 <a class="reference internal" href="library/os.html#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsdecode()</span></code></a> 及 <a class="reference internal" href="library/os.html#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsencode()</span></code></a> 則分別可用於確保 <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 及 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 的結果。由 <span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-0519/"><strong>PEP 519</strong></a> 引入。</p>
</dd>
<dt id="term-PEP">PEP<a class="headerlink" href="#term-PEP" title="連結到這個項目">¶</a></dt><dd><p>Python Enhancement Proposal（Python 增強提案）。PEP 是一份設計說明文件，它能為 Python 社群提供資訊，或是描述 Python 的一個新功能或該功能的程序和環境。PEP 應該要提供簡潔的技術規範以及被提案功能的運作原理。</p>
<p>PEP 的存在目的，是要成為重大新功能的提案、社群中關於某個問題的意見收集，以及已納入 Python 的設計決策的記錄，這些過程的主要機制。PEP 的作者要負責在社群內建立共識並記錄反對意見。</p>
<p>請參閱 <span class="target" id="index-94"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a>。</p>
</dd>
<dt id="term-portion">portion（部分）<a class="headerlink" href="#term-portion" title="連結到這個項目">¶</a></dt><dd><p>在單一目錄中的一組檔案（也可能儲存在一個 zip 檔中），這些檔案能對一個命名空間套件 (namespace package) 有所貢獻，如同 <span class="target" id="index-95"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> 中的定義。</p>
</dd>
<dt id="term-positional-argument">positional argument（位置引數）<a class="headerlink" href="#term-positional-argument" title="連結到這個項目">¶</a></dt><dd><p>請參閱 <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>（引數）。</p>
</dd>
<dt id="term-provisional-API">provisional API（暫行 API）<a class="headerlink" href="#term-provisional-API" title="連結到這個項目">¶</a></dt><dd><p>暫行 API 是指，從標準函式庫的向後相容性 (backwards compatibility) 保證中，故意被排除的 API。雖然此類介面，只要它們被標示為暫行的，理論上並不會有重大的變更，但如果核心開發人員認為有必要，也可能會出現向後不相容的變更（甚至包括移除該介面）。這種變更並不會無端地產生——只有 API 被納入之前未察覺的嚴重基本缺陷被揭露時，它們才會發生。</p>
<p>即使對於暫行 API，向後不相容的變更也會被視為「最後的解決方案」——對於任何被發現的問題，仍然會盡可能找出一個向後相容的解決方案。</p>
<p>這個過程使得標準函式庫能隨著時間不斷進化，而避免耗費過長的時間去鎖定有問題的設計錯誤。請參閱 <span class="target" id="index-96"></span><a class="pep reference external" href="https://peps.python.org/pep-0411/"><strong>PEP 411</strong></a> 了解更多細節。</p>
</dd>
<dt id="term-provisional-package">provisional package（暫行套件）<a class="headerlink" href="#term-provisional-package" title="連結到這個項目">¶</a></dt><dd><p>請參閱 <a class="reference internal" href="#term-provisional-API"><span class="xref std std-term">provisional API</span></a>（暫行 API）。</p>
</dd>
<dt id="term-Python-3000">Python 3000<a class="headerlink" href="#term-Python-3000" title="連結到這個項目">¶</a></dt><dd><p>Python 3.x 系列版本的暱稱（很久以前創造的，當時第 3 版的發布是在遙遠的未來。）也可以縮寫為「Py3k」。</p>
</dd>
<dt id="term-Pythonic">Pythonic（Python 風格的）<a class="headerlink" href="#term-Pythonic" title="連結到這個項目">¶</a></dt><dd><p>一個想法或一段程式碼，它應用了 Python 語言最常見的慣用語，而不是使用其他語言常見的概念來實作程式碼。例如，Python 中常見的一種習慣用法，是使用一個 <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 陳述式，對一個可疊代物件的所有元素進行迴圈。許多其他語言並沒有這種類型的架構，所以不熟悉 Python 的人有時會使用一個數值計數器來代替：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">food</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>相較之下，以下方法更簡潔、更具有 Python 風格：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">food</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt id="term-qualified-name">qualified name（限定名稱）<a class="headerlink" href="#term-qualified-name" title="連結到這個項目">¶</a></dt><dd><p>一個「點分隔名稱」，它顯示從一個模組的全域作用域到該模組中定義的 class、函式或 method 的「路徑」，如 <span class="target" id="index-97"></span><a class="pep reference external" href="https://peps.python.org/pep-3155/"><strong>PEP 3155</strong></a> 中的定義。對於頂層的函式和 class 而言，限定名稱與其物件名稱相同：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">meth</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D.meth&#39;</span>
</pre></div>
</div>
<p>當用於引用模組時，<em>完全限定名稱 (fully qualified name)</em> 是表示該模組的完整點分隔路徑，包括任何的父套件，例如 <code class="docutils literal notranslate"><span class="pre">email.mime.text</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">email.mime.text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="o">.</span><span class="n">mime</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;email.mime.text&#39;</span>
</pre></div>
</div>
</dd>
<dt id="term-reference-count">reference count（參照計數）<a class="headerlink" href="#term-reference-count" title="連結到這個項目">¶</a></dt><dd><p>對於一個物件的參照次數。當一個物件的參照計數下降到零時，它會被解除配置 (deallocated)。有些物件是「不滅的 (immortal)」並擁有不會被改變的參照計數，也因此永遠不會被解除配置。參照計數通常在 Python 程式碼中看不到，但它卻是 <a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> 實作的一個關鍵元素。程式設計師可以呼叫 <a class="reference internal" href="library/sys.html#sys.getrefcount" title="sys.getrefcount"><code class="xref py py-func docutils literal notranslate"><span class="pre">getrefcount()</span></code></a> 函式來回傳一個特定物件的參照計數。</p>
</dd>
<dt id="term-regular-package">regular package（正規套件）<a class="headerlink" href="#term-regular-package" title="連結到這個項目">¶</a></dt><dd><p>一個傳統的 <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a>（套件），例如一個包含 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 檔案的目錄。</p>
<p>另請參閱 <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">namespace package</span></a>（命名空間套件）。</p>
</dd>
<dt id="term-__slots__">__slots__<a class="headerlink" href="#term-__slots__" title="連結到這個項目">¶</a></dt><dd><p>在 class 內部的一個宣告，它藉由預先宣告實例屬性的空間，以及消除實例 dictionary（字典），來節省記憶體。雖然該技術很普遍，但它有點難以正確地使用，最好保留給那種在一個記憶體關鍵 (memory-critical) 的應用程式中存在大量實例的罕見情況。</p>
</dd>
<dt id="term-sequence">sequence（序列）<a class="headerlink" href="#term-sequence" title="連結到這個項目">¶</a></dt><dd><p>一個 <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterable</span></a>（可疊代物件），它透過 <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> special method（特殊方法），使用整數索引來支援高效率的元素存取，並定義了一個 <a class="reference internal" href="reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> method 來回傳該序列的長度。一些內建序列型別包括 <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>、<a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>、<a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 和 <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>。請注意，雖然 <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 也支援 <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code>，但它被視為對映 (mapping) 而不是序列，因為其查找方式是使用任意的 <a class="reference internal" href="#term-immutable"><span class="xref std std-term">immutable</span></a> 鍵，而不是整數。</p>
<p>抽象基底類別 (abstract base class) <a class="reference internal" href="library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> 定義了一個更加豐富的介面，並不僅止於 <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 和 <a class="reference internal" href="reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a>，還增加了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>、<a class="reference internal" href="reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> 和 <a class="reference internal" href="reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a>。實作此擴充介面的型別，可以使用 <a class="reference internal" href="library/abc.html#abc.ABCMeta.register" title="abc.ABCMeta.register"><code class="xref py py-func docutils literal notranslate"><span class="pre">register()</span></code></a> 被明確地註冊。更多關於序列方法的文件，請見<a class="reference internal" href="library/stdtypes.html#typesseq-common"><span class="std std-ref">常見序列操作</span></a>。</p>
</dd>
<dt id="term-set-comprehension">set comprehension（集合綜合運算）<a class="headerlink" href="#term-set-comprehension" title="連結到這個項目">¶</a></dt><dd><p>一種緊密的方法，用來處理一個可疊代物件中的全部或部分元素，並將處理結果以一個 set 回傳。<code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{c</span> <span class="pre">for</span> <span class="pre">c</span> <span class="pre">in</span> <span class="pre">'abracadabra'</span> <span class="pre">if</span> <span class="pre">c</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">'abc'}</span></code> 會產生一個字串 set：<code class="docutils literal notranslate"><span class="pre">{'r',</span> <span class="pre">'d'}</span></code>。請參閱<a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">Displays for lists, sets and dictionaries</span></a>。</p>
</dd>
<dt id="term-single-dispatch">single dispatch（單一調度）<a class="headerlink" href="#term-single-dispatch" title="連結到這個項目">¶</a></dt><dd><p><a class="reference internal" href="#term-generic-function"><span class="xref std std-term">generic function</span></a>（泛型函式）調度的一種形式，在此，實作的選擇是基於單一引數的型別。</p>
</dd>
<dt id="term-slice">slice（切片）<a class="headerlink" href="#term-slice" title="連結到這個項目">¶</a></dt><dd><p>一個物件，它通常包含一段 <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>（序列）的某一部分。建立一段切片的方法是使用下標符號 (subscript notation) <code class="docutils literal notranslate"><span class="pre">[]</span></code>，若要給出多個數字，則在數字之間使用冒號，例如 <code class="docutils literal notranslate"><span class="pre">variable_name[1:3:5]</span></code>。在括號（下標）符號的內部，會使用 <a class="reference internal" href="library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> 物件。</p>
</dd>
<dt id="term-special-method">special method（特殊方法）<a class="headerlink" href="#term-special-method" title="連結到這個項目">¶</a></dt><dd><p id="index-31">一種會被 Python 自動呼叫的 method，用於對某種型別執行某種運算，例如加法。這種 method 的名稱會在開頭和結尾有兩個下底線。Special method 在<a class="reference internal" href="reference/datamodel.html#specialnames"><span class="std std-ref">Special method names</span></a>中有詳細說明。</p>
</dd>
<dt id="term-statement">statement（陳述式）<a class="headerlink" href="#term-statement" title="連結到這個項目">¶</a></dt><dd><p>陳述式是一個套組（suite，一個程式碼「區塊」）中的一部分。陳述式可以是一個 <a class="reference internal" href="#term-expression"><span class="xref std std-term">expression</span></a>（運算式），或是含有關鍵字（例如 <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>、<a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> 或 <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>）的多種結構之一。</p>
</dd>
<dt id="term-static-type-checker">static type checker（靜態型別檢查器）<a class="headerlink" href="#term-static-type-checker" title="連結到這個項目">¶</a></dt><dd><p>會讀取 Python 程式碼並分析的外部工具，能夠找出錯誤，像是使用了不正確的型別。另請參閱<a class="reference internal" href="#term-type-hint"><span class="xref std std-term">型別提示 (type hints)</span></a> 以及 <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 模組。</p>
</dd>
<dt id="term-strong-reference">strong reference（強參照）<a class="headerlink" href="#term-strong-reference" title="連結到這個項目">¶</a></dt><dd><p>在 Python 的 C API 中，強參照是對物件的參照，該物件為持有該參照的程式碼所擁有。建立參照時透過呼叫 <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> 來獲得強參照、刪除參照時透過 <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a> 釋放強參照。</p>
<p><a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a> 函式可用於建立一個對物件的強參照。通常，在退出強參照的作用域之前，必須在該強參照上呼叫 <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a> 函式，以避免洩漏一個參照。</p>
<p>另請參閱 <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a>（借用參照）。</p>
</dd>
<dt id="term-text-encoding">text encoding（文字編碼）<a class="headerlink" href="#term-text-encoding" title="連結到這個項目">¶</a></dt><dd><p>Python 中的字串是一個 Unicode 碼點 (code point) 的序列（範圍在 <code class="docutils literal notranslate"><span class="pre">U+0000</span></code> -- <code class="docutils literal notranslate"><span class="pre">U+10FFFF</span></code> 之間）。若要儲存或傳送一個字串，它必須被序列化為一個位元組序列。</p>
<p>將一個字串序列化為位元組序列，稱為「編碼」，而從位元組序列重新建立該字串則稱為「解碼 (decoding)」。</p>
<p>有多種不同的文字序列化編解碼器 (<a class="reference internal" href="library/codecs.html#standard-encodings"><span class="std std-ref">codecs</span></a>)，它們被統稱為「文字編碼」。</p>
</dd>
<dt id="term-text-file">text file（文字檔案）<a class="headerlink" href="#term-text-file" title="連結到這個項目">¶</a></dt><dd><p>一個能夠讀取和寫入 <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 物件的一個 <a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a>（檔案物件）。通常，文字檔案實際上是存取位元組導向的資料流 (byte-oriented datastream) 並會自動處理 <a class="reference internal" href="#term-text-encoding"><span class="xref std std-term">text encoding</span></a>（文字編碼）。文字檔案的例子有：以文字模式（<code class="docutils literal notranslate"><span class="pre">'r'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'w'</span></code>）開啟的檔案、<a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a>、<a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a> 以及 <a class="reference internal" href="library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> 的實例。</p>
<p>另請參閱 <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">binary file</span></a>（二進位檔案），它是一個能夠讀取和寫入<a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">類位元組串物件 (bytes-like object)</span></a> 的檔案物件。</p>
</dd>
<dt id="term-triple-quoted-string">triple-quoted string（三引號內字串）<a class="headerlink" href="#term-triple-quoted-string" title="連結到這個項目">¶</a></dt><dd><p>由三個雙引號 (&quot;) 或單引號 (') 的作為邊界的一個字串。雖然它們並沒有提供異於單引號字串的任何額外功能，但基於許多原因，它們仍是很有用的。它們讓你可以在字串中包含未跳脫 (unescaped) 的單引號和雙引號，而且它們不需使用連續字元 (continuation character) 就可以跨越多行，這使得它們在編寫說明字串時特別有用。</p>
</dd>
<dt id="term-type">type（型別）<a class="headerlink" href="#term-type" title="連結到這個項目">¶</a></dt><dd><p>一個 Python 物件的型別決定了它是什麼類型的物件；每個物件都有一個型別。一個物件的型別可以用它的 <a class="reference internal" href="library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> 屬性來存取，或以 <code class="docutils literal notranslate"><span class="pre">type(obj)</span></code> 來檢索。</p>
</dd>
<dt id="term-type-alias">type alias（型別別名）<a class="headerlink" href="#term-type-alias" title="連結到這個項目">¶</a></dt><dd><p>一個型別的同義詞，透過將型別指定給一個識別符 (identifier) 來建立。</p>
<p>型別別名對於簡化<a class="reference internal" href="#term-type-hint"><span class="xref std std-term">型別提示 (type hint)</span></a> 很有用。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span>
        <span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>可以寫成這樣，更具有可讀性：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Color</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span><span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>請參閱 <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 和 <span class="target" id="index-98"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>，有此功能的描述。</p>
</dd>
<dt id="term-type-hint">type hint（型別提示）<a class="headerlink" href="#term-type-hint" title="連結到這個項目">¶</a></dt><dd><p>一種 <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a>（註釋），它指定一個變數、一個 class 屬性或一個函式的參數或回傳值的預期型別。</p>
<p>型別提示是選擇性的，而不是被 Python 強制的，但它們對<a class="reference internal" href="#term-static-type-checker"><span class="xref std std-term">靜態型別檢查器 (static type checkers)</span></a>很有用，並能協助 IDE 完成程式碼的補全 (completion) 和重構 (refactoring)。</p>
<p>全域變數、class 屬性和函式（不含區域變數）的型別提示，都可以使用 <a class="reference internal" href="library/typing.html#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_type_hints()</span></code></a> 來存取。</p>
<p>請參閱 <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 和 <span class="target" id="index-99"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>，有此功能的描述。</p>
</dd>
<dt id="term-universal-newlines">universal newlines（通用換行字元）<a class="headerlink" href="#term-universal-newlines" title="連結到這個項目">¶</a></dt><dd><p>一種解譯文字流 (text stream) 的方式，會將以下所有的情況識別為一行的結束：Unix 行尾慣例 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>、Windows 慣例 <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code> 和舊的 Macintosh 慣例 <code class="docutils literal notranslate"><span class="pre">'\r'</span></code>。請參閱 <span class="target" id="index-100"></span><a class="pep reference external" href="https://peps.python.org/pep-0278/"><strong>PEP 278</strong></a> 和 <span class="target" id="index-101"></span><a class="pep reference external" href="https://peps.python.org/pep-3116/"><strong>PEP 3116</strong></a>，以及用於 <a class="reference internal" href="library/stdtypes.html#bytes.splitlines" title="bytes.splitlines"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.splitlines()</span></code></a> 的附加用途。</p>
</dd>
<dt id="term-variable-annotation">variable annotation（變數註釋）<a class="headerlink" href="#term-variable-annotation" title="連結到這個項目">¶</a></dt><dd><p>一個變數或 class 屬性的 <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a>（註釋）。</p>
<p>註釋變數或 class 屬性時，賦值是選擇性的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;annotation&#39;</span>
</pre></div>
</div>
<p>變數註釋通常用於<a class="reference internal" href="#term-type-hint"><span class="xref std std-term">型別提示 (type hint)</span></a>：例如，這個變數預期會取得 <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>（整數）值：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>變數註釋的語法在<a class="reference internal" href="reference/simple_stmts.html#annassign"><span class="std std-ref">Annotated assignment statements</span></a>章節有詳細的解釋。</p>
<p>請參閱 <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">function annotation</span></a>（函式註釋）、<span class="target" id="index-102"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 和 <span class="target" id="index-103"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>，皆有此功能的描述。關於註釋的最佳實踐方法，另請參閱 <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">註釋 (annotation) 最佳實踐</span></a>。</p>
</dd>
<dt id="term-virtual-environment">virtual environment（虛擬環境）<a class="headerlink" href="#term-virtual-environment" title="連結到這個項目">¶</a></dt><dd><p>一個協作隔離 (cooperatively isolated) 的執行環境，能讓 Python 的使用者和應用程式得以安裝和升級 Python 發佈套件，而不會對同一個系統上運行的其他 Python 應用程式的行為產生干擾。</p>
<p>另請參閱 <a class="reference internal" href="library/venv.html#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a>。</p>
</dd>
<dt id="term-virtual-machine">virtual machine（虛擬機器）<a class="headerlink" href="#term-virtual-machine" title="連結到這個項目">¶</a></dt><dd><p>一部完全由軟體所定義的電腦 (computer)。Python 的虛擬機器會執行由 <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">bytecode</span></a>（位元組碼）編譯器所發出的位元組碼。</p>
</dd>
<dt id="term-Zen-of-Python">Zen of Python（Python 之禪）<a class="headerlink" href="#term-Zen-of-Python" title="連結到這個項目">¶</a></dt><dd><p>Python 設計原則與哲學的列表，其內容有助於理解和使用此語言。此列表可以透過在互動式提式字元後輸入「<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">this</span></code>」來找到它。</p>
</dd>
</dl>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="faq/installed.html"
                          title="上一章">「為什麼 Python 被安裝在我的機器上？」常見問答集</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="about.html"
                          title="下一章">關於這些說明文件</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/glossary.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="收合側邊欄">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="about.html" title="關於這些說明文件"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="「為什麼 Python 被安裝在我的機器上？」常見問答集"
             >上一頁</a> |</li>

          <li><img src="_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.12.4 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">術語表</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" id="search-box" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="copyright.html">
    
    版權
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最後更新於 Jul 20, 2024 (06:27 UTC)。
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    使用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.6 建立。
    </div>

  </body>
</html>