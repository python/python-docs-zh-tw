<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>9. Class（類別） &#8212; Python 3.12.4 說明文件</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=41b4f12d" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=b20cc3f5" />
    
    <script src="../_static/documentation_options.js?v=6bff4b4f"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f1e884e3"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.12.4 說明文件 中搜尋"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="關於這些文件" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="copyright" title="版權" href="../copyright.html" />
    <link rel="next" title="10. Python 標準函式庫概覽" href="stdlib.html" />
    <link rel="prev" title="8. 錯誤和例外" href="errors.html" />
    
    <link rel="canonical" href="https://docs.python.org/3/tutorial/classes.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" />
                <input type="submit" value="前往"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目錄</a></h3>
    <ul>
<li><a class="reference internal" href="#">9. Class（類別）</a><ul>
<li><a class="reference internal" href="#a-word-about-names-and-objects">9.1. 關於名稱與物件的一段話</a></li>
<li><a class="reference internal" href="#python-scopes-and-namespaces">9.2. Python 作用域 (Scope) 及命名空間 (Namespace)</a><ul>
<li><a class="reference internal" href="#scopes-and-namespaces-example">9.2.1. 作用域和命名空間的範例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-first-look-at-classes">9.3. 初見 class</a><ul>
<li><a class="reference internal" href="#class-definition-syntax">9.3.1. Class definition（類別定義）語法</a></li>
<li><a class="reference internal" href="#class-objects">9.3.2. Class 物件</a></li>
<li><a class="reference internal" href="#instance-objects">9.3.3. 實例物件</a></li>
<li><a class="reference internal" href="#method-objects">9.3.4. Method 物件</a></li>
<li><a class="reference internal" href="#class-and-instance-variables">9.3.5. Class 及實例變數</a></li>
</ul>
</li>
<li><a class="reference internal" href="#random-remarks">9.4. 隨意的備註</a></li>
<li><a class="reference internal" href="#inheritance">9.5. 繼承 (Inheritance)</a><ul>
<li><a class="reference internal" href="#multiple-inheritance">9.5.1. 多重繼承</a></li>
</ul>
</li>
<li><a class="reference internal" href="#private-variables">9.6. 私有變數</a></li>
<li><a class="reference internal" href="#odds-and-ends">9.7. 補充說明</a></li>
<li><a class="reference internal" href="#iterators">9.8. 疊代器 (Iterator)</a></li>
<li><a class="reference internal" href="#generators">9.9. 產生器 (Generator)</a></li>
<li><a class="reference internal" href="#generator-expressions">9.10. 產生器運算式</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="errors.html"
                          title="上一章"><span class="section-number">8. </span>錯誤和例外</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="stdlib.html"
                          title="下一章"><span class="section-number">10. </span>Python 標準函式庫概覽</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/tutorial/classes.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="stdlib.html" title="10. Python 標準函式庫概覽"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="errors.html" title="8. 錯誤和例外"
             accesskey="P">上一頁</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 教學</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9. </span>Class（類別）</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" id="search-box" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="classes">
<span id="tut-classes"></span><h1><span class="section-number">9. </span>Class（類別）<a class="headerlink" href="#classes" title="連結到這個標頭">¶</a></h1>
<p>Class 提供了一種結合資料與功能的手段。建立一個 class 將會新增一個物件的<em>型別 (type)</em>，並且允許建立該型別的新<em>實例 (instance)</em>。每一個 class 實例可以擁有一些維持該實例狀態的屬性 (attribute)。Class 實例也可以有一些（由其 class 所定義的）method（方法），用於修改該實例的狀態。</p>
<p>與其他程式語言相比，Python 的 class 機制為 class 增加了最少的新語法跟語意。他混合了 C++ 和 Modula-3 的 class 機制。Python 的 class 提供了所有物件導向程式設計 (Object Oriented Programming) 的標準特色：class 繼承機制允許多個 base class（基底類別），一個 derived class（衍生類別）可以覆寫 (override) 其 base class 的任何 method，且一個 method 可以用相同的名稱呼叫其 base class 的 method。物件可以包含任意數量及任意種類的資料。如同模組一樣，class 也具有 Python 的動態特性：他們在執行期 (runtime) 被建立，且可以在建立之後被修改。</p>
<p>在 C++ 的術語中，class 成員（包含資料成員）通常都是<em>公開</em>的（除了以下內容：<a class="reference internal" href="#tut-private"><span class="std std-ref">私有變數</span></a>），而所有的成員函式都是<em>虛擬</em>的。如同在 Modula-3 中一樣，Python 並沒有提供簡寫可以從物件的 method 裡參照其成員：method 函式與一個外顯的 (explicit)、第一個代表物件的引數被宣告，而此引數是在呼叫時隱性地 (implicitly) 被提供。如同在 Smalltak 中，class 都是物件，這為 import 及重新命名提供了語意。不像 C++ 和 Modula-3，Pyhon 內建的型別可以被使用者以 base class 用於其他擴充 (extension)。另外，如同在 C++ 中，大多數有著特別語法的內建運算子（算術運算子、下標等）都可以為了 class 實例而被重新定義。</p>
<p>（由於缺乏普遍能接受的術語來討論 class，我偶爾會使用 Smalltalk 和 C++ 的術語。我會使用 Modula-3 的術語，因為它比 C++ 更接近 Python 的物件導向語意，但我預期比較少的讀者會聽過它。）</p>
<section id="a-word-about-names-and-objects">
<span id="tut-object"></span><h2><span class="section-number">9.1. </span>關於名稱與物件的一段話<a class="headerlink" href="#a-word-about-names-and-objects" title="連結到這個標頭">¶</a></h2>
<p>物件有個體性 (individuality)，且多個名稱（在多個作用域 (scope) ）可以被連結到相同的物件。這在其他語言中被稱為別名 (aliasing)。初次接觸 Python 時通常不會注意這件事，而在處理不可變的基本型別（數值、字串、tuple）時，它也可以安全地被忽略。然而，別名在含有可變物件（如 list（串列）、dictionary（字典）、和大多數其他的型別）的 Python 程式碼語意中，可能會有意外的效果。這通常有利於程式，因為別名在某些方面表現得像指標 (pointer)。舉例來說，在實作時傳遞一個物件是便宜的，因為只有指標被傳遞；假如函式修改了一個作為引數傳遞的物件，呼叫函式者 (caller) 能夠見到這些改變——這消除了在 Pascal 中兩個相異引數傳遞機制的需求。</p>
</section>
<section id="python-scopes-and-namespaces">
<span id="tut-scopes"></span><h2><span class="section-number">9.2. </span>Python 作用域 (Scope) 及命名空間 (Namespace)<a class="headerlink" href="#python-scopes-and-namespaces" title="連結到這個標頭">¶</a></h2>
<p>在介紹 class 之前，我必須先告訴你一些關於 Python 作用域的規則。Class definition（類別定義）以命名空間展現了一些俐落的技巧，而你需要了解作用域和命名空間的運作才能完整理解正在發生的事情。順帶一提，關於這個主題的知識對任何進階的 Python 程式設計師都是很有用的。</p>
<p>讓我們從一些定義開始。</p>
<p><em>命名空間</em>是從名稱到物件的映射。大部分的命名空間現在都是以 Python 的 dictionary 被實作，但通常不會以任何方式被察覺（除了性能），且它可能會在未來改變。命名空間的例子有：內建名稱的集合（包含如 <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> 的函式，和內建的例外名稱）；模組中的全域 (global) 名稱；和在函式調用中的區域 (local) 名稱。某種意義上，物件中的屬性集合也會形成一個命名空間。關於命名空間的重要一點是，不同命名空間中的名稱之間絕對沒有關係；舉例來說，兩個不一樣的模組都可以定義一個 <code class="docutils literal notranslate"><span class="pre">maximize</span></code> 函式而不會混淆——模組的使用者必須為它加上前綴 (prefix) 模組名稱。</p>
<p>順帶一提，我使用<em>屬性 (attribute)</em> 這個字，統稱句號 (dot) 後面的任何名稱——例如，運算式中的 <code class="docutils literal notranslate"><span class="pre">z.real</span></code>，<code class="docutils literal notranslate"><span class="pre">real</span></code> 是物件 <code class="docutils literal notranslate"><span class="pre">z</span></code> 的一個屬性。嚴格來說，模組中名稱的參照都是屬性參照：在運算式 <code class="docutils literal notranslate"><span class="pre">modname.funcname</span></code> 中，<code class="docutils literal notranslate"><span class="pre">modname</span></code> 是模組物件而 <code class="docutils literal notranslate"><span class="pre">funcname</span></code> 是它的屬性。在這種情況下，模組的屬性和模組中定義的全域名稱碰巧有一個直接的對映：他們共享了相同的命名空間！<a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<p>屬性可以是唯讀的或可寫的。在後者的情況下，對屬性的賦值是可能的。模組屬性是可寫的：你可以寫 <code class="docutils literal notranslate"><span class="pre">modname.the_answer</span> <span class="pre">=</span> <span class="pre">42</span></code>。可寫屬性也可以用 <a class="reference internal" href="../reference/simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 陳述式刪除。例如，<code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">modname.the_answer</span></code> 將從名為 <code class="docutils literal notranslate"><span class="pre">modname</span></code> 的物件中刪除屬性 <code class="xref py py-attr docutils literal notranslate"><span class="pre">the_answer</span></code>。</p>
<p>命名空間在不同的時刻被建立，並且有不同的壽命。當 Python 直譯器啟動時，含有內建名稱的命名空間會被建立，並且永遠不會被刪除。當模組定義被讀入時，模組的全域命名空間會被建立；一般情況下，模組的命名空間也會持續到直譯器結束。被直譯器的頂層調用 (top-level invocation) 執行的陳述式，不論是從腳本檔案讀取的或是互動模式中的，會被視為一個稱為 <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 的模組的一部分，因此它們具有自己的全域命名空間。（內建名稱實際上也存在一個模組中，它被稱為 <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>。）</p>
<p>函式的區域命名空間是在呼叫函式時建立的，而當函式返回，或引發了未在函式中處理的例外時，此命名空間將會被刪除。（實際上，忘記是描述實際發生的事情的更好方法。） 當然，每個遞迴調用 (recursive invocation) 都有自己的區域命名空間。</p>
<p><em>作用域</em>是 Python 程式中的一個文本區域 (textual region)，在此區域，命名空間是可直接存取的。這裡的「可直接存取的」意思是，對一個名稱的非限定參照 (unqualified reference) 可以在命名空間內嘗試尋找該名稱。</p>
<p>儘管作用域是靜態地被決定，但它們是動態地被使用的。在執行期間內的任何時間點，都會有 3 或 4 個巢狀的作用域，其命名空間是可以被直接存取的：</p>
<ul class="simple">
<li><p>最內層作用域，會最先被搜尋，而它包含了區域名稱</p></li>
<li><p>任何外圍函式 (enclosing function) 的作用域，會從最近的外圍作用域開始搜尋，它包含了非區域 (non-local) 和非全域 (non-global) 的名稱</p></li>
<li><p>倒數第二個作用域，包含當前模組的全域名稱</p></li>
<li><p>最外面的作用域（最後搜尋），是包含內建名稱的命名空間</p></li>
</ul>
<p>如果一個名稱被宣告為全域，則所有的參照和賦值將直接轉到包含模組全域名稱的倒數第二個作用域。要重新連結最內層作用域以外找到的變數，可以使用 <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 陳述式；如果那些變數沒有被宣告為 nonlocal，則它們會是唯讀的（嘗試寫入這樣的變數只會在最內層的作用域內建立一個<em>新的</em>區域變數，同名的外部變數則維持不變）。</p>
<p>通常，區域作用域會參照（文本的）當前函式的區域名稱。在函式外部，區域作用域與全域作用域參照相同的命名空間：模組的命名空間。然而，Class definition 會在區域作用域中放置另一個命名空間。</p>
<p>務必要了解，作用域是按文本被決定的：在模組中定義的函式，其全域作用域便是該模組的命名空間，無論函式是從何處或以什麼別名被呼叫。另一方面，對名稱的實際搜尋是在執行時期 (run time) 動態完成的——但是，語言定義的發展，正朝向在「編譯」時期 (compile time) 的靜態名稱解析 (static name resolution)，所以不要太依賴動態名稱解析 (dynamic name resolution)！ （事實上，局部變數已經是靜態地被決定。）</p>
<p>一個 Python 的特殊癖好是——假如沒有 <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 或 <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 陳述式的效果——名稱的賦值 (assignment) 都會指向最內層作用域。賦值不會複製資料——它們只會把名稱連結至物件。刪除也是一樣：陳述式 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> 會從區域作用域參照的命名空間移除 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的連結。事實上，引入新名稱的所有運算都使用區域作用域：特別是 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 陳述式和函式定義，會連結區域作用域內的模組或函式名稱。</p>
<p><a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 陳述式可以用來表示特定變數存活在全域作用域，應該被重新綁定到那裡；<a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 陳述式表示特定變數存活在外圍作用域內，應該被重新綁定到那裡。</p>
<section id="scopes-and-namespaces-example">
<span id="tut-scopeexample"></span><h3><span class="section-number">9.2.1. </span>作用域和命名空間的範例<a class="headerlink" href="#scopes-and-namespaces-example" title="連結到這個標頭">¶</a></h3>
<p>這是一個範例，演示如何參照不同的作用域和命名空間，以及 <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 和 <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 如何影響變數的綁定：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">scope_test</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">do_local</span><span class="p">():</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;local spam&quot;</span>

    <span class="k">def</span> <span class="nf">do_nonlocal</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">spam</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;nonlocal spam&quot;</span>

    <span class="k">def</span> <span class="nf">do_global</span><span class="p">():</span>
        <span class="k">global</span> <span class="n">spam</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;global spam&quot;</span>

    <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;test spam&quot;</span>
    <span class="n">do_local</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After local assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
    <span class="n">do_nonlocal</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After nonlocal assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
    <span class="n">do_global</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After global assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>

<span class="n">scope_test</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In global scope:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
</pre></div>
</div>
<p>範例程式碼的輸出是：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
</pre></div>
</div>
<p>請注意，<em>區域</em>賦值（預設情況）不會改變 <em>scope_test</em> 對 <em>spam</em> 的連結。<a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 賦值改變了 <em>scope_test</em> 對 <em>spam</em> 的連結，而 <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 賦值改變了模組層次的連結。</p>
<p>你還可以發現，在 <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 賦值之前，沒有對 <em>spam</em> 的連結。</p>
</section>
</section>
<section id="a-first-look-at-classes">
<span id="tut-firstclasses"></span><h2><span class="section-number">9.3. </span>初見 class<a class="headerlink" href="#a-first-look-at-classes" title="連結到這個標頭">¶</a></h2>
<p>Class 採用一些新的語法，三個新的物件型別，以及一些新的語意。</p>
<section id="class-definition-syntax">
<span id="tut-classdefinition"></span><h3><span class="section-number">9.3.1. </span>Class definition（類別定義）語法<a class="headerlink" href="#class-definition-syntax" title="連結到這個標頭">¶</a></h3>
<p>Class definition 最簡單的形式如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ClassName</span><span class="p">:</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Class definition，如同函式定義（<a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a> 陳述式），必須在它們有任何效果前先執行。（你可以想像把 class definition 放在一個 <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 陳述式的分支，或在函式裡。）</p>
<p>在實作時，class definition 內的陳述式通常會是函式定義，但其他陳述式也是允許的，有時很有用——我們稍後會回到這裡。Class 中的函式定義通常會有一個獨特的引數列表形式，取決於 method 的呼叫慣例——再一次地，這將會在稍後解釋。</p>
<p>當進入 class definition，一個新的命名空間將會被建立，並且作為區域作用域——因此，所有區域變數的賦值將進入這個新的命名空間。特別是，函式定義會在這裡連結新函式的名稱。</p>
<p>正常地（從結尾處）離開 class definition 時，一個 <em>class 物件</em>會被建立。基本上這是一個包裝器 (wrapper)，裝著 class definition 建立的命名空間內容；我們將在下一節中更加了解 class 物件。原始的區域作用域（在進入 class definition 之前已生效的作用域）會恢復，在此 class 物件會被連結到 class definition 標頭中給出的 class 名稱（在範例中為 <code class="xref py py-class docutils literal notranslate"><span class="pre">ClassName</span></code>）。</p>
</section>
<section id="class-objects">
<span id="tut-classobjects"></span><h3><span class="section-number">9.3.2. </span>Class 物件<a class="headerlink" href="#class-objects" title="連結到這個標頭">¶</a></h3>
<p>Class 物件支援兩種運算：屬性參照 (attribute reference) 和實例化 (instantiation)。</p>
<p><em>屬性參照</em>使用 Python 中所有屬性參照的標準語法：<code class="docutils literal notranslate"><span class="pre">obj.name</span></code>。有效的屬性名稱是 class 物件被建立時，class 的命名空間中所有的名稱。所以，如果 class definition 看起來像這樣：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A simple example class&quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">12345</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
</pre></div>
</div>
<p>那麼 <code class="docutils literal notranslate"><span class="pre">MyClass.i</span></code> 和 <code class="docutils literal notranslate"><span class="pre">MyClass.f</span></code> 都是有效的屬性參照，會分別回傳一個整數和一個函式物件。Class 屬性也可以被指派 (assign)，所以您可以透過賦值改變 <code class="docutils literal notranslate"><span class="pre">MyClass.i</span></code> 的值。<code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 也是一個有效的屬性，會回傳屬於該 class 的說明字串 (docstring)：<code class="docutils literal notranslate"><span class="pre">&quot;A</span> <span class="pre">simple</span> <span class="pre">example</span> <span class="pre">class&quot;</span></code>。</p>
<p>Class <em>實例化</em>使用了函式記法 (function notation)。就好像 class 物件是一個沒有參數的函式，它回傳一個新的 class 實例。例如（假設是上述的 class）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</pre></div>
</div>
<p>建立 class 的一個新<em>實例</em>，並將此物件指派給區域變數 <code class="docutils literal notranslate"><span class="pre">x</span></code>。</p>
<p>實例化運算（「呼叫」一個 class 物件）會建立一個空的物件。許多 class 喜歡在建立物件時有著自訂的特定實例初始狀態。因此，class 可以定義一個名為 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 的特別 method，像這樣：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>當 class 定義了 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> method，class 實例化會為新建的 class 實例自動調用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>。所以在這個範例中，一個新的、初始化的實例可以如此獲得：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</pre></div>
</div>
<p>當然，<a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> method 可能為了更多的彈性而有引數。在這種情況下，要給 class 實例化運算子的引數會被傳遞給 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Complex</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">realpart</span><span class="p">,</span> <span class="n">imagpart</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">realpart</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">imagpart</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">i</span>
<span class="go">(3.0, -4.5)</span>
</pre></div>
</div>
</section>
<section id="instance-objects">
<span id="tut-instanceobjects"></span><h3><span class="section-number">9.3.3. </span>實例物件<a class="headerlink" href="#instance-objects" title="連結到這個標頭">¶</a></h3>
<p>現在，我們可以如何處理實例物件？實例物件能理解的唯一運算就是屬性參照。有兩種有效的屬性名稱：資料屬性 (data attribute) 和 method。</p>
<p><em>資料屬性</em>對應 Smalltalk 中的「實例變數」，以及 C++ 中的「資料成員」。資料屬性不需要被宣告；和區域變數一樣，它們在第一次被賦值時就會立即存在。例如，如果 <code class="docutils literal notranslate"><span class="pre">x</span></code> 是 <code class="xref py py-class docutils literal notranslate"><span class="pre">MyClass</span></code> 在上述例子中建立的實例，下面的程式碼將印出值 <code class="docutils literal notranslate"><span class="pre">16</span></code>，而不留下蹤跡：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
    <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">*</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">counter</span><span class="p">)</span>
<span class="k">del</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span>
</pre></div>
</div>
<p>The other kind of instance attribute reference is a <em>method</em>. A method is a
function that &quot;belongs to&quot; an object.</p>
<p id="index-0">實例物件的有效 method 名稱取決於其 class。根據定義，一個 class 中所有的函式物件屬性，就定義了實例的對應 method。所以在我們的例子中，<code class="docutils literal notranslate"><span class="pre">x.f</span></code> 是一個有效的 method 參照，因為 <code class="docutils literal notranslate"><span class="pre">MyClass.f</span></code> 是一個函式，但 <code class="docutils literal notranslate"><span class="pre">x.i</span></code> 不是，因為 <code class="docutils literal notranslate"><span class="pre">MyClass.i</span></code> 不是。但 <code class="docutils literal notranslate"><span class="pre">x.f</span></code> 與 <code class="docutils literal notranslate"><span class="pre">MyClass.f</span></code> 是不一樣的——它是一個 <em>method 物件</em>，而不是函式物件。</p>
</section>
<section id="method-objects">
<span id="tut-methodobjects"></span><h3><span class="section-number">9.3.4. </span>Method 物件<a class="headerlink" href="#method-objects" title="連結到這個標頭">¶</a></h3>
<p>通常，一個 method 在它被連結後隨即被呼叫：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>在 <code class="xref py py-class docutils literal notranslate"><span class="pre">MyClass</span></code> 的例子中，這將回傳字串 <code class="docutils literal notranslate"><span class="pre">'hello</span> <span class="pre">world'</span></code>。然而，並沒有必要立即呼叫一個 method：<code class="docutils literal notranslate"><span class="pre">x.f</span></code> 是一個 method 物件，並且可以被儲藏起來，之後再被呼叫。舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">xf</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">f</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">xf</span><span class="p">())</span>
</pre></div>
</div>
<p>將會持續印出 <code class="docutils literal notranslate"><span class="pre">hello</span> <span class="pre">world</span></code> 直到天荒地老。</p>
<p>當一個 method 被呼叫時究竟會發生什麼事？你可能已經注意到 <code class="docutils literal notranslate"><span class="pre">x.f()</span></code> 被呼叫時沒有任何的引數，儘管 <code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code> 的函式定義有指定一個引數。這個引數發生了什麼事？當一個需要引數的函式被呼叫而沒有給任何引數時，Python 肯定會引發例外——即使該引數實際上沒有被使用...</p>
<p>事實上，你可能已經猜到了答案：method 的特殊之處在於，實例物件會作為函式中的第一個引數被傳遞。在我們的例子中，<code class="docutils literal notranslate"><span class="pre">x.f()</span></code> 這個呼叫等同於 <code class="docutils literal notranslate"><span class="pre">MyClass.f(x)</span></code>。一般來說，呼叫一個有 <em>n</em> 個引數的 method，等同於呼叫一個對應函式，其引數列表 (argument list) 被建立時，會在第一個引數前插入該 method 的實例物件。</p>
<p>一般來說，方法的工作原理如下。當一個實例的非資料屬性被參照時，將會搜尋該實例的 class。如果該名稱是一個有效的 class 屬性，而且是一個函式物件，則對實例物件和函式物件的參照都會被打包到方法物件中。當使用引數串列呼叫方法物件時，會根據實例物件和引數串列來建構一個新的引數串列，並使用該新引數串列來呼叫函式物件。</p>
</section>
<section id="class-and-instance-variables">
<span id="tut-class-and-instance-variables"></span><h3><span class="section-number">9.3.5. </span>Class 及實例變數<a class="headerlink" href="#class-and-instance-variables" title="連結到這個標頭">¶</a></h3>
<p>一般來說，實例變數用於每一個實例的獨特資料，而 class 變數用於該 class 的所有實例共享的屬性和 method：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;canine&#39;</span>         <span class="c1"># class variable shared by all instances</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>    <span class="c1"># instance variable unique to each instance</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">kind</span>                  <span class="c1"># shared by all dogs</span>
<span class="s1">&#39;canine&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">kind</span>                  <span class="c1"># shared by all dogs</span>
<span class="s1">&#39;canine&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span>                  <span class="c1"># unique to d</span>
<span class="s1">&#39;Fido&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span>                  <span class="c1"># unique to e</span>
<span class="s1">&#39;Buddy&#39;</span>
</pre></div>
</div>
<p>如同在<a class="reference internal" href="#tut-object"><span class="std std-ref">關於名稱與物件的一段話</span></a>的討論，共享的資料若涉及 <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> 物件，如 list 和 dictionary，可能會產生意外的影響。舉例來說，下列程式碼的 <em>tricks</em> list 不應該作為一個 class 變數使用，因為這個 list 將會被所有的 <em>Dog</em> 實例所共享：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="n">tricks</span> <span class="o">=</span> <span class="p">[]</span>             <span class="c1"># mistaken use of a class variable</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">add_trick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trick</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trick</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;roll over&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;play dead&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">tricks</span>                <span class="c1"># unexpectedly shared by all dogs</span>
<span class="p">[</span><span class="s1">&#39;roll over&#39;</span><span class="p">,</span> <span class="s1">&#39;play dead&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>正確的 class 設計應該使用實例變數：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># creates a new empty list for each dog</span>

    <span class="k">def</span> <span class="nf">add_trick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trick</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trick</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;roll over&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;play dead&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">tricks</span>
<span class="p">[</span><span class="s1">&#39;roll over&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">tricks</span>
<span class="p">[</span><span class="s1">&#39;play dead&#39;</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="random-remarks">
<span id="tut-remarks"></span><h2><span class="section-number">9.4. </span>隨意的備註<a class="headerlink" href="#random-remarks" title="連結到這個標頭">¶</a></h2>
<p>如果屬性名稱同時出現在一個實例和一個 class 中，則屬性的尋找會以實例為優先：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Warehouse</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">purpose</span> <span class="o">=</span> <span class="s1">&#39;storage&#39;</span>
<span class="gp">... </span>   <span class="n">region</span> <span class="o">=</span> <span class="s1">&#39;west&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w1</span> <span class="o">=</span> <span class="n">Warehouse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">w1</span><span class="o">.</span><span class="n">purpose</span><span class="p">,</span> <span class="n">w1</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>
<span class="go">storage west</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w2</span> <span class="o">=</span> <span class="n">Warehouse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w2</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="s1">&#39;east&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">w2</span><span class="o">.</span><span class="n">purpose</span><span class="p">,</span> <span class="n">w2</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>
<span class="go">storage east</span>
</pre></div>
</div>
<p>資料屬性可能被 method 或是被物件的一般使用者（「客戶端」）所參照。也就是說，class 不可用於實作純粹抽象的資料型別。事實上，在 Python 中沒有任何可能的方法，可強制隱藏資料——這都是基於慣例。（另一方面，以 C 編寫的 Python 實作可以完全隱藏實作細節並且在必要時控制物件的存取；這可以被以 C 編寫的 Python 擴充所使用。）</p>
<p>客戶端應該小心使用資料屬性——客戶端可能會因為覆寫他們的資料屬性，而破壞了被 method 維護的不變性。注意，客戶端可以增加他們自己的資料屬性到實例物件，但不影響 method 的有效性，只要避免名稱衝突即可——再一次提醒，命名慣例可以在這裡節省很多麻煩。</p>
<p>在 method 中參照資料屬性（或其他 method！）是沒有簡寫的。我發現這實際上增加了 method 的可閱讀性：在瀏覽 method 時，絕不會混淆區域變數和實例變數。</p>
<p>通常，方法的第一個引數稱為 <code class="docutils literal notranslate"><span class="pre">self</span></code>。這僅僅只是一個慣例：<code class="docutils literal notranslate"><span class="pre">self</span></code> 這個名字對 Python 來說完全沒有特別的意義。但請注意，如果不遵循慣例，你的程式碼可能對其他 Python 程式設計師來說可讀性較低，此外，也可以想像一個可能因信任此慣例而編寫的 <em>class 瀏覽器 (browser)</em> 程式。</p>
<p>任何一個作為 class 屬性的函式物件都為該 class 的實例定義了一個相應的 method。函式定義不一定要包含在 class definition 的文本中：將函式物件指定給 class 中的區域變數也是可以的。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Function defined outside the class</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f1</span>

    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">g</span>
</pre></div>
</div>
<p>現在 <code class="docutils literal notranslate"><span class="pre">f</span></code>、<code class="docutils literal notranslate"><span class="pre">g</span></code> 和 <code class="docutils literal notranslate"><span class="pre">h</span></code> 都是 class <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 的屬性，並指向函式物件，所以他們都是class <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 實例的 method —— <code class="docutils literal notranslate"><span class="pre">h</span></code> 與 <code class="docutils literal notranslate"><span class="pre">g</span></code> 是完全一樣的。請注意，這種做法通常只會使該程式的讀者感到困惑。</p>
<p>Method 可以藉由使用 <code class="docutils literal notranslate"><span class="pre">self</span></code> 引數的 method 屬性，呼叫其他 method：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Bag</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">addtwice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Method 可以用與一般函式相同的方式參照全域名稱。與 method 相關的全域作用域，就是包含其定義的模組。（class 永遠不會被用作全域作用域。）雖然人們很少有在 method 中使用全域資料的充分理由，但全域作用域仍有許多合法的使用：比方說，被 import 至全域作用域的函式和模組，可以被 method 以及在該作用域中定義的函式和 class 所使用。通常，包含 method 的 class，它本身就是被定義在這個全域作用域，在下一節，我們將看到 method 想要參照自己的 class 的一些好原因。</p>
<p>每個值都是一個物件，因此都具有一個 <em>class</em>，也可以稱為它的 <em>type（型別）</em>。它以 <code class="docutils literal notranslate"><span class="pre">object.__class__</span></code> 被儲存。</p>
</section>
<section id="inheritance">
<span id="tut-inheritance"></span><h2><span class="section-number">9.5. </span>繼承 (Inheritance)<a class="headerlink" href="#inheritance" title="連結到這個標頭">¶</a></h2>
<p>當然，如果沒有支援繼承，「class」這個語言特色就不值得被稱為 class。一個 derived class（衍生類別）定義的語法看起來如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">BaseClassName</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>名稱 <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseClassName</span></code> 必須被定義於作用域可及的命名空間，且該作用域要包含 derived class 定義。要代替 base class（基底類別）的名稱，用其他任意的運算式也是被允許的。這會很有用，例如，當一個 base class 是在另一個模組中被定義時：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">modname</span><span class="o">.</span><span class="n">BaseClassName</span><span class="p">):</span>
</pre></div>
</div>
<p>執行 derived class 定義的過程，與執行 base class 相同。當 class 物件被建構時，base class 會被記住。這是用於解析屬性參照：如果一個要求的屬性無法在該 class 中找到，則會繼續在 base class 中搜尋。假如該 base class 本身也是衍生自其他 class，則這個規則會遞迴地被應用。</p>
<p>關於 derived class 的實例化並沒有特別之處：<code class="docutils literal notranslate"><span class="pre">DerivedClassName()</span></code> 會建立該 class 的一個新實例。Method 的參照被解析如下：對應的 class 屬性會被搜尋，如果需要，沿著 base class 的繼承鍊往下走，如果這產生了一個函式物件，則該 method 的參照是有效的。</p>
<p>Derived class 可以覆寫其 base class 的 method。因為 method 在呼叫同一個物件的其他 method 時沒有特別的特權，所以當 base class 的一個 method 在呼叫相同 base class 中定義的另一個 method 時，最終可能會呼叫到一個覆寫它的 derived class 中的 method。（給 C++ 程式設計師：Python 中所有 method 實際上都是 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>。）</p>
<p>一個在 derived class 覆寫的 method 可能事實上是想要擴充而非單純取代 base class 中相同名稱的 method。要直接呼叫 base class 的 method 有一個簡單的方法：只要呼叫 <code class="docutils literal notranslate"><span class="pre">BaseClassName.methodname(self,</span> <span class="pre">arguments)</span></code>。這有時對客戶端也很有用。（請注意，只有在 base class 在全域作用域可以用 <code class="docutils literal notranslate"><span class="pre">BaseClassName</span></code> 被存取時，這方法才有效。）</p>
<p>Python 有兩個內建函式可以用於繼承：</p>
<ul class="simple">
<li><p>使用 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 判斷一個實例的型別：<code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">int)</span></code> 只有在 <code class="docutils literal notranslate"><span class="pre">obj.__class__</span></code> 是 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 或衍伸自 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 時，結果才會是 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p></li>
<li><p>使用 <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 判斷 class 繼承：<code class="docutils literal notranslate"><span class="pre">issubclass(bool,</span> <span class="pre">int)</span></code> 會是 <code class="docutils literal notranslate"><span class="pre">True</span></code>，因為 <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> 是 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 的 subclass（子類別）。但是，<code class="docutils literal notranslate"><span class="pre">issubclass(float,</span> <span class="pre">int)</span></code> 是 <code class="docutils literal notranslate"><span class="pre">False</span></code>，因為 <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 並不是 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 的 subclass。</p></li>
</ul>
<section id="multiple-inheritance">
<span id="tut-multiple"></span><h3><span class="section-number">9.5.1. </span>多重繼承<a class="headerlink" href="#multiple-inheritance" title="連結到這個標頭">¶</a></h3>
<p>Python 也支援多重繼承的形式。一個有多個 base class 的 class definition 看起來像這樣子：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span><span class="p">,</span> <span class="n">Base3</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>在大多數情況下，最簡單的例子裡，你可以這樣思考，對於繼承自 parent class（父類別）的屬性，其搜尋規則為：深度優先、從左到右、在階層裡重疊的相同 class 中不重複搜尋。因此，假如有一個屬性在 <code class="xref py py-class docutils literal notranslate"><span class="pre">DerivedClassName</span></code> 沒有被找到，則在 <code class="xref py py-class docutils literal notranslate"><span class="pre">Base1</span></code> 搜尋它，接著（遞迴地）在 <code class="xref py py-class docutils literal notranslate"><span class="pre">Base1</span></code> 的 base class 中搜尋，假如在那裡又沒有找到的話，會在 <code class="xref py py-class docutils literal notranslate"><span class="pre">Base2</span></code> 搜尋，依此類推。</p>
<p>事實上，它稍微複雜一些；method 的解析順序是動態地變化，以支援對 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 的合作呼叫。這個方式在其他的多重繼承語言中，稱為呼叫下一個方法 (call-next-method)，且比在單一繼承語言中的 super call（超級呼叫）來得更強大。</p>
<p>動態排序是必要的，因為多重繼承的所有情況都表現一或多的菱形關係（其中至少一個 parent class 可以從最底層 class 透過多個路徑存取）。例如，所有的 class 都繼承自 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>，因此任何多重繼承的情況都提供了多個到達 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的路徑。為了避免 base class 被多次存取，動態演算法以這些方式將搜尋順序線性化 (linearize)：保留每個 class 中規定的從左到右的順序、對每個 parent 只會呼叫一次、使用單調的 (monotonic) 方式（意思是，一個 class 可以被 subclassed（子類別化），而不會影響其 parent 的搜尋優先順序）。總之，這些特性使設計出可靠又可擴充、具有多重繼承的 class 成為可能。更多資訊，請見 <a class="reference internal" href="../howto/mro.html#python-2-3-mro"><span class="std std-ref">The Python 2.3 Method Resolution Order</span></a>。</p>
</section>
</section>
<section id="private-variables">
<span id="tut-private"></span><h2><span class="section-number">9.6. </span>私有變數<a class="headerlink" href="#private-variables" title="連結到這個標頭">¶</a></h2>
<p>「私有」(private) 實例變數，指的是不在物件內部便無法存取的變數，這在 Python 中是不存在的。但是，大多數 Python 的程式碼都遵守一個慣例：前綴為一個底線的名稱（如：<code class="docutils literal notranslate"><span class="pre">_spam</span></code>）應被視為 API （應用程式介面）的非公有 (non-public) 部分（無論它是函式、方法或是資料成員）。這被視為一個實作細節，如有調整，亦不另行通知。</p>
<p id="index-1">既然 class 私有的成員已有一個有效的用例（即避免名稱與 subclass 定義的名稱衝突），這種機制也存在另一個有限的支援，稱為 <em class="dfn">name mangling</em>（名稱修飾）。任何格式為 <code class="docutils literal notranslate"><span class="pre">__spam</span></code>（至少兩個前導下底線，最多一個尾隨下底線）的物件名稱 (identifier) 會被文本地被替換為 <code class="docutils literal notranslate"><span class="pre">_classname__spam</span></code>，在此 <code class="docutils literal notranslate"><span class="pre">classname</span></code> 就是去掉前導下底線的當前 class 名稱。只要這個修飾是在 class 的定義之中發生，它就會在不考慮該物件名稱的語法位置的情況下完成。</p>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p>參閱<a class="reference internal" href="../reference/expressions.html#private-name-mangling"><span class="std std-ref">私有名稱修飾規格</span></a>的詳情與特殊情況。</p>
</div>
<p>名稱修飾對於讓 subclass 覆寫 method 而不用破壞 class 內部的 method 呼叫，是有幫助的。舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="n">__update</span> <span class="o">=</span> <span class="n">update</span>   <span class="c1"># private copy of original update() method</span>

<span class="k">class</span> <span class="nc">MappingSubclass</span><span class="p">(</span><span class="n">Mapping</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># provides new signature for update()</span>
        <span class="c1"># but does not break __init__()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></div>
</div>
<p>在上例中，就算在 <code class="docutils literal notranslate"><span class="pre">MappingSubclass</span></code> 當中加入 <code class="docutils literal notranslate"><span class="pre">__update</span></code> 識別符，也能順利運作，因為在 <code class="docutils literal notranslate"><span class="pre">Mapping</span></code> class 中，它會被替換為 <code class="docutils literal notranslate"><span class="pre">_Mapping__update</span></code>，而在 <code class="docutils literal notranslate"><span class="pre">MappingSubclass</span></code> class 中，它會被替換為 <code class="docutils literal notranslate"><span class="pre">_MappingSubclass__update</span></code>。</p>
<p>請注意，修飾規則是被設計來避免意外；它仍可能存取或修改一個被視為私有的變數。這在特殊情況下甚至可能很有用，例如在除錯器 (debugger)。</p>
<p>另外也注意，傳遞給 <code class="docutils literal notranslate"><span class="pre">exec()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">eval()</span></code> 的程式碼不會把調用 class 的名稱視為當前的 class；這和 <code class="docutils literal notranslate"><span class="pre">global</span></code> 陳述式的效果類似，該效果同樣僅限於整體被位元組編譯後 (byte-compiled) 的程式碼。同樣的限制適用於 <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>，<code class="docutils literal notranslate"><span class="pre">setattr()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">delattr()</span></code>，以及直接參照 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> 時。</p>
</section>
<section id="odds-and-ends">
<span id="tut-odds"></span><h2><span class="section-number">9.7. </span>補充說明<a class="headerlink" href="#odds-and-ends" title="連結到這個標頭">¶</a></h2>
<p>如果有一種資料型別，類似於 Pascal 的「record」或 C 的「struct」，可以將一些有名稱的資料項目捆綁在一起，有時候這會很有用。符合語言習慣的做法是使用 <a class="reference internal" href="../library/dataclasses.html#module-dataclasses" title="dataclasses: Generate special methods on user-defined classes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dataclasses</span></code></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Employee</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">dept</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">salary</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">john</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s1">&#39;john&#39;</span><span class="p">,</span> <span class="s1">&#39;computer lab&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">john</span><span class="o">.</span><span class="n">dept</span>
<span class="go">&#39;computer lab&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">john</span><span class="o">.</span><span class="n">salary</span>
<span class="go">1000</span>
</pre></div>
</div>
<p>用來處理特殊抽象資料型別的一段 Python 程式碼，經常能以傳遞一個 class 來替代，此 class 模擬該資料型別的多種 method。例如，如果你有一個函式，它會從一個檔案物件來格式化某些資料，你也可以定義一個有 <a class="reference internal" href="../library/io.html#io.TextIOBase.read" title="io.TextIOBase.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> 和 <a class="reference internal" href="../library/io.html#io.TextIOBase.readline" title="io.TextIOBase.readline"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> method 的 class 作為替代方式，從字串緩衝區取得資料，並將其作為引數來傳遞。</p>
<p><a class="reference internal" href="../reference/datamodel.html#instance-methods"><span class="std std-ref">實例的 method 物件</span></a>也具有屬性：<a class="reference internal" href="../reference/datamodel.html#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">m.__self__</span></code></a> 就是帶有 method <code class="xref py py-meth docutils literal notranslate"><span class="pre">m()</span></code> 的實例物件，而 <a class="reference internal" href="../reference/datamodel.html#method.__func__" title="method.__func__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">m.__func__</span></code></a> 則是該 method 所對應的<a class="reference internal" href="../reference/datamodel.html#user-defined-funcs"><span class="std std-ref">函式物件</span></a>。</p>
</section>
<section id="iterators">
<span id="tut-iterators"></span><h2><span class="section-number">9.8. </span>疊代器 (Iterator)<a class="headerlink" href="#iterators" title="連結到這個標頭">¶</a></h2>
<p>到目前為止，你可能已經注意到大多數的容器 (container) 物件都可以使用 <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 陳述式來進行迴圈：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="s2">&quot;123&quot;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;myfile.txt&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>這種存取風格清晰、簡潔且方便。疊代器的使用在 Python 中處處可見且用法一致。在幕後，<a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 陳述式會在容器物件上呼叫 <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a>。該函式回傳一個疊代器物件，此物件定義了 <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> method，而此 method 會逐一存取容器中的元素。當元素用盡時，<a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 將引發 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 例外，來通知 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 終止迴圈。你可以使用內建函式 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 來呼叫 <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> method；這個例子展示了它的運作方式：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span>
<span class="go">&lt;str_iterator object at 0x10c90e650&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>看過疊代器協定的幕後機制後，在你的 class 加入疊代器的行為就很容易了。定義一個 <a class="reference internal" href="../library/stdtypes.html#container.__iter__" title="container.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method 來回傳一個帶有 <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> method 的物件。如果 class 已定義了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code>，則 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> 可以只回傳 <code class="docutils literal notranslate"><span class="pre">self</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reverse</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rev</span> <span class="o">=</span> <span class="n">Reverse</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">iter</span><span class="p">(</span><span class="n">rev</span><span class="p">)</span>
<span class="go">&lt;__main__.Reverse object at 0x00A1DB50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">rev</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">m</span>
<span class="go">a</span>
<span class="go">p</span>
<span class="go">s</span>
</pre></div>
</div>
</section>
<section id="generators">
<span id="tut-generators"></span><h2><span class="section-number">9.9. </span>產生器 (Generator)<a class="headerlink" href="#generators" title="連結到這個標頭">¶</a></h2>
<p><a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">產生器</span></a>是一個用於建立疊代器的簡單而強大的工具。它們的寫法和常規的函式一樣，但當它們要回傳資料時，會使用 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 陳述式。每次在產生器上呼叫 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 時，它會從上次離開的位置恢復執行（它會記得所有資料值以及上一個被執行的陳述式）。以下範例顯示，建立產生器可以相當地容易：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">reverse</span><span class="p">(</span><span class="s1">&#39;golf&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">f</span>
<span class="go">l</span>
<span class="go">o</span>
<span class="go">g</span>
</pre></div>
</div>
<p>任何可以用產生器來完成的事，也能用以 class 為基礎的疊代器來完成，如同前一節的描述。而讓產生器的程式碼更為精簡的原因是，<a class="reference internal" href="../library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 和 <a class="reference internal" href="../reference/expressions.html#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> method 會自動被建立。</p>
<p>另一個關鍵的特性在於，區域變數和執行狀態會在每次呼叫之間自動被儲存。這使得該函式比使用 <code class="docutils literal notranslate"><span class="pre">self.index</span></code> 和 <code class="docutils literal notranslate"><span class="pre">self.data</span></code> 這種實例變數的方式更容易編寫且更為清晰。</p>
<p>除了會自動建立 method 和儲存程式狀態，當產生器終止時，它們還會自動引發 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>。這些特性結合在一起，使建立疊代器能與編寫常規函式一樣容易。</p>
</section>
<section id="generator-expressions">
<span id="tut-genexps"></span><h2><span class="section-number">9.10. </span>產生器運算式<a class="headerlink" href="#generator-expressions" title="連結到這個標頭">¶</a></h2>
<p>某些簡單的產生器可以寫成如運算式一般的簡潔程式碼，所用的語法類似 list comprehension（串列綜合運算），但外層為括號而非方括號。這種運算式被設計用於產生器將立即被外圍函式 (enclosing function) 所使用的情況。產生器運算式與完整的產生器定義相比，程式碼較精簡但功能較少，也比等效的 list comprehension 更為節省記憶體。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>                 <span class="c1"># sum of squares</span>
<span class="go">285</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">xvec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yvec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span> <span class="n">yvec</span><span class="p">))</span>         <span class="c1"># dot product</span>
<span class="go">260</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">unique_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">word</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">page</span>  <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">valedictorian</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">student</span><span class="o">.</span><span class="n">gpa</span><span class="p">,</span> <span class="n">student</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">student</span> <span class="ow">in</span> <span class="n">graduates</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;golf&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[&#39;f&#39;, &#39;l&#39;, &#39;o&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p class="rubric">註解</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>有一個例外。模組物件有一個秘密的唯讀屬性，稱為 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>，它回傳用於實作模組命名空間的 dictionary；<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 這個名稱是一個屬性但不是全域名稱。顯然，使用此屬性將違反命名空間實作的抽象化，而應該僅限用於事後除錯器 (post-mortem debugger) 之類的東西。</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目錄</a></h3>
    <ul>
<li><a class="reference internal" href="#">9. Class（類別）</a><ul>
<li><a class="reference internal" href="#a-word-about-names-and-objects">9.1. 關於名稱與物件的一段話</a></li>
<li><a class="reference internal" href="#python-scopes-and-namespaces">9.2. Python 作用域 (Scope) 及命名空間 (Namespace)</a><ul>
<li><a class="reference internal" href="#scopes-and-namespaces-example">9.2.1. 作用域和命名空間的範例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-first-look-at-classes">9.3. 初見 class</a><ul>
<li><a class="reference internal" href="#class-definition-syntax">9.3.1. Class definition（類別定義）語法</a></li>
<li><a class="reference internal" href="#class-objects">9.3.2. Class 物件</a></li>
<li><a class="reference internal" href="#instance-objects">9.3.3. 實例物件</a></li>
<li><a class="reference internal" href="#method-objects">9.3.4. Method 物件</a></li>
<li><a class="reference internal" href="#class-and-instance-variables">9.3.5. Class 及實例變數</a></li>
</ul>
</li>
<li><a class="reference internal" href="#random-remarks">9.4. 隨意的備註</a></li>
<li><a class="reference internal" href="#inheritance">9.5. 繼承 (Inheritance)</a><ul>
<li><a class="reference internal" href="#multiple-inheritance">9.5.1. 多重繼承</a></li>
</ul>
</li>
<li><a class="reference internal" href="#private-variables">9.6. 私有變數</a></li>
<li><a class="reference internal" href="#odds-and-ends">9.7. 補充說明</a></li>
<li><a class="reference internal" href="#iterators">9.8. 疊代器 (Iterator)</a></li>
<li><a class="reference internal" href="#generators">9.9. 產生器 (Generator)</a></li>
<li><a class="reference internal" href="#generator-expressions">9.10. 產生器運算式</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="errors.html"
                          title="上一章"><span class="section-number">8. </span>錯誤和例外</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="stdlib.html"
                          title="下一章"><span class="section-number">10. </span>Python 標準函式庫概覽</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/tutorial/classes.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="收合側邊欄">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="stdlib.html" title="10. Python 標準函式庫概覽"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="errors.html" title="8. 錯誤和例外"
             >上一頁</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 教學</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9. </span>Class（類別）</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" id="search-box" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    版權
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最後更新於 Jul 20, 2024 (06:27 UTC)。
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    使用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.6 建立。
    </div>

  </body>
</html>